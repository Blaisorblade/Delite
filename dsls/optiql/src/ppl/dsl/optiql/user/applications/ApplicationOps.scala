/***********************************************************
** AUTOGENERATED USING bin/lift_user_class.py
************************************************************/

package ppl.dsl.optiql.user.applications

import ppl.dsl.optiql.datastruct.scala.liftables._
import java.io.PrintWriter
import ppl.delite.framework.{DSLType}
import ppl.delite.framework.datastructures._
import scala.virtualization.lms.common.ScalaGenBase
import scala.virtualization.lms.util.OverloadHack
import scala.virtualization.lms.common.{EffectExp, Variables}


trait CustomerOps extends DSLType with Variables with OverloadHack {

  object Customer {
    def apply(key: Rep[Int], name: Rep[String], address: Rep[String], nationKey: Rep[Int], phone: Rep[String], accountBalance: Rep[Float], marketSegment: Rep[String], comment: Rep[String]) = customer_obj_new(key, name, address, nationKey, phone, accountBalance, marketSegment, comment)
  }

  implicit def repCustomerToCustomerOps(x: Rep[Customer]) = new customerOpsCls(x)
  implicit def customerToCustomerOps(x: Var[Customer]) = new customerOpsCls(readVar(x))

  class customerOpsCls(__x: Rep[Customer]) {
    def key = customer_key(__x)
    def name = customer_name(__x)
    def address = customer_address(__x)
    def nationKey = customer_nationKey(__x)
    def phone = customer_phone(__x)
    def accountBalance = customer_accountBalance(__x)
    def marketSegment = customer_marketSegment(__x)
    def comment = customer_comment(__x)
  }

  //object defs
  def customer_obj_new(key: Rep[Int], name: Rep[String], address: Rep[String], nationKey: Rep[Int], phone: Rep[String], accountBalance: Rep[Float], marketSegment: Rep[String], comment: Rep[String]): Rep[Customer]

  //class defs
  def customer_key(__x: Rep[Customer]): Rep[Int]
  def customer_name(__x: Rep[Customer]): Rep[String]
  def customer_address(__x: Rep[Customer]): Rep[String]
  def customer_nationKey(__x: Rep[Customer]): Rep[Int]
  def customer_phone(__x: Rep[Customer]): Rep[String]
  def customer_accountBalance(__x: Rep[Customer]): Rep[Float]
  def customer_marketSegment(__x: Rep[Customer]): Rep[String]
  def customer_comment(__x: Rep[Customer]): Rep[String]
}

trait CustomerOpsExp extends CustomerOps with FieldAccessOpsExp with EffectExp {
  case class CustomerObjectNew(key: Exp[Int], name: Exp[String], address: Exp[String], nationKey: Exp[Int], phone: Exp[String], accountBalance: Exp[Float], marketSegment: Exp[String], comment: Exp[String]) extends Def[Customer]
  def customer_obj_new(key: Exp[Int], name: Exp[String], address: Exp[String], nationKey: Exp[Int], phone: Exp[String], accountBalance: Exp[Float], marketSegment: Exp[String], comment: Exp[String]) = reflectEffect(CustomerObjectNew(key, name, address, nationKey, phone, accountBalance, marketSegment, comment))
  def customer_key(__x: Rep[Customer]) = FieldRead[Int](__x, "key", "Int")
  def customer_name(__x: Rep[Customer]) = FieldRead[String](__x, "name", "String")
  def customer_address(__x: Rep[Customer]) = FieldRead[String](__x, "address", "String")
  def customer_nationKey(__x: Rep[Customer]) = FieldRead[Int](__x, "nationKey", "Int")
  def customer_phone(__x: Rep[Customer]) = FieldRead[String](__x, "phone", "String")
  def customer_accountBalance(__x: Rep[Customer]) = FieldRead[Float](__x, "accountBalance", "Float")
  def customer_marketSegment(__x: Rep[Customer]) = FieldRead[String](__x, "marketSegment", "String")
  def customer_comment(__x: Rep[Customer]) = FieldRead[String](__x, "comment", "String")
}

trait ScalaGenCustomerOps extends ScalaGenBase {
  val IR: ApplicationOpsExp
  import IR._

  override def emitNode(sym: Sym[Any], rhs: Def[Any])(implicit stream: PrintWriter) = rhs match {
  // these are the ops that call through to the underlying real data structure
    case CustomerObjectNew(key, name, address, nationKey, phone, accountBalance, marketSegment, comment) => emitValDef(sym, "new " + remap(manifest[Customer]) + "(" + quote(key)  + "," + quote(name)  + "," + quote(address)  + "," + quote(nationKey)  + "," + quote(phone)  + "," + quote(accountBalance)  + "," + quote(marketSegment)  + "," + quote(comment)  + ")")
    case _ => super.emitNode(sym, rhs)
  }
}

trait LineItemOps extends DSLType with Variables with OverloadHack {

  object LineItem {
    def apply(orderKey: Rep[Int], partKey: Rep[Int], supplierKey: Rep[Int], lineNumber: Rep[Int], quantity: Rep[Float], extendedPrice: Rep[Float], discount: Rep[Float], tax: Rep[Float], returnFlag: Rep[Char], lineStatus: Rep[Char], shipInstruct: Rep[String], shipMode: Rep[String], comment: Rep[String]) = lineitem_obj_new(orderKey, partKey, supplierKey, lineNumber, quantity, extendedPrice, discount, tax, returnFlag, lineStatus, shipInstruct, shipMode, comment)
  }

  implicit def repLineItemToLineItemOps(x: Rep[LineItem]) = new lineitemOpsCls(x)
  implicit def lineitemToLineItemOps(x: Var[LineItem]) = new lineitemOpsCls(readVar(x))

  class lineitemOpsCls(__x: Rep[LineItem]) {
    def orderKey = lineitem_orderKey(__x)
    def partKey = lineitem_partKey(__x)
    def supplierKey = lineitem_supplierKey(__x)
    def lineNumber = lineitem_lineNumber(__x)
    def quantity = lineitem_quantity(__x)
    def extendedPrice = lineitem_extendedPrice(__x)
    def discount = lineitem_discount(__x)
    def tax = lineitem_tax(__x)
    def returnFlag = lineitem_returnFlag(__x)
    def lineStatus = lineitem_lineStatus(__x)
    def shipInstruct = lineitem_shipInstruct(__x)
    def shipMode = lineitem_shipMode(__x)
    def comment = lineitem_comment(__x)
  }

  //object defs
  def lineitem_obj_new(orderKey: Rep[Int], partKey: Rep[Int], supplierKey: Rep[Int], lineNumber: Rep[Int], quantity: Rep[Float], extendedPrice: Rep[Float], discount: Rep[Float], tax: Rep[Float], returnFlag: Rep[Char], lineStatus: Rep[Char], shipInstruct: Rep[String], shipMode: Rep[String], comment: Rep[String]): Rep[LineItem]

  //class defs
  def lineitem_orderKey(__x: Rep[LineItem]): Rep[Int]
  def lineitem_partKey(__x: Rep[LineItem]): Rep[Int]
  def lineitem_supplierKey(__x: Rep[LineItem]): Rep[Int]
  def lineitem_lineNumber(__x: Rep[LineItem]): Rep[Int]
  def lineitem_quantity(__x: Rep[LineItem]): Rep[Float]
  def lineitem_extendedPrice(__x: Rep[LineItem]): Rep[Float]
  def lineitem_discount(__x: Rep[LineItem]): Rep[Float]
  def lineitem_tax(__x: Rep[LineItem]): Rep[Float]
  def lineitem_returnFlag(__x: Rep[LineItem]): Rep[Char]
  def lineitem_lineStatus(__x: Rep[LineItem]): Rep[Char]
  def lineitem_shipInstruct(__x: Rep[LineItem]): Rep[String]
  def lineitem_shipMode(__x: Rep[LineItem]): Rep[String]
  def lineitem_comment(__x: Rep[LineItem]): Rep[String]
}

trait LineItemOpsExp extends LineItemOps with FieldAccessOpsExp with EffectExp {
  case class LineItemObjectNew(orderKey: Exp[Int], partKey: Exp[Int], supplierKey: Exp[Int], lineNumber: Exp[Int], quantity: Exp[Float], extendedPrice: Exp[Float], discount: Exp[Float], tax: Exp[Float], returnFlag: Exp[Char], lineStatus: Exp[Char], shipInstruct: Exp[String], shipMode: Exp[String], comment: Exp[String]) extends Def[LineItem]
  def lineitem_obj_new(orderKey: Exp[Int], partKey: Exp[Int], supplierKey: Exp[Int], lineNumber: Exp[Int], quantity: Exp[Float], extendedPrice: Exp[Float], discount: Exp[Float], tax: Exp[Float], returnFlag: Exp[Char], lineStatus: Exp[Char], shipInstruct: Exp[String], shipMode: Exp[String], comment: Exp[String]) = reflectEffect(LineItemObjectNew(orderKey, partKey, supplierKey, lineNumber, quantity, extendedPrice, discount, tax, returnFlag, lineStatus, shipInstruct, shipMode, comment))
  def lineitem_orderKey(__x: Rep[LineItem]) = FieldRead[Int](__x, "orderKey", "Int")
  def lineitem_partKey(__x: Rep[LineItem]) = FieldRead[Int](__x, "partKey", "Int")
  def lineitem_supplierKey(__x: Rep[LineItem]) = FieldRead[Int](__x, "supplierKey", "Int")
  def lineitem_lineNumber(__x: Rep[LineItem]) = FieldRead[Int](__x, "lineNumber", "Int")
  def lineitem_quantity(__x: Rep[LineItem]) = FieldRead[Float](__x, "quantity", "Float")
  def lineitem_extendedPrice(__x: Rep[LineItem]) = FieldRead[Float](__x, "extendedPrice", "Float")
  def lineitem_discount(__x: Rep[LineItem]) = FieldRead[Float](__x, "discount", "Float")
  def lineitem_tax(__x: Rep[LineItem]) = FieldRead[Float](__x, "tax", "Float")
  def lineitem_returnFlag(__x: Rep[LineItem]) = FieldRead[Char](__x, "returnFlag", "Char")
  def lineitem_lineStatus(__x: Rep[LineItem]) = FieldRead[Char](__x, "lineStatus", "Char")
  def lineitem_shipInstruct(__x: Rep[LineItem]) = FieldRead[String](__x, "shipInstruct", "String")
  def lineitem_shipMode(__x: Rep[LineItem]) = FieldRead[String](__x, "shipMode", "String")
  def lineitem_comment(__x: Rep[LineItem]) = FieldRead[String](__x, "comment", "String")
}

trait ScalaGenLineItemOps extends ScalaGenBase {
  val IR: ApplicationOpsExp
  import IR._

  override def emitNode(sym: Sym[Any], rhs: Def[Any])(implicit stream: PrintWriter) = rhs match {
  // these are the ops that call through to the underlying real data structure
    case LineItemObjectNew(orderKey, partKey, supplierKey, lineNumber, quantity, extendedPrice, discount, tax, returnFlag, lineStatus, shipInstruct, shipMode, comment) => emitValDef(sym, "new " + remap(manifest[LineItem]) + "(" + quote(orderKey)  + "," + quote(partKey)  + "," + quote(supplierKey)  + "," + quote(lineNumber)  + "," + quote(quantity)  + "," + quote(extendedPrice)  + "," + quote(discount)  + "," + quote(tax)  + "," + quote(returnFlag)  + "," + quote(lineStatus)  + "," + quote(shipInstruct)  + "," + quote(shipMode)  + "," + quote(comment)  + ")")
    case _ => super.emitNode(sym, rhs)
  }
}

trait NationOps extends DSLType with Variables with OverloadHack {

  object Nation {
    def apply(key: Rep[Int], name: Rep[String], regionKey: Rep[Int], comment: Rep[String]) = nation_obj_new(key, name, regionKey, comment)
  }

  implicit def repNationToNationOps(x: Rep[Nation]) = new nationOpsCls(x)
  implicit def nationToNationOps(x: Var[Nation]) = new nationOpsCls(readVar(x))

  class nationOpsCls(__x: Rep[Nation]) {
    def key = nation_key(__x)
    def name = nation_name(__x)
    def regionKey = nation_regionKey(__x)
    def comment = nation_comment(__x)
  }

  //object defs
  def nation_obj_new(key: Rep[Int], name: Rep[String], regionKey: Rep[Int], comment: Rep[String]): Rep[Nation]

  //class defs
  def nation_key(__x: Rep[Nation]): Rep[Int]
  def nation_name(__x: Rep[Nation]): Rep[String]
  def nation_regionKey(__x: Rep[Nation]): Rep[Int]
  def nation_comment(__x: Rep[Nation]): Rep[String]
}

trait NationOpsExp extends NationOps with FieldAccessOpsExp with EffectExp {
  case class NationObjectNew(key: Exp[Int], name: Exp[String], regionKey: Exp[Int], comment: Exp[String]) extends Def[Nation]
  def nation_obj_new(key: Exp[Int], name: Exp[String], regionKey: Exp[Int], comment: Exp[String]) = reflectEffect(NationObjectNew(key, name, regionKey, comment))
  def nation_key(__x: Rep[Nation]) = FieldRead[Int](__x, "key", "Int")
  def nation_name(__x: Rep[Nation]) = FieldRead[String](__x, "name", "String")
  def nation_regionKey(__x: Rep[Nation]) = FieldRead[Int](__x, "regionKey", "Int")
  def nation_comment(__x: Rep[Nation]) = FieldRead[String](__x, "comment", "String")
}

trait ScalaGenNationOps extends ScalaGenBase {
  val IR: ApplicationOpsExp
  import IR._

  override def emitNode(sym: Sym[Any], rhs: Def[Any])(implicit stream: PrintWriter) = rhs match {
  // these are the ops that call through to the underlying real data structure
    case NationObjectNew(key, name, regionKey, comment) => emitValDef(sym, "new " + remap(manifest[Nation]) + "(" + quote(key)  + "," + quote(name)  + "," + quote(regionKey)  + "," + quote(comment)  + ")")
    case _ => super.emitNode(sym, rhs)
  }
}

trait OrderOps extends DSLType with Variables with OverloadHack {

  object Order {
    def apply(key: Rep[Int], customerKey: Rep[Int], status: Rep[Char], totalPrice: Rep[Float], priority: Rep[String], clerk: Rep[String], shipPriority: Rep[Int], comment: Rep[String]) = order_obj_new(key, customerKey, status, totalPrice, priority, clerk, shipPriority, comment)
  }

  implicit def repOrderToOrderOps(x: Rep[Order]) = new orderOpsCls(x)
  implicit def orderToOrderOps(x: Var[Order]) = new orderOpsCls(readVar(x))

  class orderOpsCls(__x: Rep[Order]) {
    def key = order_key(__x)
    def customerKey = order_customerKey(__x)
    def status = order_status(__x)
    def totalPrice = order_totalPrice(__x)
    def priority = order_priority(__x)
    def clerk = order_clerk(__x)
    def shipPriority = order_shipPriority(__x)
    def comment = order_comment(__x)
  }

  //object defs
  def order_obj_new(key: Rep[Int], customerKey: Rep[Int], status: Rep[Char], totalPrice: Rep[Float], priority: Rep[String], clerk: Rep[String], shipPriority: Rep[Int], comment: Rep[String]): Rep[Order]

  //class defs
  def order_key(__x: Rep[Order]): Rep[Int]
  def order_customerKey(__x: Rep[Order]): Rep[Int]
  def order_status(__x: Rep[Order]): Rep[Char]
  def order_totalPrice(__x: Rep[Order]): Rep[Float]
  def order_priority(__x: Rep[Order]): Rep[String]
  def order_clerk(__x: Rep[Order]): Rep[String]
  def order_shipPriority(__x: Rep[Order]): Rep[Int]
  def order_comment(__x: Rep[Order]): Rep[String]
}

trait OrderOpsExp extends OrderOps with FieldAccessOpsExp with EffectExp {
  case class OrderObjectNew(key: Exp[Int], customerKey: Exp[Int], status: Exp[Char], totalPrice: Exp[Float], priority: Exp[String], clerk: Exp[String], shipPriority: Exp[Int], comment: Exp[String]) extends Def[Order]
  def order_obj_new(key: Exp[Int], customerKey: Exp[Int], status: Exp[Char], totalPrice: Exp[Float], priority: Exp[String], clerk: Exp[String], shipPriority: Exp[Int], comment: Exp[String]) = reflectEffect(OrderObjectNew(key, customerKey, status, totalPrice, priority, clerk, shipPriority, comment))
  def order_key(__x: Rep[Order]) = FieldRead[Int](__x, "key", "Int")
  def order_customerKey(__x: Rep[Order]) = FieldRead[Int](__x, "customerKey", "Int")
  def order_status(__x: Rep[Order]) = FieldRead[Char](__x, "status", "Char")
  def order_totalPrice(__x: Rep[Order]) = FieldRead[Float](__x, "totalPrice", "Float")
  def order_priority(__x: Rep[Order]) = FieldRead[String](__x, "priority", "String")
  def order_clerk(__x: Rep[Order]) = FieldRead[String](__x, "clerk", "String")
  def order_shipPriority(__x: Rep[Order]) = FieldRead[Int](__x, "shipPriority", "Int")
  def order_comment(__x: Rep[Order]) = FieldRead[String](__x, "comment", "String")
}

trait ScalaGenOrderOps extends ScalaGenBase {
  val IR: ApplicationOpsExp
  import IR._

  override def emitNode(sym: Sym[Any], rhs: Def[Any])(implicit stream: PrintWriter) = rhs match {
  // these are the ops that call through to the underlying real data structure
    case OrderObjectNew(key, customerKey, status, totalPrice, priority, clerk, shipPriority, comment) => emitValDef(sym, "new " + remap(manifest[Order]) + "(" + quote(key)  + "," + quote(customerKey)  + "," + quote(status)  + "," + quote(totalPrice)  + "," + quote(priority)  + "," + quote(clerk)  + "," + quote(shipPriority)  + "," + quote(comment)  + ")")
    case _ => super.emitNode(sym, rhs)
  }
}

trait PartOps extends DSLType with Variables with OverloadHack {

  object Part {
    def apply(key: Rep[Int], name: Rep[String], mfgr: Rep[String], brand: Rep[String], pType: Rep[String], size: Rep[Int], container: Rep[String], retailPrice: Rep[Float], comment: Rep[String]) = part_obj_new(key, name, mfgr, brand, pType, size, container, retailPrice, comment)
  }

  implicit def repPartToPartOps(x: Rep[Part]) = new partOpsCls(x)
  implicit def partToPartOps(x: Var[Part]) = new partOpsCls(readVar(x))

  class partOpsCls(__x: Rep[Part]) {
    def key = part_key(__x)
    def name = part_name(__x)
    def mfgr = part_mfgr(__x)
    def brand = part_brand(__x)
    def pType = part_pType(__x)
    def size = part_size(__x)
    def container = part_container(__x)
    def retailPrice = part_retailPrice(__x)
    def comment = part_comment(__x)
  }

  //object defs
  def part_obj_new(key: Rep[Int], name: Rep[String], mfgr: Rep[String], brand: Rep[String], pType: Rep[String], size: Rep[Int], container: Rep[String], retailPrice: Rep[Float], comment: Rep[String]): Rep[Part]

  //class defs
  def part_key(__x: Rep[Part]): Rep[Int]
  def part_name(__x: Rep[Part]): Rep[String]
  def part_mfgr(__x: Rep[Part]): Rep[String]
  def part_brand(__x: Rep[Part]): Rep[String]
  def part_pType(__x: Rep[Part]): Rep[String]
  def part_size(__x: Rep[Part]): Rep[Int]
  def part_container(__x: Rep[Part]): Rep[String]
  def part_retailPrice(__x: Rep[Part]): Rep[Float]
  def part_comment(__x: Rep[Part]): Rep[String]
}

trait PartOpsExp extends PartOps with FieldAccessOpsExp with EffectExp {
  case class PartObjectNew(key: Exp[Int], name: Exp[String], mfgr: Exp[String], brand: Exp[String], pType: Exp[String], size: Exp[Int], container: Exp[String], retailPrice: Exp[Float], comment: Exp[String]) extends Def[Part]
  def part_obj_new(key: Exp[Int], name: Exp[String], mfgr: Exp[String], brand: Exp[String], pType: Exp[String], size: Exp[Int], container: Exp[String], retailPrice: Exp[Float], comment: Exp[String]) = reflectEffect(PartObjectNew(key, name, mfgr, brand, pType, size, container, retailPrice, comment))
  def part_key(__x: Rep[Part]) = FieldRead[Int](__x, "key", "Int")
  def part_name(__x: Rep[Part]) = FieldRead[String](__x, "name", "String")
  def part_mfgr(__x: Rep[Part]) = FieldRead[String](__x, "mfgr", "String")
  def part_brand(__x: Rep[Part]) = FieldRead[String](__x, "brand", "String")
  def part_pType(__x: Rep[Part]) = FieldRead[String](__x, "pType", "String")
  def part_size(__x: Rep[Part]) = FieldRead[Int](__x, "size", "Int")
  def part_container(__x: Rep[Part]) = FieldRead[String](__x, "container", "String")
  def part_retailPrice(__x: Rep[Part]) = FieldRead[Float](__x, "retailPrice", "Float")
  def part_comment(__x: Rep[Part]) = FieldRead[String](__x, "comment", "String")
}

trait ScalaGenPartOps extends ScalaGenBase {
  val IR: ApplicationOpsExp
  import IR._

  override def emitNode(sym: Sym[Any], rhs: Def[Any])(implicit stream: PrintWriter) = rhs match {
  // these are the ops that call through to the underlying real data structure
    case PartObjectNew(key, name, mfgr, brand, pType, size, container, retailPrice, comment) => emitValDef(sym, "new " + remap(manifest[Part]) + "(" + quote(key)  + "," + quote(name)  + "," + quote(mfgr)  + "," + quote(brand)  + "," + quote(pType)  + "," + quote(size)  + "," + quote(container)  + "," + quote(retailPrice)  + "," + quote(comment)  + ")")
    case _ => super.emitNode(sym, rhs)
  }
}

trait PartSupplierOps extends DSLType with Variables with OverloadHack {

  object PartSupplier {
    def apply(key: Rep[Int], supplierKey: Rep[Int], availableQty: Rep[Int], supplyCost: Rep[Float], comment: Rep[String]) = partsupplier_obj_new(key, supplierKey, availableQty, supplyCost, comment)
  }

  implicit def repPartSupplierToPartSupplierOps(x: Rep[PartSupplier]) = new partsupplierOpsCls(x)
  implicit def partsupplierToPartSupplierOps(x: Var[PartSupplier]) = new partsupplierOpsCls(readVar(x))

  class partsupplierOpsCls(__x: Rep[PartSupplier]) {
    def key = partsupplier_key(__x)
    def supplierKey = partsupplier_supplierKey(__x)
    def availableQty = partsupplier_availableQty(__x)
    def supplyCost = partsupplier_supplyCost(__x)
    def comment = partsupplier_comment(__x)
  }

  //object defs
  def partsupplier_obj_new(key: Rep[Int], supplierKey: Rep[Int], availableQty: Rep[Int], supplyCost: Rep[Float], comment: Rep[String]): Rep[PartSupplier]

  //class defs
  def partsupplier_key(__x: Rep[PartSupplier]): Rep[Int]
  def partsupplier_supplierKey(__x: Rep[PartSupplier]): Rep[Int]
  def partsupplier_availableQty(__x: Rep[PartSupplier]): Rep[Int]
  def partsupplier_supplyCost(__x: Rep[PartSupplier]): Rep[Float]
  def partsupplier_comment(__x: Rep[PartSupplier]): Rep[String]
}

trait PartSupplierOpsExp extends PartSupplierOps with FieldAccessOpsExp with EffectExp {
  case class PartSupplierObjectNew(key: Exp[Int], supplierKey: Exp[Int], availableQty: Exp[Int], supplyCost: Exp[Float], comment: Exp[String]) extends Def[PartSupplier]
  def partsupplier_obj_new(key: Exp[Int], supplierKey: Exp[Int], availableQty: Exp[Int], supplyCost: Exp[Float], comment: Exp[String]) = reflectEffect(PartSupplierObjectNew(key, supplierKey, availableQty, supplyCost, comment))
  def partsupplier_key(__x: Rep[PartSupplier]) = FieldRead[Int](__x, "key", "Int")
  def partsupplier_supplierKey(__x: Rep[PartSupplier]) = FieldRead[Int](__x, "supplierKey", "Int")
  def partsupplier_availableQty(__x: Rep[PartSupplier]) = FieldRead[Int](__x, "availableQty", "Int")
  def partsupplier_supplyCost(__x: Rep[PartSupplier]) = FieldRead[Float](__x, "supplyCost", "Float")
  def partsupplier_comment(__x: Rep[PartSupplier]) = FieldRead[String](__x, "comment", "String")
}

trait ScalaGenPartSupplierOps extends ScalaGenBase {
  val IR: ApplicationOpsExp
  import IR._

  override def emitNode(sym: Sym[Any], rhs: Def[Any])(implicit stream: PrintWriter) = rhs match {
  // these are the ops that call through to the underlying real data structure
    case PartSupplierObjectNew(key, supplierKey, availableQty, supplyCost, comment) => emitValDef(sym, "new " + remap(manifest[PartSupplier]) + "(" + quote(key)  + "," + quote(supplierKey)  + "," + quote(availableQty)  + "," + quote(supplyCost)  + "," + quote(comment)  + ")")
    case _ => super.emitNode(sym, rhs)
  }
}

trait RegionOps extends DSLType with Variables with OverloadHack {

  object Region {
    def apply(key: Rep[Int], name: Rep[String], comment: Rep[String]) = region_obj_new(key, name, comment)
  }

  implicit def repRegionToRegionOps(x: Rep[Region]) = new regionOpsCls(x)
  implicit def regionToRegionOps(x: Var[Region]) = new regionOpsCls(readVar(x))

  class regionOpsCls(__x: Rep[Region]) {
    def key = region_key(__x)
    def name = region_name(__x)
    def comment = region_comment(__x)
  }

  //object defs
  def region_obj_new(key: Rep[Int], name: Rep[String], comment: Rep[String]): Rep[Region]

  //class defs
  def region_key(__x: Rep[Region]): Rep[Int]
  def region_name(__x: Rep[Region]): Rep[String]
  def region_comment(__x: Rep[Region]): Rep[String]
}

trait RegionOpsExp extends RegionOps with FieldAccessOpsExp with EffectExp {
  case class RegionObjectNew(key: Exp[Int], name: Exp[String], comment: Exp[String]) extends Def[Region]
  def region_obj_new(key: Exp[Int], name: Exp[String], comment: Exp[String]) = reflectEffect(RegionObjectNew(key, name, comment))
  def region_key(__x: Rep[Region]) = FieldRead[Int](__x, "key", "Int")
  def region_name(__x: Rep[Region]) = FieldRead[String](__x, "name", "String")
  def region_comment(__x: Rep[Region]) = FieldRead[String](__x, "comment", "String")
}

trait ScalaGenRegionOps extends ScalaGenBase {
  val IR: ApplicationOpsExp
  import IR._

  override def emitNode(sym: Sym[Any], rhs: Def[Any])(implicit stream: PrintWriter) = rhs match {
  // these are the ops that call through to the underlying real data structure
    case RegionObjectNew(key, name, comment) => emitValDef(sym, "new " + remap(manifest[Region]) + "(" + quote(key)  + "," + quote(name)  + "," + quote(comment)  + ")")
    case _ => super.emitNode(sym, rhs)
  }
}

trait SupplierOps extends DSLType with Variables with OverloadHack {

  object Supplier {
    def apply(key: Rep[Int], name: Rep[String], address: Rep[String], nationKey: Rep[Int], phone: Rep[String], accountBalance: Rep[Float], comment: Rep[String]) = supplier_obj_new(key, name, address, nationKey, phone, accountBalance, comment)
  }

  implicit def repSupplierToSupplierOps(x: Rep[Supplier]) = new supplierOpsCls(x)
  implicit def supplierToSupplierOps(x: Var[Supplier]) = new supplierOpsCls(readVar(x))

  class supplierOpsCls(__x: Rep[Supplier]) {
    def key = supplier_key(__x)
    def name = supplier_name(__x)
    def address = supplier_address(__x)
    def nationKey = supplier_nationKey(__x)
    def phone = supplier_phone(__x)
    def accountBalance = supplier_accountBalance(__x)
    def comment = supplier_comment(__x)
  }

  //object defs
  def supplier_obj_new(key: Rep[Int], name: Rep[String], address: Rep[String], nationKey: Rep[Int], phone: Rep[String], accountBalance: Rep[Float], comment: Rep[String]): Rep[Supplier]

  //class defs
  def supplier_key(__x: Rep[Supplier]): Rep[Int]
  def supplier_name(__x: Rep[Supplier]): Rep[String]
  def supplier_address(__x: Rep[Supplier]): Rep[String]
  def supplier_nationKey(__x: Rep[Supplier]): Rep[Int]
  def supplier_phone(__x: Rep[Supplier]): Rep[String]
  def supplier_accountBalance(__x: Rep[Supplier]): Rep[Float]
  def supplier_comment(__x: Rep[Supplier]): Rep[String]
}

trait SupplierOpsExp extends SupplierOps with FieldAccessOpsExp with EffectExp {
  case class SupplierObjectNew(key: Exp[Int], name: Exp[String], address: Exp[String], nationKey: Exp[Int], phone: Exp[String], accountBalance: Exp[Float], comment: Exp[String]) extends Def[Supplier]
  def supplier_obj_new(key: Exp[Int], name: Exp[String], address: Exp[String], nationKey: Exp[Int], phone: Exp[String], accountBalance: Exp[Float], comment: Exp[String]) = reflectEffect(SupplierObjectNew(key, name, address, nationKey, phone, accountBalance, comment))
  def supplier_key(__x: Rep[Supplier]) = FieldRead[Int](__x, "key", "Int")
  def supplier_name(__x: Rep[Supplier]) = FieldRead[String](__x, "name", "String")
  def supplier_address(__x: Rep[Supplier]) = FieldRead[String](__x, "address", "String")
  def supplier_nationKey(__x: Rep[Supplier]) = FieldRead[Int](__x, "nationKey", "Int")
  def supplier_phone(__x: Rep[Supplier]) = FieldRead[String](__x, "phone", "String")
  def supplier_accountBalance(__x: Rep[Supplier]) = FieldRead[Float](__x, "accountBalance", "Float")
  def supplier_comment(__x: Rep[Supplier]) = FieldRead[String](__x, "comment", "String")
}

trait ScalaGenSupplierOps extends ScalaGenBase {
  val IR: ApplicationOpsExp
  import IR._

  override def emitNode(sym: Sym[Any], rhs: Def[Any])(implicit stream: PrintWriter) = rhs match {
  // these are the ops that call through to the underlying real data structure
    case SupplierObjectNew(key, name, address, nationKey, phone, accountBalance, comment) => emitValDef(sym, "new " + remap(manifest[Supplier]) + "(" + quote(key)  + "," + quote(name)  + "," + quote(address)  + "," + quote(nationKey)  + "," + quote(phone)  + "," + quote(accountBalance)  + "," + quote(comment)  + ")")
    case _ => super.emitNode(sym, rhs)
  }
}
trait ApplicationOps extends CustomerOps with LineItemOps with NationOps with OrderOps with PartOps with PartSupplierOps with RegionOps with SupplierOps
trait ApplicationOpsExp extends FieldAccessOpsExp with CustomerOpsExp with LineItemOpsExp with NationOpsExp with OrderOpsExp with PartOpsExp with PartSupplierOpsExp with RegionOpsExp with SupplierOpsExp
trait ScalaGenApplicationOps extends ScalaGenFieldAccessOps with ScalaGenCustomerOps with ScalaGenLineItemOps with ScalaGenNationOps with ScalaGenOrderOps with ScalaGenPartOps with ScalaGenPartSupplierOps with ScalaGenRegionOps with ScalaGenSupplierOps 
