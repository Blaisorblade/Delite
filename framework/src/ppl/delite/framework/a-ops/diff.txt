12d11
< import ppl.delite.framework.analysis.StencilExp
16c15
<     with PrimitiveOpsExp with VariantsOpsExp with DeliteCollectionOpsExp with DeliteReductionOpsExp with DeliteArrayOpsExp with StencilExp
---
>     with VariantsOpsExp with DeliteCollectionOpsExp with DeliteReductionOpsExp
111,113d109
< 
<   trait DeliteOpInput[A] extends DeliteOp[A]
<   
140,141c136,137
<     func: Block[A]
<     //sync: Block[List[Any]] // FIXME: don't want to create lists at runtime...
---
>     func: Block[A],
>     sync: Block[List[Any]] // FIXME: don't want to create lists at runtime...
270c266
<     case e:DeliteCollectElem[_,_,_] => false //e.par == ParBuffer //e.cond.nonEmpty
---
>     case e:DeliteCollectElem[_,_,_] => e.par == ParBuffer  || e.par == ParSimpleBuffer //e.cond.nonEmpty
782,783c778,779
<       func = reifyEffects(this.func(dc_apply(in,v)))
<       //sync = reifyEffects(this.sync(i))
---
>       func = reifyEffects(this.func(dc_apply(in,v))),
>       sync = reifyEffects(this.sync(i))
829,830c825,826
<       func = reifyEffects(this.func(v))
<       //sync = reifyEffects(unit(List()))
---
>       func = reifyEffects(this.func(v)),
>       sync = reifyEffects(unit(List()))
1177,1178c1173,1174
<           func = fb(e.func)(e.mA)
<           //sync = f(e.sync)
---
>           func = fb(e.func)(e.mA),
>           sync = f(e.sync)
1218c1214
<     case op: DeliteForeachElem[_] => blocks(op.func) //::: blocks(op.sync)
---
>     case op: DeliteForeachElem[_] => blocks(op.func) ::: blocks(op.sync)
1239c1235
<     case op: DeliteForeachElem[_] => syms(op.func) //::: syms(op.sync)
---
>     case op: DeliteForeachElem[_] => syms(op.func) ::: syms(op.sync)
1257c1253
<     case op: DeliteForeachElem[_] => syms(op.func) //::: syms(op.sync)
---
>     case op: DeliteForeachElem[_] => syms(op.func) ::: syms(op.sync)
1275c1271
<     case op: DeliteForeachElem[_] => effectSyms(op.func) //::: effectSyms(op.sync)
---
>     case op: DeliteForeachElem[_] => effectSyms(op.func) ::: effectSyms(op.sync)
1295c1291
<     case op: DeliteForeachElem[_] => /*freqNormal(op.sync) :::*/ freqHot(op.func)
---
>     case op: DeliteForeachElem[_] => freqNormal(op.sync) ::: freqHot(op.func)
1453d1448
<   def emitObject(name: String)(body: => Unit)
1483a1479
>                 stream.println("val " + quote(sym) + "_zero = {"/*}*/)
1494d1489
< 
1516d1510
< 
1537a1532,1533
> 
> 
1601a1598
> 
1668,1671d1664
<             def wrap(result: String) = if (Config.generateSerializable) 
<               "new ppl.delite.runtime.data.LocalDeliteArray" + (if (isPrimitiveType(elem.mV)) remap(elem.mV) else "Object[" + remap(elem.mV) + "]") + "(" + result + ")"
<             else result
< 
1673c1666
<               stream.println("val " + quote(sym) + " = " + wrap(quote(sym) + "_hash_data.take(" + quotedGroup + "_sze)"))
---
>               stream.println("val " + quote(sym) + " = " + quote(sym) + "_hash_data.take(" + quotedGroup + "_sze)")
1675c1668
<               stream.println(prefixSym + quote(sym) + " = " + wrap(prefixSym + quote(sym) + "_hash_data.take(" + quotedGroup + "_sze)"))
---
>               stream.println(prefixSym + quote(sym) + " = " + prefixSym + quote(sym) + "_hash_data.take(" + quotedGroup + "_sze)")
1840d1832
<       case (sym, elem: DeliteHashElem[_,_]) => //done above
1918d1909
<       case (sym, elem: DeliteHashElem[_,_]) => 
1934,1935d1924
<     emitVarDef("loopStart", remap(Manifest.Int), "0")
<     emitVarDef("loopSize", remap(Manifest.Int), "0")
1944c1933
<             emitValDef(elem.sV, "loopSize")
---
>             emitValDef(elem.sV, quote(op.size))
1946,1949d1934
<             if (Config.generateSerializable) {
<               val arraySym = if (!remap(elem.allocN.tp).contains("DeliteArray")) fieldAccess(quote(getBlockResult(elem.allocN)), dc_data_field(getBlockResult(elem.allocN))(elem.mA)) else quote(getBlockResult(elem.allocN)) 
<               emitAssignment(fieldAccess(arraySym,"offset"), "loopStart") //FIXME: extremely hacky
<             }
1981c1966
<       if (op.body exists (b => loopBodyNeedsCombine(b) || loopBodyNeedsPostProcess(b))) {
---
>       if (op.body exists (loopBodyNeedsCombine _)) {
2067d2051
<           if (Config.generateSerializable) emitAssignment(fieldAccess("__act",quote(sym)), remap(sym.tp)+".combine(" + fieldAccess("__act",quote(sym)) + "," + fieldAccess("rhs",quote(sym)) + ")")
2167c2151
<               emitValDef(elem.sV, "loopSize")
---
>               emitValDef(elem.sV, quote(op.size))
2180,2205d2163
<     //TODO: This would not be needed if other targets (CUDA, C, etc) properly creates activation records
<     emitMethod("initAct", "activation_"+kernelName, List()) {
<       emitValDef("act", "activation_"+kernelName, "new activation_"+kernelName)
<       (symList zip op.body) foreach {
<         case (sym, elem: DeliteCollectElem[_,_,_]) =>
<         case (sym, elem: DeliteForeachElem[_]) =>
<         case (sym, elem: DeliteReduceElem[_]) =>
<           emitBlock(elem.zero)
<           emitAssignment(fieldAccess("act",quote(sym)+"_zero"),quote(getBlockResult(elem.zero)))
<         case (sym, elem: DeliteReduceTupleElem[_,_]) => 
<           emitBlock(elem.zero._1)
<           emitAssignment(fieldAccess("act",quote(sym)+"_zero"),quote(getBlockResult(elem.zero._1)))
<           emitBlock(elem.zero._2)
<           emitAssignment(fieldAccess("act",quote(sym)+"_zero_2"),quote(getBlockResult(elem.zero._2)))
<         case (sym, elem: DeliteHashReduceElem[_,_,_]) => 
<           emitBlock(elem.zero)
<           emitAssignment(fieldAccess("act",quote(sym)+"_zero"),quote(getBlockResult(elem.zero)))
<           emitAssignment(fieldAccess("act",quote(sym)+"_hash_data"), "new Array(128)")   
<         case (sym, elem: DeliteHashElem[_,_]) =>       
<       }
<       val keyGroups = (symList zip op.body) collect { case (sym, elem: DeliteHashReduceElem[_,_,_]) => (sym,elem) } groupBy(_._2.keyFunc)
<       for((key,kps) <- keyGroups) 
<         emitAssignment(fieldAccess("act",kps.map(p=>quote(p._1)).mkString("")+"_hash_pos"), "new generated.scala.container.HashMapImpl(512,128)") 
<       emitReturn("act")
<     }
< 
2242,2333d2199
<       if (Config.generateSerializable) {
<         emitMethod("serialize", "java.util.ArrayList[com.google.protobuf.ByteString]", List()) {
<           def serializeRef(sym: String) = "ppl.delite.runtime.messages.Serialization.serialize(this." + sym + ", true, \"" + sym + "\")"
<           def serializeVal(sym: String, size: String = "-1") = "ppl.delite.runtime.messages.Serialization.serialize(this." + sym + ", 0, " + size + ")"
< 
<           emitValDef("arr", "java.util.ArrayList[com.google.protobuf.ByteString]", "new java.util.ArrayList")
<           def prefix = "arr.add"
<           var firstHash = true
<           (symList zip op.body) foreach {
<             case (sym, elem: DeliteHashReduceElem[_,_,_]) =>
<               if (firstHash) {
<                 emitValDef("size", remap(Manifest.Int), kernelName+"_hash_pos.size")
<                 emitMethodCall(prefix, List(serializeVal(kernelName+"_hash_pos.unsafeKeys", "size")))
<                 //emitMethodCall(prefix, List(serializeVal(kernelName+"_hash_pos.unsafeIndices"))) //TODO: remove this
<                 firstHash = false
<               }
<               emitMethodCall(prefix, List(serializeVal(quote(sym)+"_hash_data", "size")))
<             case (sym, elem: DeliteCollectElem[_,_,_]) =>
<               emitMethodCall(prefix, List(serializeRef(quote(sym))))
<             case (sym, elem: DeliteForeachElem[_]) =>
<             case (sym, elem: DeliteReduceElem[_]) =>
<               emitMethodCall(prefix, List(serializeVal(quote(sym))))
<               //emitMethodCall(prefix, List(serializeVal(quote(sym)+"_zero")))
<             case (sym, elem: DeliteReduceTupleElem[_,_]) =>
<               emitMethodCall(prefix, List(serializeVal(quote(sym))))
<               emitMethodCall(prefix, List(serializeVal(quote(sym)+"_2")))
<           }
<           emitReturn("arr")
<         }
<          
<         //TODO: This would not be needed if other targets (CUDA, C, etc) properly creates activation records
<         //Target devices should send back the key array also, not just the data.
<         //This unwrapping would only work for dense perfect hash cases.
<         emitMethod("unwrap", remap(Manifest.Unit), List()) {
<           val keyGroups = (symList zip op.body) collect { case (sym, elem: DeliteHashReduceElem[_,_,_]) => (sym,elem) } groupBy(_._2.keyFunc)
<           for((key,kps) <- keyGroups) {
<             val name = kps.map(p=>quote(p._1)).mkString("")
<             emitVarDef("i_"+name, remap(Manifest.Int), "0")
<             stream.println("while(i_"+name+" < " + fieldAccess(quote(kps(0)._1),"length") + ") {")
<             emitMethodCall(fieldAccess(name+"_hash_pos","put"),List("i_"+name))
<             emitAssignment("i_"+name,"i_"+name+"+1")
<             stream.println("}")
<           }
<           (symList zip op.body) foreach { 
<             case (sym, elem: DeliteHashReduceElem[_,_,_]) =>
<               emitAssignment(quote(sym)+"_hash_data",fieldAccess(quote(sym),"data"))
<               releaseRef(quote(sym))
<             case _ =>
<           }
<         }
< 
<       }   
<     }
< 
<     emitObject("activation_" + kernelName) {
<       if (Config.generateSerializable) {
<         emitMethod("deserialize", "activation_"+kernelName, List(("bytes", "java.util.List[com.google.protobuf.ByteString]"))) {
<           var idx = -1
<           def deserialize(tp: String) = { 
<             idx += 1
<             if (tp.contains("DeliteArrayObject")) //FIXME: need to handle this generically
<               "ppl.delite.runtime.messages.Serialization.deserializeDeliteArrayObject["+tp.substring(tp.indexOf("[")+1,tp.indexOf("]"))+"](ppl.delite.runtime.messages.Messages.ArrayMessage.parseFrom(bytes.get("+idx+")))"
<             else 
<               "ppl.delite.runtime.messages.Serialization.deserialize(classOf["+tp+"], bytes.get(" + idx + "))" 
<           }
<           emitValDef("act", "activation_"+kernelName, "new activation_"+kernelName)
<           val prefix = "act."
<           var firstHash = true
<           (symList zip op.body) foreach {
<             case (sym, elem: DeliteHashReduceElem[_,_,_]) =>
<               if (firstHash) {
<                 val keyType = if (isPrimitiveType(elem.keyFunc.tp)) "ppl.delite.runtime.data.DeliteArray" + remap(elem.keyFunc.tp) else "ppl.delite.runtime.data.DeliteArrayObject[" + remap(elem.keyFunc.tp) + "]"
<                 emitValDef("keys", keyType, deserialize(keyType))
<                 //emitValDef("indices", "Array[Int]", deserialize("Array[Int]"))
<                 emitAssignment(prefix+kernelName+"_hash_pos", "", "new generated.scala.container.HashMapImpl[" + remap(elem.keyFunc.tp) + "](keys.length*4,keys.length)")
<                 stream.println("for (i <- 0 until keys.length) " + prefix+kernelName+"_hash_pos.put(keys(i))") //FIXME!              
<                 firstHash = false
<               }
<               emitAssignment(prefix+quote(sym)+"_hash_data", "", deserialize(remap(sym.tp))+".data")
<             case (sym, elem: DeliteCollectElem[_,_,_]) =>
<               emitAssignment(prefix+quote(sym), "", deserialize(remap(sym.tp)))
<             case (sym, elem: DeliteForeachElem[_]) =>
<             case (sym, elem: DeliteReduceElem[_]) =>
<               emitAssignment(prefix+quote(sym), "", deserialize(remap(sym.tp)))
<               //emitAssignment(prefix+quote(sym)+"_zero", "", deserialize(remap(sym.tp)))
<             case (sym, elem: DeliteReduceTupleElem[_,_]) => 
<               emitAssignment(prefix+quote(sym), "", deserialize(remap(sym.tp)))
<               emitAssignment(prefix+quote(sym)+"_2", "", deserialize(remap(elem.func._2.tp)))
<           }
<           emitReturn("act")
<         }
<       }
2403,2408d2268
<   def emitObject(name: String)(body: => Unit) {
<     stream.println("object " + name + " {")
<     body
<     stream.println("}")
<   }
< 
2724d2583
< 
2729c2588
<           //if(!isPrimitiveType(elem.mV)) throw new GenerationFailedException("GPUGen DeliteOPs: DeliteHashReduceElem only supports primitve type reduction.") 
---
>           if(!isPrimitiveType(elem.mV)) throw new GenerationFailedException("GPUGen DeliteOPs: DeliteHashReduceElem only supports primitve type reduction.") 
2731,2744d2589
< 
<           if(!isPrimitiveType(elem.mV)) {
<             if(encounteredZipWith contains getBlockResult(elem.rFunc)) {
<               val z = encounteredZipWith.get(getBlockResult(elem.rFunc)).get
<               if(isPrimitiveType(z.dmR)) lf.tpe = "HASH_REDUCE_SPEC"
<               else throw new GenerationFailedException("GPUGen DeliteOps: DeliteHashReduceElem with non-primitive types is not supported.")
<             }
<             else {
<               throw new GenerationFailedException("GPUGen DeliteOps: DeliteHashReduceElem with non-primitive types is not supported.")
<             }
<           }
<           else {
<             lf.tpe = "HASH_REDUCE"
<           }
2791,2794d2635
<         if(lf.tpe == "HASH_REDUCE_SPEC") {
<           val z = encounteredZipWith.get(getBlockResult(elem.rFunc)).get
<           stream.println("__device__ " + remap(z.dmR) + " dev_spcinit_" + funcNameSuffix(sym) + "(void) { return 0; }") 
<         }
2843c2684
<         val freeVars = getFreeVarBlock(elem.func,List(op.v)).distinct
---
>         val freeVars = getFreeVarBlock(Block(Combine(List(elem.func).map(getBlockResultFull))),List(op.v)).distinct
3033,3054d2873
<       case (sym, elem: DeliteHashReduceElem[_,_,_]) if(encounteredZipWith contains getBlockResult(elem.rFunc)) =>
<         // FIXIT: Hacky way of generating zip function
<         val z = encounteredZipWith.get(getBlockResult(elem.rFunc)).get
<         val zbody = z.body.asInstanceOf[DeliteCollectElem[_,_,_]]
<         val prevInnerScope = innerScope
<         val result = zbody.func
<         result.res match {
<           case r:Sym[_] if(innerScope==null) => innerScope = List(findDefinition(r).get) 
<           case r:Sym[_] => innerScope = findDefinition(r).get :: innerScope
<           case _ => // 
<         }
<         val freeVars = getFreeVarBlock(Block(Combine(List(zbody.func).map(getBlockResultFull))),List(z.fin._1.asInstanceOf[Sym[_]],z.fin._2.asInstanceOf[Sym[_]])).distinct
<         val inputs = remapInputs(freeVars ++ List(z.fin._1.asInstanceOf[Sym[_]],z.fin._2.asInstanceOf[Sym[_]]))
<         stream.println("__device__ " + remap(z.dmR) + " dev_combine_" + funcNameSuffix(sym) + "(" + inputs.mkString(",") + ") {")
<         emitBlock(result)
<         stream.println("return " + quote(getBlockResult(result)) + ";")
<         stream.println("}")
<         innerScope = prevInnerScope 
<         val lf = metaData.loopFuncs.getOrElse(sym,new LoopFunc)
<         lf.loopReduceInputs = freeVars.map(quote)
<         lf.loopFuncOutputType_2 = remap(z.dmR)
< 
3065d2883
< 
3092,3094c2910,2912
<         emitAllocFunc(List((sym,elem.zero)),"allocFunc_"+quote(sym),Nil,Map())
<         lf.loopFuncOutputType = remap(getBlockResult(elem.func).tp)
<       
---
>         val allocInputs = emitMultiLoopAllocFunc(elem.zero, "alloc_"+quote(sym), actName, quote(sym), Map())
>         e.funcs += "alloc" -> allocInputs.map(quote)
> 
3096,3102c2914,2917
<         val lf = metaData.loopFuncs.getOrElse(sym,new LoopFunc)
<         if(isPrimitiveType(sym.tp)) 
<           emitAllocFuncPrimitive(sym, "allocFunc_"+quote(sym))
<         //else
<         //  emitAllocFunc(List((sym,elem.zero)),"allocFunc_"+quote(sym),Nil,Map())
<         lf.loopFuncOutputType = remap(getBlockResult(elem.func).tp)
<           
---
>         val e = metaData.outputs.get(sym).get
>         val allocInputs = emitMultiLoopAllocFunc(elem.zero, "alloc_"+quote(sym), actName, quote(sym), Map())
>         e.funcs += "alloc" -> allocInputs.map(quote)
> 
3104,3115c2919,2922
<         val lf = metaData.loopFuncs.getOrElse(sym,new LoopFunc)
<         assert(isPrimitiveType(sym.tp))         
<         emitAllocFuncPrimitive(sym, "allocFunc_"+quote(sym))
<         lf.loopFuncOutputType = remap(getBlockResult(elem.func._1).tp)
<         lf.loopFuncOutputType_2 = remap(getBlockResult(elem.func._2).tp)
<        
<       case (sym, elem: DeliteHashReduceElem[_,_,_]) if(encounteredZipWith contains getBlockResult(elem.rFunc)) =>
<         val lf = metaData.loopFuncs.getOrElse(sym,new LoopFunc)      
<         val z = encounteredZipWith.get(getBlockResult(elem.rFunc)).get
<         val zbody = z.body.asInstanceOf[DeliteCollectElem[_,_,_]]
<         emitAllocFunc(List((sym,elem.alloc)),"allocFunc_"+quote(sym),Nil,Map())
<         lf.loopFuncOutputType = remap(getBlockResult(elem.valFunc).tp)
---
>         val e = metaData.outputs.get(sym).get
>         assert(isPrimitiveType(sym.tp))  
>         val allocInputs = emitMultiLoopAllocFunc(elem.zero._1, "alloc_"+quote(sym), actName, quote(sym), Map())       
>         e.funcs += "alloc" -> allocInputs.map(quote)
3118,3122c2925,2927
<         val lf = metaData.loopFuncs.getOrElse(sym,new LoopFunc)      
<         emitAllocFunc(List((sym,elem.alloc)),"allocFunc_"+quote(sym),Nil,Map())
<         //lf.loopFuncOutputType_2 = remap(getBlockResult(elem.keyFunc).tp) //TODO: Pass this to DEG metadata
<         lf.loopFuncOutputType = remap(getBlockResult(elem.valFunc).tp)
<         lf.loopFuncOutputType_2 = remap(getBlockResult(elem.valFunc).tp)
---
>         val e = metaData.outputs.get(sym).get
>         val allocInputs = emitMultiLoopAllocFunc(elem.zero, "alloc_"+quote(sym), actName, quote(sym), Map())
>         e.funcs += "alloc" -> allocInputs.map(quote)
3357,3360d3161
<   def emitObject(name: String)(body: => Unit) {
<     
<   }
< 
3434c3235
< }
---
> }
\ No newline at end of file
