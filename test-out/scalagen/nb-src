/*****************************************
  Emitting Generated Code                  
*******************************************/
class NaiveBayesRunner extends ((Array[java.lang.String])=>(Unit)) {
def apply(x0:Array[java.lang.String]): Unit = {
val x1 = println("Naive Bayes Example Application")
val x2 = x0.length
val x3 = x2 < 2
val x7 = {
def x7thenb(): Nothing = {
val x4 = println("NaiveBayes <training file> <test file>")
val x5 = exit(-1)
x5
}
if (x3) {
x7thenb()
}
}
val x8 = x0(0)
val x128 = { 
val x10 = new java.io.FileReader(x8)
val x11 = new java.io.BufferedReader(x10)
var x12: java.io.BufferedReader = x11
val x13 = x12
val x14 = x13.readLine()
var x15: java.lang.String = x14
val x16 = x12
val x17 = x16.readLine()
var x18: java.lang.String = x17
val x19 = x18
val x20 = x19.trim()
val x21 = x20.split("\\s+")
val x22 = x21(0)
val x23 = java.lang.Integer.parseInt(x22)
val x26 = x23 < 0
val x24 = x21(1)
val x25 = java.lang.Integer.parseInt(x24)
val x27 = x25 < 0
val x28 = x26 || x27
val x31 = {
def x31thenb(): Nothing = {
val x29 = error("Illegal input to readTokenMatrix")
x29
}
if (x28) {
x31thenb()
}
}
val x32 = x12
val x33 = x32.readLine()
val x34 = new generated.scala.DoubleVectorImpl(0,true)
val x35 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x37 : Int = 0
val x72 = while (x37 < x23) {
val x38 = x12
val x39 = x38.readLine()
x18 = x39
val x41 = x18
val x42 = x41.trim()
x18 = x42
val x44 = x18
val x46 = new generated.scala.DoubleVectorImpl(x25,true)
var x47: Int = 0
var x48: Int = 1
val x49 = x48
val x45 = x44.split("\\s+")
val x50 = x45.length
val x51 = x50 - 1
val x52 = x49 < x51
val x53 = x45(x49)
val x54 = java.lang.Integer.parseInt(x53)
val x56 = x47
val x57 = x49 + 1
val x58 = x45(x57)
val x59 = java.lang.Double.parseDouble(x58)
val x63 = while ({x52}) {
val x55 = x47 += x54
val x60 = x46(x56) = x59
val x61 = x48 += 2
()
}
val x66 = x34.length
val x64 = x45(0)
val x65 = java.lang.Double.parseDouble(x64)
val x67 = x34.insert(x66, x65)
val x68 = x46// unsafe immutable
val x69 = x35.length
val x70 = x35.insert(x69, x68)
x70
x37 = x37 + 1
}
val x73 = x34.length
val x74 = x34.isRow
val x75 = !x74
// a *thin* loop follows: x81
val x81 = {
val x77 = new generated.scala.DoubleVectorImpl(x73,x75)
x77
}
var x76 = 0
while (x76 < x73) {  // begin fat loop x81
val x79 = x34(x76)
x81.dcUpdate(x76, x79)
x76 += 1
} // end fat loop x81
val x120 = { 
val x82 = x35.length
val x83 = x82==0
val x118 = {
def x118thenb(): generated.scala.Matrix[Double] = {
val x84 = new generated.scala.DoubleMatrixImpl(0,0)
val x85 = x84// unsafe immutable
x85
}
def x118elseb(): generated.scala.Matrix[Double] = {
val x87 = x35(0)
val x88 = x87.isRow
val x89 = x87.length
val x116 = {
def x116thenb(): generated.scala.Matrix[Double] = {
val x90 = new generated.scala.DoubleMatrixImpl(x82,x89)
var x92 : Int = 0
val x101 = while (x92 < x82) {
var x94 : Int = 0
val x99 = while (x94 < x89) {
val x95 = x35(x92)
val x96 = x95(x94)
val x97 = x90(x92, x94) = x96
x97
x94 = x94 + 1
}
x99
x92 = x92 + 1
}
val x102 = x90// unsafe immutable
x102
}
def x116elseb(): generated.scala.Matrix[Double] = {
val x104 = new generated.scala.DoubleMatrixImpl(x89,x82)
var x105 : Int = 0
val x113 = while (x105 < x82) {
var x106 : Int = 0
val x111 = while (x106 < x89) {
val x107 = x35(x105)
val x108 = x107(x106)
val x109 = x104(x106, x105) = x108
x109
x106 = x106 + 1
}
x111
x105 = x105 + 1
}
val x114 = x104// unsafe immutable
x114
}
if (x88) {
x116thenb()
} else { 
x116elseb()
}
}
x116
}
if (x83) {
x118thenb()
} else { 
x118elseb()
}
}
x118
}
val x121 = x12
val x122 = x121.close()
val x123 = x120// unsafe immutable
val x124 = x81// unsafe immutable
val x125 = new generated.scala.DoubleLabelsImpl(x124)
val x126 = new generated.scala.DoubleDoubleTrainingSetImpl(x123,x125)
x126
}
val x129 = x128.numRows
val x130 = "Training model on "+x129
val x131 = x130+" documents."
val x132 = println(x131)
val x133 = Seq()
val x134 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
val x136 = new generated.scala.IndexVectorRangeImpl(0,x129)
val x135 = x128.numCols
val x148 = x136.length
val x149 = x136.isRow
def x152_block = {
val x150 = new generated.scala.DoubleVectorImpl(x148,x149)
var mapIdx = 0
while (mapIdx < x136.size) { // begin map loop x152
val x137 = x136.dcApply(mapIdx)
x150.dcUpdate(mapIdx,  {
val x142 = x137 * x135
var x147: Double = 0
var x139 = 0
while (x139 < x135) {  // begin fat loop x147
val x143 = x142 + x139
val x144 = x128.dcApply(x143)
val x145 = { 
x144
}
val x140 = x147
val x141 = x145
val x146 = x140 + x141
x147 = x146
x139 += 1
} // end fat loop x147
x147
})
mapIdx += 1
} // end map loop x152
x150
}
val x152 = x152_block
val x164 = { 
val x161 = new generated.scala.DoubleVectorImpl(x135,true)
x161
}
val x167 = { 
val x161 = new generated.scala.DoubleVectorImpl(x135,true)
x161
}
val x168 = new generated.scala.IndexVectorRangeImpl(0,x135)
val x153 = x128.labels
val x179 = x128.transposed
val x180 = x179.numCols
val x199 = x135
val x211 = List()
val x212 = {
var forIdx = 0
while (forIdx < x168.size) { // begin foreach loop x212
val x169 = x168.dcApply(forIdx)
var x170: Double = 0.0
var x171: Double = 0.0
var x172: Double = 0.0
var x173: Double = 0.0
var x174: Int = 0
val x175 = x174
val x176 = x175 < x129
val x177 = x153(x175)
val x178 = x177==1
val x181 = x169 * x180
val x182 = x181 + x175
val x183 = x179.dcApply(x182)
val x184 = { 
x183
}
val x186 = x152(x175)
val x195 = while ({x176}) {
val x192 = {
def x192thenb(): Unit = {
val x185 = x170 += x184
val x187 = x171 += x186
()
}
def x192elseb(): Unit = {
val x189 = x172 += x184
val x190 = x173 += x186
()
}
if (x178) {
x192thenb()
} else { 
x192elseb()
}
}
val x193 = x174 += 1
()
}
val x196 = x170
val x197 = x196 + 1.0
val x198 = x171
val x200 = x198 + x199
val x201 = x197 / x200
val x202 = x164(x169) = x201
val x203 = x172
val x204 = x203 + 1.0
val x205 = x173
val x206 = x205 + x199
val x207 = x204 / x206
val x208 = x167(x169) = x207
x208
forIdx += 1
} // end foreach loop x212
}
val x215 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
val x9 = x0(1)
val x334 = { 
val x216 = new java.io.FileReader(x9)
val x217 = new java.io.BufferedReader(x216)
var x218: java.io.BufferedReader = x217
val x219 = x218
val x220 = x219.readLine()
var x221: java.lang.String = x220
val x222 = x218
val x223 = x222.readLine()
var x224: java.lang.String = x223
val x225 = x224
val x226 = x225.trim()
val x227 = x226.split("\\s+")
val x228 = x227(0)
val x229 = java.lang.Integer.parseInt(x228)
val x232 = x229 < 0
val x230 = x227(1)
val x231 = java.lang.Integer.parseInt(x230)
val x233 = x231 < 0
val x234 = x232 || x233
val x237 = {
def x237thenb(): Nothing = {
val x235 = error("Illegal input to readTokenMatrix")
x235
}
if (x234) {
x237thenb()
}
}
val x238 = x218
val x239 = x238.readLine()
val x240 = new generated.scala.DoubleVectorImpl(0,true)
val x241 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x243 : Int = 0
val x278 = while (x243 < x229) {
val x244 = x218
val x245 = x244.readLine()
x224 = x245
val x247 = x224
val x248 = x247.trim()
x224 = x248
val x250 = x224
val x252 = new generated.scala.DoubleVectorImpl(x231,true)
var x253: Int = 0
var x254: Int = 1
val x255 = x254
val x251 = x250.split("\\s+")
val x256 = x251.length
val x257 = x256 - 1
val x258 = x255 < x257
val x259 = x251(x255)
val x260 = java.lang.Integer.parseInt(x259)
val x262 = x253
val x263 = x255 + 1
val x264 = x251(x263)
val x265 = java.lang.Double.parseDouble(x264)
val x269 = while ({x258}) {
val x261 = x253 += x260
val x266 = x252(x262) = x265
val x267 = x254 += 2
()
}
val x272 = x240.length
val x270 = x251(0)
val x271 = java.lang.Double.parseDouble(x270)
val x273 = x240.insert(x272, x271)
val x274 = x252// unsafe immutable
val x275 = x241.length
val x276 = x241.insert(x275, x274)
x276
x243 = x243 + 1
}
val x279 = x240.length
val x280 = x240.isRow
val x281 = !x280
// a *thin* loop follows: x287
val x287 = {
val x283 = new generated.scala.DoubleVectorImpl(x279,x281)
x283
}
var x282 = 0
while (x282 < x279) {  // begin fat loop x287
val x285 = x240(x282)
x287.dcUpdate(x282, x285)
x282 += 1
} // end fat loop x287
val x326 = { 
val x288 = x241.length
val x289 = x288==0
val x324 = {
def x324thenb(): generated.scala.Matrix[Double] = {
val x290 = new generated.scala.DoubleMatrixImpl(0,0)
val x291 = x290// unsafe immutable
x291
}
def x324elseb(): generated.scala.Matrix[Double] = {
val x293 = x241(0)
val x294 = x293.isRow
val x295 = x293.length
val x322 = {
def x322thenb(): generated.scala.Matrix[Double] = {
val x296 = new generated.scala.DoubleMatrixImpl(x288,x295)
var x298 : Int = 0
val x307 = while (x298 < x288) {
var x300 : Int = 0
val x305 = while (x300 < x295) {
val x301 = x241(x298)
val x302 = x301(x300)
val x303 = x296(x298, x300) = x302
x303
x300 = x300 + 1
}
x305
x298 = x298 + 1
}
val x308 = x296// unsafe immutable
x308
}
def x322elseb(): generated.scala.Matrix[Double] = {
val x310 = new generated.scala.DoubleMatrixImpl(x295,x288)
var x311 : Int = 0
val x319 = while (x311 < x288) {
var x312 : Int = 0
val x317 = while (x312 < x295) {
val x313 = x241(x311)
val x314 = x313(x312)
val x315 = x310(x312, x311) = x314
x315
x312 = x312 + 1
}
x317
x311 = x311 + 1
}
val x320 = x310// unsafe immutable
x320
}
if (x294) {
x322thenb()
} else { 
x322elseb()
}
}
x322
}
if (x289) {
x324thenb()
} else { 
x324elseb()
}
}
x324
}
val x327 = x218
val x328 = x327.close()
val x329 = x326// unsafe immutable
val x330 = x287// unsafe immutable
val x331 = new generated.scala.DoubleLabelsImpl(x330)
val x332 = new generated.scala.DoubleDoubleTrainingSetImpl(x329,x331)
x332
}
val x335 = println("phi_y1: ")
val x357 = { 
val x336 = x164.isRow
val x355 = {
def x355thenb(): Unit = {
val x337 = print("[ ")
var x339 : Int = 0
val x344 = while (x339 < x135) {
val x340 = x164(x339)
val x341 = print(x340)
val x342 = print(" ")
x342
x339 = x339 + 1
}
val x345 = print("]\n")
x345
}
def x355elseb(): Unit = {
var x347 : Int = 0
val x353 = while (x347 < x135) {
val x348 = print("[")
val x349 = x164(x347)
val x350 = print(x349)
val x351 = print(" ]\n")
x351
x347 = x347 + 1
}
x353
}
if (x336) {
x355thenb()
} else { 
x355elseb()
}
}
x355
}
val x358 = println("phi_y0: ")
val x379 = { 
val x359 = x167.isRow
val x377 = {
def x377thenb(): Unit = {
val x360 = print("[ ")
var x361 : Int = 0
val x366 = while (x361 < x135) {
val x362 = x167(x361)
val x363 = print(x362)
val x364 = print(" ")
x364
x361 = x361 + 1
}
val x367 = print("]\n")
x367
}
def x377elseb(): Unit = {
var x369 : Int = 0
val x375 = while (x369 < x135) {
val x370 = print("[")
val x371 = x167(x369)
val x372 = print(x371)
val x373 = print(" ]\n")
x373
x369 = x369 + 1
}
x375
}
if (x359) {
x377thenb()
} else { 
x377elseb()
}
}
x377
}
val x154 = x153.length
var x160: Double = 0
var x155 = 0
while (x155 < x154) {  // begin fat loop x160
val x158 = x153(x155)
val x156 = x160
val x157 = x158
val x159 = x156 + x157
x160 = x159
x155 += 1
} // end fat loop x160
val x213 = x129
val x214 = x160 / x213
val x380 = "phi_y: "+x214
val x381 = println(x380)
val x382 = x334.numRows
val x384 = "Testing model on "+x382
val x385 = x384+" documents."
val x386 = println(x385)
val x387 = new generated.scala.IndexVectorRangeImpl(0,x382)
val x383 = x334.numCols
val x397 = 1.0 - x214
val x398 = Math.log(x397)
val x403 = Math.log(x214)
val x408 = (0.0,0.0)
val x411 = new generated.scala.RangeVectorImpl(0,x383,1,true)
val x427 = x387.length
val x428 = x387.isRow
def x431_block = {
val x429 = new generated.scala.DoubleVectorImpl(x427,x428)
var mapIdx = 0
while (mapIdx < x387.size) { // begin map loop x431
val x388 = x387.dcApply(mapIdx)
x429.dcUpdate(mapIdx,  {
val x390 = x388 * x383
def x421_block = {
val x389 = x411.dcApply(0)
var x412 = {
val x391 = x390 + x389
val x392 = x334.dcApply(x391)
val x393 = { 
x392
}
val x394 = x393 > 0.0
val x409 = {
def x409thenb(): scala.Tuple2[Double, Double] = {
val x395 = x167(x389)
val x401 = x164(x389)
val x396 = Math.log(x395)
val x399 = x396 + x398
val x400 = x399 * x393
val x402 = Math.log(x401)
val x404 = x402 + x403
val x405 = x404 * x393
val x406 = (x400,x405)
x406
}
def x409elseb(): scala.Tuple2[Double, Double] = {
x408
}
if (x394) {
x409thenb()
} else { 
x409elseb()
}
}
x409
}
var mapReduceIdx = 1
while (mapReduceIdx < x411.size) { // begin mapReduce loop x421
val x389 = x411.dcApply(mapReduceIdx)
val x413 = {
val x391 = x390 + x389
val x392 = x334.dcApply(x391)
val x393 = { 
x392
}
val x394 = x393 > 0.0
val x409 = {
def x409thenb(): scala.Tuple2[Double, Double] = {
val x395 = x167(x389)
val x401 = x164(x389)
val x396 = Math.log(x395)
val x399 = x396 + x398
val x400 = x399 * x393
val x402 = Math.log(x401)
val x404 = x402 + x403
val x405 = x404 * x393
val x406 = (x400,x405)
x406
}
def x409elseb(): scala.Tuple2[Double, Double] = {
x408
}
if (x394) {
x409thenb()
} else { 
x409elseb()
}
}
x409
}
x412 = {
val x414 = x412._1
val x416 = x413._1
val x418 = x414 + x416
val x415 = x412._2
val x417 = x413._2
val x419 = x415 + x417
val x420 = (x418,x419)
x420
}
mapReduceIdx += 1
} // end mapReduce loop x421
x412
}
val x421 = x421_block
val x422 = x421._1
val x423 = x421._2
val x424 = x423 > x422
val x425 = {
def x425thenb(): Double = {
1.0
}
def x425elseb(): Double = {
0.0
}
if (x424) {
x425thenb()
} else { 
x425elseb()
}
}
x425
})
mapIdx += 1
} // end map loop x431
x429
}
val x431 = x431_block
val x433 = x334.labels
val x438 = new generated.scala.RangeVectorImpl(0,x382,1,true)
def x442_block = {
val x432 = x438.dcApply(0)
var x439 = {
val x434 = x433(x432)
val x435 = x431(x432)
val x436 = x434 != x435
val x437 = {
def x437thenb(): Int = {
1
}
def x437elseb(): Int = {
0
}
if (x436) {
x437thenb()
} else { 
x437elseb()
}
}
x437
}
var mapReduceIdx = 1
while (mapReduceIdx < x438.size) { // begin mapReduce loop x442
val x432 = x438.dcApply(mapReduceIdx)
val x440 = {
val x434 = x433(x432)
val x435 = x431(x432)
val x436 = x434 != x435
val x437 = {
def x437thenb(): Int = {
1
}
def x437elseb(): Int = {
0
}
if (x436) {
x437thenb()
} else { 
x437elseb()
}
}
x437
}
x439 = {
val x441 = x439 + x440
x441
}
mapReduceIdx += 1
} // end mapReduce loop x442
x439
}
val x442 = x442_block
val x443 = x442.doubleValue()
val x444 = x382.doubleValue()
val x445 = x443 / x444
val x446 = "Test error: "+x445
val x447 = println(x446)
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
