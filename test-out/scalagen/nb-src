/*****************************************
  Emitting Generated Code                  
*******************************************/
class NaiveBayesRunner extends ((Array[java.lang.String])=>(Unit)) {
def apply(x0:Array[java.lang.String]): Unit = {
val x1 = println("Naive Bayes Example Application")
val x2 = x0.length
val x3 = x2 < 2
val x7 = {
def x7thenb(): Nothing = {
val x4 = println("NaiveBayes <training file> <test file>")
val x5 = exit(-1)
x5
}
def x7elseb(): Unit = {
()
}
if (x3) {
x7thenb()
} else {
x7elseb()
}
}
val x8 = x0(0)
def x131_block = { 
val x10 = new java.io.FileReader(x8)
val x11 = new java.io.BufferedReader(x10)
var x12: java.io.BufferedReader = x11
val x13 = x12
val x14 = x13.readLine()
var x15: java.lang.String = x14
val x16 = x12
val x17 = x16.readLine()
var x18: java.lang.String = x17
val x19 = x18
val x20 = x19.trim()
val x21 = x20.split("\\s+")
val x22 = x21(0)
val x23 = java.lang.Integer.parseInt(x22)
val x26 = x23 < 0
val x24 = x21(1)
val x25 = java.lang.Integer.parseInt(x24)
val x27 = x25 < 0
val x28 = x26 || x27
val x31 = {
def x31thenb(): Nothing = {
val x29 = error("Illegal input to readTokenMatrix")
x29
}
def x31elseb(): Unit = {
()
}
if (x28) {
x31thenb()
} else {
x31elseb()
}
}
val x32 = x12
val x33 = x32.readLine()
val x34 = new generated.scala.DoubleVectorImpl(0,true)
var x36 : Int = 0
val x50 = while (x36 < x23) {
val x37 = x12
val x38 = x37.readLine()
x18 = x38
val x40 = x18
val x41 = x40.trim()
x18 = x41
val x43 = x18
val x47 = x34.length
val x44 = x43.split("\\s+")
val x45 = x44(0)
val x46 = java.lang.Double.parseDouble(x45)
val x48 = x34.insert(x47, x46)
x48
x36 = x36 + 1
}
val x51 = x34.length
val x52 = x34.isRow
val x53 = !x52
val x59 = {
val x55 = new generated.scala.DoubleVectorImpl(x51,x53)
x55
}
var x54 = 0
while (x54 < x51) {  // begin thin loop x59
val x57 = x34(x54)
x59.dcUpdate(x54, x57)
x54 += 1
} // end thin loop x59
val x60 = x12
val x61 = x60.close()
val x62 = new java.io.FileReader(x8)
val x63 = new java.io.BufferedReader(x62)
x12 = x63
val x65 = x12
val x66 = x65.readLine()
val x67 = x12
val x68 = x67.readLine()
val x69 = x12
val x70 = x69.readLine()
val x71 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x72 : Int = 0
val x105 = while (x72 < x23) {
val x73 = x12
val x74 = x73.readLine()
x18 = x74
val x76 = x18
val x77 = x76.trim()
x18 = x77
val x79 = x18
val x81 = new generated.scala.DoubleVectorImpl(x25,true)
var x82: Int = 0
var x83: Int = 1
val x80 = x79.split("\\s+")
val x85 = x80.length
val x86 = x85 - 1
val x101 = while ({val x84 = x83
val x87 = x84 < x86
x87}) {
val x89 = x83
val x90 = x80(x89)
val x91 = java.lang.Integer.parseInt(x90)
val x92 = x82 += x91
val x93 = x82
val x94 = x83
val x95 = x94 + 1
val x96 = x80(x95)
val x97 = java.lang.Double.parseDouble(x96)
val x98 = x81(x93) = x97
val x99 = x83 += 2
()
}
val x102 = x71.length
val x103 = x71.insert(x102, x81)
x103
x72 = x72 + 1
}
def x125_block = { 
val x106 = x71.length
val x107 = x106 > 0
val x111 = {
def x111thenb(): Int = {
val x108 = x71(0)
val x109 = x108.length
x109
}
def x111elseb(): Int = {
0
}
if (x107) {
x111thenb()
} else {
x111elseb()
}
}
val x112 = new generated.scala.DoubleMatrixImpl(x106,x111)
var x114 : Int = 0
val x123 = while (x114 < x106) {
var x116 : Int = 0
val x121 = while (x116 < x111) {
val x117 = x71(x114)
val x118 = x117(x116)
val x119 = x112(x114, x116) = x118
x119
x116 = x116 + 1
}
x121
x114 = x114 + 1
}
x112
}
val x125 = x125_block
val x126 = x12
val x127 = x126.close()
val x128 = new generated.scala.DoubleLabelsImpl(x59)
val x129 = new generated.scala.DoubleDoubleTrainingSetImpl(x125,x128)
x129
}
val x131 = x131_block
val x132 = Seq()
val x133 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
val x134 = x131.numRows
val x136 = new generated.scala.IndexVectorRangeImpl(0,x134)
val x135 = x131.numCols
val x145 = x136.length
val x146 = x136.isRow
def x149_block = {
val x147 = new generated.scala.DoubleVectorImpl(x145,x146)
var mapIdx = 0
while (mapIdx < x136.size) {
val x137 = x136.dcApply(mapIdx)
x147.dcUpdate(mapIdx,  {
var x144: Double = 0
var x139 = 0
while (x139 < x135) {  // begin fat loop x144
val x142 = x131(x137, x139)
val x140 = x144
val x141 = x142
val x143 = x140 + x141
x144 = x143
x139 += 1
} // end fat loop x144
x144
})
mapIdx += 1
} // end while
x147
}
val x149 = x149_block
val x150 = "Training model on "+x134
val x151 = x150+" documents."
val x152 = println(x151)
def x163_block = { 
val x161 = new generated.scala.DoubleVectorImpl(x135,true)
x161
}
val x163 = x163_block
def x166_block = { 
val x164 = new generated.scala.DoubleVectorImpl(x135,true)
x164
}
val x166 = x166_block
val x167 = new generated.scala.IndexVectorRangeImpl(0,x135)
val x153 = x131.labels
val x202 = x135
val x214 = List()
def x215_block = {
var forIdx = 0
while (forIdx < x167.size) {
val x168 = x167.dcApply(forIdx)
var x169: Double = 0.0
var x170: Double = 0.0
var x171: Double = 0.0
var x172: Double = 0.0
var x173: Int = 0
val x198 = while ({val x174 = x173
val x175 = x174 < x134
x175}) {
val x177 = x173
val x178 = x153(x177)
val x179 = x178==1
val x195 = {
def x195thenb(): Unit = {
val x181 = x173
val x180 = x131.transposed
val x182 = x180(x168, x181)
val x183 = x169 += x182
val x184 = x173
val x185 = x149(x184)
val x186 = x170 += x185
()
}
def x195elseb(): Unit = {
val x188 = x173
val x180 = x131.transposed
val x189 = x180(x168, x188)
val x190 = x171 += x189
val x191 = x173
val x192 = x149(x191)
val x193 = x172 += x192
()
}
if (x179) {
x195thenb()
} else {
x195elseb()
}
}
val x196 = x173 += 1
()
}
val x199 = x169
val x201 = x170
val x200 = x199 + 1.0
val x203 = x201 + x202
val x204 = x200 / x203
val x205 = x163(x168) = x204
val x206 = x171
val x208 = x172
val x207 = x206 + 1.0
val x209 = x208 + x202
val x210 = x207 / x209
val x211 = x166(x168) = x210
x211
forIdx += 1
} // end while
}
val x215 = x215_block
val x218 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
val x9 = x0(1)
def x340_block = { 
val x219 = new java.io.FileReader(x9)
val x220 = new java.io.BufferedReader(x219)
var x221: java.io.BufferedReader = x220
val x222 = x221
val x223 = x222.readLine()
var x224: java.lang.String = x223
val x225 = x221
val x226 = x225.readLine()
var x227: java.lang.String = x226
val x228 = x227
val x229 = x228.trim()
val x230 = x229.split("\\s+")
val x231 = x230(0)
val x232 = java.lang.Integer.parseInt(x231)
val x235 = x232 < 0
val x233 = x230(1)
val x234 = java.lang.Integer.parseInt(x233)
val x236 = x234 < 0
val x237 = x235 || x236
val x240 = {
def x240thenb(): Nothing = {
val x238 = error("Illegal input to readTokenMatrix")
x238
}
def x240elseb(): Unit = {
()
}
if (x237) {
x240thenb()
} else {
x240elseb()
}
}
val x241 = x221
val x242 = x241.readLine()
val x243 = new generated.scala.DoubleVectorImpl(0,true)
var x245 : Int = 0
val x259 = while (x245 < x232) {
val x246 = x221
val x247 = x246.readLine()
x227 = x247
val x249 = x227
val x250 = x249.trim()
x227 = x250
val x252 = x227
val x256 = x243.length
val x253 = x252.split("\\s+")
val x254 = x253(0)
val x255 = java.lang.Double.parseDouble(x254)
val x257 = x243.insert(x256, x255)
x257
x245 = x245 + 1
}
val x260 = x243.length
val x261 = x243.isRow
val x262 = !x261
val x268 = {
val x264 = new generated.scala.DoubleVectorImpl(x260,x262)
x264
}
var x263 = 0
while (x263 < x260) {  // begin thin loop x268
val x266 = x243(x263)
x268.dcUpdate(x263, x266)
x263 += 1
} // end thin loop x268
val x269 = x221
val x270 = x269.close()
val x271 = new java.io.FileReader(x9)
val x272 = new java.io.BufferedReader(x271)
x221 = x272
val x274 = x221
val x275 = x274.readLine()
val x276 = x221
val x277 = x276.readLine()
val x278 = x221
val x279 = x278.readLine()
val x280 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x281 : Int = 0
val x314 = while (x281 < x232) {
val x282 = x221
val x283 = x282.readLine()
x227 = x283
val x285 = x227
val x286 = x285.trim()
x227 = x286
val x288 = x227
val x290 = new generated.scala.DoubleVectorImpl(x234,true)
var x291: Int = 0
var x292: Int = 1
val x289 = x288.split("\\s+")
val x294 = x289.length
val x295 = x294 - 1
val x310 = while ({val x293 = x292
val x296 = x293 < x295
x296}) {
val x298 = x292
val x299 = x289(x298)
val x300 = java.lang.Integer.parseInt(x299)
val x301 = x291 += x300
val x302 = x291
val x303 = x292
val x304 = x303 + 1
val x305 = x289(x304)
val x306 = java.lang.Double.parseDouble(x305)
val x307 = x290(x302) = x306
val x308 = x292 += 2
()
}
val x311 = x280.length
val x312 = x280.insert(x311, x290)
x312
x281 = x281 + 1
}
def x334_block = { 
val x315 = x280.length
val x316 = x315 > 0
val x320 = {
def x320thenb(): Int = {
val x317 = x280(0)
val x318 = x317.length
x318
}
def x320elseb(): Int = {
0
}
if (x316) {
x320thenb()
} else {
x320elseb()
}
}
val x321 = new generated.scala.DoubleMatrixImpl(x315,x320)
var x323 : Int = 0
val x332 = while (x323 < x315) {
var x325 : Int = 0
val x330 = while (x325 < x320) {
val x326 = x280(x323)
val x327 = x326(x325)
val x328 = x321(x323, x325) = x327
x328
x325 = x325 + 1
}
x330
x323 = x323 + 1
}
x321
}
val x334 = x334_block
val x335 = x221
val x336 = x335.close()
val x337 = new generated.scala.DoubleLabelsImpl(x268)
val x338 = new generated.scala.DoubleDoubleTrainingSetImpl(x334,x337)
x338
}
val x340 = x340_block
val x341 = println("phi_y1: ")
def x363_block = { 
val x342 = x163.isRow
val x361 = {
def x361thenb(): Unit = {
val x343 = print("[ ")
var x345 : Int = 0
val x350 = while (x345 < x135) {
val x346 = x163(x345)
val x347 = print(x346)
val x348 = print(" ")
x348
x345 = x345 + 1
}
val x351 = print("]\n")
x351
}
def x361elseb(): Unit = {
var x353 : Int = 0
val x359 = while (x353 < x135) {
val x354 = print("[")
val x355 = x163(x353)
val x356 = print(x355)
val x357 = print(" ]\n")
x357
x353 = x353 + 1
}
x359
}
if (x342) {
x361thenb()
} else {
x361elseb()
}
}
x361
}
val x363 = x363_block
val x364 = println("phi_y0: ")
def x385_block = { 
val x365 = x166.isRow
val x383 = {
def x383thenb(): Unit = {
val x366 = print("[ ")
var x367 : Int = 0
val x372 = while (x367 < x135) {
val x368 = x166(x367)
val x369 = print(x368)
val x370 = print(" ")
x370
x367 = x367 + 1
}
val x373 = print("]\n")
x373
}
def x383elseb(): Unit = {
var x375 : Int = 0
val x381 = while (x375 < x135) {
val x376 = print("[")
val x377 = x166(x375)
val x378 = print(x377)
val x379 = print(" ]\n")
x379
x375 = x375 + 1
}
x381
}
if (x365) {
x383thenb()
} else {
x383elseb()
}
}
x383
}
val x385 = x385_block
val x154 = x153.length
var x160: Double = 0
var x155 = 0
while (x155 < x154) {  // begin fat loop x160
val x158 = x153(x155)
val x156 = x160
val x157 = x158
val x159 = x156 + x157
x160 = x159
x155 += 1
} // end fat loop x160
val x216 = x134
val x217 = x160 / x216
val x386 = "phi_y: "+x217
val x387 = println(x386)
val x388 = x340.numRows
val x390 = "Testing model on "+x388
val x391 = x390+" documents."
val x392 = println(x391)
val x393 = new generated.scala.IndexVectorRangeImpl(0,x388)
val x389 = x340.numCols
val x414 = new generated.scala.RangeVectorImpl(0,x389,1,true)
val x430 = x393.length
val x431 = x393.isRow
def x434_block = {
val x432 = new generated.scala.DoubleVectorImpl(x430,x431)
var mapIdx = 0
while (mapIdx < x393.size) {
val x394 = x393.dcApply(mapIdx)
x432.dcUpdate(mapIdx,  {
def x424_block = {
val x395 = x414.dcApply(0)
var x415 = {
val x396 = x340(x394, x395)
val x397 = x396 > 0.0
val x412 = {
def x412thenb(): scala.Tuple2[Double, Double] = {
val x398 = x166(x395)
val x404 = x163(x395)
val x399 = Math.log(x398)
val x400 = 1.0 - x217
val x401 = Math.log(x400)
val x402 = x399 + x401
val x403 = x402 * x396
val x405 = Math.log(x404)
val x406 = Math.log(x217)
val x407 = x405 + x406
val x408 = x407 * x396
val x409 = (x403,x408)
x409
}
def x412elseb(): scala.Tuple2[Double, Double] = {
val x411 = (0.0,0.0)
x411
}
if (x397) {
x412thenb()
} else {
x412elseb()
}
}
x412
}
var mapReduceIdx = 1
while (mapReduceIdx < x414.size) {
val x395 = x414.dcApply(mapReduceIdx)
val x416 = {
val x396 = x340(x394, x395)
val x397 = x396 > 0.0
val x412 = {
def x412thenb(): scala.Tuple2[Double, Double] = {
val x398 = x166(x395)
val x404 = x163(x395)
val x399 = Math.log(x398)
val x400 = 1.0 - x217
val x401 = Math.log(x400)
val x402 = x399 + x401
val x403 = x402 * x396
val x405 = Math.log(x404)
val x406 = Math.log(x217)
val x407 = x405 + x406
val x408 = x407 * x396
val x409 = (x403,x408)
x409
}
def x412elseb(): scala.Tuple2[Double, Double] = {
val x411 = (0.0,0.0)
x411
}
if (x397) {
x412thenb()
} else {
x412elseb()
}
}
x412
}
x415 = {
val x417 = x415._1
val x419 = x416._1
val x421 = x417 + x419
val x418 = x415._2
val x420 = x416._2
val x422 = x418 + x420
val x423 = (x421,x422)
x423
}
mapReduceIdx += 1
} // end while
x415
}
val x424 = x424_block
val x425 = x424._1
val x426 = x424._2
val x427 = x426 > x425
val x428 = {
def x428thenb(): Double = {
1.0
}
def x428elseb(): Double = {
0.0
}
if (x427) {
x428thenb()
} else {
x428elseb()
}
}
x428
})
mapIdx += 1
} // end while
x432
}
val x434 = x434_block
val x436 = x340.labels
val x441 = new generated.scala.RangeVectorImpl(0,x388,1,true)
def x445_block = {
val x435 = x441.dcApply(0)
var x442 = {
val x437 = x436(x435)
val x438 = x434(x435)
val x439 = x437 != x438
val x440 = {
def x440thenb(): Int = {
1
}
def x440elseb(): Int = {
0
}
if (x439) {
x440thenb()
} else {
x440elseb()
}
}
x440
}
var mapReduceIdx = 1
while (mapReduceIdx < x441.size) {
val x435 = x441.dcApply(mapReduceIdx)
val x443 = {
val x437 = x436(x435)
val x438 = x434(x435)
val x439 = x437 != x438
val x440 = {
def x440thenb(): Int = {
1
}
def x440elseb(): Int = {
0
}
if (x439) {
x440thenb()
} else {
x440elseb()
}
}
x440
}
x442 = {
val x444 = x442 + x443
x444
}
mapReduceIdx += 1
} // end while
x442
}
val x445 = x445_block
val x446 = x445.doubleValue()
val x447 = x388.doubleValue()
val x448 = x446 / x447
val x449 = "Test error: "+x448
val x450 = println(x449)
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
