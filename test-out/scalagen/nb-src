/*****************************************
  Emitting Generated Code                  
*******************************************/
class NaiveBayesRunner extends ((Array[java.lang.String])=>(Unit)) {
def apply(x0:Array[java.lang.String]): Unit = {
val x1 = println("Naive Bayes Example Application")
val x2 = x0.length
val x3 = x2 < 2
val x7 = {
def x7thenb(): Nothing = {
val x4 = println("NaiveBayes <training file> <test file>")
val x5 = exit(-1)
x5
}
def x7elseb(): Unit = {
()
}
if (x3) {
x7thenb()
} else {
x7elseb()
}
}
val x8 = x0(0)
val x147 = { 
val x10 = new java.io.FileReader(x8)
val x11 = new java.io.BufferedReader(x10)
var x12: java.io.BufferedReader = x11
val x13 = x12
val x14 = x13.readLine()
var x15: java.lang.String = x14
val x16 = x12
val x17 = x16.readLine()
var x18: java.lang.String = x17
val x19 = x18
val x20 = x19.trim()
val x21 = x20.split("\\s+")
val x22 = x21(0)
val x23 = java.lang.Integer.parseInt(x22)
val x26 = x23 < 0
val x24 = x21(1)
val x25 = java.lang.Integer.parseInt(x24)
val x27 = x25 < 0
val x28 = x26 || x27
val x31 = {
def x31thenb(): Nothing = {
val x29 = error("Illegal input to readTokenMatrix")
x29
}
def x31elseb(): Unit = {
()
}
if (x28) {
x31thenb()
} else {
x31elseb()
}
}
val x32 = x12
val x33 = x32.readLine()
val x34 = new generated.scala.DoubleVectorImpl(0,true)
var x36 : Int = 0
val x50 = while (x36 < x23) {
val x37 = x12
val x38 = x37.readLine()
x18 = x38
val x40 = x18
val x41 = x40.trim()
x18 = x41
val x43 = x18
val x47 = x34.length
val x44 = x43.split("\\s+")
val x45 = x44(0)
val x46 = java.lang.Double.parseDouble(x45)
val x48 = x34.insert(x47, x46)
x48
x36 = x36 + 1
}
val x51 = x34.length
val x52 = x34.isRow
val x53 = !x52
// a *thin* loop follows: x59
val x59 = {
val x55 = new generated.scala.DoubleVectorImpl(x51,x53)
x55
}
var x54 = 0
while (x54 < x51) {  // begin fat loop x59
val x57 = x34(x54)
x59.dcUpdate(x54, x57)
x54 += 1
} // end fat loop x59
val x60 = x12
val x61 = x60.close()
val x62 = new java.io.FileReader(x8)
val x63 = new java.io.BufferedReader(x62)
x12 = x63
val x65 = x12
val x66 = x65.readLine()
val x67 = x12
val x68 = x67.readLine()
val x69 = x12
val x70 = x69.readLine()
val x71 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x72 : Int = 0
val x105 = while (x72 < x23) {
val x73 = x12
val x74 = x73.readLine()
x18 = x74
val x76 = x18
val x77 = x76.trim()
x18 = x77
val x79 = x18
val x81 = new generated.scala.DoubleVectorImpl(x25,true)
var x82: Int = 0
var x83: Int = 1
val x80 = x79.split("\\s+")
val x85 = x80.length
val x86 = x85 - 1
val x101 = while ({val x84 = x83
val x87 = x84 < x86
x87}) {
val x89 = x83
val x90 = x80(x89)
val x91 = java.lang.Integer.parseInt(x90)
val x92 = x82 += x91
val x93 = x82
val x94 = x83
val x95 = x94 + 1
val x96 = x80(x95)
val x97 = java.lang.Double.parseDouble(x96)
val x98 = x81(x93) = x97
val x99 = x83 += 2
()
}
val x102 = x71.length
val x103 = x71.insert(x102, x81)
x103
x72 = x72 + 1
}
val x141 = { 
val x106 = x71.length
val x107 = x106==0
val x139 = {
def x139thenb(): generated.scala.Matrix[Double] = {
val x108 = new generated.scala.DoubleMatrixImpl(0,0)
x108
}
def x139elseb(): generated.scala.Matrix[Double] = {
val x110 = x71(0)
val x111 = x110.isRow
val x137 = {
def x137thenb(): generated.scala.Matrix[Double] = {
val x112 = x110.length
val x113 = new generated.scala.DoubleMatrixImpl(x106,x112)
var x115 : Int = 0
val x124 = while (x115 < x106) {
var x117 : Int = 0
val x122 = while (x117 < x112) {
val x118 = x71(x115)
val x119 = x118(x117)
val x120 = x113(x115, x117) = x119
x120
x117 = x117 + 1
}
x122
x115 = x115 + 1
}
x113
}
def x137elseb(): generated.scala.Matrix[Double] = {
val x112 = x110.length
val x126 = new generated.scala.DoubleMatrixImpl(x112,x106)
var x127 : Int = 0
val x135 = while (x127 < x106) {
var x128 : Int = 0
val x133 = while (x128 < x112) {
val x129 = x71(x127)
val x130 = x129(x128)
val x131 = x126(x128, x127) = x130
x131
x128 = x128 + 1
}
x133
x127 = x127 + 1
}
x126
}
if (x111) {
x137thenb()
} else {
x137elseb()
}
}
x137
}
if (x107) {
x139thenb()
} else {
x139elseb()
}
}
x139
}
val x142 = x12
val x143 = x142.close()
val x144 = new generated.scala.DoubleLabelsImpl(x59)
val x145 = new generated.scala.DoubleDoubleTrainingSetImpl(x141,x144)
x145
}
val x148 = Seq()
val x149 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
val x150 = x147.numRows
val x152 = new generated.scala.IndexVectorRangeImpl(0,x150)
val x151 = x147.numCols
val x164 = x152.length
val x165 = x152.isRow
def x168_block = {
val x166 = new generated.scala.DoubleVectorImpl(x164,x165)
var mapIdx = 0
while (mapIdx < x152.size) { // begin map loop x168
val x153 = x152.dcApply(mapIdx)
x166.dcUpdate(mapIdx,  {
val x158 = x153 * x151
var x163: Double = 0
var x155 = 0
while (x155 < x151) {  // begin fat loop x163
val x159 = x158 + x155
val x160 = x147.dcApply(x159)
val x161 = { 
x160
}
val x156 = x163
val x157 = x161
val x162 = x156 + x157
x163 = x162
x155 += 1
} // end fat loop x163
x163
})
mapIdx += 1
} // end map loop x168
x166
}
val x168 = x168_block
val x169 = "Training model on "+x150
val x170 = x169+" documents."
val x171 = println(x170)
val x182 = { 
val x180 = new generated.scala.DoubleVectorImpl(x151,true)
x180
}
val x185 = { 
val x183 = new generated.scala.DoubleVectorImpl(x151,true)
x183
}
val x186 = new generated.scala.IndexVectorRangeImpl(0,x151)
val x172 = x147.labels
val x227 = x151
val x239 = List()
def x240_block = {
var forIdx = 0
while (forIdx < x186.size) { // begin foreach loop x240
val x187 = x186.dcApply(forIdx)
var x188: Double = 0.0
var x189: Double = 0.0
var x190: Double = 0.0
var x191: Double = 0.0
var x192: Int = 0
val x223 = while ({val x193 = x192
val x194 = x193 < x150
x194}) {
val x196 = x192
val x197 = x172(x196)
val x198 = x197==1
val x220 = {
def x220thenb(): Unit = {
val x200 = x192
val x199 = x147.transposed
val x201 = x199.numCols
val x202 = x187 * x201
val x203 = x202 + x200
val x204 = x199.dcApply(x203)
val x205 = { 
x204
}
val x206 = x188 += x205
val x207 = x192
val x208 = x168(x207)
val x209 = x189 += x208
()
}
def x220elseb(): Unit = {
val x211 = x192
val x199 = x147.transposed
val x201 = x199.numCols
val x202 = x187 * x201
val x212 = x202 + x211
val x213 = x199.dcApply(x212)
val x214 = { 
x213
}
val x215 = x190 += x214
val x216 = x192
val x217 = x168(x216)
val x218 = x191 += x217
()
}
if (x198) {
x220thenb()
} else {
x220elseb()
}
}
val x221 = x192 += 1
()
}
val x224 = x188
val x226 = x189
val x225 = x224 + 1.0
val x228 = x226 + x227
val x229 = x225 / x228
val x230 = x182(x187) = x229
val x231 = x190
val x233 = x191
val x232 = x231 + 1.0
val x234 = x233 + x227
val x235 = x232 / x234
val x236 = x185(x187) = x235
x236
forIdx += 1
} // end foreach loop x240
}
val x240 = x240_block
val x243 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
val x9 = x0(1)
val x381 = { 
val x244 = new java.io.FileReader(x9)
val x245 = new java.io.BufferedReader(x244)
var x246: java.io.BufferedReader = x245
val x247 = x246
val x248 = x247.readLine()
var x249: java.lang.String = x248
val x250 = x246
val x251 = x250.readLine()
var x252: java.lang.String = x251
val x253 = x252
val x254 = x253.trim()
val x255 = x254.split("\\s+")
val x256 = x255(0)
val x257 = java.lang.Integer.parseInt(x256)
val x260 = x257 < 0
val x258 = x255(1)
val x259 = java.lang.Integer.parseInt(x258)
val x261 = x259 < 0
val x262 = x260 || x261
val x265 = {
def x265thenb(): Nothing = {
val x263 = error("Illegal input to readTokenMatrix")
x263
}
def x265elseb(): Unit = {
()
}
if (x262) {
x265thenb()
} else {
x265elseb()
}
}
val x266 = x246
val x267 = x266.readLine()
val x268 = new generated.scala.DoubleVectorImpl(0,true)
var x270 : Int = 0
val x284 = while (x270 < x257) {
val x271 = x246
val x272 = x271.readLine()
x252 = x272
val x274 = x252
val x275 = x274.trim()
x252 = x275
val x277 = x252
val x281 = x268.length
val x278 = x277.split("\\s+")
val x279 = x278(0)
val x280 = java.lang.Double.parseDouble(x279)
val x282 = x268.insert(x281, x280)
x282
x270 = x270 + 1
}
val x285 = x268.length
val x286 = x268.isRow
val x287 = !x286
// a *thin* loop follows: x293
val x293 = {
val x289 = new generated.scala.DoubleVectorImpl(x285,x287)
x289
}
var x288 = 0
while (x288 < x285) {  // begin fat loop x293
val x291 = x268(x288)
x293.dcUpdate(x288, x291)
x288 += 1
} // end fat loop x293
val x294 = x246
val x295 = x294.close()
val x296 = new java.io.FileReader(x9)
val x297 = new java.io.BufferedReader(x296)
x246 = x297
val x299 = x246
val x300 = x299.readLine()
val x301 = x246
val x302 = x301.readLine()
val x303 = x246
val x304 = x303.readLine()
val x305 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x306 : Int = 0
val x339 = while (x306 < x257) {
val x307 = x246
val x308 = x307.readLine()
x252 = x308
val x310 = x252
val x311 = x310.trim()
x252 = x311
val x313 = x252
val x315 = new generated.scala.DoubleVectorImpl(x259,true)
var x316: Int = 0
var x317: Int = 1
val x314 = x313.split("\\s+")
val x319 = x314.length
val x320 = x319 - 1
val x335 = while ({val x318 = x317
val x321 = x318 < x320
x321}) {
val x323 = x317
val x324 = x314(x323)
val x325 = java.lang.Integer.parseInt(x324)
val x326 = x316 += x325
val x327 = x316
val x328 = x317
val x329 = x328 + 1
val x330 = x314(x329)
val x331 = java.lang.Double.parseDouble(x330)
val x332 = x315(x327) = x331
val x333 = x317 += 2
()
}
val x336 = x305.length
val x337 = x305.insert(x336, x315)
x337
x306 = x306 + 1
}
val x375 = { 
val x340 = x305.length
val x341 = x340==0
val x373 = {
def x373thenb(): generated.scala.Matrix[Double] = {
val x342 = new generated.scala.DoubleMatrixImpl(0,0)
x342
}
def x373elseb(): generated.scala.Matrix[Double] = {
val x344 = x305(0)
val x345 = x344.isRow
val x371 = {
def x371thenb(): generated.scala.Matrix[Double] = {
val x346 = x344.length
val x347 = new generated.scala.DoubleMatrixImpl(x340,x346)
var x349 : Int = 0
val x358 = while (x349 < x340) {
var x351 : Int = 0
val x356 = while (x351 < x346) {
val x352 = x305(x349)
val x353 = x352(x351)
val x354 = x347(x349, x351) = x353
x354
x351 = x351 + 1
}
x356
x349 = x349 + 1
}
x347
}
def x371elseb(): generated.scala.Matrix[Double] = {
val x346 = x344.length
val x360 = new generated.scala.DoubleMatrixImpl(x346,x340)
var x361 : Int = 0
val x369 = while (x361 < x340) {
var x362 : Int = 0
val x367 = while (x362 < x346) {
val x363 = x305(x361)
val x364 = x363(x362)
val x365 = x360(x362, x361) = x364
x365
x362 = x362 + 1
}
x367
x361 = x361 + 1
}
x360
}
if (x345) {
x371thenb()
} else {
x371elseb()
}
}
x371
}
if (x341) {
x373thenb()
} else {
x373elseb()
}
}
x373
}
val x376 = x246
val x377 = x376.close()
val x378 = new generated.scala.DoubleLabelsImpl(x293)
val x379 = new generated.scala.DoubleDoubleTrainingSetImpl(x375,x378)
x379
}
val x382 = println("phi_y1: ")
val x404 = { 
val x383 = x182.isRow
val x402 = {
def x402thenb(): Unit = {
val x384 = print("[ ")
var x386 : Int = 0
val x391 = while (x386 < x151) {
val x387 = x182(x386)
val x388 = print(x387)
val x389 = print(" ")
x389
x386 = x386 + 1
}
val x392 = print("]\n")
x392
}
def x402elseb(): Unit = {
var x394 : Int = 0
val x400 = while (x394 < x151) {
val x395 = print("[")
val x396 = x182(x394)
val x397 = print(x396)
val x398 = print(" ]\n")
x398
x394 = x394 + 1
}
x400
}
if (x383) {
x402thenb()
} else {
x402elseb()
}
}
x402
}
val x405 = println("phi_y0: ")
val x426 = { 
val x406 = x185.isRow
val x424 = {
def x424thenb(): Unit = {
val x407 = print("[ ")
var x408 : Int = 0
val x413 = while (x408 < x151) {
val x409 = x185(x408)
val x410 = print(x409)
val x411 = print(" ")
x411
x408 = x408 + 1
}
val x414 = print("]\n")
x414
}
def x424elseb(): Unit = {
var x416 : Int = 0
val x422 = while (x416 < x151) {
val x417 = print("[")
val x418 = x185(x416)
val x419 = print(x418)
val x420 = print(" ]\n")
x420
x416 = x416 + 1
}
x422
}
if (x406) {
x424thenb()
} else {
x424elseb()
}
}
x424
}
val x173 = x172.length
var x179: Double = 0
var x174 = 0
while (x174 < x173) {  // begin fat loop x179
val x177 = x172(x174)
val x175 = x179
val x176 = x177
val x178 = x175 + x176
x179 = x178
x174 += 1
} // end fat loop x179
val x241 = x150
val x242 = x179 / x241
val x427 = "phi_y: "+x242
val x428 = println(x427)
val x429 = x381.numRows
val x431 = "Testing model on "+x429
val x432 = x431+" documents."
val x433 = println(x432)
val x434 = new generated.scala.IndexVectorRangeImpl(0,x429)
val x430 = x381.numCols
val x458 = new generated.scala.RangeVectorImpl(0,x430,1,true)
val x474 = x434.length
val x475 = x434.isRow
def x478_block = {
val x476 = new generated.scala.DoubleVectorImpl(x474,x475)
var mapIdx = 0
while (mapIdx < x434.size) { // begin map loop x478
val x435 = x434.dcApply(mapIdx)
x476.dcUpdate(mapIdx,  {
val x437 = x435 * x430
def x468_block = {
val x436 = x458.dcApply(0)
var x459 = {
val x438 = x437 + x436
val x439 = x381.dcApply(x438)
val x440 = { 
x439
}
val x441 = x440 > 0.0
val x456 = {
def x456thenb(): scala.Tuple2[Double, Double] = {
val x442 = x185(x436)
val x448 = x182(x436)
val x443 = Math.log(x442)
val x444 = 1.0 - x242
val x445 = Math.log(x444)
val x446 = x443 + x445
val x447 = x446 * x440
val x449 = Math.log(x448)
val x450 = Math.log(x242)
val x451 = x449 + x450
val x452 = x451 * x440
val x453 = (x447,x452)
x453
}
def x456elseb(): scala.Tuple2[Double, Double] = {
val x455 = (0.0,0.0)
x455
}
if (x441) {
x456thenb()
} else {
x456elseb()
}
}
x456
}
var mapReduceIdx = 1
while (mapReduceIdx < x458.size) { // begin mapReduce loop x468
val x436 = x458.dcApply(mapReduceIdx)
val x460 = {
val x438 = x437 + x436
val x439 = x381.dcApply(x438)
val x440 = { 
x439
}
val x441 = x440 > 0.0
val x456 = {
def x456thenb(): scala.Tuple2[Double, Double] = {
val x442 = x185(x436)
val x448 = x182(x436)
val x443 = Math.log(x442)
val x444 = 1.0 - x242
val x445 = Math.log(x444)
val x446 = x443 + x445
val x447 = x446 * x440
val x449 = Math.log(x448)
val x450 = Math.log(x242)
val x451 = x449 + x450
val x452 = x451 * x440
val x453 = (x447,x452)
x453
}
def x456elseb(): scala.Tuple2[Double, Double] = {
val x455 = (0.0,0.0)
x455
}
if (x441) {
x456thenb()
} else {
x456elseb()
}
}
x456
}
x459 = {
val x461 = x459._1
val x463 = x460._1
val x465 = x461 + x463
val x462 = x459._2
val x464 = x460._2
val x466 = x462 + x464
val x467 = (x465,x466)
x467
}
mapReduceIdx += 1
} // end mapReduce loop x468
x459
}
val x468 = x468_block
val x469 = x468._1
val x470 = x468._2
val x471 = x470 > x469
val x472 = {
def x472thenb(): Double = {
1.0
}
def x472elseb(): Double = {
0.0
}
if (x471) {
x472thenb()
} else {
x472elseb()
}
}
x472
})
mapIdx += 1
} // end map loop x478
x476
}
val x478 = x478_block
val x480 = x381.labels
val x485 = new generated.scala.RangeVectorImpl(0,x429,1,true)
def x489_block = {
val x479 = x485.dcApply(0)
var x486 = {
val x481 = x480(x479)
val x482 = x478(x479)
val x483 = x481 != x482
val x484 = {
def x484thenb(): Int = {
1
}
def x484elseb(): Int = {
0
}
if (x483) {
x484thenb()
} else {
x484elseb()
}
}
x484
}
var mapReduceIdx = 1
while (mapReduceIdx < x485.size) { // begin mapReduce loop x489
val x479 = x485.dcApply(mapReduceIdx)
val x487 = {
val x481 = x480(x479)
val x482 = x478(x479)
val x483 = x481 != x482
val x484 = {
def x484thenb(): Int = {
1
}
def x484elseb(): Int = {
0
}
if (x483) {
x484thenb()
} else {
x484elseb()
}
}
x484
}
x486 = {
val x488 = x486 + x487
x488
}
mapReduceIdx += 1
} // end mapReduce loop x489
x486
}
val x489 = x489_block
val x490 = x489.doubleValue()
val x491 = x429.doubleValue()
val x492 = x490 / x491
val x493 = "Test error: "+x492
val x494 = println(x493)
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
