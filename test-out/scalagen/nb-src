/*****************************************
  Emitting Generated Code                  
*******************************************/
class NaiveBayesRunner extends ((Array[java.lang.String])=>(Unit)) {
def apply(x0:Array[java.lang.String]): Unit = {
val x1 = println("Naive Bayes Example Application")
val x2 = x0.length
val x3 = x2 < 2
val x7 = {
def x7thenb(): Nothing = {
val x4 = println("NaiveBayes <training file> <test file>")
val x5 = exit(-1)
x5
}
if (x3) {
x7thenb()
}
}
val x8 = x0(0)
val x123 = { 
val x10 = new java.io.FileReader(x8)
val x11 = new java.io.BufferedReader(x10)
var x12: java.io.BufferedReader = x11
val x13 = x12
val x14 = x13.readLine()
var x15: java.lang.String = x14
val x16 = x12
val x17 = x16.readLine()
var x18: java.lang.String = x17
val x19 = x18
val x20 = x19.trim()
val x21 = x20.split("\\s+")
val x22 = x21(0)
val x23 = java.lang.Integer.parseInt(x22)
val x26 = x23 < 0
val x24 = x21(1)
val x25 = java.lang.Integer.parseInt(x24)
val x27 = x25 < 0
val x28 = x26 || x27
val x31 = {
def x31thenb(): Nothing = {
val x29 = error("Illegal input to readTokenMatrix")
x29
}
if (x28) {
x31thenb()
}
}
val x32 = x12
val x33 = x32.readLine()
val x34 = new generated.scala.DoubleVectorImpl(0,true)
val x35 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x37 : Int = 0
val x72 = while (x37 < x23) {
val x38 = x12
val x39 = x38.readLine()
x18 = x39
val x41 = x18
val x42 = x41.trim()
x18 = x42
val x44 = x18
val x46 = new generated.scala.DoubleVectorImpl(x25,true)
var x47: Int = 0
var x48: Int = 1
val x49 = x48
val x45 = x44.split("\\s+")
val x50 = x45.length
val x51 = x50 - 1
val x52 = x49 < x51
val x53 = x45(x49)
val x54 = java.lang.Integer.parseInt(x53)
val x56 = x47
val x57 = x49 + 1
val x58 = x45(x57)
val x59 = java.lang.Double.parseDouble(x58)
val x63 = while ({x52}) {
val x55 = x47 += x54
val x60 = x46(x56) = x59
val x61 = x48 += 2
()
}
val x66 = x34.length
val x64 = x45(0)
val x65 = java.lang.Double.parseDouble(x64)
val x67 = x34.insert(x66, x65)
val x68 = x46.cloneL
val x69 = x35.length
val x70 = x35.insert(x69, x68)
x70
x37 = x37 + 1
}
val x73 = x34.length
val x74 = x34.isRow
val x75 = !x74
// a *thin* loop follows: x81
val x81 = {
val x77 = new generated.scala.DoubleVectorImpl(x73,x75)
x77
}
var x76 = 0
while (x76 < x73) {  // begin fat loop x81
val x79 = x34(x76)
x81.dcUpdate(x76, x79)
x76 += 1
} // end fat loop x81
val x117 = { 
val x82 = x35.length
val x83 = x82==0
val x115 = {
def x115thenb(): generated.scala.Matrix[Double] = {
val x84 = new generated.scala.DoubleMatrixImpl(0,0)
x84
}
def x115elseb(): generated.scala.Matrix[Double] = {
val x86 = x35(0)
val x87 = x86.isRow
val x113 = {
def x113thenb(): generated.scala.Matrix[Double] = {
val x88 = x86.length
val x89 = new generated.scala.DoubleMatrixImpl(x82,x88)
var x91 : Int = 0
val x100 = while (x91 < x82) {
var x93 : Int = 0
val x98 = while (x93 < x88) {
val x94 = x35(x91)
val x95 = x94(x93)
val x96 = x89(x91, x93) = x95
x96
x93 = x93 + 1
}
x98
x91 = x91 + 1
}
x89
}
def x113elseb(): generated.scala.Matrix[Double] = {
val x88 = x86.length
val x102 = new generated.scala.DoubleMatrixImpl(x88,x82)
var x103 : Int = 0
val x111 = while (x103 < x82) {
var x104 : Int = 0
val x109 = while (x104 < x88) {
val x105 = x35(x103)
val x106 = x105(x104)
val x107 = x102(x104, x103) = x106
x107
x104 = x104 + 1
}
x109
x103 = x103 + 1
}
x102
}
if (x87) {
x113thenb()
} else { 
x113elseb()
}
}
x113
}
if (x83) {
x115thenb()
} else { 
x115elseb()
}
}
x115
}
val x118 = x12
val x119 = x118.close()
val x120 = new generated.scala.DoubleLabelsImpl(x81)
val x121 = new generated.scala.DoubleDoubleTrainingSetImpl(x117,x120)
x121
}
val x124 = x123.numRows
val x125 = "Training model on "+x124
val x126 = x125+" documents."
val x127 = println(x126)
val x128 = Seq()
val x129 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
val x131 = new generated.scala.IndexVectorRangeImpl(0,x124)
val x130 = x123.numCols
val x143 = x131.length
val x144 = x131.isRow
def x147_block = {
val x145 = new generated.scala.DoubleVectorImpl(x143,x144)
var mapIdx = 0
while (mapIdx < x131.size) { // begin map loop x147
val x132 = x131.dcApply(mapIdx)
x145.dcUpdate(mapIdx,  {
val x137 = x132 * x130
var x142: Double = 0
var x134 = 0
while (x134 < x130) {  // begin fat loop x142
val x138 = x137 + x134
val x139 = x123.dcApply(x138)
val x140 = { 
x139
}
val x135 = x142
val x136 = x140
val x141 = x135 + x136
x142 = x141
x134 += 1
} // end fat loop x142
x142
})
mapIdx += 1
} // end map loop x147
x145
}
val x147 = x147_block
val x159 = { 
val x156 = new generated.scala.DoubleVectorImpl(x130,true)
x156
}
val x162 = { 
val x156 = new generated.scala.DoubleVectorImpl(x130,true)
x156
}
val x163 = new generated.scala.IndexVectorRangeImpl(0,x130)
val x148 = x123.labels
val x194 = x130
val x206 = List()
val x207 = {
var forIdx = 0
while (forIdx < x163.size) { // begin foreach loop x207
val x164 = x163.dcApply(forIdx)
var x165: Double = 0.0
var x166: Double = 0.0
var x167: Double = 0.0
var x168: Double = 0.0
var x169: Int = 0
val x170 = x169
val x171 = x170 < x124
val x172 = x148(x170)
val x173 = x172==1
val x190 = while ({x171}) {
val x187 = {
def x187thenb(): Unit = {
val x174 = x123.transposed
val x175 = x174.numCols
val x176 = x164 * x175
val x177 = x176 + x170
val x178 = x174.dcApply(x177)
val x179 = { 
x178
}
val x180 = x165 += x179
val x181 = x147(x170)
val x182 = x166 += x181
()
}
def x187elseb(): Unit = {
val x174 = x123.transposed
val x175 = x174.numCols
val x176 = x164 * x175
val x177 = x176 + x170
val x178 = x174.dcApply(x177)
val x179 = { 
x178
}
val x184 = x167 += x179
val x181 = x147(x170)
val x185 = x168 += x181
()
}
if (x173) {
x187thenb()
} else { 
x187elseb()
}
}
val x188 = x169 += 1
()
}
val x191 = x165
val x192 = x191 + 1.0
val x193 = x166
val x195 = x193 + x194
val x196 = x192 / x195
val x197 = x159(x164) = x196
val x198 = x167
val x199 = x198 + 1.0
val x200 = x168
val x201 = x200 + x194
val x202 = x199 / x201
val x203 = x162(x164) = x202
x203
forIdx += 1
} // end foreach loop x207
}
val x210 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
val x9 = x0(1)
val x324 = { 
val x211 = new java.io.FileReader(x9)
val x212 = new java.io.BufferedReader(x211)
var x213: java.io.BufferedReader = x212
val x214 = x213
val x215 = x214.readLine()
var x216: java.lang.String = x215
val x217 = x213
val x218 = x217.readLine()
var x219: java.lang.String = x218
val x220 = x219
val x221 = x220.trim()
val x222 = x221.split("\\s+")
val x223 = x222(0)
val x224 = java.lang.Integer.parseInt(x223)
val x227 = x224 < 0
val x225 = x222(1)
val x226 = java.lang.Integer.parseInt(x225)
val x228 = x226 < 0
val x229 = x227 || x228
val x232 = {
def x232thenb(): Nothing = {
val x230 = error("Illegal input to readTokenMatrix")
x230
}
if (x229) {
x232thenb()
}
}
val x233 = x213
val x234 = x233.readLine()
val x235 = new generated.scala.DoubleVectorImpl(0,true)
val x236 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x238 : Int = 0
val x273 = while (x238 < x224) {
val x239 = x213
val x240 = x239.readLine()
x219 = x240
val x242 = x219
val x243 = x242.trim()
x219 = x243
val x245 = x219
val x247 = new generated.scala.DoubleVectorImpl(x226,true)
var x248: Int = 0
var x249: Int = 1
val x250 = x249
val x246 = x245.split("\\s+")
val x251 = x246.length
val x252 = x251 - 1
val x253 = x250 < x252
val x254 = x246(x250)
val x255 = java.lang.Integer.parseInt(x254)
val x257 = x248
val x258 = x250 + 1
val x259 = x246(x258)
val x260 = java.lang.Double.parseDouble(x259)
val x264 = while ({x253}) {
val x256 = x248 += x255
val x261 = x247(x257) = x260
val x262 = x249 += 2
()
}
val x267 = x235.length
val x265 = x246(0)
val x266 = java.lang.Double.parseDouble(x265)
val x268 = x235.insert(x267, x266)
val x269 = x247.cloneL
val x270 = x236.length
val x271 = x236.insert(x270, x269)
x271
x238 = x238 + 1
}
val x274 = x235.length
val x275 = x235.isRow
val x276 = !x275
// a *thin* loop follows: x282
val x282 = {
val x278 = new generated.scala.DoubleVectorImpl(x274,x276)
x278
}
var x277 = 0
while (x277 < x274) {  // begin fat loop x282
val x280 = x235(x277)
x282.dcUpdate(x277, x280)
x277 += 1
} // end fat loop x282
val x318 = { 
val x283 = x236.length
val x284 = x283==0
val x316 = {
def x316thenb(): generated.scala.Matrix[Double] = {
val x285 = new generated.scala.DoubleMatrixImpl(0,0)
x285
}
def x316elseb(): generated.scala.Matrix[Double] = {
val x287 = x236(0)
val x288 = x287.isRow
val x314 = {
def x314thenb(): generated.scala.Matrix[Double] = {
val x289 = x287.length
val x290 = new generated.scala.DoubleMatrixImpl(x283,x289)
var x292 : Int = 0
val x301 = while (x292 < x283) {
var x294 : Int = 0
val x299 = while (x294 < x289) {
val x295 = x236(x292)
val x296 = x295(x294)
val x297 = x290(x292, x294) = x296
x297
x294 = x294 + 1
}
x299
x292 = x292 + 1
}
x290
}
def x314elseb(): generated.scala.Matrix[Double] = {
val x289 = x287.length
val x303 = new generated.scala.DoubleMatrixImpl(x289,x283)
var x304 : Int = 0
val x312 = while (x304 < x283) {
var x305 : Int = 0
val x310 = while (x305 < x289) {
val x306 = x236(x304)
val x307 = x306(x305)
val x308 = x303(x305, x304) = x307
x308
x305 = x305 + 1
}
x310
x304 = x304 + 1
}
x303
}
if (x288) {
x314thenb()
} else { 
x314elseb()
}
}
x314
}
if (x284) {
x316thenb()
} else { 
x316elseb()
}
}
x316
}
val x319 = x213
val x320 = x319.close()
val x321 = new generated.scala.DoubleLabelsImpl(x282)
val x322 = new generated.scala.DoubleDoubleTrainingSetImpl(x318,x321)
x322
}
val x325 = println("phi_y1: ")
val x347 = { 
val x326 = x159.isRow
val x345 = {
def x345thenb(): Unit = {
val x327 = print("[ ")
var x329 : Int = 0
val x334 = while (x329 < x130) {
val x330 = x159(x329)
val x331 = print(x330)
val x332 = print(" ")
x332
x329 = x329 + 1
}
val x335 = print("]\n")
x335
}
def x345elseb(): Unit = {
var x337 : Int = 0
val x343 = while (x337 < x130) {
val x338 = print("[")
val x339 = x159(x337)
val x340 = print(x339)
val x341 = print(" ]\n")
x341
x337 = x337 + 1
}
x343
}
if (x326) {
x345thenb()
} else { 
x345elseb()
}
}
x345
}
val x348 = println("phi_y0: ")
val x369 = { 
val x349 = x162.isRow
val x367 = {
def x367thenb(): Unit = {
val x350 = print("[ ")
var x351 : Int = 0
val x356 = while (x351 < x130) {
val x352 = x162(x351)
val x353 = print(x352)
val x354 = print(" ")
x354
x351 = x351 + 1
}
val x357 = print("]\n")
x357
}
def x367elseb(): Unit = {
var x359 : Int = 0
val x365 = while (x359 < x130) {
val x360 = print("[")
val x361 = x162(x359)
val x362 = print(x361)
val x363 = print(" ]\n")
x363
x359 = x359 + 1
}
x365
}
if (x349) {
x367thenb()
} else { 
x367elseb()
}
}
x367
}
val x149 = x148.length
var x155: Double = 0
var x150 = 0
while (x150 < x149) {  // begin fat loop x155
val x153 = x148(x150)
val x151 = x155
val x152 = x153
val x154 = x151 + x152
x155 = x154
x150 += 1
} // end fat loop x155
val x208 = x124
val x209 = x155 / x208
val x370 = "phi_y: "+x209
val x371 = println(x370)
val x372 = x324.numRows
val x374 = "Testing model on "+x372
val x375 = x374+" documents."
val x376 = println(x375)
val x377 = new generated.scala.IndexVectorRangeImpl(0,x372)
val x373 = x324.numCols
val x401 = new generated.scala.RangeVectorImpl(0,x373,1,true)
val x417 = x377.length
val x418 = x377.isRow
def x421_block = {
val x419 = new generated.scala.DoubleVectorImpl(x417,x418)
var mapIdx = 0
while (mapIdx < x377.size) { // begin map loop x421
val x378 = x377.dcApply(mapIdx)
x419.dcUpdate(mapIdx,  {
val x380 = x378 * x373
def x411_block = {
val x379 = x401.dcApply(0)
var x402 = {
val x381 = x380 + x379
val x382 = x324.dcApply(x381)
val x383 = { 
x382
}
val x384 = x383 > 0.0
val x399 = {
def x399thenb(): scala.Tuple2[Double, Double] = {
val x385 = x162(x379)
val x391 = x159(x379)
val x386 = Math.log(x385)
val x387 = 1.0 - x209
val x388 = Math.log(x387)
val x389 = x386 + x388
val x390 = x389 * x383
val x392 = Math.log(x391)
val x393 = Math.log(x209)
val x394 = x392 + x393
val x395 = x394 * x383
val x396 = (x390,x395)
x396
}
def x399elseb(): scala.Tuple2[Double, Double] = {
val x398 = (0.0,0.0)
x398
}
if (x384) {
x399thenb()
} else { 
x399elseb()
}
}
x399
}
var mapReduceIdx = 1
while (mapReduceIdx < x401.size) { // begin mapReduce loop x411
val x379 = x401.dcApply(mapReduceIdx)
val x403 = {
val x381 = x380 + x379
val x382 = x324.dcApply(x381)
val x383 = { 
x382
}
val x384 = x383 > 0.0
val x399 = {
def x399thenb(): scala.Tuple2[Double, Double] = {
val x385 = x162(x379)
val x391 = x159(x379)
val x386 = Math.log(x385)
val x387 = 1.0 - x209
val x388 = Math.log(x387)
val x389 = x386 + x388
val x390 = x389 * x383
val x392 = Math.log(x391)
val x393 = Math.log(x209)
val x394 = x392 + x393
val x395 = x394 * x383
val x396 = (x390,x395)
x396
}
def x399elseb(): scala.Tuple2[Double, Double] = {
val x398 = (0.0,0.0)
x398
}
if (x384) {
x399thenb()
} else { 
x399elseb()
}
}
x399
}
x402 = {
val x404 = x402._1
val x406 = x403._1
val x408 = x404 + x406
val x405 = x402._2
val x407 = x403._2
val x409 = x405 + x407
val x410 = (x408,x409)
x410
}
mapReduceIdx += 1
} // end mapReduce loop x411
x402
}
val x411 = x411_block
val x412 = x411._1
val x413 = x411._2
val x414 = x413 > x412
val x415 = {
def x415thenb(): Double = {
1.0
}
def x415elseb(): Double = {
0.0
}
if (x414) {
x415thenb()
} else { 
x415elseb()
}
}
x415
})
mapIdx += 1
} // end map loop x421
x419
}
val x421 = x421_block
val x423 = x324.labels
val x428 = new generated.scala.RangeVectorImpl(0,x372,1,true)
def x432_block = {
val x422 = x428.dcApply(0)
var x429 = {
val x424 = x423(x422)
val x425 = x421(x422)
val x426 = x424 != x425
val x427 = {
def x427thenb(): Int = {
1
}
def x427elseb(): Int = {
0
}
if (x426) {
x427thenb()
} else { 
x427elseb()
}
}
x427
}
var mapReduceIdx = 1
while (mapReduceIdx < x428.size) { // begin mapReduce loop x432
val x422 = x428.dcApply(mapReduceIdx)
val x430 = {
val x424 = x423(x422)
val x425 = x421(x422)
val x426 = x424 != x425
val x427 = {
def x427thenb(): Int = {
1
}
def x427elseb(): Int = {
0
}
if (x426) {
x427thenb()
} else { 
x427elseb()
}
}
x427
}
x429 = {
val x431 = x429 + x430
x431
}
mapReduceIdx += 1
} // end mapReduce loop x432
x429
}
val x432 = x432_block
val x433 = x432.doubleValue()
val x434 = x372.doubleValue()
val x435 = x433 / x434
val x436 = "Test error: "+x435
val x437 = println(x436)
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
