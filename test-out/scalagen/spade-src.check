/*****************************************
  Emitting Generated Code                  
*******************************************/
class SpadeRunner extends ((Array[java.lang.String])=>(Unit)) {
def apply(x0:Array[java.lang.String]): Unit = {
val x1 = x0.length
val x2 = x1 < 2
val x6 = {
def x6thenb(): Nothing = {
val x3 = println("Usage: Spade <input data file> <output data file>")
val x4 = exit(-1)
x4
}
if (x2) {
x6thenb()
}
}
val x7 = x0(0)
val x56 = { 
val x8 = new java.io.FileReader(x7)
val x9 = new java.io.BufferedReader(x8)
val x10 = x9.readLine()
var x11: java.lang.String = x10
val x12 = x11
val x13 = x12.trim()
x11 = x13
val x15 = x11
val x16 = x15.split("\\s+")
var x17: Array[java.lang.String] = x16
val x18 = x17
val x19 = x18.length
val x20 = new generated.scala.DoubleMatrixImpl(0,x19)
val x52 = while ({val x21 = x11
val x22 = x21 != null
x22}) {
val x24 = x17
val x25 = x24.length
val x26 = new generated.scala.IndexVectorRangeImpl(0,x25)
val x28 = x26.length
val x29 = x26.isRow
// a *thin* loop follows: x37
var x27 = 0
val x33 = x17
val x32 = x26.dcApply(x27)
val x34 = x33(x32)
val x35 = java.lang.Double.parseDouble(x34)
val x37 = {
val x30 = new generated.scala.DoubleVectorImpl(x28,x29)
x30
}
x37.dcUpdate(x27, x35)
x27 = 1
while (x27 < x28) {  // begin fat loop x37
val x33 = x17
val x32 = x26.dcApply(x27)
val x34 = x33(x32)
val x35 = java.lang.Double.parseDouble(x34)
x37.dcUpdate(x27, x35)
x27 += 1
} // end fat loop x37
val x38 = x20.numRows
val x39 = x20.insertRow(x38,x37)
val x40 = x9.readLine()
x11 = x40
val x42 = x11
val x43 = x42 != null
val x50 = {
def x50thenb(): Unit = {
val x44 = x42.trim()
x11 = x44
val x46 = x11
val x47 = x46.split("\\s+")
x17 = x47
()
}
if (x43) {
x50thenb()
}
}
x50
}
val x53 = x9.close()
val x54 = x20// unsafe immutable
x54
}
val x57 = new generated.scala.IntVectorImpl(0,false)
val x58 = x57// unsafe immutable
val x59 = new generated.scala.IntLabelsImpl(x58)
val x60 = new generated.scala.DoubleIntTrainingSetImpl(x56,x59)
val x61 = Seq()
val x62 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
val x63 = new generated.scala.IntVectorImpl(0,true)
val x64 = x63.length
val x65 = x63.insert(x64, 0)
val x66 = x63// unsafe immutable
val x67 = x60.numRows
val x68 = "   Input matrix size: "+x67
val x69 = x68+"*"
val x70 = x60.numCols
val x71 = x69+x70
val x72 = println(x71)
val x78 = new generated.scala.IntVectorImpl(0,true)
val x79 = x78.length
val x80 = x78.insert(x79, x67)
val x81 = x78.length
val x82 = x78.insert(x81, 2000)
val x83 = x78.length
val x73 = x67
val x74 = 2.5E9f / x73
val x75 = x74
val x76 = Math.floor(x75)
val x77 = x76.asInstanceOf[Int]
val x84 = x78.insert(x83, x77)
val x85 = x78// unsafe immutable
val x89 = x85.length
var x86 = 0
val x90 = x85.dcApply(x86)
var x93: Int = {
if (x89 == 0) {2147483647}
else {
val x90 = x85.dcApply(x86)
x90
}
}
x86 = 1
while (x86 < x89) {  // begin fat loop x93
val x90 = x85.dcApply(x86)
val x87 = x93
val x88 = x90
val x91 = x87 < x88
val x92 = {
def x92thenb(): Int = {
x87
}
def x92elseb(): Int = {
x88
}
if (x91) {
x92thenb()
} else { 
x92elseb()
}
}
x93 = x92
x86 += 1
} // end fat loop x93
val x94 = "   numSamples = "+x93
val x95 = println(x94)
val x96 = println("   finding empirical dist of the min distance between cells ...")
val x97 = println("   med_min_dist = 4.4593519740000005")
val x98 = "   For this "+x67
val x99 = x98+" channel data, KERNEL WIDTH is "
val x100 = x99+22.296759870000002
val x101 = x100+", APPRX WIDTH is "
val x102 = x101+6.689027961000001
val x103 = println(x102)
val x104 = println("   finding local density for each cell ...")
val x141 = new generated.scala.IntVectorImpl(x67,true)
var x146: Int = 0
val x138 = 100000 / x67
val x139 = x138 + 1000
val x142 = x139.doubleValue()
val x143 = x73 / x142
val x144 = Math.ceil(x143)
val x145 = x144.asInstanceOf[Int]
val x244 = List()
val x137 = { (x105: Int, x106: Int) => 
val x112 = x105 * x70
val x116 = x106 * x70
val x136 = { 
// a *thin* loop follows: x121
var x109 = 0
val x113 = x112 + x109
val x114 = x60.dcApply(x113)
val x115 = { 
x114
}
val x117 = x116 + x109
val x118 = x60.dcApply(x117)
val x119 = { 
x118
}
val x120 = x115 - x119
val x121 = {
val x110 = new generated.scala.DoubleVectorImpl(x70,true)
x110
}
x121.dcUpdate(x109, x120)
x109 = 1
while (x109 < x70) {  // begin fat loop x121
val x113 = x112 + x109
val x114 = x60.dcApply(x113)
val x115 = { 
x114
}
val x117 = x116 + x109
val x118 = x60.dcApply(x117)
val x119 = { 
x118
}
val x120 = x115 - x119
x121.dcUpdate(x109, x120)
x109 += 1
} // end fat loop x121
val x123 = x121.isRow
// a *thin* loop follows: x128
var x122 = 0
val x126 = x121.dcApply(x122)
val x127 = java.lang.Math.abs(x126)
val x128 = {
val x124 = new generated.scala.DoubleVectorImpl(x70,x123)
x124
}
x128.dcUpdate(x122, x127)
x122 = 1
while (x122 < x70) {  // begin fat loop x128
val x126 = x121.dcApply(x122)
val x127 = java.lang.Math.abs(x126)
x128.dcUpdate(x122, x127)
x122 += 1
} // end fat loop x128
var x129 = 0
val x132 = x128.dcApply(x129)
var x134: Double = {
if (x70 == 0) {0.0}
else {
val x132 = x128.dcApply(x129)
x132
}
}
x129 = 1
while (x129 < x70) {  // begin fat loop x134
val x132 = x128.dcApply(x129)
val x130 = x134
val x131 = x132
val x133 = x130 + x131
x134 = x133
x129 += 1
} // end fat loop x134
x134
}
x136: Double
}
val x140 = new generated.scala.DoubleStreamImpl(x67,x67,x139,x137,true)
val x166 = while ({val x147 = x146
val x148 = x147 < x145
x148}) {
val x150 = x146
val x159 = x146
val x151 = x150 * x139
val x152 = x67 - x151
val x153 = x152 < 0
val x154 = {
def x154thenb(): Int = {
x67
}
def x154elseb(): Int = {
x152
}
if (x153) {
x154thenb()
} else { 
x154elseb()
}
}
val x155 = Math.min(x139, x154)
val x156 = x155.asInstanceOf[Int]
val x157 = { 
x156
}
val x158 = new generated.scala.IndexVectorRangeImpl(0,x157)
val x162 = x158.length
val x185 = x159 * x139
// a *thin* loop follows: x163
var x160 = 0
var x163: Unit = {
val x182 = x158.dcApply(x160)
val x186 = x185 + x182
val x218 = x186 % 1000
val x219 = x218==0
val x223 = {
def x223thenb(): Unit = {
val x220 = "  (streaming) # processed node = "+x186
val x221 = println(x220)
x221
}
if (x219) {
x223thenb()
}
}
val x224 = x141(x186)
val x225 = x224==0
val x184 = x140.chunkRow(x182,x159)
val x192 = x186 * x70
var x183 = 0
val x196 = x183 * x70
val x216 = { 
// a *thin* loop follows: x201
var x189 = 0
val x193 = x192 + x189
val x194 = x60.dcApply(x193)
val x195 = { 
x194
}
val x197 = x196 + x189
val x198 = x60.dcApply(x197)
val x199 = { 
x198
}
val x200 = x195 - x199
val x201 = {
val x190 = new generated.scala.DoubleVectorImpl(x70,true)
x190
}
x201.dcUpdate(x189, x200)
x189 = 1
while (x189 < x70) {  // begin fat loop x201
val x193 = x192 + x189
val x194 = x60.dcApply(x193)
val x195 = { 
x194
}
val x197 = x196 + x189
val x198 = x60.dcApply(x197)
val x199 = { 
x198
}
val x200 = x195 - x199
x201.dcUpdate(x189, x200)
x189 += 1
} // end fat loop x201
val x203 = x201.isRow
// a *thin* loop follows: x208
var x202 = 0
val x206 = x201.dcApply(x202)
val x207 = java.lang.Math.abs(x206)
val x208 = {
val x204 = new generated.scala.DoubleVectorImpl(x70,x203)
x204
}
x208.dcUpdate(x202, x207)
x202 = 1
while (x202 < x70) {  // begin fat loop x208
val x206 = x201.dcApply(x202)
val x207 = java.lang.Math.abs(x206)
x208.dcUpdate(x202, x207)
x202 += 1
} // end fat loop x208
var x209 = 0
val x212 = x208.dcApply(x209)
var x214: Double = {
if (x70 == 0) {0.0}
else {
val x212 = x208.dcApply(x209)
x212
}
}
x209 = 1
while (x209 < x70) {  // begin fat loop x214
val x212 = x208.dcApply(x209)
val x210 = x214
val x211 = x212
val x213 = x210 + x211
x214 = x213
x209 += 1
} // end fat loop x214
x214
}
val x217 = {
x184
}
x217.dcUpdate(x183, x216)
x183 = 1
while (x183 < x67) {  // begin fat loop x217
val x196 = x183 * x70
val x216 = { 
// a *thin* loop follows: x201
var x189 = 0
val x193 = x192 + x189
val x194 = x60.dcApply(x193)
val x195 = { 
x194
}
val x197 = x196 + x189
val x198 = x60.dcApply(x197)
val x199 = { 
x198
}
val x200 = x195 - x199
val x201 = {
val x190 = new generated.scala.DoubleVectorImpl(x70,true)
x190
}
x201.dcUpdate(x189, x200)
x189 = 1
while (x189 < x70) {  // begin fat loop x201
val x193 = x192 + x189
val x194 = x60.dcApply(x193)
val x195 = { 
x194
}
val x197 = x196 + x189
val x198 = x60.dcApply(x197)
val x199 = { 
x198
}
val x200 = x195 - x199
x201.dcUpdate(x189, x200)
x189 += 1
} // end fat loop x201
val x203 = x201.isRow
// a *thin* loop follows: x208
var x202 = 0
val x206 = x201.dcApply(x202)
val x207 = java.lang.Math.abs(x206)
val x208 = {
val x204 = new generated.scala.DoubleVectorImpl(x70,x203)
x204
}
x208.dcUpdate(x202, x207)
x202 = 1
while (x202 < x70) {  // begin fat loop x208
val x206 = x201.dcApply(x202)
val x207 = java.lang.Math.abs(x206)
x208.dcUpdate(x202, x207)
x202 += 1
} // end fat loop x208
var x209 = 0
val x212 = x208.dcApply(x209)
var x214: Double = {
if (x70 == 0) {0.0}
else {
val x212 = x208.dcApply(x209)
x212
}
}
x209 = 1
while (x209 < x70) {  // begin fat loop x214
val x212 = x208.dcApply(x209)
val x210 = x214
val x211 = x212
val x213 = x210 + x211
x214 = x213
x209 += 1
} // end fat loop x214
x214
}
x217.dcUpdate(x183, x216)
x183 += 1
} // end fat loop x217
var x232 = 0
val x235 = x217.dcApply(x232)
val x236 = x235 < 22.296759870000002
var x238: Int = {
if (x67 == 0) {0}
else {
0
}
}
x232 = 1
while (x232 < x67) {  // begin fat loop x238
val x235 = x217.dcApply(x232)
val x236 = x235 < 22.296759870000002
if (x236) {
// TODO: we could optimize this check away with more convoluted runtime support if necessary
if (x238 == 0)x238 = {
1
}
else {
val x233 = x238
val x234 = 1
val x237 = x233 + x234
x238 = x237
}
}
x232 += 1
} // end fat loop x238
val x247 = {
def x247thenb(): Unit = {
// a *thin* loop follows: x231
var x226 = 0
val x229 = x217.dcApply(x226)
val x230 = x229 < 6.689027961000001
val x231 = {
val x227 = new generated.scala.IndexVectorSeqImpl(0)
//TODO: buffer size might be wrong (loop has conditions)
x227
}
if (x230) x231.insert(x231.length, x226)
x226 = 1
while (x226 < x67) {  // begin fat loop x231
val x229 = x217.dcApply(x226)
val x230 = x229 < 6.689027961000001
if (x230) x231.insert(x231.length, x226)
x226 += 1
} // end fat loop x231
// a *thin* loop follows: x245
var x239 = 0
var x245: Unit = {
val x241 = x231.dcApply(x239)
val x242 = x141(x241) = x238
x242
}
x239 = 1
while (x239 < x67) {  // begin fat loop x245
x245 = {
val x241 = x231.dcApply(x239)
val x242 = x141(x241) = x238
x242
}
x239 += 1
} // end fat loop x245
x245
}
if (x225) {
x247thenb()
}
}
x247
}
x160 = 1
while (x160 < x162) {  // begin fat loop x163
x163 = {
val x182 = x158.dcApply(x160)
val x186 = x185 + x182
val x218 = x186 % 1000
val x219 = x218==0
val x223 = {
def x223thenb(): Unit = {
val x220 = "  (streaming) # processed node = "+x186
val x221 = println(x220)
x221
}
if (x219) {
x223thenb()
}
}
val x224 = x141(x186)
val x225 = x224==0
val x184 = x140.chunkRow(x182,x159)
val x192 = x186 * x70
var x183 = 0
val x196 = x183 * x70
val x216 = { 
// a *thin* loop follows: x201
var x189 = 0
val x193 = x192 + x189
val x194 = x60.dcApply(x193)
val x195 = { 
x194
}
val x197 = x196 + x189
val x198 = x60.dcApply(x197)
val x199 = { 
x198
}
val x200 = x195 - x199
val x201 = {
val x190 = new generated.scala.DoubleVectorImpl(x70,true)
x190
}
x201.dcUpdate(x189, x200)
x189 = 1
while (x189 < x70) {  // begin fat loop x201
val x193 = x192 + x189
val x194 = x60.dcApply(x193)
val x195 = { 
x194
}
val x197 = x196 + x189
val x198 = x60.dcApply(x197)
val x199 = { 
x198
}
val x200 = x195 - x199
x201.dcUpdate(x189, x200)
x189 += 1
} // end fat loop x201
val x203 = x201.isRow
// a *thin* loop follows: x208
var x202 = 0
val x206 = x201.dcApply(x202)
val x207 = java.lang.Math.abs(x206)
val x208 = {
val x204 = new generated.scala.DoubleVectorImpl(x70,x203)
x204
}
x208.dcUpdate(x202, x207)
x202 = 1
while (x202 < x70) {  // begin fat loop x208
val x206 = x201.dcApply(x202)
val x207 = java.lang.Math.abs(x206)
x208.dcUpdate(x202, x207)
x202 += 1
} // end fat loop x208
var x209 = 0
val x212 = x208.dcApply(x209)
var x214: Double = {
if (x70 == 0) {0.0}
else {
val x212 = x208.dcApply(x209)
x212
}
}
x209 = 1
while (x209 < x70) {  // begin fat loop x214
val x212 = x208.dcApply(x209)
val x210 = x214
val x211 = x212
val x213 = x210 + x211
x214 = x213
x209 += 1
} // end fat loop x214
x214
}
val x217 = {
x184
}
x217.dcUpdate(x183, x216)
x183 = 1
while (x183 < x67) {  // begin fat loop x217
val x196 = x183 * x70
val x216 = { 
// a *thin* loop follows: x201
var x189 = 0
val x193 = x192 + x189
val x194 = x60.dcApply(x193)
val x195 = { 
x194
}
val x197 = x196 + x189
val x198 = x60.dcApply(x197)
val x199 = { 
x198
}
val x200 = x195 - x199
val x201 = {
val x190 = new generated.scala.DoubleVectorImpl(x70,true)
x190
}
x201.dcUpdate(x189, x200)
x189 = 1
while (x189 < x70) {  // begin fat loop x201
val x193 = x192 + x189
val x194 = x60.dcApply(x193)
val x195 = { 
x194
}
val x197 = x196 + x189
val x198 = x60.dcApply(x197)
val x199 = { 
x198
}
val x200 = x195 - x199
x201.dcUpdate(x189, x200)
x189 += 1
} // end fat loop x201
val x203 = x201.isRow
// a *thin* loop follows: x208
var x202 = 0
val x206 = x201.dcApply(x202)
val x207 = java.lang.Math.abs(x206)
val x208 = {
val x204 = new generated.scala.DoubleVectorImpl(x70,x203)
x204
}
x208.dcUpdate(x202, x207)
x202 = 1
while (x202 < x70) {  // begin fat loop x208
val x206 = x201.dcApply(x202)
val x207 = java.lang.Math.abs(x206)
x208.dcUpdate(x202, x207)
x202 += 1
} // end fat loop x208
var x209 = 0
val x212 = x208.dcApply(x209)
var x214: Double = {
if (x70 == 0) {0.0}
else {
val x212 = x208.dcApply(x209)
x212
}
}
x209 = 1
while (x209 < x70) {  // begin fat loop x214
val x212 = x208.dcApply(x209)
val x210 = x214
val x211 = x212
val x213 = x210 + x211
x214 = x213
x209 += 1
} // end fat loop x214
x214
}
x217.dcUpdate(x183, x216)
x183 += 1
} // end fat loop x217
var x232 = 0
val x235 = x217.dcApply(x232)
val x236 = x235 < 22.296759870000002
var x238: Int = {
if (x67 == 0) {0}
else {
0
}
}
x232 = 1
while (x232 < x67) {  // begin fat loop x238
val x235 = x217.dcApply(x232)
val x236 = x235 < 22.296759870000002
if (x236) {
// TODO: we could optimize this check away with more convoluted runtime support if necessary
if (x238 == 0)x238 = {
1
}
else {
val x233 = x238
val x234 = 1
val x237 = x233 + x234
x238 = x237
}
}
x232 += 1
} // end fat loop x238
val x247 = {
def x247thenb(): Unit = {
// a *thin* loop follows: x231
var x226 = 0
val x229 = x217.dcApply(x226)
val x230 = x229 < 6.689027961000001
val x231 = {
val x227 = new generated.scala.IndexVectorSeqImpl(0)
//TODO: buffer size might be wrong (loop has conditions)
x227
}
if (x230) x231.insert(x231.length, x226)
x226 = 1
while (x226 < x67) {  // begin fat loop x231
val x229 = x217.dcApply(x226)
val x230 = x229 < 6.689027961000001
if (x230) x231.insert(x231.length, x226)
x226 += 1
} // end fat loop x231
// a *thin* loop follows: x245
var x239 = 0
var x245: Unit = {
val x241 = x231.dcApply(x239)
val x242 = x141(x241) = x238
x242
}
x239 = 1
while (x239 < x67) {  // begin fat loop x245
x245 = {
val x241 = x231.dcApply(x239)
val x242 = x141(x241) = x238
x242
}
x239 += 1
} // end fat loop x245
x245
}
if (x225) {
x247thenb()
}
}
x247
}
x160 += 1
} // end fat loop x163
val x164 = x146 += 1
()
}
val x167 = Seq(x141)
val x168 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
var x169: Int = 0
val x179 = while ({val x170 = x169
val x171 = x170 < 9
x171}) {
val x173 = x169
val x174 = x141(x173)
val x175 = x174+" "
val x176 = print(x175)
val x177 = x169 += 1
()
}
val x180 = println(())
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
