/*****************************************
  Emitting Generated Code                  
*******************************************/
class kmeans extends ((Array[java.lang.String])=>(Unit)) {
def apply(x0:Array[java.lang.String]): Unit = {
val x1 = x0.length
val x2 = x1 < 1
val x6 = {
def x6thenb(): Nothing = {
val x3 = println("Usage: kmeans <input data file> <initmu data file>")
val x4 = exit(-1)
x4
}
def x6elseb(): Unit = {
()
}
if (x2) {
x6thenb()
} else {
x6elseb()
}
}
val x7 = x0(0)
def x58_block = { 
val x8 = new java.io.FileReader(x7)
val x9 = new java.io.BufferedReader(x8)
val x10 = x9.readLine()
var x11 = x10
val x12 = x11
val x13 = x12.trim()
x11 = x13
val x15 = x11
val x16 = x15.split("\\s+")
var x17 = x16
val x18 = x17
val x19 = x18.length
val x20 = new generated.scala.DoubleMatrixImpl(0,x19)
val x21 = x11
val x55 = while ({val x23 = x11
val x24 = x23 != null
x24}) {
val x26 = x17
val x27 = x26.length
val x28 = new generated.scala.DoubleVectorImpl(x27,true)
val x29 = x17
val x30 = x29.length
var x32 : Int = 0
val x38 = while (x32 < x30) {
val x33 = x17
val x34 = x33(x32)
val x35 = java.lang.Double.parseDouble(x34)
val x36 = x28(x32) = x35
x36
x32 = x32 + 1
}
val x40 = x28
val x39 = x20.numRows
val x41 = x20.insertRow(x39,x40)
val x42 = x9.readLine()
x11 = x42
val x44 = x11
val x45 = x44 != null
val x53 = {
def x53thenb(): Unit = {
val x46 = x11
val x47 = x46.trim()
x11 = x47
val x49 = x11
val x50 = x49.split("\\s+")
x17 = x50
()
}
def x53elseb(): Unit = {
()
}
if (x45) {
x53thenb()
} else {
x53elseb()
}
}
x53
}
val x56 = x9.close()
x20
}
val x58 = x58_block
val x59 = x0(1)
def x110_block = { 
val x60 = new java.io.FileReader(x59)
val x61 = new java.io.BufferedReader(x60)
val x62 = x61.readLine()
var x63 = x62
val x64 = x63
val x65 = x64.trim()
x63 = x65
val x67 = x63
val x68 = x67.split("\\s+")
var x69 = x68
val x70 = x69
val x71 = x70.length
val x72 = new generated.scala.DoubleMatrixImpl(0,x71)
val x73 = x63
val x107 = while ({val x75 = x63
val x76 = x75 != null
x76}) {
val x78 = x69
val x79 = x78.length
val x80 = new generated.scala.DoubleVectorImpl(x79,true)
val x81 = x69
val x82 = x81.length
var x84 : Int = 0
val x90 = while (x84 < x82) {
val x85 = x69
val x86 = x85(x84)
val x87 = java.lang.Double.parseDouble(x86)
val x88 = x80(x84) = x87
x88
x84 = x84 + 1
}
val x92 = x80
val x91 = x72.numRows
val x93 = x72.insertRow(x91,x92)
val x94 = x61.readLine()
x63 = x94
val x96 = x63
val x97 = x96 != null
val x105 = {
def x105thenb(): Unit = {
val x98 = x63
val x99 = x98.trim()
x63 = x99
val x101 = x63
val x102 = x101.split("\\s+")
x69 = x102
()
}
def x105elseb(): Unit = {
()
}
if (x97) {
x105thenb()
} else {
x105elseb()
}
}
x105
}
val x108 = x61.close()
x72
}
val x110 = x110_block
val x111 = x110.numRows
val x112 = x58.numCols
def x115_block = { 
val x113 = new generated.scala.DoubleMatrixImpl(x111,x112)
x113
}
val x115 = x115_block
val x116 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
var x118 = 0
var x119 = 1.7976931348623157E308
val x120 = null.asInstanceOf[generated.scala.Matrix[Double]]
var x121 = x120
var x122 = x110
var x123 = 0
val x124 = x119
val x127 = x123
val x310 = while ({val x130 = x119
val x131 = Math.abs(x130)
val x132 = x131 > 0.0010
val x133 = x123
val x134 = x133 < 1000
val x135 = x132 && x134
x135}) {
val x137 = x122
val x138 = x137.cloneL
x121 = x138
val x140 = x122
val x141 = x118 += 1
val x117 = x58.numRows
val x142 = new generated.scala.IndexVectorRangeImpl(0,x117)
def x189_block = {
val x185 = x142.length
val x186 = x142.isRow
val x187 = new generated.scala.IntVectorImpl(x185,x186)
var mapIdx = 0
while (mapIdx < x142.size) {
val x143 = x142.dcApply(mapIdx)
x187.dcUpdate(mapIdx,  {
val x147 = scala.Double.PositiveInfinity
var x148 = x147
var x149 = -1
var x150 = 0
val x151 = x150
val x182 = while ({val x154 = x150
val x152 = x140.numRows
val x155 = x154 < x152
x155}) {
def x146_block = { 
val x144 = x143 * x112
val x145 = x58.vview(x144,1,x112,true)
x145
}
val x146 = x146_block
val x157 = x146.length
val x168 = new generated.scala.RangeVectorImpl(0,x157,1,true)
def x172_block = {
val x158 = x168.dcApply(0)
var x169 = {
val x159 = x146(x158)
val x160 = x150
val x161 = x140(x160, x158)
val x162 = x159 - x161
val x163 = x150
val x164 = x140(x163, x158)
val x165 = x159 - x164
val x166 = x162 * x165
x166
}
var mapReduceIdx = 1
while (mapReduceIdx < x168.size) {
val x158 = x168.dcApply(mapReduceIdx)
val x170 = {
val x159 = x146(x158)
val x160 = x150
val x161 = x140(x160, x158)
val x162 = x159 - x161
val x163 = x150
val x164 = x140(x163, x158)
val x165 = x159 - x164
val x166 = x162 * x165
x166
}
x169 = {
val x171 = x169 + x170
x171
}
mapReduceIdx += 1
} // end while
x169
}
val x172 = x172_block
val x173 = x148
val x174 = x172 < x173
val x179 = {
def x179thenb(): Unit = {
x148 = x172
val x176 = x150
x149 = x176
()
}
def x179elseb(): Unit = {
()
}
if (x174) {
x179thenb()
} else {
x179elseb()
}
}
val x180 = x150 += 1
()
}
val x183 = x149
x183
})
mapIdx += 1
} // end while
x187
}
val x189 = x189_block
val x190 = new generated.scala.IndexVectorRangeImpl(0,x111)
def x254_block = {
var forIdx = 0
while (forIdx < x190.size) {
val x191 = x190.dcApply(forIdx)
def x194_block = { 
val x192 = new generated.scala.DoubleVectorImpl(x112,true)
x192
}
val x194 = x194_block
var x195 = 0
var x196 = 0
val x197 = x196
val x218 = while ({val x199 = x196
val x200 = x199 < x117
x200}) {
val x202 = x196
val x203 = x189(x202)
val x204 = x203==x191
val x215 = {
def x215thenb(): Unit = {
val x205 = x196
def x208_block = { 
val x206 = x205 * x112
val x207 = x58.vview(x206,1,x112,true)
x207
}
val x208 = x208_block
def x212_block = {
var zipIdx = 0
while (zipIdx < x194.size) {
val x209 = x194.dcApply(zipIdx)
val x210 = x208.dcApply(zipIdx)
x194.dcUpdate(zipIdx,  {
val x211 = x209 + x210
x211
})
zipIdx += 1
} // end while
x194
}
val x212 = x212_block
val x213 = x195 += 1
()
}
def x215elseb(): Unit = {
()
}
if (x204) {
x215thenb()
} else {
x215elseb()
}
}
val x216 = x196 += 1
()
}
val x219 = x195
val x220 = x219==0
val x223 = {
def x223thenb(): Unit = {
val x221 = x195 += 1
()
}
def x223elseb(): Unit = {
()
}
if (x220) {
x223thenb()
} else {
x223elseb()
}
}
val x224 = x195
def x232_block = {
val x226 = x194.length
val x227 = x194.isRow
val x228 = new generated.scala.DoubleVectorImpl(x226,x227)
var mapIdx = 0
while (mapIdx < x194.size) {
val x230 = x194.dcApply(mapIdx)
x228.dcUpdate(mapIdx,  {
val x225 = x224
val x231 = x230 / x225
x231
})
mapIdx += 1
} // end while
x228
}
val x232 = x232_block
def x249_block = { 
var x233 = 0
val x234 = x233
val x235 = x140
val x247 = while ({val x238 = x233
val x236 = x235.numCols
val x239 = x238 < x236
x239}) {
val x241 = x233
val x242 = x233
val x243 = x232(x242)
val x244 = x140(x191, x241) = x243
val x245 = x233 += 1
()
}
()
}
val x249 = x249_block
x249
forIdx += 1
} // end while
}
val x254 = x254_block
val x255 = x140
x122 = x255
val x257 = x123 += 1
val x258 = x122
val x259 = x121
def x307_block = { 
val x260 = 0==0
val x305 = {
def x305thenb(): Double = {
def x268_block = {
val x261 = x258.numRows
val x262 = x258.numCols
val x263 = new generated.scala.DoubleMatrixImpl(x261,x262)
var zipIdx = 0
while (zipIdx < x258.size) {
val x265 = x258.dcApply(zipIdx)
val x266 = x259.dcApply(zipIdx)
x263.dcUpdate(zipIdx,  {
val x267 = x265 - x266
x267
})
zipIdx += 1
} // end while
x263
}
val x268 = x268_block
def x275_block = {
val x269 = x268.numRows
val x270 = x268.numCols
val x271 = new generated.scala.DoubleMatrixImpl(x269,x270)
var mapIdx = 0
while (mapIdx < x268.size) {
val x273 = x268.dcApply(mapIdx)
x271.dcUpdate(mapIdx,  {
val x274 = Math.abs(x273)
x274
})
mapIdx += 1
} // end while
x271
}
val x275 = x275_block
def x279_block = {
var x276 = x275.dcApply(0)
var reduceIdx = 1
while (reduceIdx < x275.size) {
val x277 = x275.dcApply(reduceIdx)
x276 = {
val x278 = x276 + x277
x278
}
reduceIdx += 1
} // end while
x276
}
val x279 = x279_block
x279
}
def x305elseb(): Double = {
val x280 = 0==1
val x303 = {
def x303thenb(): Double = {
val x282 = x258(0, 0)
val x281 = println("NOT IMPLEMENTED YET -- SHOULD NOT BE CALLED")
x282
}
def x303elseb(): Double = {
val x284 = 0==2
val x301 = {
def x301thenb(): Double = {
def x268_block = {
val x261 = x258.numRows
val x262 = x258.numCols
val x263 = new generated.scala.DoubleMatrixImpl(x261,x262)
var zipIdx = 0
while (zipIdx < x258.size) {
val x265 = x258.dcApply(zipIdx)
val x266 = x259.dcApply(zipIdx)
x263.dcUpdate(zipIdx,  {
val x267 = x265 - x266
x267
})
zipIdx += 1
} // end while
x263
}
val x268 = x268_block
def x292_block = {
var mapIdx = 0
while (mapIdx < x268.size) {
val x290 = x268.dcApply(mapIdx)
x268.dcUpdate(mapIdx,  {
val x291 = x290 * x290
x291
})
mapIdx += 1
} // end while
x268
}
val x292 = x292_block
def x296_block = {
var x293 = x292.dcApply(0)
var reduceIdx = 1
while (reduceIdx < x292.size) {
val x294 = x292.dcApply(reduceIdx)
x293 = {
val x295 = x293 + x294
x295
}
reduceIdx += 1
} // end while
x293
}
val x296 = x296_block
x296
}
def x301elseb(): Nothing = {
val x298 = println("error: unknown dist metric selected")
val x299 = exit(0)
x299
}
if (x284) {
x301thenb()
} else {
x301elseb()
}
}
x301
}
if (x280) {
x303thenb()
} else {
x303elseb()
}
}
x303
}
if (x260) {
x305thenb()
} else {
x305elseb()
}
}
x305
}
val x307 = x307_block
x119 = x307
()
}
val x311 = x123
val x312 = x311==1000
val x316 = {
def x316thenb(): Unit = {
val x313 = println("Maximum iterations exceeded")
val x314 = return ()
x314
}
def x316elseb(): Unit = {
()
}
if (x312) {
x316thenb()
} else {
x316elseb()
}
}
val x317 = x122
val x318 = x118
val x319 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
val x320 = "finished in "+x318
val x321 = x320+" iterations"
val x322 = println(x321)
def x338_block = { 
var x324 : Int = 0
val x336 = while (x324 < x111) {
val x325 = print("[ ")
val x326 = x110.numCols
var x328 : Int = 0
val x333 = while (x328 < x326) {
val x329 = x110(x324, x328)
val x330 = print(x329)
val x331 = print(" ")
x331
x328 = x328 + 1
}
val x334 = print("]\n")
x334
x324 = x324 + 1
}
x336
}
val x338 = x338_block
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
