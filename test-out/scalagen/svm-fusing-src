/*****************************************
  Emitting Generated Code                  
*******************************************/
class SVMRunnerFusing extends ((Array[java.lang.String])=>(Unit)) {
def apply(x708:Array[java.lang.String]): Unit = {
val x709 = x708.length
val x710 = x709 < 1
val x714 = {
def x714thenb(): Nothing = {
val x711 = println("Usage: SVM <train data file> <test data file> <model filename> <num tests>")
val x712 = exit(-1)
x712
}
def x714elseb(): Unit = {
()
}
if (x710) {
x714thenb()
} else {
x714elseb()
}
}
val x720 = { generated.scala.Global.randRef.setSeed(generated.scala.Global.INITIAL_SEED);   generated.scala.Global.intRandRef.setSeed(generated.scala.Global.INITIAL_SEED); }
val x715 = x708(0)
def x842_block = { 
val x721 = new java.io.FileReader(x715)
val x722 = new java.io.BufferedReader(x721)
var x723: java.io.BufferedReader = x722
val x724 = x723
val x725 = x724.readLine()
var x726: java.lang.String = x725
val x727 = x723
val x728 = x727.readLine()
var x729: java.lang.String = x728
val x730 = x729
val x731 = x730.trim()
val x732 = x731.split("\\s+")
val x733 = x732(0)
val x734 = java.lang.Integer.parseInt(x733)
val x737 = x734 < 0
val x735 = x732(1)
val x736 = java.lang.Integer.parseInt(x735)
val x738 = x736 < 0
val x739 = x737 || x738
val x742 = {
def x742thenb(): Nothing = {
val x740 = error("Illegal input to readTokenMatrix")
x740
}
def x742elseb(): Unit = {
()
}
if (x739) {
x742thenb()
} else {
x742elseb()
}
}
val x743 = x723
val x744 = x743.readLine()
val x745 = new generated.scala.DoubleVectorImpl(0,true)
var x747 : Int = 0
val x761 = while (x747 < x734) {
val x748 = x723
val x749 = x748.readLine()
x729 = x749
val x751 = x729
val x752 = x751.trim()
x729 = x752
val x754 = x729
val x758 = x745.length
val x755 = x754.split("\\s+")
val x756 = x755(0)
val x757 = java.lang.Double.parseDouble(x756)
val x759 = x745.insert(x758, x757)
x759
x747 = x747 + 1
}
val x762 = x745.length
val x763 = x745.isRow
val x764 = !x763
val x770 = {
val x766 = new generated.scala.DoubleVectorImpl(x762,x764)
x766
}
var x765 = 0
while (x765 < x762) {  // begin thin loop x770
val x768 = x745(x765)
x770.dcUpdate(x765, x768)
x765 += 1
} // end thin loop x770
val x771 = x723
val x772 = x771.close()
val x773 = new java.io.FileReader(x715)
val x774 = new java.io.BufferedReader(x773)
x723 = x774
val x776 = x723
val x777 = x776.readLine()
val x778 = x723
val x779 = x778.readLine()
val x780 = x723
val x781 = x780.readLine()
val x782 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x783 : Int = 0
val x816 = while (x783 < x734) {
val x784 = x723
val x785 = x784.readLine()
x729 = x785
val x787 = x729
val x788 = x787.trim()
x729 = x788
val x790 = x729
val x792 = new generated.scala.DoubleVectorImpl(x736,true)
var x793: Int = 0
var x794: Int = 1
val x791 = x790.split("\\s+")
val x796 = x791.length
val x797 = x796 - 1
val x812 = while ({val x795 = x794
val x798 = x795 < x797
x798}) {
val x800 = x794
val x801 = x791(x800)
val x802 = java.lang.Integer.parseInt(x801)
val x803 = x793 += x802
val x804 = x793
val x805 = x794
val x806 = x805 + 1
val x807 = x791(x806)
val x808 = java.lang.Double.parseDouble(x807)
val x809 = x792(x804) = x808
val x810 = x794 += 2
()
}
val x813 = x782.length
val x814 = x782.insert(x813, x792)
x814
x783 = x783 + 1
}
def x836_block = { 
val x817 = x782.length
val x818 = x817 > 0
val x822 = {
def x822thenb(): Int = {
val x819 = x782(0)
val x820 = x819.length
x820
}
def x822elseb(): Int = {
0
}
if (x818) {
x822thenb()
} else {
x822elseb()
}
}
val x823 = new generated.scala.DoubleMatrixImpl(x817,x822)
var x825 : Int = 0
val x834 = while (x825 < x817) {
var x827 : Int = 0
val x832 = while (x827 < x822) {
val x828 = x782(x825)
val x829 = x828(x827)
val x830 = x823(x825, x827) = x829
x830
x827 = x827 + 1
}
x832
x825 = x825 + 1
}
x823
}
val x836 = x836_block
val x837 = x723
val x838 = x837.close()
val x839 = new generated.scala.DoubleLabelsImpl(x770)
val x840 = new generated.scala.DoubleDoubleTrainingSetImpl(x836,x839)
x840
}
val x842 = x842_block
val x716 = x708(1)
def x964_block = { 
val x843 = new java.io.FileReader(x716)
val x844 = new java.io.BufferedReader(x843)
var x845: java.io.BufferedReader = x844
val x846 = x845
val x847 = x846.readLine()
var x848: java.lang.String = x847
val x849 = x845
val x850 = x849.readLine()
var x851: java.lang.String = x850
val x852 = x851
val x853 = x852.trim()
val x854 = x853.split("\\s+")
val x855 = x854(0)
val x856 = java.lang.Integer.parseInt(x855)
val x859 = x856 < 0
val x857 = x854(1)
val x858 = java.lang.Integer.parseInt(x857)
val x860 = x858 < 0
val x861 = x859 || x860
val x864 = {
def x864thenb(): Nothing = {
val x862 = error("Illegal input to readTokenMatrix")
x862
}
def x864elseb(): Unit = {
()
}
if (x861) {
x864thenb()
} else {
x864elseb()
}
}
val x865 = x845
val x866 = x865.readLine()
val x867 = new generated.scala.DoubleVectorImpl(0,true)
var x869 : Int = 0
val x883 = while (x869 < x856) {
val x870 = x845
val x871 = x870.readLine()
x851 = x871
val x873 = x851
val x874 = x873.trim()
x851 = x874
val x876 = x851
val x880 = x867.length
val x877 = x876.split("\\s+")
val x878 = x877(0)
val x879 = java.lang.Double.parseDouble(x878)
val x881 = x867.insert(x880, x879)
x881
x869 = x869 + 1
}
val x884 = x867.length
val x885 = x867.isRow
val x886 = !x885
val x892 = {
val x888 = new generated.scala.DoubleVectorImpl(x884,x886)
x888
}
var x887 = 0
while (x887 < x884) {  // begin thin loop x892
val x890 = x867(x887)
x892.dcUpdate(x887, x890)
x887 += 1
} // end thin loop x892
val x893 = x845
val x894 = x893.close()
val x895 = new java.io.FileReader(x716)
val x896 = new java.io.BufferedReader(x895)
x845 = x896
val x898 = x845
val x899 = x898.readLine()
val x900 = x845
val x901 = x900.readLine()
val x902 = x845
val x903 = x902.readLine()
val x904 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x905 : Int = 0
val x938 = while (x905 < x856) {
val x906 = x845
val x907 = x906.readLine()
x851 = x907
val x909 = x851
val x910 = x909.trim()
x851 = x910
val x912 = x851
val x914 = new generated.scala.DoubleVectorImpl(x858,true)
var x915: Int = 0
var x916: Int = 1
val x913 = x912.split("\\s+")
val x918 = x913.length
val x919 = x918 - 1
val x934 = while ({val x917 = x916
val x920 = x917 < x919
x920}) {
val x922 = x916
val x923 = x913(x922)
val x924 = java.lang.Integer.parseInt(x923)
val x925 = x915 += x924
val x926 = x915
val x927 = x916
val x928 = x927 + 1
val x929 = x913(x928)
val x930 = java.lang.Double.parseDouble(x929)
val x931 = x914(x926) = x930
val x932 = x916 += 2
()
}
val x935 = x904.length
val x936 = x904.insert(x935, x914)
x936
x905 = x905 + 1
}
def x958_block = { 
val x939 = x904.length
val x940 = x939 > 0
val x944 = {
def x944thenb(): Int = {
val x941 = x904(0)
val x942 = x941.length
x942
}
def x944elseb(): Int = {
0
}
if (x940) {
x944thenb()
} else {
x944elseb()
}
}
val x945 = new generated.scala.DoubleMatrixImpl(x939,x944)
var x947 : Int = 0
val x956 = while (x947 < x939) {
var x949 : Int = 0
val x954 = while (x949 < x944) {
val x950 = x904(x947)
val x951 = x950(x949)
val x952 = x945(x947, x949) = x951
x952
x949 = x949 + 1
}
x954
x947 = x947 + 1
}
x945
}
val x958 = x958_block
val x959 = x845
val x960 = x959.close()
val x961 = new generated.scala.DoubleLabelsImpl(x892)
val x962 = new generated.scala.DoubleDoubleTrainingSetImpl(x958,x961)
x962
}
val x964 = x964_block
val x965 = x842.labels
def x969_block = {
var mapIdx = 0
while (mapIdx < x965.size) {
val x966 = x965.dcApply(mapIdx)
x965.dcUpdate(mapIdx,  {
val x967 = x966==0
val x968 = {
def x968thenb(): Double = {
-1.0
}
def x968elseb(): Double = {
1.0
}
if (x967) {
x968thenb()
} else {
x968elseb()
}
}
x968
})
mapIdx += 1
} // end while
x965
}
val x969 = x969_block
val x970 = x964.labels
def x974_block = {
var mapIdx = 0
while (mapIdx < x970.size) {
val x971 = x970.dcApply(mapIdx)
x970.dcUpdate(mapIdx,  {
val x972 = x971==0
val x973 = {
def x973thenb(): Double = {
-1.0
}
def x973elseb(): Double = {
1.0
}
if (x972) {
x973thenb()
} else {
x973elseb()
}
}
x973
})
mapIdx += 1
} // end while
x970
}
val x974 = x974_block
val x267 = Seq()
val x975 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
val x976 = println("Training SVM using the SMO algorithm")
val x977 = x842.numCols
def x980_block = { 
val x978 = new generated.scala.DoubleVectorImpl(x977,true)
x978
}
val x980 = x980_block
var x981: generated.scala.Vector[Double] = x980
var x982: Double = 0.0
val x983 = x842.numRows
def x986_block = { 
val x984 = new generated.scala.DoubleVectorImpl(x983,true)
x984
}
val x986 = x986_block
val x987 = x986.mtrans
var x988: Int = 0
val x1328 = while ({val x989 = x988
val x990 = x989 < 10
x990}) {
val x992 = print(".")
var x993: Int = 0
var x994: Int = 0
val x1319 = while ({val x995 = x994
val x996 = x995 < x983
x996}) {
val x998 = x986.cloneL
val x1007 = x994
val x1045 = x982
val x1047 = x994
val x1050 = x994
val x1054 = x994
val x1058 = x994
val x1062 = x994
val x999 = x998.isRow
var x1044: Double = 0
val x1006 = {
val x1001 = new generated.scala.DoubleVectorImpl(x983,x999)
x1001
}
var x1039 = 0
while (x1039 < x983) {  // begin fat loop x1044,x1006
val x1417 = x998(x1039)
val x1418 = x965(x1039)
val x1419 = x1417 * x1418
var x1030: Double = 0
var x1018 = 0
while (x1018 < x977) {  // begin fat loop x1030
val x1420 = x842(x1039, x1018)
val x1022 = x842(x1007, x1018)
val x1421 = x1420 * x1022
val x1026 = x1030
val x1027 = x1421
val x1029 = x1026 + x1027
x1030 = x1029
x1018 += 1
} // end fat loop x1030
val x1422 = x1419 * x1030
val x1040 = x1044
val x1041 = x1422
val x1043 = x1040 + x1041
x1044 = x1043
x1006.dcUpdate(x1039, x1419)
x1039 += 1
} // end fat loop x1044,x1006
val x1046 = x1044 + x1045
val x1048 = x965(x1047)
val x1049 = x1046 - x1048
val x1051 = x965(x1050)
val x1052 = x1051 * x1049
val x1053 = x1052 < -1.0E-4
val x1055 = x998(x1054)
val x1056 = x1055 < 1.0
val x1057 = x1053 && x1056
val x1059 = x965(x1058)
val x1060 = x1059 * x1049
val x1061 = x1060 > 1.0E-4
val x1063 = x998(x1062)
val x1064 = x1063 > 0.0
val x1065 = x1061 && x1064
val x1066 = x1057 || x1065
val x1316 = {
def x1316thenb(): Unit = {
val x1067 = generated.scala.Global.randRef.nextDouble()
val x1068 = x1067.asInstanceOf[Double]
val x1069 = x983 - 1
val x1070 = x1069
val x1071 = x1068 * x1070
val x1072 = Math.floor(x1071)
val x1073 = x1072.asInstanceOf[Int]
val x1074 = x1073 + 1
var x1075: Int = x1074
val x1088 = while ({val x1076 = x1075
val x1077 = x994
val x1078 = x1076==x1077
x1078}) {
val x1080 = generated.scala.Global.randRef.nextDouble()
val x1081 = x1080.asInstanceOf[Double]
val x1082 = x1081 * x1070
val x1083 = Math.floor(x1082)
val x1084 = x1083.asInstanceOf[Int]
val x1085 = x1084 + 1
x1075 = x1085
()
}
val x1095 = x1075
val x1133 = x982
var x1138: Double = 0.0
var x1139: Double = 0.0
val x1140 = x994
val x1135 = x965(x1095)
val x1141 = x965(x1140)
val x1142 = x1141 != x1135
val x1159 = {
def x1159thenb(): Unit = {
val x1137 = x998(x1095)
val x1143 = x998(x1140)
val x1144 = x1137 - x1143
val x1145 = Math.max(0.0, x1144)
x1138 = x1145
val x1147 = 1.0 + x1137
val x1148 = x1147 - x1143
val x1149 = Math.min(1.0, x1148)
x1139 = x1149
()
}
def x1159elseb(): Unit = {
val x1137 = x998(x1095)
val x1143 = x998(x1140)
val x1152 = x1143 + x1137
val x1153 = x1152 - 1.0
val x1154 = Math.max(0.0, x1153)
x1138 = x1154
val x1156 = Math.min(1.0, x1152)
x1139 = x1156
()
}
if (x1142) {
x1159thenb()
} else {
x1159elseb()
}
}
val x1160 = x1138
val x1161 = x1139
val x1162 = x1160 != x1161
val x1314 = {
def x1314thenb(): Unit = {
var x1176: Double = 0
var x1189: Double = 0
var x1202: Double = 0
var x1164 = 0
while (x1164 < x977) {  // begin fat loop x1176,x1189,x1202
val x1167 = x842(x1140, x1164)
val x1168 = x842(x1095, x1164)
val x1169 = x1167 * x1168
val x1423 = x1167 * x1167
val x1424 = x1168 * x1168
val x1172 = x1176
val x1173 = x1169
val x1175 = x1172 + x1173
x1176 = x1175
val x1185 = x1189
val x1186 = x1423
val x1188 = x1185 + x1186
x1189 = x1188
val x1198 = x1202
val x1199 = x1424
val x1201 = x1198 + x1199
x1202 = x1201
x1164 += 1
} // end fat loop x1176,x1189,x1202
val x1177 = x1176 * 2.0
val x1190 = x1177 - x1189
val x1203 = x1190 - x1202
val x1204 = x1203 < 0.0
val x1312 = {
def x1312thenb(): Unit = {
val x1137 = x998(x1095)
var x1132: Double = 0
var x1127 = 0
while (x1127 < x983) {  // begin fat loop x1132
val x1427 = x1006(x1127)
var x1118: Double = 0
var x1106 = 0
while (x1106 < x977) {  // begin fat loop x1118
val x1428 = x842(x1127, x1106)
val x1110 = x842(x1095, x1106)
val x1429 = x1428 * x1110
val x1114 = x1118
val x1115 = x1429
val x1117 = x1114 + x1115
x1118 = x1117
x1106 += 1
} // end fat loop x1118
val x1430 = x1427 * x1118
val x1128 = x1132
val x1129 = x1430
val x1131 = x1128 + x1129
x1132 = x1131
x1127 += 1
} // end fat loop x1132
val x1134 = x1132 + x1133
val x1136 = x1134 - x1135
val x1205 = x1049 - x1136
val x1206 = x1135 * x1205
val x1207 = x1206 / x1203
val x1208 = x1137 - x1207
val x1209 = x986(x1095) = x1208
val x1210 = x986(x1095)
val x1211 = x1210 > x1161
val x1219 = {
def x1219thenb(): Unit = {
val x1212 = x986(x1095) = x1161
x1212
}
def x1219elseb(): Unit = {
val x1214 = x1210 < x1160
val x1217 = {
def x1217thenb(): Unit = {
val x1215 = x986(x1095) = x1160
x1215
}
def x1217elseb(): Unit = {
()
}
if (x1214) {
x1217thenb()
} else {
x1217elseb()
}
}
x1217
}
if (x1211) {
x1219thenb()
} else {
x1219elseb()
}
}
val x1220 = x986(x1095)
val x1221 = x1220 - x1137
val x1222 = Math.abs(x1221)
val x1223 = x1222 > 1.0E-4
val x1310 = {
def x1310thenb(): Unit = {
val x1143 = x998(x1140)
val x1224 = x1141 * x1135
val x1225 = x1137 - x1220
val x1226 = x1224 * x1225
val x1227 = x1143 + x1226
val x1228 = x986(x1140) = x1227
val x1241 = x986(x1140)
val x1257 = x986(x1095)
val x1289 = x1241 > 0.0
val x1290 = x1241 < 1.0
val x1291 = x1289 && x1290
val x1294 = {
def x1294thenb(): Unit = {
val x1229 = x1133 - x1049
val x1240 = x1189 * x1141
val x1242 = x1241 - x1143
val x1243 = x1240 * x1242
val x1244 = x1229 - x1243
val x1256 = x1176 * x1135
val x1258 = x1257 - x1137
val x1259 = x1256 * x1258
val x1260 = x1244 - x1259
x982 = x1260
()
}
def x1294elseb(): Unit = {
()
}
if (x1291) {
x1294thenb()
} else {
x1294elseb()
}
}
val x1295 = x1257 > 0.0
val x1296 = x1257 < 1.0
val x1297 = x1295 && x1296
val x1300 = {
def x1300thenb(): Unit = {
val x1261 = x1133 - x1136
val x1242 = x1241 - x1143
val x1273 = x1176 * x1141
val x1274 = x1273 * x1242
val x1275 = x1261 - x1274
val x1258 = x1257 - x1137
val x1286 = x1202 * x1135
val x1287 = x1286 * x1258
val x1288 = x1275 - x1287
x982 = x1288
()
}
def x1300elseb(): Unit = {
()
}
if (x1297) {
x1300thenb()
} else {
x1300elseb()
}
}
val x1301 = x982
val x1302 = x1301==x1301
val x1307 = {
def x1307thenb(): Unit = {
val x1229 = x1133 - x1049
val x1240 = x1189 * x1141
val x1242 = x1241 - x1143
val x1243 = x1240 * x1242
val x1244 = x1229 - x1243
val x1256 = x1176 * x1135
val x1258 = x1257 - x1137
val x1259 = x1256 * x1258
val x1260 = x1244 - x1259
val x1261 = x1133 - x1136
val x1273 = x1176 * x1141
val x1274 = x1273 * x1242
val x1275 = x1261 - x1274
val x1286 = x1202 * x1135
val x1287 = x1286 * x1258
val x1288 = x1275 - x1287
val x1303 = x1260 + x1288
val x1304 = x1303 / 2.0
x982 = x1304
()
}
def x1307elseb(): Unit = {
()
}
if (x1302) {
x1307thenb()
} else {
x1307elseb()
}
}
val x1308 = x993 += 1
()
}
def x1310elseb(): Unit = {
()
}
if (x1223) {
x1310thenb()
} else {
x1310elseb()
}
}
x1310
}
def x1312elseb(): Unit = {
()
}
if (x1204) {
x1312thenb()
} else {
x1312elseb()
}
}
x1312
}
def x1314elseb(): Unit = {
()
}
if (x1162) {
x1314thenb()
} else {
x1314elseb()
}
}
x1314
}
def x1316elseb(): Unit = {
()
}
if (x1066) {
x1316thenb()
} else {
x1316elseb()
}
}
val x1317 = x994 += 1
()
}
val x1320 = x993
val x1321 = x1320==0
val x1326 = {
def x1326thenb(): Unit = {
val x1322 = x988 += 1
()
}
def x1326elseb(): Unit = {
x988 = 0
()
}
if (x1321) {
x1326thenb()
} else {
x1326elseb()
}
}
x1326
}
var x1329: Int = 0
val x1364 = while ({val x1330 = x1329
val x1331 = x1330 < x983
x1331}) {
val x1333 = x981
val x1334 = x1329
val x1336 = x1329
val x1337 = x986(x1336)
val x1344 = x1329
val x1352 = x1333.length
val x1353 = x1333.isRow
val x1345 = x965(x1344)
val x1351 = {
val x1347 = new generated.scala.DoubleVectorImpl(x977,true)
x1347
}
var x1338 = 0
while (x1338 < x977) {  // begin fat loop x1351
val x1341 = x842(x1334, x1338)
val x1342 = x1341 * x1337
val x1431 = x1342 * x1345
x1351.dcUpdate(x1338, x1431)
x1338 += 1
} // end fat loop x1351
val x1360 = {
val x1355 = new generated.scala.DoubleVectorImpl(x1352,x1353)
x1355
}
var x1354 = 0
while (x1354 < x1352) {  // begin fat loop x1360
val x1357 = x1333(x1354)
val x1358 = x1351(x1354)
val x1359 = x1357 + x1358
x1360.dcUpdate(x1354, x1359)
x1354 += 1
} // end fat loop x1360
x981 = x1360
val x1362 = x1329 += 1
()
}
val x1365 = print("\n")
val x1366 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
val x1367 = x964.numRows
val x1368 = new generated.scala.IndexVectorRangeImpl(0,x1367)
val x1392 = x1368.length
val x1393 = x1368.isRow
def x1396_block = {
val x1394 = new generated.scala.IntVectorImpl(x1392,x1393)
var mapIdx = 0
while (mapIdx < x1368.size) {
val x1369 = x1368.dcApply(mapIdx)
x1394.dcUpdate(mapIdx,  {
val x1370 = x981
val x1371 = x982
val x1373 = x1370.length
var x1387: Double = 0
var x1375 = 0
while (x1375 < x1373) {  // begin fat loop x1387
val x1378 = x1370(x1375)
val x1379 = x964(x1369, x1375)
val x1380 = x1378 * x1379
val x1383 = x1387
val x1384 = x1380
val x1386 = x1383 + x1384
x1387 = x1386
x1375 += 1
} // end fat loop x1387
val x1388 = x1387 + x1371
val x1389 = x1388 < 0.0
val x1390 = {
def x1390thenb(): Int = {
-1
}
def x1390elseb(): Int = {
1
}
if (x1389) {
x1390thenb()
} else {
x1390elseb()
}
}
x1390
})
mapIdx += 1
} // end while
x1394
}
val x1396 = x1396_block
val x1397 = println("SVM testing finished. Calculating error..")
val x1403 = new generated.scala.RangeVectorImpl(0,x1367,1,true)
def x1407_block = {
val x1398 = x1403.dcApply(0)
var x1404 = {
val x1399 = x970(x1398)
val x1400 = x1396(x1398)
val x1401 = x1399 != x1400
val x1402 = {
def x1402thenb(): Int = {
1
}
def x1402elseb(): Int = {
0
}
if (x1401) {
x1402thenb()
} else {
x1402elseb()
}
}
x1402
}
var mapReduceIdx = 1
while (mapReduceIdx < x1403.size) {
val x1398 = x1403.dcApply(mapReduceIdx)
val x1405 = {
val x1399 = x970(x1398)
val x1400 = x1396(x1398)
val x1401 = x1399 != x1400
val x1402 = {
def x1402thenb(): Int = {
1
}
def x1402elseb(): Int = {
0
}
if (x1401) {
x1402thenb()
} else {
x1402elseb()
}
}
x1402
}
x1404 = {
val x1406 = x1404 + x1405
x1406
}
mapReduceIdx += 1
} // end while
x1404
}
val x1407 = x1407_block
val x1408 = x1407.doubleValue()
val x1409 = x1367.doubleValue()
val x1410 = x1408 / x1409
val x1411 = "Classification error: "+x1410
val x1412 = println(x1411)
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
