/*****************************************
  Emitting Generated Code                  
*******************************************/
class SVMRunnerFusing extends ((Array[java.lang.String])=>(Unit)) {
def apply(x784:Array[java.lang.String]): Unit = {
val x785 = x784.length
val x786 = x785 < 1
val x790 = {
def x790thenb(): Nothing = {
val x787 = println("Usage: SVM <train data file> <test data file> <model filename> <num tests>")
val x788 = exit(-1)
x788
}
def x790elseb(): Unit = {
()
}
if (x786) {
x790thenb()
} else {
x790elseb()
}
}
val x796 = { generated.scala.Global.randRef.setSeed(generated.scala.Global.INITIAL_SEED);   generated.scala.Global.intRandRef.setSeed(generated.scala.Global.INITIAL_SEED); }
val x791 = x784(0)
val x934 = { 
val x797 = new java.io.FileReader(x791)
val x798 = new java.io.BufferedReader(x797)
var x799: java.io.BufferedReader = x798
val x800 = x799
val x801 = x800.readLine()
var x802: java.lang.String = x801
val x803 = x799
val x804 = x803.readLine()
var x805: java.lang.String = x804
val x806 = x805
val x807 = x806.trim()
val x808 = x807.split("\\s+")
val x809 = x808(0)
val x810 = java.lang.Integer.parseInt(x809)
val x813 = x810 < 0
val x811 = x808(1)
val x812 = java.lang.Integer.parseInt(x811)
val x814 = x812 < 0
val x815 = x813 || x814
val x818 = {
def x818thenb(): Nothing = {
val x816 = error("Illegal input to readTokenMatrix")
x816
}
def x818elseb(): Unit = {
()
}
if (x815) {
x818thenb()
} else {
x818elseb()
}
}
val x819 = x799
val x820 = x819.readLine()
val x821 = new generated.scala.DoubleVectorImpl(0,true)
var x823 : Int = 0
val x837 = while (x823 < x810) {
val x824 = x799
val x825 = x824.readLine()
x805 = x825
val x827 = x805
val x828 = x827.trim()
x805 = x828
val x830 = x805
val x834 = x821.length
val x831 = x830.split("\\s+")
val x832 = x831(0)
val x833 = java.lang.Double.parseDouble(x832)
val x835 = x821.insert(x834, x833)
x835
x823 = x823 + 1
}
val x838 = x821.length
val x839 = x821.isRow
val x840 = !x839
// a *thin* loop follows: x846
val x846 = {
val x842 = new generated.scala.DoubleVectorImpl(x838,x840)
x842
}
var x841 = 0
while (x841 < x838) {  // begin fat loop x846
val x844 = x821(x841)
x846.dcUpdate(x841, x844)
x841 += 1
} // end fat loop x846
val x847 = x799
val x848 = x847.close()
val x849 = new java.io.FileReader(x791)
val x850 = new java.io.BufferedReader(x849)
x799 = x850
val x852 = x799
val x853 = x852.readLine()
val x854 = x799
val x855 = x854.readLine()
val x856 = x799
val x857 = x856.readLine()
val x858 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x859 : Int = 0
val x892 = while (x859 < x810) {
val x860 = x799
val x861 = x860.readLine()
x805 = x861
val x863 = x805
val x864 = x863.trim()
x805 = x864
val x866 = x805
val x868 = new generated.scala.DoubleVectorImpl(x812,true)
var x869: Int = 0
var x870: Int = 1
val x867 = x866.split("\\s+")
val x872 = x867.length
val x873 = x872 - 1
val x888 = while ({val x871 = x870
val x874 = x871 < x873
x874}) {
val x876 = x870
val x877 = x867(x876)
val x878 = java.lang.Integer.parseInt(x877)
val x879 = x869 += x878
val x880 = x869
val x881 = x870
val x882 = x881 + 1
val x883 = x867(x882)
val x884 = java.lang.Double.parseDouble(x883)
val x885 = x868(x880) = x884
val x886 = x870 += 2
()
}
val x889 = x858.length
val x890 = x858.insert(x889, x868)
x890
x859 = x859 + 1
}
val x928 = { 
val x893 = x858.length
val x894 = x893==0
val x926 = {
def x926thenb(): generated.scala.Matrix[Double] = {
val x895 = new generated.scala.DoubleMatrixImpl(0,0)
x895
}
def x926elseb(): generated.scala.Matrix[Double] = {
val x897 = x858(0)
val x898 = x897.isRow
val x924 = {
def x924thenb(): generated.scala.Matrix[Double] = {
val x899 = x897.length
val x900 = new generated.scala.DoubleMatrixImpl(x893,x899)
var x902 : Int = 0
val x911 = while (x902 < x893) {
var x904 : Int = 0
val x909 = while (x904 < x899) {
val x905 = x858(x902)
val x906 = x905(x904)
val x907 = x900(x902, x904) = x906
x907
x904 = x904 + 1
}
x909
x902 = x902 + 1
}
x900
}
def x924elseb(): generated.scala.Matrix[Double] = {
val x899 = x897.length
val x913 = new generated.scala.DoubleMatrixImpl(x899,x893)
var x914 : Int = 0
val x922 = while (x914 < x893) {
var x915 : Int = 0
val x920 = while (x915 < x899) {
val x916 = x858(x914)
val x917 = x916(x915)
val x918 = x913(x915, x914) = x917
x918
x915 = x915 + 1
}
x920
x914 = x914 + 1
}
x913
}
if (x898) {
x924thenb()
} else {
x924elseb()
}
}
x924
}
if (x894) {
x926thenb()
} else {
x926elseb()
}
}
x926
}
val x929 = x799
val x930 = x929.close()
val x931 = new generated.scala.DoubleLabelsImpl(x846)
val x932 = new generated.scala.DoubleDoubleTrainingSetImpl(x928,x931)
x932
}
val x792 = x784(1)
val x1072 = { 
val x935 = new java.io.FileReader(x792)
val x936 = new java.io.BufferedReader(x935)
var x937: java.io.BufferedReader = x936
val x938 = x937
val x939 = x938.readLine()
var x940: java.lang.String = x939
val x941 = x937
val x942 = x941.readLine()
var x943: java.lang.String = x942
val x944 = x943
val x945 = x944.trim()
val x946 = x945.split("\\s+")
val x947 = x946(0)
val x948 = java.lang.Integer.parseInt(x947)
val x951 = x948 < 0
val x949 = x946(1)
val x950 = java.lang.Integer.parseInt(x949)
val x952 = x950 < 0
val x953 = x951 || x952
val x956 = {
def x956thenb(): Nothing = {
val x954 = error("Illegal input to readTokenMatrix")
x954
}
def x956elseb(): Unit = {
()
}
if (x953) {
x956thenb()
} else {
x956elseb()
}
}
val x957 = x937
val x958 = x957.readLine()
val x959 = new generated.scala.DoubleVectorImpl(0,true)
var x961 : Int = 0
val x975 = while (x961 < x948) {
val x962 = x937
val x963 = x962.readLine()
x943 = x963
val x965 = x943
val x966 = x965.trim()
x943 = x966
val x968 = x943
val x972 = x959.length
val x969 = x968.split("\\s+")
val x970 = x969(0)
val x971 = java.lang.Double.parseDouble(x970)
val x973 = x959.insert(x972, x971)
x973
x961 = x961 + 1
}
val x976 = x959.length
val x977 = x959.isRow
val x978 = !x977
// a *thin* loop follows: x984
val x984 = {
val x980 = new generated.scala.DoubleVectorImpl(x976,x978)
x980
}
var x979 = 0
while (x979 < x976) {  // begin fat loop x984
val x982 = x959(x979)
x984.dcUpdate(x979, x982)
x979 += 1
} // end fat loop x984
val x985 = x937
val x986 = x985.close()
val x987 = new java.io.FileReader(x792)
val x988 = new java.io.BufferedReader(x987)
x937 = x988
val x990 = x937
val x991 = x990.readLine()
val x992 = x937
val x993 = x992.readLine()
val x994 = x937
val x995 = x994.readLine()
val x996 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x997 : Int = 0
val x1030 = while (x997 < x948) {
val x998 = x937
val x999 = x998.readLine()
x943 = x999
val x1001 = x943
val x1002 = x1001.trim()
x943 = x1002
val x1004 = x943
val x1006 = new generated.scala.DoubleVectorImpl(x950,true)
var x1007: Int = 0
var x1008: Int = 1
val x1005 = x1004.split("\\s+")
val x1010 = x1005.length
val x1011 = x1010 - 1
val x1026 = while ({val x1009 = x1008
val x1012 = x1009 < x1011
x1012}) {
val x1014 = x1008
val x1015 = x1005(x1014)
val x1016 = java.lang.Integer.parseInt(x1015)
val x1017 = x1007 += x1016
val x1018 = x1007
val x1019 = x1008
val x1020 = x1019 + 1
val x1021 = x1005(x1020)
val x1022 = java.lang.Double.parseDouble(x1021)
val x1023 = x1006(x1018) = x1022
val x1024 = x1008 += 2
()
}
val x1027 = x996.length
val x1028 = x996.insert(x1027, x1006)
x1028
x997 = x997 + 1
}
val x1066 = { 
val x1031 = x996.length
val x1032 = x1031==0
val x1064 = {
def x1064thenb(): generated.scala.Matrix[Double] = {
val x1033 = new generated.scala.DoubleMatrixImpl(0,0)
x1033
}
def x1064elseb(): generated.scala.Matrix[Double] = {
val x1035 = x996(0)
val x1036 = x1035.isRow
val x1062 = {
def x1062thenb(): generated.scala.Matrix[Double] = {
val x1037 = x1035.length
val x1038 = new generated.scala.DoubleMatrixImpl(x1031,x1037)
var x1040 : Int = 0
val x1049 = while (x1040 < x1031) {
var x1042 : Int = 0
val x1047 = while (x1042 < x1037) {
val x1043 = x996(x1040)
val x1044 = x1043(x1042)
val x1045 = x1038(x1040, x1042) = x1044
x1045
x1042 = x1042 + 1
}
x1047
x1040 = x1040 + 1
}
x1038
}
def x1062elseb(): generated.scala.Matrix[Double] = {
val x1037 = x1035.length
val x1051 = new generated.scala.DoubleMatrixImpl(x1037,x1031)
var x1052 : Int = 0
val x1060 = while (x1052 < x1031) {
var x1053 : Int = 0
val x1058 = while (x1053 < x1037) {
val x1054 = x996(x1052)
val x1055 = x1054(x1053)
val x1056 = x1051(x1053, x1052) = x1055
x1056
x1053 = x1053 + 1
}
x1058
x1052 = x1052 + 1
}
x1051
}
if (x1036) {
x1062thenb()
} else {
x1062elseb()
}
}
x1062
}
if (x1032) {
x1064thenb()
} else {
x1064elseb()
}
}
x1064
}
val x1067 = x937
val x1068 = x1067.close()
val x1069 = new generated.scala.DoubleLabelsImpl(x984)
val x1070 = new generated.scala.DoubleDoubleTrainingSetImpl(x1066,x1069)
x1070
}
val x1073 = x934.labels
def x1077_block = {
var mapIdx = 0
while (mapIdx < x1073.size) { // begin map loop x1077
val x1074 = x1073.dcApply(mapIdx)
x1073.dcUpdate(mapIdx,  {
val x1075 = x1074==0
val x1076 = {
def x1076thenb(): Double = {
-1.0
}
def x1076elseb(): Double = {
1.0
}
if (x1075) {
x1076thenb()
} else {
x1076elseb()
}
}
x1076
})
mapIdx += 1
} // end map loop x1077
x1073
}
val x1077 = x1077_block
val x1078 = x1072.labels
def x1082_block = {
var mapIdx = 0
while (mapIdx < x1078.size) { // begin map loop x1082
val x1079 = x1078.dcApply(mapIdx)
x1078.dcUpdate(mapIdx,  {
val x1080 = x1079==0
val x1081 = {
def x1081thenb(): Double = {
-1.0
}
def x1081elseb(): Double = {
1.0
}
if (x1080) {
x1081thenb()
} else {
x1081elseb()
}
}
x1081
})
mapIdx += 1
} // end map loop x1082
x1078
}
val x1082 = x1082_block
val x299 = Seq()
val x1083 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
val x1084 = println("Training SVM using the SMO algorithm")
val x1085 = x934.numCols
val x1088 = { 
val x1086 = new generated.scala.DoubleVectorImpl(x1085,true)
x1086
}
var x1089: generated.scala.Vector[Double] = x1088
var x1090: Double = 0.0
val x1091 = x934.numRows
val x1094 = { 
val x1092 = new generated.scala.DoubleVectorImpl(x1091,true)
x1092
}
val x1095 = x1094.mtrans
var x1096: Int = 0
val x1473 = while ({val x1097 = x1096
val x1098 = x1097 < 10
x1098}) {
val x1100 = print(".")
var x1101: Int = 0
var x1102: Int = 0
val x1464 = while ({val x1103 = x1102
val x1104 = x1103 < x1091
x1104}) {
val x1106 = x1094.cloneL
val x1115 = x1102
val x1161 = x1090
val x1163 = x1102
val x1166 = x1102
val x1170 = x1102
val x1174 = x1102
val x1178 = x1102
val x1120 = x1115 * x1085
val x1107 = x1106.isRow
var x1160: Double = 0
val x1114 = {
val x1109 = new generated.scala.DoubleVectorImpl(x1091,x1107)
x1109
}
var x1155 = 0
while (x1155 < x1091) {  // begin fat loop x1160,x1114
val x1572 = x1106(x1155)
val x1573 = x1073(x1155)
val x1574 = x1572 * x1573
val x1575 = x1155 * x1085
var x1146: Double = 0
var x1129 = 0
while (x1129 < x1085) {  // begin fat loop x1146
val x1576 = x1575 + x1129
val x1577 = x934.dcApply(x1576)
val x1578 = { 
x1577
}
val x1136 = x1120 + x1129
val x1137 = x934.dcApply(x1136)
val x1138 = { 
x1137
}
val x1579 = x1578 * x1138
val x1142 = x1146
val x1143 = x1579
val x1145 = x1142 + x1143
x1146 = x1145
x1129 += 1
} // end fat loop x1146
val x1580 = x1574 * x1146
val x1156 = x1160
val x1157 = x1580
val x1159 = x1156 + x1157
x1160 = x1159
x1114.dcUpdate(x1155, x1574)
x1155 += 1
} // end fat loop x1160,x1114
val x1162 = x1160 + x1161
val x1164 = x1073(x1163)
val x1165 = x1162 - x1164
val x1167 = x1073(x1166)
val x1168 = x1167 * x1165
val x1169 = x1168 < -1.0E-4
val x1171 = x1106(x1170)
val x1172 = x1171 < 1.0
val x1173 = x1169 && x1172
val x1175 = x1073(x1174)
val x1176 = x1175 * x1165
val x1177 = x1176 > 1.0E-4
val x1179 = x1106(x1178)
val x1180 = x1179 > 0.0
val x1181 = x1177 && x1180
val x1182 = x1173 || x1181
val x1461 = {
def x1461thenb(): Unit = {
val x1183 = generated.scala.Global.randRef.nextDouble()
val x1184 = x1183.asInstanceOf[Double]
val x1185 = x1091 - 1
val x1186 = x1185
val x1187 = x1184 * x1186
val x1188 = Math.floor(x1187)
val x1189 = x1188.asInstanceOf[Int]
val x1190 = x1189 + 1
var x1191: Int = x1190
val x1204 = while ({val x1192 = x1191
val x1193 = x1102
val x1194 = x1192==x1193
x1194}) {
val x1196 = generated.scala.Global.randRef.nextDouble()
val x1197 = x1196.asInstanceOf[Double]
val x1198 = x1197 * x1186
val x1199 = Math.floor(x1198)
val x1200 = x1199.asInstanceOf[Int]
val x1201 = x1200 + 1
x1191 = x1201
()
}
val x1211 = x1191
val x1257 = x1090
var x1262: Double = 0.0
var x1263: Double = 0.0
val x1264 = x1102
val x1259 = x1073(x1211)
val x1265 = x1073(x1264)
val x1266 = x1265 != x1259
val x1283 = {
def x1283thenb(): Unit = {
val x1261 = x1106(x1211)
val x1267 = x1106(x1264)
val x1268 = x1261 - x1267
val x1269 = Math.max(0.0, x1268)
x1262 = x1269
val x1271 = 1.0 + x1261
val x1272 = x1271 - x1267
val x1273 = Math.min(1.0, x1272)
x1263 = x1273
()
}
def x1283elseb(): Unit = {
val x1261 = x1106(x1211)
val x1267 = x1106(x1264)
val x1276 = x1267 + x1261
val x1277 = x1276 - 1.0
val x1278 = Math.max(0.0, x1277)
x1262 = x1278
val x1280 = Math.min(1.0, x1276)
x1263 = x1280
()
}
if (x1266) {
x1283thenb()
} else {
x1283elseb()
}
}
val x1284 = x1262
val x1285 = x1263
val x1286 = x1284 != x1285
val x1459 = {
def x1459thenb(): Unit = {
val x1291 = x1264 * x1085
val x1216 = x1211 * x1085
var x1305: Double = 0
var x1320: Double = 0
var x1335: Double = 0
var x1288 = 0
while (x1288 < x1085) {  // begin fat loop x1305,x1320,x1335
val x1292 = x1291 + x1288
val x1293 = x934.dcApply(x1292)
val x1294 = { 
x1293
}
val x1295 = x1216 + x1288
val x1296 = x934.dcApply(x1295)
val x1297 = { 
x1296
}
val x1298 = x1294 * x1297
val x1581 = x1294 * x1294
val x1582 = x1297 * x1297
val x1301 = x1305
val x1302 = x1298
val x1304 = x1301 + x1302
x1305 = x1304
val x1316 = x1320
val x1317 = x1581
val x1319 = x1316 + x1317
x1320 = x1319
val x1331 = x1335
val x1332 = x1582
val x1334 = x1331 + x1332
x1335 = x1334
x1288 += 1
} // end fat loop x1305,x1320,x1335
val x1306 = x1305 * 2.0
val x1321 = x1306 - x1320
val x1336 = x1321 - x1335
val x1337 = x1336 < 0.0
val x1457 = {
def x1457thenb(): Unit = {
val x1261 = x1106(x1211)
var x1256: Double = 0
var x1251 = 0
while (x1251 < x1091) {  // begin fat loop x1256
val x1585 = x1114(x1251)
val x1586 = x1251 * x1085
var x1242: Double = 0
var x1225 = 0
while (x1225 < x1085) {  // begin fat loop x1242
val x1587 = x1586 + x1225
val x1588 = x934.dcApply(x1587)
val x1589 = { 
x1588
}
val x1232 = x1216 + x1225
val x1233 = x934.dcApply(x1232)
val x1234 = { 
x1233
}
val x1590 = x1589 * x1234
val x1238 = x1242
val x1239 = x1590
val x1241 = x1238 + x1239
x1242 = x1241
x1225 += 1
} // end fat loop x1242
val x1591 = x1585 * x1242
val x1252 = x1256
val x1253 = x1591
val x1255 = x1252 + x1253
x1256 = x1255
x1251 += 1
} // end fat loop x1256
val x1258 = x1256 + x1257
val x1260 = x1258 - x1259
val x1338 = x1165 - x1260
val x1339 = x1259 * x1338
val x1340 = x1339 / x1336
val x1341 = x1261 - x1340
val x1342 = x1094(x1211) = x1341
val x1343 = x1094(x1211)
val x1344 = x1343 > x1285
val x1352 = {
def x1352thenb(): Unit = {
val x1345 = x1094(x1211) = x1285
x1345
}
def x1352elseb(): Unit = {
val x1347 = x1343 < x1284
val x1350 = {
def x1350thenb(): Unit = {
val x1348 = x1094(x1211) = x1284
x1348
}
def x1350elseb(): Unit = {
()
}
if (x1347) {
x1350thenb()
} else {
x1350elseb()
}
}
x1350
}
if (x1344) {
x1352thenb()
} else {
x1352elseb()
}
}
val x1353 = x1094(x1211)
val x1354 = x1353 - x1261
val x1355 = Math.abs(x1354)
val x1356 = x1355 > 1.0E-4
val x1455 = {
def x1455thenb(): Unit = {
val x1267 = x1106(x1264)
val x1357 = x1265 * x1259
val x1358 = x1261 - x1353
val x1359 = x1357 * x1358
val x1360 = x1267 + x1359
val x1361 = x1094(x1264) = x1360
val x1376 = x1094(x1264)
val x1396 = x1094(x1211)
val x1434 = x1376 > 0.0
val x1435 = x1376 < 1.0
val x1436 = x1434 && x1435
val x1439 = {
def x1439thenb(): Unit = {
val x1362 = x1257 - x1165
val x1375 = x1320 * x1265
val x1377 = x1376 - x1267
val x1378 = x1375 * x1377
val x1379 = x1362 - x1378
val x1395 = x1305 * x1259
val x1397 = x1396 - x1261
val x1398 = x1395 * x1397
val x1399 = x1379 - x1398
x1090 = x1399
()
}
def x1439elseb(): Unit = {
()
}
if (x1436) {
x1439thenb()
} else {
x1439elseb()
}
}
val x1440 = x1396 > 0.0
val x1441 = x1396 < 1.0
val x1442 = x1440 && x1441
val x1445 = {
def x1445thenb(): Unit = {
val x1400 = x1257 - x1260
val x1377 = x1376 - x1267
val x1416 = x1305 * x1265
val x1417 = x1416 * x1377
val x1418 = x1400 - x1417
val x1397 = x1396 - x1261
val x1431 = x1335 * x1259
val x1432 = x1431 * x1397
val x1433 = x1418 - x1432
x1090 = x1433
()
}
def x1445elseb(): Unit = {
()
}
if (x1442) {
x1445thenb()
} else {
x1445elseb()
}
}
val x1446 = x1090
val x1447 = x1446==x1446
val x1452 = {
def x1452thenb(): Unit = {
val x1362 = x1257 - x1165
val x1375 = x1320 * x1265
val x1377 = x1376 - x1267
val x1378 = x1375 * x1377
val x1379 = x1362 - x1378
val x1395 = x1305 * x1259
val x1397 = x1396 - x1261
val x1398 = x1395 * x1397
val x1399 = x1379 - x1398
val x1400 = x1257 - x1260
val x1416 = x1305 * x1265
val x1417 = x1416 * x1377
val x1418 = x1400 - x1417
val x1431 = x1335 * x1259
val x1432 = x1431 * x1397
val x1433 = x1418 - x1432
val x1448 = x1399 + x1433
val x1449 = x1448 / 2.0
x1090 = x1449
()
}
def x1452elseb(): Unit = {
()
}
if (x1447) {
x1452thenb()
} else {
x1452elseb()
}
}
val x1453 = x1101 += 1
()
}
def x1455elseb(): Unit = {
()
}
if (x1356) {
x1455thenb()
} else {
x1455elseb()
}
}
x1455
}
def x1457elseb(): Unit = {
()
}
if (x1337) {
x1457thenb()
} else {
x1457elseb()
}
}
x1457
}
def x1459elseb(): Unit = {
()
}
if (x1286) {
x1459thenb()
} else {
x1459elseb()
}
}
x1459
}
def x1461elseb(): Unit = {
()
}
if (x1182) {
x1461thenb()
} else {
x1461elseb()
}
}
val x1462 = x1102 += 1
()
}
val x1465 = x1101
val x1466 = x1465==0
val x1471 = {
def x1471thenb(): Unit = {
val x1467 = x1096 += 1
()
}
def x1471elseb(): Unit = {
x1096 = 0
()
}
if (x1466) {
x1471thenb()
} else {
x1471elseb()
}
}
x1471
}
var x1474: Int = 0
val x1512 = while ({val x1475 = x1474
val x1476 = x1475 < x1091
x1476}) {
val x1478 = x1089
val x1479 = x1474
val x1481 = x1474
val x1482 = x1094(x1481)
val x1492 = x1474
val x1500 = x1478.length
val x1501 = x1478.isRow
val x1493 = x1073(x1492)
val x1486 = x1479 * x1085
val x1499 = {
val x1495 = new generated.scala.DoubleVectorImpl(x1085,true)
x1495
}
var x1483 = 0
while (x1483 < x1085) {  // begin fat loop x1499
val x1487 = x1486 + x1483
val x1488 = x934.dcApply(x1487)
val x1489 = { 
x1488
}
val x1490 = x1489 * x1482
val x1592 = x1490 * x1493
x1499.dcUpdate(x1483, x1592)
x1483 += 1
} // end fat loop x1499
val x1508 = {
val x1503 = new generated.scala.DoubleVectorImpl(x1500,x1501)
x1503
}
var x1502 = 0
while (x1502 < x1500) {  // begin fat loop x1508
val x1505 = x1478(x1502)
val x1506 = x1499(x1502)
val x1507 = x1505 + x1506
x1508.dcUpdate(x1502, x1507)
x1502 += 1
} // end fat loop x1508
x1089 = x1508
val x1510 = x1474 += 1
()
}
val x1513 = print("\n")
val x1514 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
val x1515 = x1072.numRows
val x1516 = new generated.scala.IndexVectorRangeImpl(0,x1515)
val x1527 = x1072.numCols
val x1544 = x1516.length
val x1545 = x1516.isRow
def x1548_block = {
val x1546 = new generated.scala.IntVectorImpl(x1544,x1545)
var mapIdx = 0
while (mapIdx < x1516.size) { // begin map loop x1548
val x1517 = x1516.dcApply(mapIdx)
x1546.dcUpdate(mapIdx,  {
val x1518 = x1089
val x1519 = x1090
val x1521 = x1518.length
val x1528 = x1517 * x1527
var x1539: Double = 0
var x1523 = 0
while (x1523 < x1521) {  // begin fat loop x1539
val x1526 = x1518(x1523)
val x1529 = x1528 + x1523
val x1530 = x1072.dcApply(x1529)
val x1531 = { 
x1530
}
val x1532 = x1526 * x1531
val x1535 = x1539
val x1536 = x1532
val x1538 = x1535 + x1536
x1539 = x1538
x1523 += 1
} // end fat loop x1539
val x1540 = x1539 + x1519
val x1541 = x1540 < 0.0
val x1542 = {
def x1542thenb(): Int = {
-1
}
def x1542elseb(): Int = {
1
}
if (x1541) {
x1542thenb()
} else {
x1542elseb()
}
}
x1542
})
mapIdx += 1
} // end map loop x1548
x1546
}
val x1548 = x1548_block
val x1549 = println("SVM testing finished. Calculating error..")
val x1555 = new generated.scala.RangeVectorImpl(0,x1515,1,true)
def x1559_block = {
val x1550 = x1555.dcApply(0)
var x1556 = {
val x1551 = x1078(x1550)
val x1552 = x1548(x1550)
val x1553 = x1551 != x1552
val x1554 = {
def x1554thenb(): Int = {
1
}
def x1554elseb(): Int = {
0
}
if (x1553) {
x1554thenb()
} else {
x1554elseb()
}
}
x1554
}
var mapReduceIdx = 1
while (mapReduceIdx < x1555.size) { // begin mapReduce loop x1559
val x1550 = x1555.dcApply(mapReduceIdx)
val x1557 = {
val x1551 = x1078(x1550)
val x1552 = x1548(x1550)
val x1553 = x1551 != x1552
val x1554 = {
def x1554thenb(): Int = {
1
}
def x1554elseb(): Int = {
0
}
if (x1553) {
x1554thenb()
} else {
x1554elseb()
}
}
x1554
}
x1556 = {
val x1558 = x1556 + x1557
x1558
}
mapReduceIdx += 1
} // end mapReduce loop x1559
x1556
}
val x1559 = x1559_block
val x1560 = x1559.doubleValue()
val x1561 = x1515.doubleValue()
val x1562 = x1560 / x1561
val x1563 = "Classification error: "+x1562
val x1564 = println(x1563)
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
