/*****************************************
  Emitting Generated Code                  
*******************************************/
class SVMRunnerFusing extends ((Array[java.lang.String])=>(Unit)) {
def apply(x831:Array[java.lang.String]): Unit = {
val x832 = x831.length
val x833 = x832 < 1
val x837 = {
def x837thenb(): Nothing = {
val x834 = println("Usage: SVM <train data file> <test data file> <model filename> <num tests>")
val x835 = exit(-1)
x835
}
if (x833) {
x837thenb()
}
}
val x843 = { generated.scala.Global.randRef.setSeed(generated.scala.Global.INITIAL_SEED);   generated.scala.Global.intRandRef.setSeed(generated.scala.Global.INITIAL_SEED); }
val x838 = x831(0)
val x960 = { 
val x844 = new java.io.FileReader(x838)
val x845 = new java.io.BufferedReader(x844)
val x846 = x845.readLine()
var x847: java.lang.String = x846
val x848 = x845.readLine()
var x849: java.lang.String = x848
val x850 = x849
val x851 = x850.trim()
val x852 = x851.split("\\s+")
val x853 = x852(0)
val x854 = java.lang.Integer.parseInt(x853)
val x857 = x854 < 0
val x855 = x852(1)
val x856 = java.lang.Integer.parseInt(x855)
val x858 = x856 < 0
val x859 = x857 || x858
val x862 = {
def x862thenb(): Nothing = {
val x860 = error("Illegal input to readTokenMatrix")
x860
}
if (x859) {
x862thenb()
}
}
val x863 = x845.readLine()
val x864 = new generated.scala.DoubleVectorImpl(0,true)
val x865 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x867 : Int = 0
val x904 = while (x867 < x854) {
val x868 = x845.readLine()
x849 = x868
val x870 = x849
val x871 = x870.trim()
x849 = x871
val x873 = x849
val x875 = new generated.scala.DoubleVectorImpl(x856,true)
var x876: Int = 0
var x877: Int = 1
val x874 = x873.split("\\s+")
val x879 = x874.length
val x880 = x879 - 1
val x895 = while ({val x878 = x877
val x881 = x878 < x880
x881}) {
val x883 = x877
val x884 = x874(x883)
val x885 = java.lang.Integer.parseInt(x884)
val x886 = x876 += x885
val x887 = x876
val x888 = x877
val x889 = x888 + 1
val x890 = x874(x889)
val x891 = java.lang.Double.parseDouble(x890)
val x892 = x875(x887) = x891
val x893 = x877 += 2
()
}
val x898 = x864.length
val x896 = x874(0)
val x897 = java.lang.Double.parseDouble(x896)
val x899 = x864.insert(x898, x897)
val x900 = x875// unsafe immutable
val x901 = x865.length
val x902 = x865.insert(x901, x900)
x902
x867 = x867 + 1
}
val x906 = x864.length
// a *thin* loop follows: x914
var x905 = 0
val x912 = x864.dcApply(x905)
val x914 = {
val x907 = x864.length
val x908 = x864.isRow
val x909 = !x908
val x910 = new generated.scala.DoubleVectorImpl(x907,x909)
x910
}
x914.dcUpdate(x905, x912)
x905 = 1
while (x905 < x906) {  // begin fat loop x914
val x912 = x864.dcApply(x905)
x914.dcUpdate(x905, x912)
x905 += 1
} // end fat loop x914
val x953 = { 
val x915 = x865.length
val x916 = x915==0
val x951 = {
def x951thenb(): generated.scala.Matrix[Double] = {
val x917 = new generated.scala.DoubleMatrixImpl(0,0)
val x918 = x917// unsafe immutable
x918
}
def x951elseb(): generated.scala.Matrix[Double] = {
val x920 = x865(0)
val x921 = x920.isRow
val x949 = {
def x949thenb(): generated.scala.Matrix[Double] = {
val x922 = x920.length
val x923 = new generated.scala.DoubleMatrixImpl(x915,x922)
var x925 : Int = 0
val x934 = while (x925 < x915) {
var x927 : Int = 0
val x932 = while (x927 < x922) {
val x928 = x865(x925)
val x929 = x928(x927)
val x930 = x923(x925, x927) = x929
x930
x927 = x927 + 1
}
x932
x925 = x925 + 1
}
val x935 = x923// unsafe immutable
x935
}
def x949elseb(): generated.scala.Matrix[Double] = {
val x922 = x920.length
val x937 = new generated.scala.DoubleMatrixImpl(x922,x915)
var x938 : Int = 0
val x946 = while (x938 < x915) {
var x939 : Int = 0
val x944 = while (x939 < x922) {
val x940 = x865(x938)
val x941 = x940(x939)
val x942 = x937(x939, x938) = x941
x942
x939 = x939 + 1
}
x944
x938 = x938 + 1
}
val x947 = x937// unsafe immutable
x947
}
if (x921) {
x949thenb()
} else { 
x949elseb()
}
}
x949
}
if (x916) {
x951thenb()
} else { 
x951elseb()
}
}
x951
}
val x954 = x845.close()
val x955 = x953// unsafe immutable
val x956 = x914// unsafe immutable
val x957 = new generated.scala.DoubleLabelsImpl(x956)
val x958 = new generated.scala.DoubleDoubleTrainingSetImpl(x955,x957)
x958
}
val x839 = x831(1)
val x1077 = { 
val x961 = new java.io.FileReader(x839)
val x962 = new java.io.BufferedReader(x961)
val x963 = x962.readLine()
var x964: java.lang.String = x963
val x965 = x962.readLine()
var x966: java.lang.String = x965
val x967 = x966
val x968 = x967.trim()
val x969 = x968.split("\\s+")
val x970 = x969(0)
val x971 = java.lang.Integer.parseInt(x970)
val x974 = x971 < 0
val x972 = x969(1)
val x973 = java.lang.Integer.parseInt(x972)
val x975 = x973 < 0
val x976 = x974 || x975
val x979 = {
def x979thenb(): Nothing = {
val x977 = error("Illegal input to readTokenMatrix")
x977
}
if (x976) {
x979thenb()
}
}
val x980 = x962.readLine()
val x981 = new generated.scala.DoubleVectorImpl(0,true)
val x982 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x984 : Int = 0
val x1021 = while (x984 < x971) {
val x985 = x962.readLine()
x966 = x985
val x987 = x966
val x988 = x987.trim()
x966 = x988
val x990 = x966
val x992 = new generated.scala.DoubleVectorImpl(x973,true)
var x993: Int = 0
var x994: Int = 1
val x991 = x990.split("\\s+")
val x996 = x991.length
val x997 = x996 - 1
val x1012 = while ({val x995 = x994
val x998 = x995 < x997
x998}) {
val x1000 = x994
val x1001 = x991(x1000)
val x1002 = java.lang.Integer.parseInt(x1001)
val x1003 = x993 += x1002
val x1004 = x993
val x1005 = x994
val x1006 = x1005 + 1
val x1007 = x991(x1006)
val x1008 = java.lang.Double.parseDouble(x1007)
val x1009 = x992(x1004) = x1008
val x1010 = x994 += 2
()
}
val x1015 = x981.length
val x1013 = x991(0)
val x1014 = java.lang.Double.parseDouble(x1013)
val x1016 = x981.insert(x1015, x1014)
val x1017 = x992// unsafe immutable
val x1018 = x982.length
val x1019 = x982.insert(x1018, x1017)
x1019
x984 = x984 + 1
}
val x1023 = x981.length
// a *thin* loop follows: x1031
var x1022 = 0
val x1029 = x981.dcApply(x1022)
val x1031 = {
val x1024 = x981.length
val x1025 = x981.isRow
val x1026 = !x1025
val x1027 = new generated.scala.DoubleVectorImpl(x1024,x1026)
x1027
}
x1031.dcUpdate(x1022, x1029)
x1022 = 1
while (x1022 < x1023) {  // begin fat loop x1031
val x1029 = x981.dcApply(x1022)
x1031.dcUpdate(x1022, x1029)
x1022 += 1
} // end fat loop x1031
val x1070 = { 
val x1032 = x982.length
val x1033 = x1032==0
val x1068 = {
def x1068thenb(): generated.scala.Matrix[Double] = {
val x1034 = new generated.scala.DoubleMatrixImpl(0,0)
val x1035 = x1034// unsafe immutable
x1035
}
def x1068elseb(): generated.scala.Matrix[Double] = {
val x1037 = x982(0)
val x1038 = x1037.isRow
val x1066 = {
def x1066thenb(): generated.scala.Matrix[Double] = {
val x1039 = x1037.length
val x1040 = new generated.scala.DoubleMatrixImpl(x1032,x1039)
var x1042 : Int = 0
val x1051 = while (x1042 < x1032) {
var x1044 : Int = 0
val x1049 = while (x1044 < x1039) {
val x1045 = x982(x1042)
val x1046 = x1045(x1044)
val x1047 = x1040(x1042, x1044) = x1046
x1047
x1044 = x1044 + 1
}
x1049
x1042 = x1042 + 1
}
val x1052 = x1040// unsafe immutable
x1052
}
def x1066elseb(): generated.scala.Matrix[Double] = {
val x1039 = x1037.length
val x1054 = new generated.scala.DoubleMatrixImpl(x1039,x1032)
var x1055 : Int = 0
val x1063 = while (x1055 < x1032) {
var x1056 : Int = 0
val x1061 = while (x1056 < x1039) {
val x1057 = x982(x1055)
val x1058 = x1057(x1056)
val x1059 = x1054(x1056, x1055) = x1058
x1059
x1056 = x1056 + 1
}
x1061
x1055 = x1055 + 1
}
val x1064 = x1054// unsafe immutable
x1064
}
if (x1038) {
x1066thenb()
} else { 
x1066elseb()
}
}
x1066
}
if (x1033) {
x1068thenb()
} else { 
x1068elseb()
}
}
x1068
}
val x1071 = x962.close()
val x1072 = x1070// unsafe immutable
val x1073 = x1031// unsafe immutable
val x1074 = new generated.scala.DoubleLabelsImpl(x1073)
val x1075 = new generated.scala.DoubleDoubleTrainingSetImpl(x1072,x1074)
x1075
}
val x247 = Seq()
val x1078 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
val x1079 = println("Training SVM using the SMO algorithm")
val x1080 = x960.labels
val x1082 = x1080.length
val x1083 = x1080.isRow
// a *thin* loop follows: x1089
var x1081 = 0
val x1086 = x1080.dcApply(x1081)
val x1087 = x1086==0
val x1088 = {
def x1088thenb(): Double = {
-1.0
}
def x1088elseb(): Double = {
1.0
}
if (x1087) {
x1088thenb()
} else { 
x1088elseb()
}
}
val x1089 = {
val x1084 = new generated.scala.DoubleVectorImpl(x1082,x1083)
x1084
}
x1089.dcUpdate(x1081, x1088)
x1081 = 1
while (x1081 < x1082) {  // begin fat loop x1089
val x1086 = x1080.dcApply(x1081)
val x1087 = x1086==0
val x1088 = {
def x1088thenb(): Double = {
-1.0
}
def x1088elseb(): Double = {
1.0
}
if (x1087) {
x1088thenb()
} else { 
x1088elseb()
}
}
x1089.dcUpdate(x1081, x1088)
x1081 += 1
} // end fat loop x1089
val x1090 = x960.numCols
val x1094 = { 
val x1091 = new generated.scala.DoubleVectorImpl(x1090,true)
x1091
}
var x1095: Double = 0.0
val x1096 = x960.numRows
val x1100 = { 
val x1097 = new generated.scala.DoubleVectorImpl(x1096,true)
x1097
}
val x1101 = x1100.mtrans
var x1102: Int = 0
var x1103: Int = 0
val x296 = !true
val x810 = List()
val x1134 = new generated.scala.IndexVectorRangeImpl(0,x1096)
val x1137 = x1134.length
val x1180 = x1096 - 1
val x1181 = x1180
val x1513 = while ({val x1104 = x1102
val x1105 = x1104 < 10
x1105}) {
val x1107 = print(".")
val x1108 = x1103 += 1
var x1109: Int = 0
var x1110: Int = 0
val x1504 = while ({val x1111 = x1110
val x1112 = x1111 < x1096
x1112}) {
val x1114 = x1100.cloneL
val x1116 = x1114.isRow
// a *thin* loop follows: x1122
var x1115 = 0
val x1119 = x1114.dcApply(x1115)
val x1120 = x1089.dcApply(x1115)
val x1121 = x1119 * x1120
val x1122 = {
val x1117 = new generated.scala.DoubleVectorImpl(x1096,x1116)
x1117
}
x1122.dcUpdate(x1115, x1121)
x1115 = 1
while (x1115 < x1096) {  // begin fat loop x1122
val x1119 = x1114.dcApply(x1115)
val x1120 = x1089.dcApply(x1115)
val x1121 = x1119 * x1120
x1122.dcUpdate(x1115, x1121)
x1115 += 1
} // end fat loop x1122
val x1123 = x1110
val x1128 = x1123 * x1090
// a *thin* loop follows: x1132
var x1125 = 0
val x1129 = x1128 + x1125
val x1130 = x960.dcApply(x1129)
val x1131 = { 
x1130
}
val x1132 = {
val x1126 = new generated.scala.DoubleVectorImpl(x1090,x296)
x1126
}
x1132.dcUpdate(x1125, x1131)
x1125 = 1
while (x1125 < x1090) {  // begin fat loop x1132
val x1129 = x1128 + x1125
val x1130 = x960.dcApply(x1129)
val x1131 = { 
x1130
}
x1132.dcUpdate(x1125, x1131)
x1125 += 1
} // end fat loop x1132
val x1143 = x1122.isRow
val x1141 = { 
val x1133 = new generated.scala.DoubleVectorImpl(x1096,false)
// a *thin* loop follows: x1138
var x1135 = 0
var x1138: Unit = {
val x1619 = x1134.dcApply(x1135)
val x1624 = x1619 * x1090
// a *thin* loop follows: x1630
var x1621 = 0
val x1625 = x1624 + x1621
val x1626 = x960.dcApply(x1625)
val x1627 = { 
x1626
}
val x1628 = x1132.dcApply(x1621)
val x1629 = x1627 * x1628
val x1630 = {
val x1622 = new generated.scala.DoubleVectorImpl(x1090,true)
x1622
}
x1630.dcUpdate(x1621, x1629)
x1621 = 1
while (x1621 < x1090) {  // begin fat loop x1630
val x1625 = x1624 + x1621
val x1626 = x960.dcApply(x1625)
val x1627 = { 
x1626
}
val x1628 = x1132.dcApply(x1621)
val x1629 = x1627 * x1628
x1630.dcUpdate(x1621, x1629)
x1621 += 1
} // end fat loop x1630
var x1631 = 0
val x1634 = x1630.dcApply(x1631)
var x1636: Double = {
if (x1090 == 0) {0.0}
else {
val x1634 = x1630.dcApply(x1631)
x1634
}
}
x1631 = 1
while (x1631 < x1090) {  // begin fat loop x1636
val x1634 = x1630.dcApply(x1631)
val x1632 = x1636
val x1633 = x1634
val x1635 = x1632 + x1633
x1636 = x1635
x1631 += 1
} // end fat loop x1636
val x1637 = x1133(x1619) = x1636
x1637
}
x1135 = 1
while (x1135 < x1137) {  // begin fat loop x1138
x1138 = {
val x1619 = x1134.dcApply(x1135)
val x1624 = x1619 * x1090
// a *thin* loop follows: x1630
var x1621 = 0
val x1625 = x1624 + x1621
val x1626 = x960.dcApply(x1625)
val x1627 = { 
x1626
}
val x1628 = x1132.dcApply(x1621)
val x1629 = x1627 * x1628
val x1630 = {
val x1622 = new generated.scala.DoubleVectorImpl(x1090,true)
x1622
}
x1630.dcUpdate(x1621, x1629)
x1621 = 1
while (x1621 < x1090) {  // begin fat loop x1630
val x1625 = x1624 + x1621
val x1626 = x960.dcApply(x1625)
val x1627 = { 
x1626
}
val x1628 = x1132.dcApply(x1621)
val x1629 = x1627 * x1628
x1630.dcUpdate(x1621, x1629)
x1621 += 1
} // end fat loop x1630
var x1631 = 0
val x1634 = x1630.dcApply(x1631)
var x1636: Double = {
if (x1090 == 0) {0.0}
else {
val x1634 = x1630.dcApply(x1631)
x1634
}
}
x1631 = 1
while (x1631 < x1090) {  // begin fat loop x1636
val x1634 = x1630.dcApply(x1631)
val x1632 = x1636
val x1633 = x1634
val x1635 = x1632 + x1633
x1636 = x1635
x1631 += 1
} // end fat loop x1636
val x1637 = x1133(x1619) = x1636
x1637
}
x1135 += 1
} // end fat loop x1138
val x1139 = x1133// unsafe immutable
x1139
}
// a *thin* loop follows: x1149
var x1142 = 0
val x1146 = x1122.dcApply(x1142)
val x1147 = x1141.dcApply(x1142)
val x1148 = x1146 * x1147
val x1149 = {
val x1144 = new generated.scala.DoubleVectorImpl(x1096,x1143)
x1144
}
x1149.dcUpdate(x1142, x1148)
x1142 = 1
while (x1142 < x1096) {  // begin fat loop x1149
val x1146 = x1122.dcApply(x1142)
val x1147 = x1141.dcApply(x1142)
val x1148 = x1146 * x1147
x1149.dcUpdate(x1142, x1148)
x1142 += 1
} // end fat loop x1149
val x1156 = x1095
val x1158 = x1110
val x1161 = x1110
val x1165 = x1110
val x1169 = x1110
val x1173 = x1110
var x1150 = 0
val x1153 = x1149.dcApply(x1150)
var x1155: Double = {
if (x1096 == 0) {0.0}
else {
val x1153 = x1149.dcApply(x1150)
x1153
}
}
x1150 = 1
while (x1150 < x1096) {  // begin fat loop x1155
val x1153 = x1149.dcApply(x1150)
val x1151 = x1155
val x1152 = x1153
val x1154 = x1151 + x1152
x1155 = x1154
x1150 += 1
} // end fat loop x1155
val x1157 = x1155 + x1156
val x1159 = x1089(x1158)
val x1160 = x1157 - x1159
val x1162 = x1089(x1161)
val x1163 = x1162 * x1160
val x1164 = x1163 < -0.0010
val x1166 = x1114(x1165)
val x1167 = x1166 < 1.0
val x1168 = x1164 && x1167
val x1170 = x1089(x1169)
val x1171 = x1170 * x1160
val x1172 = x1171 > 0.0010
val x1174 = x1114(x1173)
val x1175 = x1174 > 0.0
val x1176 = x1172 && x1175
val x1177 = x1168 || x1176
val x1501 = {
def x1501thenb(): Unit = {
val x1178 = generated.scala.Global.randRef.nextDouble()
val x1179 = x1178.asInstanceOf[Double]
val x1182 = x1179 * x1181
val x1183 = Math.floor(x1182)
val x1184 = x1183.asInstanceOf[Int]
val x1185 = x1184 + 1
var x1186: Int = x1185
val x1199 = while ({val x1187 = x1186
val x1188 = x1110
val x1189 = x1187==x1188
x1189}) {
val x1191 = generated.scala.Global.randRef.nextDouble()
val x1192 = x1191.asInstanceOf[Double]
val x1193 = x1192 * x1181
val x1194 = Math.floor(x1193)
val x1195 = x1194.asInstanceOf[Int]
val x1196 = x1195 + 1
x1186 = x1196
()
}
// a *thin* loop follows: x1206
var x1200 = 0
val x1203 = x1114.dcApply(x1200)
val x1204 = x1089.dcApply(x1200)
val x1205 = x1203 * x1204
val x1206 = {
val x1201 = new generated.scala.DoubleVectorImpl(x1096,x1116)
x1201
}
x1206.dcUpdate(x1200, x1205)
x1200 = 1
while (x1200 < x1096) {  // begin fat loop x1206
val x1203 = x1114.dcApply(x1200)
val x1204 = x1089.dcApply(x1200)
val x1205 = x1203 * x1204
x1206.dcUpdate(x1200, x1205)
x1200 += 1
} // end fat loop x1206
val x1207 = x1186
val x1212 = x1207 * x1090
// a *thin* loop follows: x1216
var x1209 = 0
val x1213 = x1212 + x1209
val x1214 = x960.dcApply(x1213)
val x1215 = { 
x1214
}
val x1216 = {
val x1210 = new generated.scala.DoubleVectorImpl(x1090,x296)
x1210
}
x1216.dcUpdate(x1209, x1215)
x1209 = 1
while (x1209 < x1090) {  // begin fat loop x1216
val x1213 = x1212 + x1209
val x1214 = x960.dcApply(x1213)
val x1215 = { 
x1214
}
x1216.dcUpdate(x1209, x1215)
x1209 += 1
} // end fat loop x1216
val x1225 = x1206.isRow
val x1223 = { 
val x1217 = new generated.scala.DoubleVectorImpl(x1096,false)
// a *thin* loop follows: x1220
var x1218 = 0
var x1220: Unit = {
val x1639 = x1134.dcApply(x1218)
val x1644 = x1639 * x1090
// a *thin* loop follows: x1650
var x1641 = 0
val x1645 = x1644 + x1641
val x1646 = x960.dcApply(x1645)
val x1647 = { 
x1646
}
val x1648 = x1216.dcApply(x1641)
val x1649 = x1647 * x1648
val x1650 = {
val x1642 = new generated.scala.DoubleVectorImpl(x1090,true)
x1642
}
x1650.dcUpdate(x1641, x1649)
x1641 = 1
while (x1641 < x1090) {  // begin fat loop x1650
val x1645 = x1644 + x1641
val x1646 = x960.dcApply(x1645)
val x1647 = { 
x1646
}
val x1648 = x1216.dcApply(x1641)
val x1649 = x1647 * x1648
x1650.dcUpdate(x1641, x1649)
x1641 += 1
} // end fat loop x1650
var x1651 = 0
val x1654 = x1650.dcApply(x1651)
var x1656: Double = {
if (x1090 == 0) {0.0}
else {
val x1654 = x1650.dcApply(x1651)
x1654
}
}
x1651 = 1
while (x1651 < x1090) {  // begin fat loop x1656
val x1654 = x1650.dcApply(x1651)
val x1652 = x1656
val x1653 = x1654
val x1655 = x1652 + x1653
x1656 = x1655
x1651 += 1
} // end fat loop x1656
val x1657 = x1217(x1639) = x1656
x1657
}
x1218 = 1
while (x1218 < x1137) {  // begin fat loop x1220
x1220 = {
val x1639 = x1134.dcApply(x1218)
val x1644 = x1639 * x1090
// a *thin* loop follows: x1650
var x1641 = 0
val x1645 = x1644 + x1641
val x1646 = x960.dcApply(x1645)
val x1647 = { 
x1646
}
val x1648 = x1216.dcApply(x1641)
val x1649 = x1647 * x1648
val x1650 = {
val x1642 = new generated.scala.DoubleVectorImpl(x1090,true)
x1642
}
x1650.dcUpdate(x1641, x1649)
x1641 = 1
while (x1641 < x1090) {  // begin fat loop x1650
val x1645 = x1644 + x1641
val x1646 = x960.dcApply(x1645)
val x1647 = { 
x1646
}
val x1648 = x1216.dcApply(x1641)
val x1649 = x1647 * x1648
x1650.dcUpdate(x1641, x1649)
x1641 += 1
} // end fat loop x1650
var x1651 = 0
val x1654 = x1650.dcApply(x1651)
var x1656: Double = {
if (x1090 == 0) {0.0}
else {
val x1654 = x1650.dcApply(x1651)
x1654
}
}
x1651 = 1
while (x1651 < x1090) {  // begin fat loop x1656
val x1654 = x1650.dcApply(x1651)
val x1652 = x1656
val x1653 = x1654
val x1655 = x1652 + x1653
x1656 = x1655
x1651 += 1
} // end fat loop x1656
val x1657 = x1217(x1639) = x1656
x1657
}
x1218 += 1
} // end fat loop x1220
val x1221 = x1217// unsafe immutable
x1221
}
// a *thin* loop follows: x1231
var x1224 = 0
val x1228 = x1206.dcApply(x1224)
val x1229 = x1223.dcApply(x1224)
val x1230 = x1228 * x1229
val x1231 = {
val x1226 = new generated.scala.DoubleVectorImpl(x1096,x1225)
x1226
}
x1231.dcUpdate(x1224, x1230)
x1224 = 1
while (x1224 < x1096) {  // begin fat loop x1231
val x1228 = x1206.dcApply(x1224)
val x1229 = x1223.dcApply(x1224)
val x1230 = x1228 * x1229
x1231.dcUpdate(x1224, x1230)
x1224 += 1
} // end fat loop x1231
var x1242: Double = 0.0
var x1243: Double = 0.0
val x1244 = x1110
val x1239 = x1089(x1207)
val x1245 = x1089(x1244)
val x1246 = x1245 != x1239
val x1271 = {
def x1271thenb(): Unit = {
val x1247 = x1110
val x1241 = x1114(x1207)
val x1248 = x1114(x1247)
val x1249 = x1241 - x1248
val x1250 = Math.max(0.0, x1249)
x1242 = x1250
val x1253 = x1110
val x1252 = 1.0 + x1241
val x1254 = x1114(x1253)
val x1255 = x1252 - x1254
val x1256 = Math.min(1.0, x1255)
x1243 = x1256
()
}
def x1271elseb(): Unit = {
val x1259 = x1110
val x1241 = x1114(x1207)
val x1260 = x1114(x1259)
val x1261 = x1260 + x1241
val x1262 = x1261 - 1.0
val x1263 = Math.max(0.0, x1262)
x1242 = x1263
val x1265 = x1110
val x1266 = x1114(x1265)
val x1267 = x1266 + x1241
val x1268 = Math.min(1.0, x1267)
x1243 = x1268
()
}
if (x1246) {
x1271thenb()
} else { 
x1271elseb()
}
}
val x1272 = x1242
val x1273 = x1243
val x1274 = x1272 != x1273
val x1499 = {
def x1499thenb(): Unit = {
val x1275 = x1110
val x1280 = x1275 * x1090
// a *thin* loop follows: x1288
var x1277 = 0
val x1281 = x1280 + x1277
val x1282 = x960.dcApply(x1281)
val x1283 = { 
x1282
}
val x1284 = x1212 + x1277
val x1285 = x960.dcApply(x1284)
val x1286 = { 
x1285
}
val x1287 = x1283 * x1286
val x1288 = {
val x1278 = new generated.scala.DoubleVectorImpl(x1090,true)
x1278
}
x1288.dcUpdate(x1277, x1287)
x1277 = 1
while (x1277 < x1090) {  // begin fat loop x1288
val x1281 = x1280 + x1277
val x1282 = x960.dcApply(x1281)
val x1283 = { 
x1282
}
val x1284 = x1212 + x1277
val x1285 = x960.dcApply(x1284)
val x1286 = { 
x1285
}
val x1287 = x1283 * x1286
x1288.dcUpdate(x1277, x1287)
x1277 += 1
} // end fat loop x1288
val x1296 = x1110
val x1298 = x1110
val x1303 = x1296 * x1090
val x1307 = x1298 * x1090
// a *thin* loop follows: x1312
var x1300 = 0
val x1304 = x1303 + x1300
val x1305 = x960.dcApply(x1304)
val x1306 = { 
x1305
}
val x1308 = x1307 + x1300
val x1309 = x960.dcApply(x1308)
val x1310 = { 
x1309
}
val x1311 = x1306 * x1310
val x1312 = {
val x1301 = new generated.scala.DoubleVectorImpl(x1090,true)
x1301
}
x1312.dcUpdate(x1300, x1311)
x1300 = 1
while (x1300 < x1090) {  // begin fat loop x1312
val x1304 = x1303 + x1300
val x1305 = x960.dcApply(x1304)
val x1306 = { 
x1305
}
val x1308 = x1307 + x1300
val x1309 = x960.dcApply(x1308)
val x1310 = { 
x1309
}
val x1311 = x1306 * x1310
x1312.dcUpdate(x1300, x1311)
x1300 += 1
} // end fat loop x1312
// a *thin* loop follows: x1327
var x1320 = 0
val x1323 = x1212 + x1320
val x1324 = x960.dcApply(x1323)
val x1325 = { 
x1324
}
val x1326 = x1325 * x1325
val x1327 = {
val x1321 = new generated.scala.DoubleVectorImpl(x1090,true)
x1321
}
x1327.dcUpdate(x1320, x1326)
x1320 = 1
while (x1320 < x1090) {  // begin fat loop x1327
val x1323 = x1212 + x1320
val x1324 = x960.dcApply(x1323)
val x1325 = { 
x1324
}
val x1326 = x1325 * x1325
x1327.dcUpdate(x1320, x1326)
x1320 += 1
} // end fat loop x1327
var x1289 = 0
val x1292 = x1288.dcApply(x1289)
val x1659 = x1312.dcApply(x1289)
val x1665 = x1327.dcApply(x1289)
var x1294: Double = {
if (x1090 == 0) {0.0}
else {
val x1292 = x1288.dcApply(x1289)
x1292
}
}
var x1318: Double = {
if (x1090 == 0) {0.0}
else {
val x1659 = x1312.dcApply(x1289)
x1659
}
}
var x1333: Double = {
if (x1090 == 0) {0.0}
else {
val x1665 = x1327.dcApply(x1289)
x1665
}
}
x1289 = 1
while (x1289 < x1090) {  // begin fat loop x1294,x1318,x1333
val x1292 = x1288.dcApply(x1289)
val x1659 = x1312.dcApply(x1289)
val x1665 = x1327.dcApply(x1289)
val x1290 = x1294
val x1291 = x1292
val x1293 = x1290 + x1291
x1294 = x1293
val x1314 = x1318
val x1315 = x1659
val x1317 = x1314 + x1315
x1318 = x1317
val x1329 = x1333
val x1330 = x1665
val x1332 = x1329 + x1330
x1333 = x1332
x1289 += 1
} // end fat loop x1294,x1318,x1333
val x1295 = x1294 * 2.0
val x1319 = x1295 - x1318
val x1334 = x1319 - x1333
val x1335 = x1334 < 0.0
val x1497 = {
def x1497thenb(): Unit = {
val x1241 = x1114(x1207)
var x1232 = 0
val x1235 = x1231.dcApply(x1232)
var x1237: Double = {
if (x1096 == 0) {0.0}
else {
val x1235 = x1231.dcApply(x1232)
x1235
}
}
x1232 = 1
while (x1232 < x1096) {  // begin fat loop x1237
val x1235 = x1231.dcApply(x1232)
val x1233 = x1237
val x1234 = x1235
val x1236 = x1233 + x1234
x1237 = x1236
x1232 += 1
} // end fat loop x1237
val x1238 = x1237 + x1156
val x1240 = x1238 - x1239
val x1336 = x1160 - x1240
val x1337 = x1239 * x1336
val x1338 = x1337 / x1334
val x1339 = x1241 - x1338
val x1340 = x1100(x1207) = x1339
val x1341 = x1100(x1207)
val x1342 = x1341 > x1273
val x1350 = {
def x1350thenb(): Unit = {
val x1343 = x1100(x1207) = x1273
x1343
}
def x1350elseb(): Unit = {
val x1345 = x1341 < x1272
val x1348 = {
def x1348thenb(): Unit = {
val x1346 = x1100(x1207) = x1272
x1346
}
if (x1345) {
x1348thenb()
}
}
x1348
}
if (x1342) {
x1350thenb()
} else { 
x1350elseb()
}
}
val x1351 = x1100(x1207)
val x1352 = x1351 - x1241
val x1353 = Math.abs(x1352)
val x1354 = x1353 > 1.0E-5
val x1495 = {
def x1495thenb(): Unit = {
val x1355 = x1110
val x1357 = x1110
val x1358 = x1110
val x1360 = x1110
val x1359 = x1114(x1358)
val x1361 = x1089(x1360)
val x1362 = x1361 * x1239
val x1363 = x1241 - x1351
val x1364 = x1362 * x1363
val x1365 = x1359 + x1364
val x1366 = x1100(x1357) = x1365
val x1368 = x1110
val x1370 = x1110
val x1375 = x1368 * x1090
val x1379 = x1370 * x1090
// a *thin* loop follows: x1384
var x1372 = 0
val x1376 = x1375 + x1372
val x1377 = x960.dcApply(x1376)
val x1378 = { 
x1377
}
val x1380 = x1379 + x1372
val x1381 = x960.dcApply(x1380)
val x1382 = { 
x1381
}
val x1383 = x1378 * x1382
val x1384 = {
val x1373 = new generated.scala.DoubleVectorImpl(x1090,true)
x1373
}
x1384.dcUpdate(x1372, x1383)
x1372 = 1
while (x1372 < x1090) {  // begin fat loop x1384
val x1376 = x1375 + x1372
val x1377 = x960.dcApply(x1376)
val x1378 = { 
x1377
}
val x1380 = x1379 + x1372
val x1381 = x960.dcApply(x1380)
val x1382 = { 
x1381
}
val x1383 = x1378 * x1382
x1384.dcUpdate(x1372, x1383)
x1372 += 1
} // end fat loop x1384
val x1391 = x1110
val x1394 = x1110
val x1395 = x1100(x1394)
val x1399 = x1110
val x1404 = x1399 * x1090
// a *thin* loop follows: x1412
var x1401 = 0
val x1405 = x1404 + x1401
val x1406 = x960.dcApply(x1405)
val x1407 = { 
x1406
}
val x1408 = x1212 + x1401
val x1409 = x960.dcApply(x1408)
val x1410 = { 
x1409
}
val x1411 = x1407 * x1410
val x1412 = {
val x1402 = new generated.scala.DoubleVectorImpl(x1090,true)
x1402
}
x1412.dcUpdate(x1401, x1411)
x1401 = 1
while (x1401 < x1090) {  // begin fat loop x1412
val x1405 = x1404 + x1401
val x1406 = x960.dcApply(x1405)
val x1407 = { 
x1406
}
val x1408 = x1212 + x1401
val x1409 = x960.dcApply(x1408)
val x1410 = { 
x1409
}
val x1411 = x1407 * x1410
x1412.dcUpdate(x1401, x1411)
x1401 += 1
} // end fat loop x1412
val x1420 = x1100(x1207)
val x1425 = x1110
val x1430 = x1425 * x1090
// a *thin* loop follows: x1438
var x1427 = 0
val x1431 = x1430 + x1427
val x1432 = x960.dcApply(x1431)
val x1433 = { 
x1432
}
val x1434 = x1212 + x1427
val x1435 = x960.dcApply(x1434)
val x1436 = { 
x1435
}
val x1437 = x1433 * x1436
val x1438 = {
val x1428 = new generated.scala.DoubleVectorImpl(x1090,true)
x1428
}
x1438.dcUpdate(x1427, x1437)
x1427 = 1
while (x1427 < x1090) {  // begin fat loop x1438
val x1431 = x1430 + x1427
val x1432 = x960.dcApply(x1431)
val x1433 = { 
x1432
}
val x1434 = x1212 + x1427
val x1435 = x960.dcApply(x1434)
val x1436 = { 
x1435
}
val x1437 = x1433 * x1436
x1438.dcUpdate(x1427, x1437)
x1427 += 1
} // end fat loop x1438
val x1445 = x1110
val x1448 = x1110
val x1449 = x1100(x1448)
// a *thin* loop follows: x1460
var x1453 = 0
val x1456 = x1212 + x1453
val x1457 = x960.dcApply(x1456)
val x1458 = { 
x1457
}
val x1459 = x1458 * x1458
val x1460 = {
val x1454 = new generated.scala.DoubleVectorImpl(x1090,true)
x1454
}
x1460.dcUpdate(x1453, x1459)
x1453 = 1
while (x1453 < x1090) {  // begin fat loop x1460
val x1456 = x1212 + x1453
val x1457 = x960.dcApply(x1456)
val x1458 = { 
x1457
}
val x1459 = x1458 * x1458
x1460.dcUpdate(x1453, x1459)
x1453 += 1
} // end fat loop x1460
val x1470 = x1110
val x1471 = x1100(x1470)
val x1473 = x1110
val x1474 = x1100(x1473)
val x1472 = x1471 > 0.0
val x1475 = x1474 < 1.0
val x1476 = x1472 && x1475
val x1479 = {
def x1479thenb(): Unit = {
val x1367 = x1156 - x1160
val x1392 = x1089(x1391)
var x1385 = 0
val x1388 = x1384.dcApply(x1385)
val x1691 = x1412.dcApply(x1385)
var x1390: Double = {
if (x1090 == 0) {0.0}
else {
val x1388 = x1384.dcApply(x1385)
x1388
}
}
var x1418: Double = {
if (x1090 == 0) {0.0}
else {
val x1691 = x1412.dcApply(x1385)
x1691
}
}
x1385 = 1
while (x1385 < x1090) {  // begin fat loop x1390,x1418
val x1388 = x1384.dcApply(x1385)
val x1691 = x1412.dcApply(x1385)
val x1386 = x1390
val x1387 = x1388
val x1389 = x1386 + x1387
x1390 = x1389
val x1414 = x1418
val x1415 = x1691
val x1417 = x1414 + x1415
x1418 = x1417
x1385 += 1
} // end fat loop x1390,x1418
val x1393 = x1390 * x1392
val x1356 = x1114(x1355)
val x1396 = x1395 - x1356
val x1397 = x1393 * x1396
val x1398 = x1367 - x1397
val x1419 = x1418 * x1239
val x1421 = x1420 - x1241
val x1422 = x1419 * x1421
val x1423 = x1398 - x1422
x1095 = x1423
()
}
if (x1476) {
x1479thenb()
}
}
val x1480 = x1420 > 0.0
val x1481 = x1420 < 1.0
val x1482 = x1480 && x1481
val x1485 = {
def x1485thenb(): Unit = {
val x1424 = x1156 - x1240
val x1446 = x1089(x1445)
var x1439 = 0
val x1442 = x1438.dcApply(x1439)
val x1707 = x1460.dcApply(x1439)
var x1444: Double = {
if (x1090 == 0) {0.0}
else {
val x1442 = x1438.dcApply(x1439)
x1442
}
}
var x1466: Double = {
if (x1090 == 0) {0.0}
else {
val x1707 = x1460.dcApply(x1439)
x1707
}
}
x1439 = 1
while (x1439 < x1090) {  // begin fat loop x1444,x1466
val x1442 = x1438.dcApply(x1439)
val x1707 = x1460.dcApply(x1439)
val x1440 = x1444
val x1441 = x1442
val x1443 = x1440 + x1441
x1444 = x1443
val x1462 = x1466
val x1463 = x1707
val x1465 = x1462 + x1463
x1466 = x1465
x1439 += 1
} // end fat loop x1444,x1466
val x1447 = x1444 * x1446
val x1356 = x1114(x1355)
val x1450 = x1449 - x1356
val x1451 = x1447 * x1450
val x1452 = x1424 - x1451
val x1421 = x1420 - x1241
val x1467 = x1466 * x1239
val x1468 = x1467 * x1421
val x1469 = x1452 - x1468
x1095 = x1469
()
}
if (x1482) {
x1485thenb()
}
}
val x1486 = x1095
val x1487 = x1486==x1486
val x1492 = {
def x1492thenb(): Unit = {
val x1367 = x1156 - x1160
val x1392 = x1089(x1391)
var x1385 = 0
val x1388 = x1384.dcApply(x1385)
val x1691 = x1412.dcApply(x1385)
val x1728 = x1438.dcApply(x1385)
val x1734 = x1460.dcApply(x1385)
var x1390: Double = {
if (x1090 == 0) {0.0}
else {
val x1388 = x1384.dcApply(x1385)
x1388
}
}
var x1418: Double = {
if (x1090 == 0) {0.0}
else {
val x1691 = x1412.dcApply(x1385)
x1691
}
}
var x1444: Double = {
if (x1090 == 0) {0.0}
else {
val x1728 = x1438.dcApply(x1385)
x1728
}
}
var x1466: Double = {
if (x1090 == 0) {0.0}
else {
val x1734 = x1460.dcApply(x1385)
x1734
}
}
x1385 = 1
while (x1385 < x1090) {  // begin fat loop x1390,x1418,x1444,x1466
val x1388 = x1384.dcApply(x1385)
val x1691 = x1412.dcApply(x1385)
val x1728 = x1438.dcApply(x1385)
val x1734 = x1460.dcApply(x1385)
val x1386 = x1390
val x1387 = x1388
val x1389 = x1386 + x1387
x1390 = x1389
val x1414 = x1418
val x1415 = x1691
val x1417 = x1414 + x1415
x1418 = x1417
val x1440 = x1444
val x1441 = x1728
val x1443 = x1440 + x1441
x1444 = x1443
val x1462 = x1466
val x1463 = x1734
val x1465 = x1462 + x1463
x1466 = x1465
x1385 += 1
} // end fat loop x1390,x1418,x1444,x1466
val x1393 = x1390 * x1392
val x1356 = x1114(x1355)
val x1396 = x1395 - x1356
val x1397 = x1393 * x1396
val x1398 = x1367 - x1397
val x1419 = x1418 * x1239
val x1421 = x1420 - x1241
val x1422 = x1419 * x1421
val x1423 = x1398 - x1422
val x1424 = x1156 - x1240
val x1446 = x1089(x1445)
val x1447 = x1444 * x1446
val x1450 = x1449 - x1356
val x1451 = x1447 * x1450
val x1452 = x1424 - x1451
val x1467 = x1466 * x1239
val x1468 = x1467 * x1421
val x1469 = x1452 - x1468
val x1488 = x1423 + x1469
val x1489 = x1488 / 2.0
x1095 = x1489
()
}
if (x1487) {
x1492thenb()
}
}
val x1493 = x1109 += 1
()
}
if (x1354) {
x1495thenb()
}
}
x1495
}
if (x1335) {
x1497thenb()
}
}
x1497
}
if (x1274) {
x1499thenb()
}
}
x1499
}
if (x1177) {
x1501thenb()
}
}
val x1502 = x1110 += 1
()
}
val x1505 = x1109
val x1506 = x1505==0
val x1511 = {
def x1511thenb(): Unit = {
val x1507 = x1102 += 1
()
}
def x1511elseb(): Unit = {
x1102 = 0
()
}
if (x1506) {
x1511thenb()
} else { 
x1511elseb()
}
}
x1511
}
val x1514 = x1103
val x1515 = "ITER "+x1514
val x1516 = println(x1515)
val x1517 = "num iterations: "+x1514
val x1518 = println(x1517)
var x1519: Int = 0
val x1553 = while ({val x1520 = x1519
val x1521 = x1520 < x1096
x1521}) {
val x1523 = x1519
val x1525 = x1519
val x1526 = x1100(x1525)
val x1530 = x1523 * x1090
// a *thin* loop follows: x1535
var x1527 = 0
val x1531 = x1530 + x1527
val x1532 = x960.dcApply(x1531)
val x1533 = { 
x1532
}
val x1534 = x1533 * x1526
val x1535 = {
val x1528 = new generated.scala.DoubleVectorImpl(x1090,true)
x1528
}
x1535.dcUpdate(x1527, x1534)
x1527 = 1
while (x1527 < x1090) {  // begin fat loop x1535
val x1531 = x1530 + x1527
val x1532 = x960.dcApply(x1531)
val x1533 = { 
x1532
}
val x1534 = x1533 * x1526
x1535.dcUpdate(x1527, x1534)
x1527 += 1
} // end fat loop x1535
val x1536 = x1519
val x1539 = x1535.isRow
val x1537 = x1089(x1536)
// a *thin* loop follows: x1544
var x1538 = 0
val x1542 = x1535.dcApply(x1538)
val x1543 = x1542 * x1537
val x1544 = {
val x1540 = new generated.scala.DoubleVectorImpl(x1090,x1539)
x1540
}
x1544.dcUpdate(x1538, x1543)
x1538 = 1
while (x1538 < x1090) {  // begin fat loop x1544
val x1542 = x1535.dcApply(x1538)
val x1543 = x1542 * x1537
x1544.dcUpdate(x1538, x1543)
x1538 += 1
} // end fat loop x1544
// a *thin* loop follows: x1550
var x1545 = 0
val x1546 = x1094.dcApply(x1545)
val x1547 = x1544.dcApply(x1545)
val x1548 = x1546 + x1547
val x1550 = {
x1094
}
x1550.dcUpdate(x1545, x1548)
x1545 = 1
while (x1545 < x1090) {  // begin fat loop x1550
val x1546 = x1094.dcApply(x1545)
val x1547 = x1544.dcApply(x1545)
val x1548 = x1546 + x1547
x1550.dcUpdate(x1545, x1548)
x1545 += 1
} // end fat loop x1550
val x1551 = x1519 += 1
()
}
val x1554 = print("\n")
val x1555 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
val x1556 = x1077.labels
val x1558 = x1556.length
val x1559 = x1556.isRow
// a *thin* loop follows: x1565
var x1557 = 0
val x1562 = x1556.dcApply(x1557)
val x1563 = x1562==0
val x1564 = {
def x1564thenb(): Double = {
-1.0
}
def x1564elseb(): Double = {
1.0
}
if (x1563) {
x1564thenb()
} else { 
x1564elseb()
}
}
val x1565 = {
val x1560 = new generated.scala.DoubleVectorImpl(x1558,x1559)
x1560
}
x1565.dcUpdate(x1557, x1564)
x1557 = 1
while (x1557 < x1558) {  // begin fat loop x1565
val x1562 = x1556.dcApply(x1557)
val x1563 = x1562==0
val x1564 = {
def x1564thenb(): Double = {
-1.0
}
def x1564elseb(): Double = {
1.0
}
if (x1563) {
x1564thenb()
} else { 
x1564elseb()
}
}
x1565.dcUpdate(x1557, x1564)
x1557 += 1
} // end fat loop x1565
val x1566 = x1077.numRows
val x1567 = new generated.scala.IndexVectorRangeImpl(0,x1566)
val x1569 = x1567.length
val x1570 = x1567.isRow
val x1581 = x1077.numCols
// a *thin* loop follows: x1600
var x1568 = 0
val x1574 = x1095
val x1573 = x1567.dcApply(x1568)
val x1582 = x1573 * x1581
// a *thin* loop follows: x1588
var x1576 = 0
val x1580 = x1094.dcApply(x1576)
val x1583 = x1582 + x1576
val x1584 = x1077.dcApply(x1583)
val x1585 = { 
x1584
}
val x1586 = x1580 * x1585
val x1588 = {
val x1577 = x1094.isRow
val x1578 = new generated.scala.DoubleVectorImpl(x1090,x1577)
x1578
}
x1588.dcUpdate(x1576, x1586)
x1576 = 1
while (x1576 < x1090) {  // begin fat loop x1588
val x1580 = x1094.dcApply(x1576)
val x1583 = x1582 + x1576
val x1584 = x1077.dcApply(x1583)
val x1585 = { 
x1584
}
val x1586 = x1580 * x1585
x1588.dcUpdate(x1576, x1586)
x1576 += 1
} // end fat loop x1588
var x1589 = 0
val x1592 = x1588.dcApply(x1589)
var x1595: Double = {
if (x1090 == 0) {0.0}
else {
val x1592 = x1588.dcApply(x1589)
x1592
}
}
x1589 = 1
while (x1589 < x1090) {  // begin fat loop x1595
val x1592 = x1588.dcApply(x1589)
val x1590 = x1595
val x1591 = x1592
val x1594 = x1590 + x1591
x1595 = x1594
x1589 += 1
} // end fat loop x1595
val x1596 = x1595 + x1574
val x1597 = x1596 < 0.0
val x1598 = {
def x1598thenb(): Int = {
-1
}
def x1598elseb(): Int = {
1
}
if (x1597) {
x1598thenb()
} else { 
x1598elseb()
}
}
val x1600 = {
val x1571 = new generated.scala.IntVectorImpl(x1569,x1570)
x1571
}
x1600.dcUpdate(x1568, x1598)
x1568 = 1
while (x1568 < x1569) {  // begin fat loop x1600
val x1574 = x1095
val x1573 = x1567.dcApply(x1568)
val x1582 = x1573 * x1581
// a *thin* loop follows: x1588
var x1576 = 0
val x1580 = x1094.dcApply(x1576)
val x1583 = x1582 + x1576
val x1584 = x1077.dcApply(x1583)
val x1585 = { 
x1584
}
val x1586 = x1580 * x1585
val x1588 = {
val x1577 = x1094.isRow
val x1578 = new generated.scala.DoubleVectorImpl(x1090,x1577)
x1578
}
x1588.dcUpdate(x1576, x1586)
x1576 = 1
while (x1576 < x1090) {  // begin fat loop x1588
val x1580 = x1094.dcApply(x1576)
val x1583 = x1582 + x1576
val x1584 = x1077.dcApply(x1583)
val x1585 = { 
x1584
}
val x1586 = x1580 * x1585
x1588.dcUpdate(x1576, x1586)
x1576 += 1
} // end fat loop x1588
var x1589 = 0
val x1592 = x1588.dcApply(x1589)
var x1595: Double = {
if (x1090 == 0) {0.0}
else {
val x1592 = x1588.dcApply(x1589)
x1592
}
}
x1589 = 1
while (x1589 < x1090) {  // begin fat loop x1595
val x1592 = x1588.dcApply(x1589)
val x1590 = x1595
val x1591 = x1592
val x1594 = x1590 + x1591
x1595 = x1594
x1589 += 1
} // end fat loop x1595
val x1596 = x1595 + x1574
val x1597 = x1596 < 0.0
val x1598 = {
def x1598thenb(): Int = {
-1
}
def x1598elseb(): Int = {
1
}
if (x1597) {
x1598thenb()
} else { 
x1598elseb()
}
}
x1600.dcUpdate(x1568, x1598)
x1568 += 1
} // end fat loop x1600
val x1601 = println("SVM testing finished. Calculating error..")
val x1605 = x1566 - 0
var x1602 = 0
val x1606 = x1567.dcApply(x1602)
val x1607 = x1565(x1606)
val x1608 = x1600(x1606)
val x1609 = x1607 != x1608
val x1610 = {
def x1610thenb(): Int = {
1
}
def x1610elseb(): Int = {
0
}
if (x1609) {
x1610thenb()
} else { 
x1610elseb()
}
}
var x1612: Int = {
if (x1605 == 0) {0}
else {
val x1606 = x1567.dcApply(x1602)
val x1607 = x1565(x1606)
val x1608 = x1600(x1606)
val x1609 = x1607 != x1608
val x1610 = {
def x1610thenb(): Int = {
1
}
def x1610elseb(): Int = {
0
}
if (x1609) {
x1610thenb()
} else { 
x1610elseb()
}
}
x1610
}
}
x1602 = 1
while (x1602 < x1605) {  // begin fat loop x1612
val x1606 = x1567.dcApply(x1602)
val x1607 = x1565(x1606)
val x1608 = x1600(x1606)
val x1609 = x1607 != x1608
val x1610 = {
def x1610thenb(): Int = {
1
}
def x1610elseb(): Int = {
0
}
if (x1609) {
x1610thenb()
} else { 
x1610elseb()
}
}
val x1603 = x1612
val x1604 = x1610
val x1611 = x1603 + x1604
x1612 = x1611
x1602 += 1
} // end fat loop x1612
val x1613 = x1612.doubleValue()
val x1614 = x1566.doubleValue()
val x1615 = x1613 / x1614
val x1616 = "Classification error: "+x1615
val x1617 = println(x1616)
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
