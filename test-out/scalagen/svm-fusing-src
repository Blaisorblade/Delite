/*****************************************
  Emitting Generated Code                  
*******************************************/
class SVMRunnerFusing extends ((Array[java.lang.String])=>(Unit)) {
def apply(x738:Array[java.lang.String]): Unit = {
val x739 = x738.length
val x740 = x739 < 1
val x744 = {
def x744thenb(): Nothing = {
val x741 = println("Usage: SVM <train data file> <test data file> <model filename> <num tests>")
val x742 = exit(-1)
x742
}
if (x740) {
x744thenb()
}
}
val x750 = { generated.scala.Global.randRef.setSeed(generated.scala.Global.INITIAL_SEED);   generated.scala.Global.intRandRef.setSeed(generated.scala.Global.INITIAL_SEED); }
val x745 = x738(0)
val x869 = { 
val x751 = new java.io.FileReader(x745)
val x752 = new java.io.BufferedReader(x751)
var x753: java.io.BufferedReader = x752
val x754 = x753
val x755 = x754.readLine()
var x756: java.lang.String = x755
val x757 = x753
val x758 = x757.readLine()
var x759: java.lang.String = x758
val x760 = x759
val x761 = x760.trim()
val x762 = x761.split("\\s+")
val x763 = x762(0)
val x764 = java.lang.Integer.parseInt(x763)
val x767 = x764 < 0
val x765 = x762(1)
val x766 = java.lang.Integer.parseInt(x765)
val x768 = x766 < 0
val x769 = x767 || x768
val x772 = {
def x772thenb(): Nothing = {
val x770 = error("Illegal input to readTokenMatrix")
x770
}
if (x769) {
x772thenb()
}
}
val x773 = x753
val x774 = x773.readLine()
val x775 = new generated.scala.DoubleVectorImpl(0,true)
val x776 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x778 : Int = 0
val x813 = while (x778 < x764) {
val x779 = x753
val x780 = x779.readLine()
x759 = x780
val x782 = x759
val x783 = x782.trim()
x759 = x783
val x785 = x759
val x787 = new generated.scala.DoubleVectorImpl(x766,true)
var x788: Int = 0
var x789: Int = 1
val x790 = x789
val x786 = x785.split("\\s+")
val x791 = x786.length
val x792 = x791 - 1
val x793 = x790 < x792
val x794 = x786(x790)
val x795 = java.lang.Integer.parseInt(x794)
val x797 = x788
val x798 = x790 + 1
val x799 = x786(x798)
val x800 = java.lang.Double.parseDouble(x799)
val x804 = while ({x793}) {
val x796 = x788 += x795
val x801 = x787(x797) = x800
val x802 = x789 += 2
()
}
val x807 = x775.length
val x805 = x786(0)
val x806 = java.lang.Double.parseDouble(x805)
val x808 = x775.insert(x807, x806)
val x809 = x787// unsafe immutable
val x810 = x776.length
val x811 = x776.insert(x810, x809)
x811
x778 = x778 + 1
}
val x814 = x775.length
val x815 = x775.isRow
val x816 = !x815
// a *thin* loop follows: x822
val x822 = {
val x818 = new generated.scala.DoubleVectorImpl(x814,x816)
x818
}
var x817 = 0
while (x817 < x814) {  // begin fat loop x822
val x820 = x775(x817)
x822.dcUpdate(x817, x820)
x817 += 1
} // end fat loop x822
val x861 = { 
val x823 = x776.length
val x824 = x823==0
val x859 = {
def x859thenb(): generated.scala.Matrix[Double] = {
val x825 = new generated.scala.DoubleMatrixImpl(0,0)
val x826 = x825// unsafe immutable
x826
}
def x859elseb(): generated.scala.Matrix[Double] = {
val x828 = x776(0)
val x829 = x828.isRow
val x830 = x828.length
val x857 = {
def x857thenb(): generated.scala.Matrix[Double] = {
val x831 = new generated.scala.DoubleMatrixImpl(x823,x830)
var x833 : Int = 0
val x842 = while (x833 < x823) {
var x835 : Int = 0
val x840 = while (x835 < x830) {
val x836 = x776(x833)
val x837 = x836(x835)
val x838 = x831(x833, x835) = x837
x838
x835 = x835 + 1
}
x840
x833 = x833 + 1
}
val x843 = x831// unsafe immutable
x843
}
def x857elseb(): generated.scala.Matrix[Double] = {
val x845 = new generated.scala.DoubleMatrixImpl(x830,x823)
var x846 : Int = 0
val x854 = while (x846 < x823) {
var x847 : Int = 0
val x852 = while (x847 < x830) {
val x848 = x776(x846)
val x849 = x848(x847)
val x850 = x845(x847, x846) = x849
x850
x847 = x847 + 1
}
x852
x846 = x846 + 1
}
val x855 = x845// unsafe immutable
x855
}
if (x829) {
x857thenb()
} else { 
x857elseb()
}
}
x857
}
if (x824) {
x859thenb()
} else { 
x859elseb()
}
}
x859
}
val x862 = x753
val x863 = x862.close()
val x864 = x861// unsafe immutable
val x865 = x822// unsafe immutable
val x866 = new generated.scala.DoubleLabelsImpl(x865)
val x867 = new generated.scala.DoubleDoubleTrainingSetImpl(x864,x866)
x867
}
val x746 = x738(1)
val x988 = { 
val x870 = new java.io.FileReader(x746)
val x871 = new java.io.BufferedReader(x870)
var x872: java.io.BufferedReader = x871
val x873 = x872
val x874 = x873.readLine()
var x875: java.lang.String = x874
val x876 = x872
val x877 = x876.readLine()
var x878: java.lang.String = x877
val x879 = x878
val x880 = x879.trim()
val x881 = x880.split("\\s+")
val x882 = x881(0)
val x883 = java.lang.Integer.parseInt(x882)
val x886 = x883 < 0
val x884 = x881(1)
val x885 = java.lang.Integer.parseInt(x884)
val x887 = x885 < 0
val x888 = x886 || x887
val x891 = {
def x891thenb(): Nothing = {
val x889 = error("Illegal input to readTokenMatrix")
x889
}
if (x888) {
x891thenb()
}
}
val x892 = x872
val x893 = x892.readLine()
val x894 = new generated.scala.DoubleVectorImpl(0,true)
val x895 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x897 : Int = 0
val x932 = while (x897 < x883) {
val x898 = x872
val x899 = x898.readLine()
x878 = x899
val x901 = x878
val x902 = x901.trim()
x878 = x902
val x904 = x878
val x906 = new generated.scala.DoubleVectorImpl(x885,true)
var x907: Int = 0
var x908: Int = 1
val x909 = x908
val x905 = x904.split("\\s+")
val x910 = x905.length
val x911 = x910 - 1
val x912 = x909 < x911
val x913 = x905(x909)
val x914 = java.lang.Integer.parseInt(x913)
val x916 = x907
val x917 = x909 + 1
val x918 = x905(x917)
val x919 = java.lang.Double.parseDouble(x918)
val x923 = while ({x912}) {
val x915 = x907 += x914
val x920 = x906(x916) = x919
val x921 = x908 += 2
()
}
val x926 = x894.length
val x924 = x905(0)
val x925 = java.lang.Double.parseDouble(x924)
val x927 = x894.insert(x926, x925)
val x928 = x906// unsafe immutable
val x929 = x895.length
val x930 = x895.insert(x929, x928)
x930
x897 = x897 + 1
}
val x933 = x894.length
val x934 = x894.isRow
val x935 = !x934
// a *thin* loop follows: x941
val x941 = {
val x937 = new generated.scala.DoubleVectorImpl(x933,x935)
x937
}
var x936 = 0
while (x936 < x933) {  // begin fat loop x941
val x939 = x894(x936)
x941.dcUpdate(x936, x939)
x936 += 1
} // end fat loop x941
val x980 = { 
val x942 = x895.length
val x943 = x942==0
val x978 = {
def x978thenb(): generated.scala.Matrix[Double] = {
val x944 = new generated.scala.DoubleMatrixImpl(0,0)
val x945 = x944// unsafe immutable
x945
}
def x978elseb(): generated.scala.Matrix[Double] = {
val x947 = x895(0)
val x948 = x947.isRow
val x949 = x947.length
val x976 = {
def x976thenb(): generated.scala.Matrix[Double] = {
val x950 = new generated.scala.DoubleMatrixImpl(x942,x949)
var x952 : Int = 0
val x961 = while (x952 < x942) {
var x954 : Int = 0
val x959 = while (x954 < x949) {
val x955 = x895(x952)
val x956 = x955(x954)
val x957 = x950(x952, x954) = x956
x957
x954 = x954 + 1
}
x959
x952 = x952 + 1
}
val x962 = x950// unsafe immutable
x962
}
def x976elseb(): generated.scala.Matrix[Double] = {
val x964 = new generated.scala.DoubleMatrixImpl(x949,x942)
var x965 : Int = 0
val x973 = while (x965 < x942) {
var x966 : Int = 0
val x971 = while (x966 < x949) {
val x967 = x895(x965)
val x968 = x967(x966)
val x969 = x964(x966, x965) = x968
x969
x966 = x966 + 1
}
x971
x965 = x965 + 1
}
val x974 = x964// unsafe immutable
x974
}
if (x948) {
x976thenb()
} else { 
x976elseb()
}
}
x976
}
if (x943) {
x978thenb()
} else { 
x978elseb()
}
}
x978
}
val x981 = x872
val x982 = x981.close()
val x983 = x980// unsafe immutable
val x984 = x941// unsafe immutable
val x985 = new generated.scala.DoubleLabelsImpl(x984)
val x986 = new generated.scala.DoubleDoubleTrainingSetImpl(x983,x985)
x986
}
val x251 = Seq()
val x989 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
val x990 = println("Training SVM using the SMO algorithm")
val x1000 = x869.numCols
val x1004 = { 
val x1001 = new generated.scala.DoubleVectorImpl(x1000,true)
x1001
}
var x1005: Double = 0.0
val x1006 = x869.numRows
val x1010 = { 
val x1007 = new generated.scala.DoubleVectorImpl(x1006,true)
x1007
}
val x1011 = x1010.mtrans
var x1012: Int = 0
var x1013: Int = 0
val x1014 = x1012
val x1015 = x1014 < 10
val x991 = x869.labels
val x995 = x991.length
val x996 = x991.isRow
def x999_block = {
val x997 = new generated.scala.DoubleVectorImpl(x995,x996)
var mapIdx = 0
while (mapIdx < x991.size) { // begin map loop x999
val x992 = x991.dcApply(mapIdx)
x997.dcUpdate(mapIdx,  {
val x993 = x992==0
val x994 = {
def x994thenb(): Double = {
-1.0
}
def x994elseb(): Double = {
1.0
}
if (x993) {
x994thenb()
} else { 
x994elseb()
}
}
x994
})
mapIdx += 1
} // end map loop x999
x997
}
val x999 = x999_block
val x295 = !true
val x329 = List()
val x1041 = new generated.scala.IndexVectorRangeImpl(0,x1006)
val x1082 = x1005
val x1097 = x1006 - 1
val x1098 = x1097
val x1354 = x1082==x1082
val x1380 = while ({x1015}) {
val x1016 = print(".")
val x1017 = x1013 += 1
var x1018: Int = 0
var x1019: Int = 0
val x1020 = x1019
val x1021 = x1020 < x1006
val x1084 = x999(x1020)
val x1035 = x1020 * x1000
val x1039 = {
val x1033 = new generated.scala.DoubleVectorImpl(x1000,x295)
x1033
}
var x1228: Double = 0
var x1032 = 0
while (x1032 < x1000) {  // begin fat loop x1039,x1228
val x1036 = x1035 + x1032
val x1037 = x869.dcApply(x1036)
val x1038 = { 
x1037
}
val x1473 = x1038 * x1038
x1039.dcUpdate(x1032, x1038)
val x1224 = x1228
val x1225 = x1473
val x1227 = x1224 + x1225
x1228 = x1227
x1032 += 1
} // end fat loop x1039,x1228
val x1283 = x1228 * x1084
val x1371 = while ({x1021}) {
val x1022 = x1010.cloneL
val x1068 = { 
val x1040 = new generated.scala.DoubleVectorImpl(x1006,false)
val x1065 = {
var forIdx = 0
while (forIdx < x1041.size) { // begin foreach loop x1065
val x1042 = x1041.dcApply(forIdx)
val x1047 = x1042 * x1000
var x1061: Double = 0
var x1044 = 0
while (x1044 < x1000) {  // begin fat loop x1061
val x1048 = x1047 + x1044
val x1049 = x869.dcApply(x1048)
val x1050 = { 
x1049
}
val x1051 = x1035 + x1044
val x1052 = x869.dcApply(x1051)
val x1053 = { 
x1052
}
val x1054 = x1050 * x1053
val x1057 = x1061
val x1058 = x1054
val x1060 = x1057 + x1058
x1061 = x1060
x1044 += 1
} // end fat loop x1061
val x1062 = x1040(x1042) = x1061
x1062
forIdx += 1
} // end foreach loop x1065
}
val x1066 = x1040// unsafe immutable
x1066
}
val x1023 = x1022.isRow
var x1081: Double = 0
val x1030 = {
val x1025 = new generated.scala.DoubleVectorImpl(x1006,x1023)
x1025
}
var x1076 = 0
while (x1076 < x1006) {  // begin fat loop x1081,x1030
val x1476 = x1022(x1076)
val x1477 = x999(x1076)
val x1478 = x1476 * x1477
val x1479 = x1068(x1076)
val x1480 = x1478 * x1479
val x1077 = x1081
val x1078 = x1480
val x1080 = x1077 + x1078
x1081 = x1080
x1030.dcUpdate(x1076, x1478)
x1076 += 1
} // end fat loop x1081,x1030
val x1083 = x1081 + x1082
val x1085 = x1083 - x1084
val x1086 = x1084 * x1085
val x1087 = x1086 < -0.0010
val x1088 = x1022(x1020)
val x1089 = x1088 < 1.0
val x1090 = x1087 && x1089
val x1091 = x1086 > 0.0010
val x1092 = x1088 > 0.0
val x1093 = x1091 && x1092
val x1094 = x1090 || x1093
val x1270 = x1082 - x1085
val x1368 = {
def x1368thenb(): Unit = {
val x1095 = generated.scala.Global.randRef.nextDouble()
val x1096 = x1095.asInstanceOf[Double]
val x1099 = x1096 * x1098
val x1100 = Math.floor(x1099)
val x1101 = x1100.asInstanceOf[Int]
val x1102 = x1101 + 1
var x1103: Int = x1102
val x1104 = x1103
val x1105 = x1104==x1020
val x1114 = while ({x1105}) {
val x1106 = generated.scala.Global.randRef.nextDouble()
val x1107 = x1106.asInstanceOf[Double]
val x1108 = x1107 * x1098
val x1109 = Math.floor(x1108)
val x1110 = x1109.asInstanceOf[Int]
val x1111 = x1110 + 1
x1103 = x1111
()
}
var x1175: Double = 0.0
var x1176: Double = 0.0
val x1172 = x999(x1104)
val x1177 = x1084 != x1172
val x1174 = x1022(x1104)
val x1178 = x1174 - x1088
val x1179 = Math.max(0.0, x1178)
val x1181 = 1.0 + x1174
val x1182 = x1181 - x1088
val x1183 = Math.min(1.0, x1182)
val x1186 = x1088 + x1174
val x1187 = x1186 - 1.0
val x1188 = Math.max(0.0, x1187)
val x1190 = Math.min(1.0, x1186)
val x1193 = {
def x1193thenb(): Unit = {
x1175 = x1179
x1176 = x1183
()
}
def x1193elseb(): Unit = {
x1175 = x1188
x1176 = x1190
()
}
if (x1177) {
x1193thenb()
} else { 
x1193elseb()
}
}
val x1194 = x1175
val x1195 = x1176
val x1196 = x1194 != x1195
val x1125 = x1104 * x1000
var x1213: Double = 0
var x1243: Double = 0
val x1129 = {
val x1123 = new generated.scala.DoubleVectorImpl(x1000,x295)
x1123
}
var x1197 = 0
while (x1197 < x1000) {  // begin fat loop x1213,x1243,x1129
val x1203 = x1125 + x1197
val x1204 = x869.dcApply(x1203)
val x1205 = { 
x1204
}
val x1200 = x1035 + x1197
val x1201 = x869.dcApply(x1200)
val x1202 = { 
x1201
}
val x1206 = x1202 * x1205
val x1481 = x1205 * x1205
val x1209 = x1213
val x1210 = x1206
val x1212 = x1209 + x1210
x1213 = x1212
val x1239 = x1243
val x1240 = x1481
val x1242 = x1239 + x1240
x1243 = x1242
x1129.dcUpdate(x1197, x1205)
x1197 += 1
} // end fat loop x1213,x1243,x1129
val x1214 = x1213 * 2.0
val x1229 = x1214 - x1228
val x1244 = x1229 - x1243
val x1245 = x1244 < 0.0
val x1157 = { 
val x1130 = new generated.scala.DoubleVectorImpl(x1006,false)
val x1154 = {
var forIdx = 0
while (forIdx < x1041.size) { // begin foreach loop x1154
val x1131 = x1041.dcApply(forIdx)
val x1136 = x1131 * x1000
var x1150: Double = 0
var x1133 = 0
while (x1133 < x1000) {  // begin fat loop x1150
val x1137 = x1136 + x1133
val x1138 = x869.dcApply(x1137)
val x1139 = { 
x1138
}
val x1140 = x1125 + x1133
val x1141 = x869.dcApply(x1140)
val x1142 = { 
x1141
}
val x1143 = x1139 * x1142
val x1146 = x1150
val x1147 = x1143
val x1149 = x1146 + x1147
x1150 = x1149
x1133 += 1
} // end fat loop x1150
val x1151 = x1130(x1131) = x1150
x1151
forIdx += 1
} // end foreach loop x1154
}
val x1155 = x1130// unsafe immutable
x1155
}
var x1170: Double = 0
var x1158 = 0
while (x1158 < x1006) {  // begin fat loop x1170
val x1161 = x1030(x1158)
val x1162 = x1157(x1158)
val x1163 = x1161 * x1162
val x1166 = x1170
val x1167 = x1163
val x1169 = x1166 + x1167
x1170 = x1169
x1158 += 1
} // end fat loop x1170
val x1171 = x1170 + x1082
val x1173 = x1171 - x1172
val x1246 = x1085 - x1173
val x1247 = x1172 * x1246
val x1248 = x1247 / x1244
val x1249 = x1174 - x1248
val x1265 = x1084 * x1172
val x1303 = x1213 * x1172
val x1308 = x1082 - x1173
val x1324 = x1213 * x1084
val x1339 = x1243 * x1172
val x1366 = {
def x1366thenb(): Unit = {
val x1364 = {
def x1364thenb(): Unit = {
val x1250 = x1010(x1104) = x1249
val x1251 = x1010(x1104)
val x1252 = x1251 > x1195
val x1255 = x1251 < x1194
val x1260 = {
def x1260thenb(): Unit = {
val x1253 = x1010(x1104) = x1195
x1253
}
def x1260elseb(): Unit = {
val x1258 = {
def x1258thenb(): Unit = {
val x1256 = x1010(x1104) = x1194
x1256
}
if (x1255) {
x1258thenb()
}
}
x1258
}
if (x1252) {
x1260thenb()
} else { 
x1260elseb()
}
}
val x1261 = x1010(x1104)
val x1262 = x1261 - x1174
val x1263 = Math.abs(x1262)
val x1264 = x1263 > 1.0E-5
val x1266 = x1174 - x1261
val x1267 = x1265 * x1266
val x1268 = x1088 + x1267
val x1362 = {
def x1362thenb(): Unit = {
val x1269 = x1010(x1020) = x1268
val x1284 = x1010(x1020)
val x1304 = x1010(x1104)
val x1342 = x1284 > 0.0
val x1343 = x1284 < 1.0
val x1344 = x1342 && x1343
val x1285 = x1284 - x1088
val x1286 = x1283 * x1285
val x1287 = x1270 - x1286
val x1305 = x1304 - x1174
val x1306 = x1303 * x1305
val x1307 = x1287 - x1306
val x1347 = {
def x1347thenb(): Unit = {
x1005 = x1307
()
}
if (x1344) {
x1347thenb()
}
}
val x1348 = x1304 > 0.0
val x1349 = x1304 < 1.0
val x1350 = x1348 && x1349
val x1325 = x1324 * x1285
val x1326 = x1308 - x1325
val x1340 = x1339 * x1305
val x1341 = x1326 - x1340
val x1353 = {
def x1353thenb(): Unit = {
x1005 = x1341
()
}
if (x1350) {
x1353thenb()
}
}
val x1355 = x1307 + x1341
val x1356 = x1355 / 2.0
val x1359 = {
def x1359thenb(): Unit = {
x1005 = x1356
()
}
if (x1354) {
x1359thenb()
}
}
val x1360 = x1018 += 1
()
}
if (x1264) {
x1362thenb()
}
}
x1362
}
if (x1245) {
x1364thenb()
}
}
x1364
}
if (x1196) {
x1366thenb()
}
}
x1366
}
if (x1094) {
x1368thenb()
}
}
val x1369 = x1019 += 1
()
}
val x1372 = x1018
val x1373 = x1372==0
val x1378 = {
def x1378thenb(): Unit = {
val x1374 = x1012 += 1
()
}
def x1378elseb(): Unit = {
x1012 = 0
()
}
if (x1373) {
x1378thenb()
} else { 
x1378elseb()
}
}
x1378
}
val x1381 = x1013
val x1382 = "num iterations: "+x1381
val x1383 = println(x1382)
var x1384: Int = 0
val x1385 = x1384
val x1386 = x1385 < x1006
val x1398 = x999(x1385)
val x1392 = x1385 * x1000
val x1411 = while ({x1386}) {
val x1388 = x1010(x1385)
val x1404 = {
val x1400 = new generated.scala.DoubleVectorImpl(x1000,true)
x1400
}
var x1389 = 0
while (x1389 < x1000) {  // begin fat loop x1404
val x1393 = x1392 + x1389
val x1394 = x869.dcApply(x1393)
val x1395 = { 
x1394
}
val x1396 = x1395 * x1388
val x1500 = x1396 * x1398
x1404.dcUpdate(x1389, x1500)
x1389 += 1
} // end fat loop x1404
def x1408_block = {
var zipIdx = 0
while (zipIdx < x1004.size) { // begin zip loop x1408
val x1405 = x1004.dcApply(zipIdx)
val x1406 = x1404.dcApply(zipIdx)
x1004.dcUpdate(zipIdx,  {
val x1407 = x1405 + x1406
x1407
})
zipIdx += 1
} // end zip loop x1408
x1004
}
val x1408 = x1408_block
val x1409 = x1384 += 1
()
}
val x1412 = print("\n")
val x1413 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
val x1423 = x988.numRows
val x1424 = new generated.scala.IndexVectorRangeImpl(0,x1423)
val x1432 = x988.numCols
val x1451 = x1424.length
val x1452 = x1424.isRow
def x1455_block = {
val x1453 = new generated.scala.IntVectorImpl(x1451,x1452)
var mapIdx = 0
while (mapIdx < x1424.size) { // begin map loop x1455
val x1425 = x1424.dcApply(mapIdx)
x1453.dcUpdate(mapIdx,  {
val x1427 = x1004.isRow
val x1433 = x1425 * x1432
// a *thin* loop follows: x1439
val x1439 = {
val x1429 = new generated.scala.DoubleVectorImpl(x1000,x1427)
x1429
}
var x1428 = 0
while (x1428 < x1000) {  // begin fat loop x1439
val x1431 = x1004(x1428)
val x1434 = x1433 + x1428
val x1435 = x988.dcApply(x1434)
val x1436 = { 
x1435
}
val x1437 = x1431 * x1436
x1439.dcUpdate(x1428, x1437)
x1428 += 1
} // end fat loop x1439
// a *thin* loop follows: x1446
var x1446: Double = 0
var x1440 = 0
while (x1440 < x1000) {  // begin fat loop x1446
val x1443 = x1439(x1440)
val x1441 = x1446
val x1442 = x1443
val x1445 = x1441 + x1442
x1446 = x1445
x1440 += 1
} // end fat loop x1446
val x1447 = x1446 + x1082
val x1448 = x1447 < 0.0
val x1449 = {
def x1449thenb(): Int = {
-1
}
def x1449elseb(): Int = {
1
}
if (x1448) {
x1449thenb()
} else { 
x1449elseb()
}
}
x1449
})
mapIdx += 1
} // end map loop x1455
x1453
}
val x1455 = x1455_block
val x1456 = println("SVM testing finished. Calculating error..")
val x1414 = x988.labels
val x1418 = x1414.length
val x1419 = x1414.isRow
def x1422_block = {
val x1420 = new generated.scala.DoubleVectorImpl(x1418,x1419)
var mapIdx = 0
while (mapIdx < x1414.size) { // begin map loop x1422
val x1415 = x1414.dcApply(mapIdx)
x1420.dcUpdate(mapIdx,  {
val x1416 = x1415==0
val x1417 = {
def x1417thenb(): Double = {
-1.0
}
def x1417elseb(): Double = {
1.0
}
if (x1416) {
x1417thenb()
} else { 
x1417elseb()
}
}
x1417
})
mapIdx += 1
} // end map loop x1422
x1420
}
val x1422 = x1422_block
val x1462 = new generated.scala.RangeVectorImpl(0,x1423,1,true)
def x1466_block = {
val x1457 = x1462.dcApply(0)
var x1463 = {
val x1458 = x1422(x1457)
val x1459 = x1455(x1457)
val x1460 = x1458 != x1459
val x1461 = {
def x1461thenb(): Int = {
1
}
def x1461elseb(): Int = {
0
}
if (x1460) {
x1461thenb()
} else { 
x1461elseb()
}
}
x1461
}
var mapReduceIdx = 1
while (mapReduceIdx < x1462.size) { // begin mapReduce loop x1466
val x1457 = x1462.dcApply(mapReduceIdx)
val x1464 = {
val x1458 = x1422(x1457)
val x1459 = x1455(x1457)
val x1460 = x1458 != x1459
val x1461 = {
def x1461thenb(): Int = {
1
}
def x1461elseb(): Int = {
0
}
if (x1460) {
x1461thenb()
} else { 
x1461elseb()
}
}
x1461
}
x1463 = {
val x1465 = x1463 + x1464
x1465
}
mapReduceIdx += 1
} // end mapReduce loop x1466
x1463
}
val x1466 = x1466_block
val x1467 = x1466.doubleValue()
val x1468 = x1423.doubleValue()
val x1469 = x1467 / x1468
val x1470 = "Classification error: "+x1469
val x1471 = println(x1470)
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
