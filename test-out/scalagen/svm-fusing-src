/*****************************************
  Emitting Generated Code                  
*******************************************/
class SVMRunnerFusing extends ((Array[java.lang.String])=>(Unit)) {
def apply(x726:Array[java.lang.String]): Unit = {
val x727 = x726.length
val x728 = x727 < 1
val x732 = {
def x732thenb(): Nothing = {
val x729 = println("Usage: SVM <train data file> <test data file> <model filename> <num tests>")
val x730 = exit(-1)
x730
}
if (x728) {
x732thenb()
}
}
val x738 = { generated.scala.Global.randRef.setSeed(generated.scala.Global.INITIAL_SEED);   generated.scala.Global.intRandRef.setSeed(generated.scala.Global.INITIAL_SEED); }
val x733 = x726(0)
val x852 = { 
val x739 = new java.io.FileReader(x733)
val x740 = new java.io.BufferedReader(x739)
var x741: java.io.BufferedReader = x740
val x742 = x741
val x743 = x742.readLine()
var x744: java.lang.String = x743
val x745 = x741
val x746 = x745.readLine()
var x747: java.lang.String = x746
val x748 = x747
val x749 = x748.trim()
val x750 = x749.split("\\s+")
val x751 = x750(0)
val x752 = java.lang.Integer.parseInt(x751)
val x755 = x752 < 0
val x753 = x750(1)
val x754 = java.lang.Integer.parseInt(x753)
val x756 = x754 < 0
val x757 = x755 || x756
val x760 = {
def x760thenb(): Nothing = {
val x758 = error("Illegal input to readTokenMatrix")
x758
}
if (x757) {
x760thenb()
}
}
val x761 = x741
val x762 = x761.readLine()
val x763 = new generated.scala.DoubleVectorImpl(0,true)
val x764 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x766 : Int = 0
val x801 = while (x766 < x752) {
val x767 = x741
val x768 = x767.readLine()
x747 = x768
val x770 = x747
val x771 = x770.trim()
x747 = x771
val x773 = x747
val x775 = new generated.scala.DoubleVectorImpl(x754,true)
var x776: Int = 0
var x777: Int = 1
val x778 = x777
val x774 = x773.split("\\s+")
val x779 = x774.length
val x780 = x779 - 1
val x781 = x778 < x780
val x782 = x774(x778)
val x783 = java.lang.Integer.parseInt(x782)
val x785 = x776
val x786 = x778 + 1
val x787 = x774(x786)
val x788 = java.lang.Double.parseDouble(x787)
val x792 = while ({x781}) {
val x784 = x776 += x783
val x789 = x775(x785) = x788
val x790 = x777 += 2
()
}
val x795 = x763.length
val x793 = x774(0)
val x794 = java.lang.Double.parseDouble(x793)
val x796 = x763.insert(x795, x794)
val x797 = x775.cloneL
val x798 = x764.length
val x799 = x764.insert(x798, x797)
x799
x766 = x766 + 1
}
val x802 = x763.length
val x803 = x763.isRow
val x804 = !x803
// a *thin* loop follows: x810
val x810 = {
val x806 = new generated.scala.DoubleVectorImpl(x802,x804)
x806
}
var x805 = 0
while (x805 < x802) {  // begin fat loop x810
val x808 = x763(x805)
x810.dcUpdate(x805, x808)
x805 += 1
} // end fat loop x810
val x846 = { 
val x811 = x764.length
val x812 = x811==0
val x844 = {
def x844thenb(): generated.scala.Matrix[Double] = {
val x813 = new generated.scala.DoubleMatrixImpl(0,0)
x813
}
def x844elseb(): generated.scala.Matrix[Double] = {
val x815 = x764(0)
val x816 = x815.isRow
val x842 = {
def x842thenb(): generated.scala.Matrix[Double] = {
val x817 = x815.length
val x818 = new generated.scala.DoubleMatrixImpl(x811,x817)
var x820 : Int = 0
val x829 = while (x820 < x811) {
var x822 : Int = 0
val x827 = while (x822 < x817) {
val x823 = x764(x820)
val x824 = x823(x822)
val x825 = x818(x820, x822) = x824
x825
x822 = x822 + 1
}
x827
x820 = x820 + 1
}
x818
}
def x842elseb(): generated.scala.Matrix[Double] = {
val x817 = x815.length
val x831 = new generated.scala.DoubleMatrixImpl(x817,x811)
var x832 : Int = 0
val x840 = while (x832 < x811) {
var x833 : Int = 0
val x838 = while (x833 < x817) {
val x834 = x764(x832)
val x835 = x834(x833)
val x836 = x831(x833, x832) = x835
x836
x833 = x833 + 1
}
x838
x832 = x832 + 1
}
x831
}
if (x816) {
x842thenb()
} else { 
x842elseb()
}
}
x842
}
if (x812) {
x844thenb()
} else { 
x844elseb()
}
}
x844
}
val x847 = x741
val x848 = x847.close()
val x849 = new generated.scala.DoubleLabelsImpl(x810)
val x850 = new generated.scala.DoubleDoubleTrainingSetImpl(x846,x849)
x850
}
val x734 = x726(1)
val x966 = { 
val x853 = new java.io.FileReader(x734)
val x854 = new java.io.BufferedReader(x853)
var x855: java.io.BufferedReader = x854
val x856 = x855
val x857 = x856.readLine()
var x858: java.lang.String = x857
val x859 = x855
val x860 = x859.readLine()
var x861: java.lang.String = x860
val x862 = x861
val x863 = x862.trim()
val x864 = x863.split("\\s+")
val x865 = x864(0)
val x866 = java.lang.Integer.parseInt(x865)
val x869 = x866 < 0
val x867 = x864(1)
val x868 = java.lang.Integer.parseInt(x867)
val x870 = x868 < 0
val x871 = x869 || x870
val x874 = {
def x874thenb(): Nothing = {
val x872 = error("Illegal input to readTokenMatrix")
x872
}
if (x871) {
x874thenb()
}
}
val x875 = x855
val x876 = x875.readLine()
val x877 = new generated.scala.DoubleVectorImpl(0,true)
val x878 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x880 : Int = 0
val x915 = while (x880 < x866) {
val x881 = x855
val x882 = x881.readLine()
x861 = x882
val x884 = x861
val x885 = x884.trim()
x861 = x885
val x887 = x861
val x889 = new generated.scala.DoubleVectorImpl(x868,true)
var x890: Int = 0
var x891: Int = 1
val x892 = x891
val x888 = x887.split("\\s+")
val x893 = x888.length
val x894 = x893 - 1
val x895 = x892 < x894
val x896 = x888(x892)
val x897 = java.lang.Integer.parseInt(x896)
val x899 = x890
val x900 = x892 + 1
val x901 = x888(x900)
val x902 = java.lang.Double.parseDouble(x901)
val x906 = while ({x895}) {
val x898 = x890 += x897
val x903 = x889(x899) = x902
val x904 = x891 += 2
()
}
val x909 = x877.length
val x907 = x888(0)
val x908 = java.lang.Double.parseDouble(x907)
val x910 = x877.insert(x909, x908)
val x911 = x889.cloneL
val x912 = x878.length
val x913 = x878.insert(x912, x911)
x913
x880 = x880 + 1
}
val x916 = x877.length
val x917 = x877.isRow
val x918 = !x917
// a *thin* loop follows: x924
val x924 = {
val x920 = new generated.scala.DoubleVectorImpl(x916,x918)
x920
}
var x919 = 0
while (x919 < x916) {  // begin fat loop x924
val x922 = x877(x919)
x924.dcUpdate(x919, x922)
x919 += 1
} // end fat loop x924
val x960 = { 
val x925 = x878.length
val x926 = x925==0
val x958 = {
def x958thenb(): generated.scala.Matrix[Double] = {
val x927 = new generated.scala.DoubleMatrixImpl(0,0)
x927
}
def x958elseb(): generated.scala.Matrix[Double] = {
val x929 = x878(0)
val x930 = x929.isRow
val x956 = {
def x956thenb(): generated.scala.Matrix[Double] = {
val x931 = x929.length
val x932 = new generated.scala.DoubleMatrixImpl(x925,x931)
var x934 : Int = 0
val x943 = while (x934 < x925) {
var x936 : Int = 0
val x941 = while (x936 < x931) {
val x937 = x878(x934)
val x938 = x937(x936)
val x939 = x932(x934, x936) = x938
x939
x936 = x936 + 1
}
x941
x934 = x934 + 1
}
x932
}
def x956elseb(): generated.scala.Matrix[Double] = {
val x931 = x929.length
val x945 = new generated.scala.DoubleMatrixImpl(x931,x925)
var x946 : Int = 0
val x954 = while (x946 < x925) {
var x947 : Int = 0
val x952 = while (x947 < x931) {
val x948 = x878(x946)
val x949 = x948(x947)
val x950 = x945(x947, x946) = x949
x950
x947 = x947 + 1
}
x952
x946 = x946 + 1
}
x945
}
if (x930) {
x956thenb()
} else { 
x956elseb()
}
}
x956
}
if (x926) {
x958thenb()
} else { 
x958elseb()
}
}
x958
}
val x961 = x855
val x962 = x961.close()
val x963 = new generated.scala.DoubleLabelsImpl(x924)
val x964 = new generated.scala.DoubleDoubleTrainingSetImpl(x960,x963)
x964
}
val x241 = Seq()
val x967 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
val x968 = println("Training SVM using the SMO algorithm")
val x978 = x852.numCols
val x982 = { 
val x979 = new generated.scala.DoubleVectorImpl(x978,true)
x979
}
var x983: Double = 0.0
val x984 = x852.numRows
val x988 = { 
val x985 = new generated.scala.DoubleVectorImpl(x984,true)
x985
}
val x989 = x988.mtrans
var x990: Int = 0
var x991: Int = 0
val x992 = x990
val x993 = x992 < 10
val x969 = x852.labels
val x973 = x969.length
val x974 = x969.isRow
def x977_block = {
val x975 = new generated.scala.DoubleVectorImpl(x973,x974)
var mapIdx = 0
while (mapIdx < x969.size) { // begin map loop x977
val x970 = x969.dcApply(mapIdx)
x975.dcUpdate(mapIdx,  {
val x971 = x970==0
val x972 = {
def x972thenb(): Double = {
-1.0
}
def x972elseb(): Double = {
1.0
}
if (x971) {
x972thenb()
} else { 
x972elseb()
}
}
x972
})
mapIdx += 1
} // end map loop x977
x975
}
val x977 = x977_block
val x285 = !true
val x319 = List()
val x1019 = new generated.scala.IndexVectorRangeImpl(0,x984)
val x1059 = x983
val x1356 = while ({x993}) {
val x994 = print(".")
val x995 = x991 += 1
var x996: Int = 0
var x997: Int = 0
val x998 = x997
val x999 = x998 < x984
val x1061 = x977(x998)
val x1013 = x998 * x978
val x1017 = {
val x1011 = new generated.scala.DoubleVectorImpl(x978,x285)
x1011
}
var x1010 = 0
while (x1010 < x978) {  // begin fat loop x1017
val x1014 = x1013 + x1010
val x1015 = x852.dcApply(x1014)
val x1016 = { 
x1015
}
x1017.dcUpdate(x1010, x1016)
x1010 += 1
} // end fat loop x1017
val x1347 = while ({x999}) {
val x1000 = x988.cloneL
val x1045 = { 
val x1018 = new generated.scala.DoubleVectorImpl(x984,false)
val x1043 = {
var forIdx = 0
while (forIdx < x1019.size) { // begin foreach loop x1043
val x1020 = x1019.dcApply(forIdx)
val x1025 = x1020 * x978
var x1039: Double = 0
var x1022 = 0
while (x1022 < x978) {  // begin fat loop x1039
val x1026 = x1025 + x1022
val x1027 = x852.dcApply(x1026)
val x1028 = { 
x1027
}
val x1029 = x1013 + x1022
val x1030 = x852.dcApply(x1029)
val x1031 = { 
x1030
}
val x1032 = x1028 * x1031
val x1035 = x1039
val x1036 = x1032
val x1038 = x1035 + x1036
x1039 = x1038
x1022 += 1
} // end fat loop x1039
val x1040 = x1018(x1020) = x1039
x1040
forIdx += 1
} // end foreach loop x1043
}
x1018
}
val x1001 = x1000.isRow
var x1058: Double = 0
val x1008 = {
val x1003 = new generated.scala.DoubleVectorImpl(x984,x1001)
x1003
}
var x1053 = 0
while (x1053 < x984) {  // begin fat loop x1058,x1008
val x1451 = x1000(x1053)
val x1452 = x977(x1053)
val x1453 = x1451 * x1452
val x1454 = x1045(x1053)
val x1455 = x1453 * x1454
val x1054 = x1058
val x1055 = x1455
val x1057 = x1054 + x1055
x1058 = x1057
x1008.dcUpdate(x1053, x1453)
x1053 += 1
} // end fat loop x1058,x1008
val x1060 = x1058 + x1059
val x1062 = x1060 - x1061
val x1063 = x1061 * x1062
val x1064 = x1063 < -0.0010
val x1065 = x1000(x998)
val x1066 = x1065 < 1.0
val x1067 = x1064 && x1066
val x1068 = x1063 > 0.0010
val x1069 = x1065 > 0.0
val x1070 = x1068 && x1069
val x1071 = x1067 || x1070
val x1344 = {
def x1344thenb(): Unit = {
val x1072 = generated.scala.Global.randRef.nextDouble()
val x1073 = x1072.asInstanceOf[Double]
val x1074 = x984 - 1
val x1075 = x1074
val x1076 = x1073 * x1075
val x1077 = Math.floor(x1076)
val x1078 = x1077.asInstanceOf[Int]
val x1079 = x1078 + 1
var x1080: Int = x1079
val x1081 = x1080
val x1082 = x1081==x998
val x1091 = while ({x1082}) {
val x1083 = generated.scala.Global.randRef.nextDouble()
val x1084 = x1083.asInstanceOf[Double]
val x1085 = x1084 * x1075
val x1086 = Math.floor(x1085)
val x1087 = x1086.asInstanceOf[Int]
val x1088 = x1087 + 1
x1080 = x1088
()
}
var x1151: Double = 0.0
var x1152: Double = 0.0
val x1148 = x977(x1081)
val x1153 = x1061 != x1148
val x1169 = {
def x1169thenb(): Unit = {
val x1150 = x1000(x1081)
val x1154 = x1150 - x1065
val x1155 = Math.max(0.0, x1154)
x1151 = x1155
val x1157 = 1.0 + x1150
val x1158 = x1157 - x1065
val x1159 = Math.min(1.0, x1158)
x1152 = x1159
()
}
def x1169elseb(): Unit = {
val x1150 = x1000(x1081)
val x1162 = x1065 + x1150
val x1163 = x1162 - 1.0
val x1164 = Math.max(0.0, x1163)
x1151 = x1164
val x1166 = Math.min(1.0, x1162)
x1152 = x1166
()
}
if (x1153) {
x1169thenb()
} else { 
x1169elseb()
}
}
val x1170 = x1151
val x1171 = x1152
val x1172 = x1170 != x1171
val x1342 = {
def x1342thenb(): Unit = {
val x1102 = x1081 * x978
var x1189: Double = 0
var x1204: Double = 0
var x1219: Double = 0
var x1173 = 0
while (x1173 < x978) {  // begin fat loop x1189,x1204,x1219
val x1176 = x1013 + x1173
val x1177 = x852.dcApply(x1176)
val x1178 = { 
x1177
}
val x1179 = x1102 + x1173
val x1180 = x852.dcApply(x1179)
val x1181 = { 
x1180
}
val x1182 = x1178 * x1181
val x1456 = x1178 * x1178
val x1457 = x1181 * x1181
val x1185 = x1189
val x1186 = x1182
val x1188 = x1185 + x1186
x1189 = x1188
val x1200 = x1204
val x1201 = x1456
val x1203 = x1200 + x1201
x1204 = x1203
val x1215 = x1219
val x1216 = x1457
val x1218 = x1215 + x1216
x1219 = x1218
x1173 += 1
} // end fat loop x1189,x1204,x1219
val x1190 = x1189 * 2.0
val x1205 = x1190 - x1204
val x1220 = x1205 - x1219
val x1221 = x1220 < 0.0
val x1340 = {
def x1340thenb(): Unit = {
val x1150 = x1000(x1081)
val x1106 = {
val x1100 = new generated.scala.DoubleVectorImpl(x978,x285)
x1100
}
var x1099 = 0
while (x1099 < x978) {  // begin fat loop x1106
val x1103 = x1102 + x1099
val x1104 = x852.dcApply(x1103)
val x1105 = { 
x1104
}
x1106.dcUpdate(x1099, x1105)
x1099 += 1
} // end fat loop x1106
val x1133 = { 
val x1107 = new generated.scala.DoubleVectorImpl(x984,false)
val x1131 = {
var forIdx = 0
while (forIdx < x1019.size) { // begin foreach loop x1131
val x1108 = x1019.dcApply(forIdx)
val x1113 = x1108 * x978
var x1127: Double = 0
var x1110 = 0
while (x1110 < x978) {  // begin fat loop x1127
val x1114 = x1113 + x1110
val x1115 = x852.dcApply(x1114)
val x1116 = { 
x1115
}
val x1117 = x1102 + x1110
val x1118 = x852.dcApply(x1117)
val x1119 = { 
x1118
}
val x1120 = x1116 * x1119
val x1123 = x1127
val x1124 = x1120
val x1126 = x1123 + x1124
x1127 = x1126
x1110 += 1
} // end fat loop x1127
val x1128 = x1107(x1108) = x1127
x1128
forIdx += 1
} // end foreach loop x1131
}
x1107
}
var x1146: Double = 0
var x1134 = 0
while (x1134 < x984) {  // begin fat loop x1146
val x1137 = x1008(x1134)
val x1138 = x1133(x1134)
val x1139 = x1137 * x1138
val x1142 = x1146
val x1143 = x1139
val x1145 = x1142 + x1143
x1146 = x1145
x1134 += 1
} // end fat loop x1146
val x1147 = x1146 + x1059
val x1149 = x1147 - x1148
val x1222 = x1062 - x1149
val x1223 = x1148 * x1222
val x1224 = x1223 / x1220
val x1225 = x1150 - x1224
val x1226 = x988(x1081) = x1225
val x1227 = x988(x1081)
val x1228 = x1227 > x1171
val x1236 = {
def x1236thenb(): Unit = {
val x1229 = x988(x1081) = x1171
x1229
}
def x1236elseb(): Unit = {
val x1231 = x1227 < x1170
val x1234 = {
def x1234thenb(): Unit = {
val x1232 = x988(x1081) = x1170
x1232
}
if (x1231) {
x1234thenb()
}
}
x1234
}
if (x1228) {
x1236thenb()
} else { 
x1236elseb()
}
}
val x1237 = x988(x1081)
val x1238 = x1237 - x1150
val x1239 = Math.abs(x1238)
val x1240 = x1239 > 1.0E-5
val x1338 = {
def x1338thenb(): Unit = {
val x1241 = x1061 * x1148
val x1242 = x1150 - x1237
val x1243 = x1241 * x1242
val x1244 = x1065 + x1243
val x1245 = x988(x998) = x1244
val x1260 = x988(x998)
val x1280 = x988(x1081)
val x1318 = x1260 > 0.0
val x1319 = x1260 < 1.0
val x1320 = x1318 && x1319
val x1323 = {
def x1323thenb(): Unit = {
val x1246 = x1059 - x1062
val x1259 = x1204 * x1061
val x1261 = x1260 - x1065
val x1262 = x1259 * x1261
val x1263 = x1246 - x1262
val x1279 = x1189 * x1148
val x1281 = x1280 - x1150
val x1282 = x1279 * x1281
val x1283 = x1263 - x1282
x983 = x1283
()
}
if (x1320) {
x1323thenb()
}
}
val x1324 = x1280 > 0.0
val x1325 = x1280 < 1.0
val x1326 = x1324 && x1325
val x1329 = {
def x1329thenb(): Unit = {
val x1284 = x1059 - x1149
val x1261 = x1260 - x1065
val x1300 = x1189 * x1061
val x1301 = x1300 * x1261
val x1302 = x1284 - x1301
val x1281 = x1280 - x1150
val x1315 = x1219 * x1148
val x1316 = x1315 * x1281
val x1317 = x1302 - x1316
x983 = x1317
()
}
if (x1326) {
x1329thenb()
}
}
val x1330 = x1059==x1059
val x1335 = {
def x1335thenb(): Unit = {
val x1246 = x1059 - x1062
val x1259 = x1204 * x1061
val x1261 = x1260 - x1065
val x1262 = x1259 * x1261
val x1263 = x1246 - x1262
val x1279 = x1189 * x1148
val x1281 = x1280 - x1150
val x1282 = x1279 * x1281
val x1283 = x1263 - x1282
val x1284 = x1059 - x1149
val x1300 = x1189 * x1061
val x1301 = x1300 * x1261
val x1302 = x1284 - x1301
val x1315 = x1219 * x1148
val x1316 = x1315 * x1281
val x1317 = x1302 - x1316
val x1331 = x1283 + x1317
val x1332 = x1331 / 2.0
x983 = x1332
()
}
if (x1330) {
x1335thenb()
}
}
val x1336 = x996 += 1
()
}
if (x1240) {
x1338thenb()
}
}
x1338
}
if (x1221) {
x1340thenb()
}
}
x1340
}
if (x1172) {
x1342thenb()
}
}
x1342
}
if (x1071) {
x1344thenb()
}
}
val x1345 = x997 += 1
()
}
val x1348 = x996
val x1349 = x1348==0
val x1354 = {
def x1354thenb(): Unit = {
val x1350 = x990 += 1
()
}
def x1354elseb(): Unit = {
x990 = 0
()
}
if (x1349) {
x1354thenb()
} else { 
x1354elseb()
}
}
x1354
}
val x1357 = x991
val x1358 = "num iterations: "+x1357
val x1359 = println(x1358)
var x1360: Int = 0
val x1361 = x1360
val x1362 = x1361 < x984
val x1374 = x977(x1361)
val x1368 = x1361 * x978
val x1387 = while ({x1362}) {
val x1364 = x988(x1361)
val x1380 = {
val x1376 = new generated.scala.DoubleVectorImpl(x978,true)
x1376
}
var x1365 = 0
while (x1365 < x978) {  // begin fat loop x1380
val x1369 = x1368 + x1365
val x1370 = x852.dcApply(x1369)
val x1371 = { 
x1370
}
val x1372 = x1371 * x1364
val x1458 = x1372 * x1374
x1380.dcUpdate(x1365, x1458)
x1365 += 1
} // end fat loop x1380
def x1384_block = {
var zipIdx = 0
while (zipIdx < x982.size) { // begin zip loop x1384
val x1381 = x982.dcApply(zipIdx)
val x1382 = x1380.dcApply(zipIdx)
x982.dcUpdate(zipIdx,  {
val x1383 = x1381 + x1382
x1383
})
zipIdx += 1
} // end zip loop x1384
x982
}
val x1384 = x1384_block
val x1385 = x1360 += 1
()
}
val x1388 = print("\n")
val x1389 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
val x1399 = x966.numRows
val x1400 = new generated.scala.IndexVectorRangeImpl(0,x1399)
val x1408 = x966.numCols
val x1427 = x1400.length
val x1428 = x1400.isRow
def x1431_block = {
val x1429 = new generated.scala.IntVectorImpl(x1427,x1428)
var mapIdx = 0
while (mapIdx < x1400.size) { // begin map loop x1431
val x1401 = x1400.dcApply(mapIdx)
x1429.dcUpdate(mapIdx,  {
val x1403 = x982.isRow
val x1409 = x1401 * x1408
// a *thin* loop follows: x1415
val x1415 = {
val x1405 = new generated.scala.DoubleVectorImpl(x978,x1403)
x1405
}
var x1404 = 0
while (x1404 < x978) {  // begin fat loop x1415
val x1407 = x982(x1404)
val x1410 = x1409 + x1404
val x1411 = x966.dcApply(x1410)
val x1412 = { 
x1411
}
val x1413 = x1407 * x1412
x1415.dcUpdate(x1404, x1413)
x1404 += 1
} // end fat loop x1415
// a *thin* loop follows: x1422
var x1422: Double = 0
var x1416 = 0
while (x1416 < x978) {  // begin fat loop x1422
val x1419 = x1415(x1416)
val x1417 = x1422
val x1418 = x1419
val x1421 = x1417 + x1418
x1422 = x1421
x1416 += 1
} // end fat loop x1422
val x1423 = x1422 + x1059
val x1424 = x1423 < 0.0
val x1425 = {
def x1425thenb(): Int = {
-1
}
def x1425elseb(): Int = {
1
}
if (x1424) {
x1425thenb()
} else { 
x1425elseb()
}
}
x1425
})
mapIdx += 1
} // end map loop x1431
x1429
}
val x1431 = x1431_block
val x1432 = println("SVM testing finished. Calculating error..")
val x1390 = x966.labels
val x1394 = x1390.length
val x1395 = x1390.isRow
def x1398_block = {
val x1396 = new generated.scala.DoubleVectorImpl(x1394,x1395)
var mapIdx = 0
while (mapIdx < x1390.size) { // begin map loop x1398
val x1391 = x1390.dcApply(mapIdx)
x1396.dcUpdate(mapIdx,  {
val x1392 = x1391==0
val x1393 = {
def x1393thenb(): Double = {
-1.0
}
def x1393elseb(): Double = {
1.0
}
if (x1392) {
x1393thenb()
} else { 
x1393elseb()
}
}
x1393
})
mapIdx += 1
} // end map loop x1398
x1396
}
val x1398 = x1398_block
val x1438 = new generated.scala.RangeVectorImpl(0,x1399,1,true)
def x1442_block = {
val x1433 = x1438.dcApply(0)
var x1439 = {
val x1434 = x1398(x1433)
val x1435 = x1431(x1433)
val x1436 = x1434 != x1435
val x1437 = {
def x1437thenb(): Int = {
1
}
def x1437elseb(): Int = {
0
}
if (x1436) {
x1437thenb()
} else { 
x1437elseb()
}
}
x1437
}
var mapReduceIdx = 1
while (mapReduceIdx < x1438.size) { // begin mapReduce loop x1442
val x1433 = x1438.dcApply(mapReduceIdx)
val x1440 = {
val x1434 = x1398(x1433)
val x1435 = x1431(x1433)
val x1436 = x1434 != x1435
val x1437 = {
def x1437thenb(): Int = {
1
}
def x1437elseb(): Int = {
0
}
if (x1436) {
x1437thenb()
} else { 
x1437elseb()
}
}
x1437
}
x1439 = {
val x1441 = x1439 + x1440
x1441
}
mapReduceIdx += 1
} // end mapReduce loop x1442
x1439
}
val x1442 = x1442_block
val x1443 = x1442.doubleValue()
val x1444 = x1399.doubleValue()
val x1445 = x1443 / x1444
val x1446 = "Classification error: "+x1445
val x1447 = println(x1446)
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
