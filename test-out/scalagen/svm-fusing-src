/*****************************************
  Emitting Generated Code                  
*******************************************/
class Application extends ((Array[java.lang.String])=>(Unit)) {
def apply(x717:Array[java.lang.String]): Unit = {
val x718 = x717.length
val x719 = x718 < 1
val x723 = {
def x723thenb(): Nothing = {
val x720 = println("Usage: SVM <train data file> <test data file> <model filename> <num tests>")
val x721 = exit(-1)
x721
}
def x723elseb(): Unit = {
()
}
if (x719) {
x723thenb()
} else {
x723elseb()
}
}
val x729 = { generated.scala.Global.randRef.setSeed(generated.scala.Global.INITIAL_SEED);   generated.scala.Global.intRandRef.setSeed(generated.scala.Global.INITIAL_SEED); }
val x724 = x717(0)
def x851_block = { 
val x730 = new java.io.FileReader(x724)
val x731 = new java.io.BufferedReader(x730)
var x732 = x731
val x733 = x732
val x734 = x733.readLine()
var x735 = x734
val x736 = x732
val x737 = x736.readLine()
var x738 = x737
val x739 = x738
val x740 = x739.trim()
val x741 = x740.split("\\s+")
val x742 = x741(0)
val x743 = java.lang.Integer.parseInt(x742)
val x746 = x743 < 0
val x744 = x741(1)
val x745 = java.lang.Integer.parseInt(x744)
val x747 = x745 < 0
val x748 = x746 || x747
val x751 = {
def x751thenb(): Nothing = {
val x749 = error("Illegal input to readTokenMatrix")
x749
}
def x751elseb(): Unit = {
()
}
if (x748) {
x751thenb()
} else {
x751elseb()
}
}
val x752 = x732
val x753 = x752.readLine()
val x754 = new generated.scala.DoubleVectorImpl(0,true)
var x756 : Int = 0
val x770 = while (x756 < x743) {
val x757 = x732
val x758 = x757.readLine()
x738 = x758
val x760 = x738
val x761 = x760.trim()
x738 = x761
val x763 = x738
val x767 = x754.length
val x764 = x763.split("\\s+")
val x765 = x764(0)
val x766 = java.lang.Double.parseDouble(x765)
val x768 = x754.insert(x767, x766)
x768
x756 = x756 + 1
}
val x771 = x754.length
val x772 = x754.isRow
val x773 = !x772
val x779 = {
val x775 = new generated.scala.DoubleVectorImpl(x771,x773)
x775
}
var x774 = 0
while (x774 < x771) {  // begin thin loop x779
val x777 = x754(x774)
x779.dcUpdate(x774, x777)
x774 += 1
} // end thin loop x779
val x780 = x732
val x781 = x780.close()
val x782 = new java.io.FileReader(x724)
val x783 = new java.io.BufferedReader(x782)
x732 = x783
val x785 = x732
val x786 = x785.readLine()
val x787 = x732
val x788 = x787.readLine()
val x789 = x732
val x790 = x789.readLine()
val x791 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x792 : Int = 0
val x825 = while (x792 < x743) {
val x793 = x732
val x794 = x793.readLine()
x738 = x794
val x796 = x738
val x797 = x796.trim()
x738 = x797
val x799 = x738
val x801 = new generated.scala.DoubleVectorImpl(x745,true)
var x802 = 0
var x803 = 1
val x800 = x799.split("\\s+")
val x805 = x800.length
val x806 = x805 - 1
val x821 = while ({val x804 = x803
val x807 = x804 < x806
x807}) {
val x809 = x803
val x810 = x800(x809)
val x811 = java.lang.Integer.parseInt(x810)
val x812 = x802 += x811
val x813 = x802
val x814 = x803
val x815 = x814 + 1
val x816 = x800(x815)
val x817 = java.lang.Double.parseDouble(x816)
val x818 = x801(x813) = x817
val x819 = x803 += 2
()
}
val x822 = x791.length
val x823 = x791.insert(x822, x801)
x823
x792 = x792 + 1
}
def x845_block = { 
val x826 = x791.length
val x827 = x826 > 0
val x831 = {
def x831thenb(): Int = {
val x828 = x791(0)
val x829 = x828.length
x829
}
def x831elseb(): Int = {
0
}
if (x827) {
x831thenb()
} else {
x831elseb()
}
}
val x832 = new generated.scala.DoubleMatrixImpl(x826,x831)
var x834 : Int = 0
val x843 = while (x834 < x826) {
var x836 : Int = 0
val x841 = while (x836 < x831) {
val x837 = x791(x834)
val x838 = x837(x836)
val x839 = x832(x834, x836) = x838
x839
x836 = x836 + 1
}
x841
x834 = x834 + 1
}
x832
}
val x845 = x845_block
val x846 = x732
val x847 = x846.close()
val x848 = new generated.scala.DoubleLabelsImpl(x779)
val x849 = new generated.scala.DoubleDoubleTrainingSetImpl(x845,x848)
x849
}
val x851 = x851_block
val x725 = x717(1)
def x973_block = { 
val x852 = new java.io.FileReader(x725)
val x853 = new java.io.BufferedReader(x852)
var x854 = x853
val x855 = x854
val x856 = x855.readLine()
var x857 = x856
val x858 = x854
val x859 = x858.readLine()
var x860 = x859
val x861 = x860
val x862 = x861.trim()
val x863 = x862.split("\\s+")
val x864 = x863(0)
val x865 = java.lang.Integer.parseInt(x864)
val x868 = x865 < 0
val x866 = x863(1)
val x867 = java.lang.Integer.parseInt(x866)
val x869 = x867 < 0
val x870 = x868 || x869
val x873 = {
def x873thenb(): Nothing = {
val x871 = error("Illegal input to readTokenMatrix")
x871
}
def x873elseb(): Unit = {
()
}
if (x870) {
x873thenb()
} else {
x873elseb()
}
}
val x874 = x854
val x875 = x874.readLine()
val x876 = new generated.scala.DoubleVectorImpl(0,true)
var x878 : Int = 0
val x892 = while (x878 < x865) {
val x879 = x854
val x880 = x879.readLine()
x860 = x880
val x882 = x860
val x883 = x882.trim()
x860 = x883
val x885 = x860
val x889 = x876.length
val x886 = x885.split("\\s+")
val x887 = x886(0)
val x888 = java.lang.Double.parseDouble(x887)
val x890 = x876.insert(x889, x888)
x890
x878 = x878 + 1
}
val x893 = x876.length
val x894 = x876.isRow
val x895 = !x894
val x901 = {
val x897 = new generated.scala.DoubleVectorImpl(x893,x895)
x897
}
var x896 = 0
while (x896 < x893) {  // begin thin loop x901
val x899 = x876(x896)
x901.dcUpdate(x896, x899)
x896 += 1
} // end thin loop x901
val x902 = x854
val x903 = x902.close()
val x904 = new java.io.FileReader(x725)
val x905 = new java.io.BufferedReader(x904)
x854 = x905
val x907 = x854
val x908 = x907.readLine()
val x909 = x854
val x910 = x909.readLine()
val x911 = x854
val x912 = x911.readLine()
val x913 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x914 : Int = 0
val x947 = while (x914 < x865) {
val x915 = x854
val x916 = x915.readLine()
x860 = x916
val x918 = x860
val x919 = x918.trim()
x860 = x919
val x921 = x860
val x923 = new generated.scala.DoubleVectorImpl(x867,true)
var x924 = 0
var x925 = 1
val x922 = x921.split("\\s+")
val x927 = x922.length
val x928 = x927 - 1
val x943 = while ({val x926 = x925
val x929 = x926 < x928
x929}) {
val x931 = x925
val x932 = x922(x931)
val x933 = java.lang.Integer.parseInt(x932)
val x934 = x924 += x933
val x935 = x924
val x936 = x925
val x937 = x936 + 1
val x938 = x922(x937)
val x939 = java.lang.Double.parseDouble(x938)
val x940 = x923(x935) = x939
val x941 = x925 += 2
()
}
val x944 = x913.length
val x945 = x913.insert(x944, x923)
x945
x914 = x914 + 1
}
def x967_block = { 
val x948 = x913.length
val x949 = x948 > 0
val x953 = {
def x953thenb(): Int = {
val x950 = x913(0)
val x951 = x950.length
x951
}
def x953elseb(): Int = {
0
}
if (x949) {
x953thenb()
} else {
x953elseb()
}
}
val x954 = new generated.scala.DoubleMatrixImpl(x948,x953)
var x956 : Int = 0
val x965 = while (x956 < x948) {
var x958 : Int = 0
val x963 = while (x958 < x953) {
val x959 = x913(x956)
val x960 = x959(x958)
val x961 = x954(x956, x958) = x960
x961
x958 = x958 + 1
}
x963
x956 = x956 + 1
}
x954
}
val x967 = x967_block
val x968 = x854
val x969 = x968.close()
val x970 = new generated.scala.DoubleLabelsImpl(x901)
val x971 = new generated.scala.DoubleDoubleTrainingSetImpl(x967,x970)
x971
}
val x973 = x973_block
val x974 = x851.labels
def x978_block = {
var mapIdx = 0
while (mapIdx < x974.size) {
val x975 = x974.dcApply(mapIdx)
x974.dcUpdate(mapIdx,  {
val x976 = x975==0
val x977 = {
def x977thenb(): Double = {
-1.0
}
def x977elseb(): Double = {
1.0
}
if (x976) {
x977thenb()
} else {
x977elseb()
}
}
x977
})
mapIdx += 1
} // end while
x974
}
val x978 = x978_block
val x979 = x973.labels
def x983_block = {
var mapIdx = 0
while (mapIdx < x979.size) {
val x980 = x979.dcApply(mapIdx)
x979.dcUpdate(mapIdx,  {
val x981 = x980==0
val x982 = {
def x982thenb(): Double = {
-1.0
}
def x982elseb(): Double = {
1.0
}
if (x981) {
x982thenb()
} else {
x982elseb()
}
}
x982
})
mapIdx += 1
} // end while
x979
}
val x983 = x983_block
val x984 = println("tic:" + (System.nanoTime / 1000000L))
val x985 = println("Training SVM using the SMO algorithm")
val x986 = x851.numCols
def x989_block = { 
val x987 = new generated.scala.DoubleVectorImpl(x986,true)
x987
}
val x989 = x989_block
var x990 = x989
var x991 = 0.0
val x992 = x851.numRows
def x995_block = { 
val x993 = new generated.scala.DoubleVectorImpl(x992,true)
x993
}
val x995 = x995_block
val x996 = x995.mtrans
var x997 = 0
val x1347 = while ({val x998 = x997
val x999 = x998 < 10
x999}) {
val x1001 = print(".")
var x1002 = 0
var x1004 : Int = 0
val x1338 = while (x1004 < x992) {
val x1005 = x995.cloneL
val x1055 = x991
val x1057 = x974(x1004)
val x1006 = x1005.isRow
var x1054: Double = 0
val x1013 = {
val x1008 = new generated.scala.DoubleVectorImpl(x992,x1006)
x1008
}
var x1049 = 0
while (x1049 < x992) {  // begin fat loop x1054,x1013
val x1436 = x1005(x1049)
val x1437 = x974(x1049)
val x1438 = x1436 * x1437
var x1040: Double = 0
var x1028 = 0
while (x1028 < x986) {  // begin fat loop x1040
val x1439 = x851(x1049, x1028)
val x1032 = x851(x1004, x1028)
val x1440 = x1439 * x1032
val x1036 = x1040
val x1037 = x1440
val x1039 = x1036 + x1037
x1040 = x1039
x1028 += 1
} // end fat loop x1040
val x1441 = x1438 * x1040
val x1050 = x1054
val x1051 = x1441
val x1053 = x1050 + x1051
x1054 = x1053
x1013.dcUpdate(x1049, x1438)
x1049 += 1
} // end fat loop x1054,x1013
val x1056 = x1054 + x1055
val x1058 = x1056 - x1057
val x1059 = x1057 * x1058
val x1060 = x1059 < -1.0E-4
val x1061 = x1005(x1004)
val x1062 = x1061 < 1.0
val x1063 = x1060 && x1062
val x1064 = x1059 > 1.0E-4
val x1065 = x1061 > 0.0
val x1066 = x1064 && x1065
val x1067 = x1063 || x1066
val x1336 = {
def x1336thenb(): Unit = {
val x1068 = generated.scala.Global.randRef.nextDouble()
val x1069 = x1068.asInstanceOf[Double]
val x1070 = x992 - 1
val x1071 = x1070
val x1072 = x1069 * x1071
val x1073 = Math.floor(x1072)
val x1074 = x1073.asInstanceOf[Int]
val x1075 = x1074 + 1
var x1076 = x1075
val x1088 = while ({val x1077 = x1076
val x1078 = x1077==x1004
x1078}) {
val x1080 = generated.scala.Global.randRef.nextDouble()
val x1081 = x1080.asInstanceOf[Double]
val x1082 = x1081 * x1071
val x1083 = Math.floor(x1082)
val x1084 = x1083.asInstanceOf[Int]
val x1085 = x1084 + 1
x1076 = x1085
()
}
val x1095 = x1076
val x1137 = x991
var x1142 = 0.0
var x1143 = 0.0
val x1139 = x974(x1095)
val x1144 = x1057 != x1139
val x1160 = {
def x1160thenb(): Unit = {
val x1141 = x1005(x1095)
val x1145 = x1141 - x1061
val x1146 = Math.max(0.0, x1145)
x1142 = x1146
val x1148 = 1.0 + x1141
val x1149 = x1148 - x1061
val x1150 = Math.min(1.0, x1149)
x1143 = x1150
()
}
def x1160elseb(): Unit = {
val x1141 = x1005(x1095)
val x1153 = x1061 + x1141
val x1154 = x1153 - 1.0
val x1155 = Math.max(0.0, x1154)
x1142 = x1155
val x1157 = Math.min(1.0, x1153)
x1143 = x1157
()
}
if (x1144) {
x1160thenb()
} else {
x1160elseb()
}
}
val x1161 = x1142
val x1162 = x1143
val x1163 = x1161 != x1162
val x1334 = {
def x1334thenb(): Unit = {
val x1164 = x1076
var x1180: Double = 0
var x1193: Double = 0
var x1206: Double = 0
var x1168 = 0
while (x1168 < x986) {  // begin fat loop x1180,x1193,x1206
val x1171 = x851(x1004, x1168)
val x1172 = x851(x1164, x1168)
val x1173 = x1171 * x1172
val x1442 = x1171 * x1171
val x1443 = x1172 * x1172
val x1176 = x1180
val x1177 = x1173
val x1179 = x1176 + x1177
x1180 = x1179
val x1189 = x1193
val x1190 = x1442
val x1192 = x1189 + x1190
x1193 = x1192
val x1202 = x1206
val x1203 = x1443
val x1205 = x1202 + x1203
x1206 = x1205
x1168 += 1
} // end fat loop x1180,x1193,x1206
val x1181 = x1180 * 2.0
val x1194 = x1181 - x1193
val x1207 = x1194 - x1206
val x1208 = x1207 < 0.0
val x1332 = {
def x1332thenb(): Unit = {
val x1209 = x1005(x1164)
val x1210 = x974(x1164)
var x1136: Double = 0
var x1131 = 0
while (x1131 < x992) {  // begin fat loop x1136
val x1446 = x1013(x1131)
var x1122: Double = 0
var x1110 = 0
while (x1110 < x986) {  // begin fat loop x1122
val x1447 = x851(x1131, x1110)
val x1114 = x851(x1095, x1110)
val x1448 = x1447 * x1114
val x1118 = x1122
val x1119 = x1448
val x1121 = x1118 + x1119
x1122 = x1121
x1110 += 1
} // end fat loop x1122
val x1449 = x1446 * x1122
val x1132 = x1136
val x1133 = x1449
val x1135 = x1132 + x1133
x1136 = x1135
x1131 += 1
} // end fat loop x1136
val x1138 = x1136 + x1137
val x1140 = x1138 - x1139
val x1211 = x1058 - x1140
val x1212 = x1210 * x1211
val x1213 = x1212 / x1207
val x1214 = x1209 - x1213
val x1215 = x995(x1164) = x1214
val x1216 = x995(x1164)
val x1217 = x1216 > x1162
val x1225 = {
def x1225thenb(): Unit = {
val x1218 = x995(x1164) = x1162
x1218
}
def x1225elseb(): Unit = {
val x1220 = x1216 < x1161
val x1223 = {
def x1223thenb(): Unit = {
val x1221 = x995(x1164) = x1161
x1221
}
def x1223elseb(): Unit = {
()
}
if (x1220) {
x1223thenb()
} else {
x1223elseb()
}
}
x1223
}
if (x1217) {
x1225thenb()
} else {
x1225elseb()
}
}
val x1226 = x1076
val x1227 = x995(x1226)
val x1141 = x1005(x1095)
val x1228 = x1227 - x1141
val x1229 = Math.abs(x1228)
val x1230 = x1229 > 1.0E-4
val x1330 = {
def x1330thenb(): Unit = {
val x1231 = x1076
val x1234 = x995(x1231)
val x1232 = x974(x1231)
val x1233 = x1057 * x1232
val x1235 = x1141 - x1234
val x1236 = x1233 * x1235
val x1237 = x1061 + x1236
val x1238 = x995(x1004) = x1237
val x1239 = x991
val x1252 = x995(x1004)
val x1273 = x995(x1231)
val x1307 = x1252 > 0.0
val x1308 = x1252 < 1.0
val x1309 = x1307 && x1308
val x1312 = {
def x1312thenb(): Unit = {
val x1240 = x1239 - x1058
val x1251 = x1193 * x1057
val x1253 = x1252 - x1061
val x1254 = x1251 * x1253
val x1255 = x1240 - x1254
var x1271: Double = 0
var x1259 = 0
while (x1259 < x986) {  // begin fat loop x1271
val x1262 = x851(x1004, x1259)
val x1263 = x851(x1231, x1259)
val x1264 = x1262 * x1263
val x1267 = x1271
val x1268 = x1264
val x1270 = x1267 + x1268
x1271 = x1270
x1259 += 1
} // end fat loop x1271
val x1272 = x1271 * x1232
val x1274 = x1273 - x1141
val x1275 = x1272 * x1274
val x1276 = x1255 - x1275
x991 = x1276
()
}
def x1312elseb(): Unit = {
()
}
if (x1309) {
x1312thenb()
} else {
x1312elseb()
}
}
val x1313 = x1076
val x1314 = x995(x1313)
val x1315 = x1314 > 0.0
val x1316 = x1314 < 1.0
val x1317 = x1315 && x1316
val x1320 = {
def x1320thenb(): Unit = {
val x1277 = x1239 - x1140
val x1253 = x1252 - x1061
var x1271: Double = 0
var x1303: Double = 0
var x1259 = 0
while (x1259 < x986) {  // begin fat loop x1271,x1303
val x1262 = x851(x1004, x1259)
val x1263 = x851(x1231, x1259)
val x1264 = x1262 * x1263
val x1450 = x1263 * x1263
val x1267 = x1271
val x1268 = x1264
val x1270 = x1267 + x1268
x1271 = x1270
val x1299 = x1303
val x1300 = x1450
val x1302 = x1299 + x1300
x1303 = x1302
x1259 += 1
} // end fat loop x1271,x1303
val x1289 = x1271 * x1057
val x1290 = x1289 * x1253
val x1291 = x1277 - x1290
val x1274 = x1273 - x1141
val x1304 = x1303 * x1232
val x1305 = x1304 * x1274
val x1306 = x1291 - x1305
x991 = x1306
()
}
def x1320elseb(): Unit = {
()
}
if (x1317) {
x1320thenb()
} else {
x1320elseb()
}
}
val x1321 = x991
val x1322 = x1321==x1321
val x1327 = {
def x1327thenb(): Unit = {
val x1240 = x1239 - x1058
val x1251 = x1193 * x1057
val x1253 = x1252 - x1061
val x1254 = x1251 * x1253
val x1255 = x1240 - x1254
var x1271: Double = 0
var x1303: Double = 0
var x1259 = 0
while (x1259 < x986) {  // begin fat loop x1271,x1303
val x1262 = x851(x1004, x1259)
val x1263 = x851(x1231, x1259)
val x1264 = x1262 * x1263
val x1450 = x1263 * x1263
val x1267 = x1271
val x1268 = x1264
val x1270 = x1267 + x1268
x1271 = x1270
val x1299 = x1303
val x1300 = x1450
val x1302 = x1299 + x1300
x1303 = x1302
x1259 += 1
} // end fat loop x1271,x1303
val x1272 = x1271 * x1232
val x1274 = x1273 - x1141
val x1275 = x1272 * x1274
val x1276 = x1255 - x1275
val x1277 = x1239 - x1140
val x1289 = x1271 * x1057
val x1290 = x1289 * x1253
val x1291 = x1277 - x1290
val x1304 = x1303 * x1232
val x1305 = x1304 * x1274
val x1306 = x1291 - x1305
val x1323 = x1276 + x1306
val x1324 = x1323 / 2.0
x991 = x1324
()
}
def x1327elseb(): Unit = {
()
}
if (x1322) {
x1327thenb()
} else {
x1327elseb()
}
}
val x1328 = x1002 += 1
()
}
def x1330elseb(): Unit = {
()
}
if (x1230) {
x1330thenb()
} else {
x1330elseb()
}
}
x1330
}
def x1332elseb(): Unit = {
()
}
if (x1208) {
x1332thenb()
} else {
x1332elseb()
}
}
x1332
}
def x1334elseb(): Unit = {
()
}
if (x1163) {
x1334thenb()
} else {
x1334elseb()
}
}
x1334
}
def x1336elseb(): Unit = {
()
}
if (x1067) {
x1336thenb()
} else {
x1336elseb()
}
}
x1336
x1004 = x1004 + 1
}
val x1339 = x1002
val x1340 = x1339==0
val x1345 = {
def x1345thenb(): Unit = {
val x1341 = x997 += 1
()
}
def x1345elseb(): Unit = {
x997 = 0
()
}
if (x1340) {
x1345thenb()
} else {
x1345elseb()
}
}
x1345
}
var x1348 : Int = 0
val x1378 = while (x1348 < x992) {
val x1349 = x990
val x1353 = x995(x1348)
val x1367 = x1349.length
val x1368 = x1349.isRow
val x1360 = x974(x1348)
val x1366 = {
val x1362 = new generated.scala.DoubleVectorImpl(x986,true)
x1362
}
var x1354 = 0
while (x1354 < x986) {  // begin fat loop x1366
val x1357 = x851(x1348, x1354)
val x1358 = x1357 * x1353
val x1451 = x1358 * x1360
x1366.dcUpdate(x1354, x1451)
x1354 += 1
} // end fat loop x1366
val x1375 = {
val x1370 = new generated.scala.DoubleVectorImpl(x1367,x1368)
x1370
}
var x1369 = 0
while (x1369 < x1367) {  // begin fat loop x1375
val x1372 = x1349(x1369)
val x1373 = x1366(x1369)
val x1374 = x1372 + x1373
x1375.dcUpdate(x1369, x1374)
x1369 += 1
} // end fat loop x1375
x990 = x1375
()
x1348 = x1348 + 1
}
val x1379 = print("\n")
val x1380 = println("toc:" + (System.nanoTime / 1000000L))
val x1381 = x973.numRows
val x1382 = new generated.scala.IndexVectorRangeImpl(0,x1381)
val x1409 = x1382.length
val x1410 = x1382.isRow
def x1413_block = {
val x1411 = new generated.scala.IntVectorImpl(x1409,x1410)
var mapIdx = 0
while (mapIdx < x1382.size) {
val x1383 = x1382.dcApply(mapIdx)
x1411.dcUpdate(mapIdx,  {
val x1384 = x990
val x1385 = x991
val x1390 = x1384.length
var x1404: Double = 0
var x1392 = 0
while (x1392 < x1390) {  // begin fat loop x1404
val x1395 = x1384(x1392)
val x1396 = x973(x1383, x1392)
val x1397 = x1395 * x1396
val x1400 = x1404
val x1401 = x1397
val x1403 = x1400 + x1401
x1404 = x1403
x1392 += 1
} // end fat loop x1404
val x1405 = x1404 + x1385
val x1406 = x1405 < 0.0
val x1407 = {
def x1407thenb(): Int = {
-1
}
def x1407elseb(): Int = {
1
}
if (x1406) {
x1407thenb()
} else {
x1407elseb()
}
}
x1407
})
mapIdx += 1
} // end while
x1411
}
val x1413 = x1413_block
val x1414 = println("SVM testing finished. Calculating error..")
var x1415 = 0
var x1417 : Int = 0
val x1425 = while (x1417 < x1381) {
val x1418 = x979(x1417)
val x1419 = x1413(x1417)
val x1420 = x1418 != x1419
val x1423 = {
def x1423thenb(): Unit = {
val x1421 = x1415 += 1
()
}
def x1423elseb(): Unit = {
()
}
if (x1420) {
x1423thenb()
} else {
x1423elseb()
}
}
x1423
x1417 = x1417 + 1
}
val x1426 = x1415
val x1427 = x1426.doubleValue()
val x1428 = x1381.doubleValue()
val x1429 = x1427 / x1428
val x1430 = "Classification error: "+x1429
val x1431 = println(x1430)
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
