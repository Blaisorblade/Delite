/*****************************************
  Emitting Generated Code                  
*******************************************/
class SpadeRunner extends ((Array[java.lang.String])=>(Unit)) {
def apply(x0:Array[java.lang.String]): Unit = {
val x1 = x0.length
val x2 = x1 < 2
val x6 = {
def x6thenb(): Nothing = {
val x3 = println("Usage: Spade <input data file> <output data file>")
val x4 = exit(-1)
x4
}
def x6elseb(): Unit = {
()
}
if (x2) {
x6thenb()
} else {
x6elseb()
}
}
val x7 = x0(0)
val x52 = { 
val x8 = new java.io.FileReader(x7)
val x9 = new java.io.BufferedReader(x8)
val x10 = x9.readLine()
var x11: java.lang.String = x10
val x12 = x11
val x13 = x12.trim()
x11 = x13
val x15 = x11
val x16 = x15.split("\\s+")
var x17: Array[java.lang.String] = x16
val x18 = x17
val x19 = x18.length
val x20 = new generated.scala.DoubleMatrixImpl(0,x19)
val x49 = while ({val x21 = x11
val x22 = x21 != null
x22}) {
val x24 = x17
val x25 = x24.length
val x26 = new generated.scala.DoubleVectorImpl(x25,true)
var x28 : Int = 0
val x34 = while (x28 < x25) {
val x29 = x17
val x30 = x29(x28)
val x31 = java.lang.Double.parseDouble(x30)
val x32 = x26(x28) = x31
x32
x28 = x28 + 1
}
val x35 = x20.numRows
val x36 = x20.insertRow(x35,x26)
val x37 = x9.readLine()
x11 = x37
val x39 = x11
val x40 = x39 != null
val x47 = {
def x47thenb(): Unit = {
val x41 = x39.trim()
x11 = x41
val x43 = x11
val x44 = x43.split("\\s+")
x17 = x44
()
}
def x47elseb(): Unit = {
()
}
if (x40) {
x47thenb()
} else {
x47elseb()
}
}
x47
}
val x50 = x9.close()
x20
}
val x53 = new generated.scala.IntVectorImpl(0,false)
val x54 = new generated.scala.IntLabelsImpl(x53)
val x55 = new generated.scala.DoubleIntTrainingSetImpl(x52,x54)
val x56 = Seq()
val x57 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
val x58 = new generated.scala.IntVectorImpl(0,true)
val x59 = x58.length
val x60 = x58.insert(x59, 0)
val x61 = x55.numRows
val x62 = "   Input matrix size: "+x61
val x63 = x62+"*"
val x64 = x55.numCols
val x65 = x63+x64
val x66 = println(x65)
val x72 = new generated.scala.IntVectorImpl(0,true)
val x73 = x72.length
val x74 = x72.insert(x73, x61)
val x75 = x72.length
val x76 = x72.insert(x75, 2000)
val x77 = x72.length
val x67 = x61
val x68 = 2.5E9f / x67
val x69 = x68
val x70 = Math.floor(x69)
val x71 = x70.asInstanceOf[Int]
val x78 = x72.insert(x77, x71)
val x79 = x72.length
// a *thin* loop follows: x87
var x87: Int = 2147483647
var x80 = 0
while (x80 < x79) {  // begin fat loop x87
val x83 = x72(x80)
val x81 = x87
val x82 = x83
val x85 = x81 < x82
val x86 = {
def x86thenb(): Int = {
x81
}
def x86elseb(): Int = {
x82
}
if (x85) {
x86thenb()
} else {
x86elseb()
}
}
x87 = x86
x80 += 1
} // end fat loop x87
val x88 = "   numSamples = "+x87
val x89 = println(x88)
val x90 = println("   finding empirical dist of the min distance between cells ...")
val x113 = new generated.scala.IndexVectorRangeImpl(0,x87)
val x91 = new generated.scala.IndexVectorRangeImpl(0,x61)
val x92 = x91.length
val x93 = new generated.scala.IndexVectorRangeImpl(0,x92)
val x95 = x91.isRow
val x112 = { 
val x94 = x93.cloneL
val x96 = new generated.scala.IntVectorImpl(0,x95)
var x98 : Int = 0
val x110 = while (x98 < x87) {
val x99 = x92 - x98
val x100 = generated.scala.Global.randRef.nextInt(x99)
val x101 = x98 + x100
val x102 = x94(x101)
val x104 = x96.length
val x103 = x91(x102)
val x105 = x96.insert(x104, x103)
val x106 = x94(x98)
val x107 = x94(x101) = x106
val x108 = x94(x98) = x102
x108
x98 = x98 + 1
}
x96
}
val x159 = !false
val x197 = x113.length
val x198 = x113.isRow
def x201_block = {
val x199 = new generated.scala.DoubleVectorImpl(x197,x198)
var mapIdx = 0
while (mapIdx < x113.size) { // begin map loop x201
val x114 = x113.dcApply(mapIdx)
x199.dcUpdate(mapIdx,  {
val x115 = x112(x114)
val x122 = {
val x118 = new generated.scala.DoubleVectorImpl(x64,true)
x118
}
var x117 = 0
while (x117 < x64) {  // begin fat loop x122
val x120 = x55(x115, x117)
val x121 = x120 - x120
x122.dcUpdate(x117, x121)
x117 += 1
} // end fat loop x122
val x128 = {
val x124 = new generated.scala.DoubleVectorImpl(x64,true)
x124
}
var x123 = 0
while (x123 < x64) {  // begin fat loop x128
val x126 = x122(x123)
val x127 = java.lang.Math.abs(x126)
x128.dcUpdate(x123, x127)
x123 += 1
} // end fat loop x128
var x134: Double = 0
var x129 = 0
while (x129 < x64) {  // begin fat loop x134
val x132 = x128(x129)
val x130 = x134
val x131 = x132
val x133 = x130 + x131
x134 = x133
x129 += 1
} // end fat loop x134
val x135 = { 
x134
}
def x165_block = {
val x163 = new generated.scala.DoubleVectorImpl(x92,x95)
var mapIdx = 0
while (mapIdx < x91.size) { // begin map loop x165
val x136 = x91.dcApply(mapIdx)
x163.dcUpdate(mapIdx,  {
val x144 = {
val x139 = new generated.scala.DoubleVectorImpl(x64,true)
x139
}
var x138 = 0
while (x138 < x64) {  // begin fat loop x144
val x141 = x55(x115, x138)
val x142 = x55(x136, x138)
val x143 = x141 - x142
x144.dcUpdate(x138, x143)
x138 += 1
} // end fat loop x144
val x150 = {
val x146 = new generated.scala.DoubleVectorImpl(x64,true)
x146
}
var x145 = 0
while (x145 < x64) {  // begin fat loop x150
val x148 = x144(x145)
val x149 = java.lang.Math.abs(x148)
x150.dcUpdate(x145, x149)
x145 += 1
} // end fat loop x150
var x156: Double = 0
var x151 = 0
while (x151 < x64) {  // begin fat loop x156
val x154 = x150(x151)
val x152 = x156
val x153 = x154
val x155 = x152 + x153
x156 = x155
x151 += 1
} // end fat loop x156
val x157 = { 
x156
}
val x158 = x157==x135
val x160 = x158 && x159
val x162 = {
def x162thenb(): Double = {
val x161 = 2147483647.asInstanceOf[Double]
x161
}
def x162elseb(): Double = {
x157
}
if (x160) {
x162thenb()
} else {
x162elseb()
}
}
x162
})
mapIdx += 1
} // end map loop x165
x163
}
val x165 = x165_block
val x166 = x165.length
var x174: Int = 0
var x167 = 0
while (x167 < x166) {  // begin fat loop x174
val x168 = x174
val x169 = x167
val x170 = x165(x168)
val x171 = x165(x169)
val x172 = x170 < x171
val x173 = {
def x173thenb(): Int = {
x168
}
def x173elseb(): Int = {
x169
}
if (x172) {
x173thenb()
} else {
x173elseb()
}
}
x174 = x173
x167 += 1
} // end fat loop x174
val x182 = {
val x177 = new generated.scala.DoubleVectorImpl(x64,true)
x177
}
var x176 = 0
while (x176 < x64) {  // begin fat loop x182
val x179 = x55(x115, x176)
val x180 = x55(x174, x176)
val x181 = x179 - x180
x182.dcUpdate(x176, x181)
x176 += 1
} // end fat loop x182
val x188 = {
val x184 = new generated.scala.DoubleVectorImpl(x64,true)
x184
}
var x183 = 0
while (x183 < x64) {  // begin fat loop x188
val x186 = x182(x183)
val x187 = java.lang.Math.abs(x186)
x188.dcUpdate(x183, x187)
x183 += 1
} // end fat loop x188
var x194: Double = 0
var x189 = 0
while (x189 < x64) {  // begin fat loop x194
val x192 = x188(x189)
val x190 = x194
val x191 = x192
val x193 = x190 + x191
x194 = x193
x189 += 1
} // end fat loop x194
val x195 = { 
x194
}
x195
})
mapIdx += 1
} // end map loop x201
x199
}
val x201 = x201_block
val x202 = x201.sort
val x203 = x202.length
val x204 = x203 / 2
val x205 = x202(x204)
val x206 = { 
x205
}
val x207 = "   med_min_dist = "+x206
val x208 = println(x207)
val x210 = 1.5 * x206
val x209 = 5.0 * x206
val x211 = "   For this "+x61
val x212 = x211+" channel data, KERNEL WIDTH is "
val x213 = x212+x209
val x214 = x213+", APPRX WIDTH is "
val x215 = x214+x210
val x216 = println(x215)
val x217 = println("   finding local density for each cell ...")
val x246 = new generated.scala.IntVectorImpl(x61,true)
var x251: Int = 0
val x243 = 100000 / x61
val x244 = x243 + 1000
val x247 = x244.doubleValue()
val x248 = x67 / x247
val x249 = Math.ceil(x248)
val x250 = x249.asInstanceOf[Int]
val x242 = { (x218: Int, x219: Int) => 
val x228 = {
val x223 = new generated.scala.DoubleVectorImpl(x64,true)
x223
}
var x222 = 0
while (x222 < x64) {  // begin fat loop x228
val x225 = x55(x218, x222)
val x226 = x55(x219, x222)
val x227 = x225 - x226
x228.dcUpdate(x222, x227)
x222 += 1
} // end fat loop x228
val x234 = {
val x230 = new generated.scala.DoubleVectorImpl(x64,true)
x230
}
var x229 = 0
while (x229 < x64) {  // begin fat loop x234
val x232 = x228(x229)
val x233 = java.lang.Math.abs(x232)
x234.dcUpdate(x229, x233)
x229 += 1
} // end fat loop x234
var x240: Double = 0
var x235 = 0
while (x235 < x64) {  // begin fat loop x240
val x238 = x234(x235)
val x236 = x240
val x237 = x238
val x239 = x236 + x237
x240 = x239
x235 += 1
} // end fat loop x240
val x241 = { 
x240
}
x241: Double
}
val x245 = new generated.scala.DoubleStreamImpl(x61,x61,x244,x242,true)
val x261 = List()
val x322 = while ({val x252 = x251
val x253 = x252 < x250
x253}) {
val x255 = x251
val x259 = x251
val x256 = x245.rowsIn(x255)
val x257 = new generated.scala.IndexVectorRangeImpl(0,x256)
val x264 = x259 * x244
def x319_block = {
var forIdx = 0
while (forIdx < x257.size) { // begin foreach loop x319
val x258 = x257.dcApply(forIdx)
val x265 = x264 + x258
val x289 = x265 % 1000
val x290 = x289==0
val x294 = {
def x294thenb(): Unit = {
val x291 = "  (streaming) # processed node = "+x265
val x292 = println(x291)
x292
}
def x294elseb(): Unit = {
()
}
if (x290) {
x294thenb()
} else {
x294elseb()
}
}
val x295 = x246(x265)
val x296 = x295==0
val x317 = {
def x317thenb(): Unit = {
val x263 = x245.chunkRow(x258,x259)
val x288 = {
x263
}
var x262 = 0
while (x262 < x61) {  // begin fat loop x288
val x274 = {
val x269 = new generated.scala.DoubleVectorImpl(x64,true)
x269
}
var x268 = 0
while (x268 < x64) {  // begin fat loop x274
val x271 = x55(x265, x268)
val x272 = x55(x262, x268)
val x273 = x271 - x272
x274.dcUpdate(x268, x273)
x268 += 1
} // end fat loop x274
val x280 = {
val x276 = new generated.scala.DoubleVectorImpl(x64,true)
x276
}
var x275 = 0
while (x275 < x64) {  // begin fat loop x280
val x278 = x274(x275)
val x279 = java.lang.Math.abs(x278)
x280.dcUpdate(x275, x279)
x275 += 1
} // end fat loop x280
var x286: Double = 0
var x281 = 0
while (x281 < x64) {  // begin fat loop x286
val x284 = x280(x281)
val x282 = x286
val x283 = x284
val x285 = x282 + x283
x286 = x285
x281 += 1
} // end fat loop x286
val x287 = { 
x286
}
x288.dcUpdate(x262, x287)
x262 += 1
} // end fat loop x288
val x303 = {
val x298 = new generated.scala.IntVectorImpl(0,true)
val x299 = new generated.scala.IndexVectorSeqImpl(x298)
//TODO: buffer size might be wrong (loop has conditions)
x299
}
var x297 = 0
while (x297 < x61) {  // begin fat loop x303
val x301 = x288(x297)
val x302 = x301 < x210
if (x302) x303.insert(x303.length, x297)
x297 += 1
} // end fat loop x303
var x310: Int = 0
var x304 = 0
while (x304 < x61) {  // begin fat loop x310
val x307 = x288(x304)
val x308 = x307 < x209
if (x308) {
val x305 = x310
val x306 = 1
val x309 = x305 + x306
x310 = x309
}
x304 += 1
} // end fat loop x310
def x315_block = {
var forIdx = 0
while (forIdx < x303.size) { // begin foreach loop x315
val x312 = x303.dcApply(forIdx)
val x313 = x246(x312) = x310
x313
forIdx += 1
} // end foreach loop x315
}
val x315 = x315_block
x315
}
def x317elseb(): Unit = {
()
}
if (x296) {
x317thenb()
} else {
x317elseb()
}
}
x317
forIdx += 1
} // end foreach loop x319
}
val x319 = x319_block
val x320 = x251 += 1
()
}
val x323 = Seq(x246)
val x324 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
var x325: Int = 0
val x335 = while ({val x326 = x325
val x327 = x326 < 9
x327}) {
val x329 = x325
val x330 = x246(x329)
val x331 = x330+" "
val x332 = print(x331)
val x333 = x325 += 1
()
}
val x336 = println(())
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
