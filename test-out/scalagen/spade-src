/*****************************************
  Emitting Generated Code                  
*******************************************/
class SpadeRunner extends ((Array[java.lang.String])=>(Unit)) {
def apply(x0:Array[java.lang.String]): Unit = {
val x1 = x0.length
val x2 = x1 < 2
val x6 = {
def x6thenb(): Nothing = {
val x3 = println("Usage: Spade <input data file> <output data file>")
val x4 = exit(-1)
x4
}
if (x2) {
x6thenb()
}
}
val x7 = x0(0)
val x54 = { 
val x8 = new java.io.FileReader(x7)
val x9 = new java.io.BufferedReader(x8)
val x10 = x9.readLine()
var x11: java.lang.String = x10
val x12 = x11
val x13 = x12.trim()
x11 = x13
val x15 = x11
val x16 = x15.split("\\s+")
var x17: Array[java.lang.String] = x16
val x18 = x17
val x19 = x18.length
val x20 = new generated.scala.DoubleMatrixImpl(0,x19)
val x50 = while ({val x21 = x11
val x22 = x21 != null
x22}) {
val x24 = x17
val x25 = x24.length
val x26 = new generated.scala.DoubleVectorImpl(x25,true)
var x28 : Int = 0
val x34 = while (x28 < x25) {
val x29 = x17
val x30 = x29(x28)
val x31 = java.lang.Double.parseDouble(x30)
val x32 = x26(x28) = x31
x32
x28 = x28 + 1
}
val x35 = x26// unsafe immutable
val x36 = x20.numRows
val x37 = x20.insertRow(x36,x35)
val x38 = x9.readLine()
x11 = x38
val x40 = x11
val x41 = x40 != null
val x42 = x40.trim()
val x48 = {
def x48thenb(): Unit = {
x11 = x42
val x44 = x11
val x45 = x44.split("\\s+")
x17 = x45
()
}
if (x41) {
x48thenb()
}
}
x48
}
val x51 = x9.close()
val x52 = x20// unsafe immutable
x52
}
val x55 = new generated.scala.IntVectorImpl(0,false)
val x56 = x55// unsafe immutable
val x57 = new generated.scala.IntLabelsImpl(x56)
val x58 = new generated.scala.DoubleIntTrainingSetImpl(x54,x57)
val x59 = Seq()
val x60 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
val x61 = new generated.scala.IntVectorImpl(0,true)
val x62 = x61.length
val x63 = x61.insert(x62, 0)
val x64 = x61.cloneL
val x65 = x58.numRows
val x66 = "   Input matrix size: "+x65
val x67 = x66+"*"
val x68 = x58.numCols
val x69 = x67+x68
val x70 = println(x69)
val x76 = new generated.scala.IntVectorImpl(0,true)
val x77 = x76.length
val x78 = x76.insert(x77, x65)
val x79 = x76.length
val x80 = x76.insert(x79, 2000)
val x81 = x76.length
val x71 = x65
val x72 = 2.5E9f / x71
val x73 = x72
val x74 = Math.floor(x73)
val x75 = x74.asInstanceOf[Int]
val x82 = x76.insert(x81, x75)
val x83 = x76.cloneL
val x84 = x76.length
var x91: Int = 2147483647
var x85 = 0
while (x85 < x84) {  // begin fat loop x91
val x88 = x83(x85)
val x86 = x91
val x87 = x88
val x89 = x86 < x87
val x90 = {
def x90thenb(): Int = {
x86
}
def x90elseb(): Int = {
x87
}
if (x89) {
x90thenb()
} else { 
x90elseb()
}
}
x91 = x90
x85 += 1
} // end fat loop x91
val x92 = "   numSamples = "+x91
val x93 = println(x92)
val x94 = println("   finding empirical dist of the min distance between cells ...")
val x95 = println("   med_min_dist = 4.4593519740000005")
val x96 = "   For this "+x65
val x97 = x96+" channel data, KERNEL WIDTH is "
val x98 = x97+22.296759870000002
val x99 = x98+", APPRX WIDTH is "
val x100 = x99+6.689027961000001
val x101 = println(x100)
val x102 = println("   finding local density for each cell ...")
val x137 = new generated.scala.IntVectorImpl(x65,true)
var x142: Int = 0
val x134 = 100000 / x65
val x135 = x134 + 1000
val x138 = x135.doubleValue()
val x139 = x71 / x138
val x140 = Math.ceil(x139)
val x141 = x140.asInstanceOf[Int]
val x143 = x142
val x144 = x143 < x141
val x145 = x143 * x135
val x146 = x65 - x145
val x147 = x146 < 0
val x148 = {
def x148thenb(): Int = {
x65
}
def x148elseb(): Int = {
x146
}
if (x147) {
x148thenb()
} else { 
x148elseb()
}
}
val x149 = Math.min(x135, x148)
val x150 = x149.asInstanceOf[Int]
val x151 = { 
x150
}
val x152 = new generated.scala.IndexVectorRangeImpl(0,x151)
val x155 = List()
val x133 = { (x103: Int, x104: Int) => 
val x110 = x103 * x68
val x114 = x104 * x68
val x119 = {
val x108 = new generated.scala.DoubleVectorImpl(x68,true)
x108
}
var x107 = 0
while (x107 < x68) {  // begin fat loop x119
val x111 = x110 + x107
val x112 = x58.dcApply(x111)
val x113 = { 
x112
}
val x115 = x114 + x107
val x116 = x58.dcApply(x115)
val x117 = { 
x116
}
val x118 = x113 - x117
x119.dcUpdate(x107, x118)
x107 += 1
} // end fat loop x119
val x125 = {
val x121 = new generated.scala.DoubleVectorImpl(x68,true)
x121
}
var x120 = 0
while (x120 < x68) {  // begin fat loop x125
val x123 = x119(x120)
val x124 = java.lang.Math.abs(x123)
x125.dcUpdate(x120, x124)
x120 += 1
} // end fat loop x125
var x131: Double = 0
var x126 = 0
while (x126 < x68) {  // begin fat loop x131
val x129 = x125(x126)
val x127 = x131
val x128 = x129
val x130 = x127 + x128
x131 = x130
x126 += 1
} // end fat loop x131
val x132 = { 
x131
}
x132: Double
}
val x136 = new generated.scala.DoubleStreamImpl(x65,x65,x135,x133,true)
val x220 = while ({x144}) {
val x217 = {
var forIdx = 0
while (forIdx < x152.size) { // begin foreach loop x217
val x153 = x152.dcApply(forIdx)
val x158 = x145 + x153
val x188 = x158 % 1000
val x189 = x188==0
val x190 = "  (streaming) # processed node = "+x158
val x193 = {
def x193thenb(): Unit = {
val x191 = println(x190)
x191
}
if (x189) {
x193thenb()
}
}
val x194 = x137(x158)
val x195 = x194==0
val x157 = x136.chunkRow(x153,x143)
val x164 = x158 * x68
val x187 = {
x157
}
var x156 = 0
while (x156 < x65) {  // begin fat loop x187
val x168 = x156 * x68
val x173 = {
val x162 = new generated.scala.DoubleVectorImpl(x68,true)
x162
}
var x161 = 0
while (x161 < x68) {  // begin fat loop x173
val x165 = x164 + x161
val x166 = x58.dcApply(x165)
val x167 = { 
x166
}
val x169 = x168 + x161
val x170 = x58.dcApply(x169)
val x171 = { 
x170
}
val x172 = x167 - x171
x173.dcUpdate(x161, x172)
x161 += 1
} // end fat loop x173
val x179 = {
val x175 = new generated.scala.DoubleVectorImpl(x68,true)
x175
}
var x174 = 0
while (x174 < x68) {  // begin fat loop x179
val x177 = x173(x174)
val x178 = java.lang.Math.abs(x177)
x179.dcUpdate(x174, x178)
x174 += 1
} // end fat loop x179
var x185: Double = 0
var x180 = 0
while (x180 < x68) {  // begin fat loop x185
val x183 = x179(x180)
val x181 = x185
val x182 = x183
val x184 = x181 + x182
x185 = x184
x180 += 1
} // end fat loop x185
val x186 = { 
x185
}
x187.dcUpdate(x156, x186)
x156 += 1
} // end fat loop x187
val x201 = {
val x197 = new generated.scala.IndexVectorSeqImpl(0)
//TODO: buffer size might be wrong (loop has conditions)
x197
}
var x196 = 0
while (x196 < x65) {  // begin fat loop x201
val x199 = x187(x196)
val x200 = x199 < 6.689027961000001
if (x200) x201.insert(x201.length, x196)
x196 += 1
} // end fat loop x201
var x208: Int = 0
var x202 = 0
while (x202 < x65) {  // begin fat loop x208
val x205 = x187(x202)
val x206 = x205 < 22.296759870000002
if (x206) {
val x203 = x208
val x204 = 1
val x207 = x203 + x204
x208 = x207
}
x202 += 1
} // end fat loop x208
val x215 = {
def x215thenb(): Unit = {
val x213 = {
var forIdx = 0
while (forIdx < x201.size) { // begin foreach loop x213
val x210 = x201.dcApply(forIdx)
val x211 = x137(x210) = x208
x211
forIdx += 1
} // end foreach loop x213
}
x213
}
if (x195) {
x215thenb()
}
}
x215
forIdx += 1
} // end foreach loop x217
}
val x218 = x142 += 1
()
}
val x221 = Seq(x137)
val x222 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
var x223: Int = 0
val x224 = x223
val x225 = x224 < 9
val x231 = while ({x225}) {
val x226 = x137(x224)
val x227 = x226+" "
val x228 = print(x227)
val x229 = x223 += 1
()
}
val x232 = println(())
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
