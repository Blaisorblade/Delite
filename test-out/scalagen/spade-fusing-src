/*****************************************
  Emitting Generated Code                  
*******************************************/
class SpadeRunnerFusing extends ((Array[java.lang.String])=>(Unit)) {
def apply(x338:Array[java.lang.String]): Unit = {
val x339 = x338.length
val x340 = x339 < 2
val x344 = {
def x344thenb(): Nothing = {
val x341 = println("Usage: Spade <input data file> <output data file>")
val x342 = exit(-1)
x342
}
def x344elseb(): Unit = {
()
}
if (x340) {
x344thenb()
} else {
x344elseb()
}
}
val x345 = x338(0)
val x390 = { 
val x346 = new java.io.FileReader(x345)
val x347 = new java.io.BufferedReader(x346)
val x348 = x347.readLine()
var x349: java.lang.String = x348
val x350 = x349
val x351 = x350.trim()
x349 = x351
val x353 = x349
val x354 = x353.split("\\s+")
var x355: Array[java.lang.String] = x354
val x356 = x355
val x357 = x356.length
val x358 = new generated.scala.DoubleMatrixImpl(0,x357)
val x387 = while ({val x359 = x349
val x360 = x359 != null
x360}) {
val x362 = x355
val x363 = x362.length
val x364 = new generated.scala.DoubleVectorImpl(x363,true)
var x366 : Int = 0
val x372 = while (x366 < x363) {
val x367 = x355
val x368 = x367(x366)
val x369 = java.lang.Double.parseDouble(x368)
val x370 = x364(x366) = x369
x370
x366 = x366 + 1
}
val x373 = x358.numRows
val x374 = x358.insertRow(x373,x364)
val x375 = x347.readLine()
x349 = x375
val x377 = x349
val x378 = x377 != null
val x385 = {
def x385thenb(): Unit = {
val x379 = x377.trim()
x349 = x379
val x381 = x349
val x382 = x381.split("\\s+")
x355 = x382
()
}
def x385elseb(): Unit = {
()
}
if (x378) {
x385thenb()
} else {
x385elseb()
}
}
x385
}
val x388 = x347.close()
x358
}
val x391 = new generated.scala.IntVectorImpl(0,false)
val x392 = new generated.scala.IntLabelsImpl(x391)
val x393 = new generated.scala.DoubleIntTrainingSetImpl(x390,x392)
val x56 = Seq()
val x394 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
val x395 = new generated.scala.IntVectorImpl(0,true)
val x396 = x395.length
val x397 = x395.insert(x396, 0)
val x398 = x393.numRows
val x399 = "   Input matrix size: "+x398
val x400 = x399+"*"
val x401 = x393.numCols
val x402 = x400+x401
val x403 = println(x402)
val x409 = new generated.scala.IntVectorImpl(0,true)
val x410 = x409.length
val x411 = x409.insert(x410, x398)
val x412 = x409.length
val x413 = x409.insert(x412, 2000)
val x414 = x409.length
val x404 = x398
val x405 = 2.5E9f / x404
val x406 = x405
val x407 = Math.floor(x406)
val x408 = x407.asInstanceOf[Int]
val x415 = x409.insert(x414, x408)
val x416 = x409.length
// a *thin* loop follows: x424
var x424: Int = 2147483647
var x417 = 0
while (x417 < x416) {  // begin fat loop x424
val x420 = x409(x417)
val x418 = x424
val x419 = x420
val x422 = x418 < x419
val x423 = {
def x423thenb(): Int = {
x418
}
def x423elseb(): Int = {
x419
}
if (x422) {
x423thenb()
} else {
x423elseb()
}
}
x424 = x423
x417 += 1
} // end fat loop x424
val x425 = "   numSamples = "+x424
val x426 = println(x425)
val x427 = println("   finding empirical dist of the min distance between cells ...")
val x450 = new generated.scala.IndexVectorRangeImpl(0,x424)
val x428 = new generated.scala.IndexVectorRangeImpl(0,x398)
val x429 = x428.length
val x430 = new generated.scala.IndexVectorRangeImpl(0,x429)
val x432 = x428.isRow
val x449 = { 
val x431 = x430.cloneL
val x433 = new generated.scala.IntVectorImpl(0,x432)
var x435 : Int = 0
val x447 = while (x435 < x424) {
val x436 = x429 - x435
val x437 = generated.scala.Global.randRef.nextInt(x436)
val x438 = x435 + x437
val x439 = x431(x438)
val x441 = x433.length
val x440 = x428(x439)
val x442 = x433.insert(x441, x440)
val x443 = x431(x435)
val x444 = x431(x438) = x443
val x445 = x431(x435) = x439
x445
x435 = x435 + 1
}
x433
}
val x159 = !false
val x532 = x450.length
val x533 = x450.isRow
def x536_block = {
val x534 = new generated.scala.DoubleVectorImpl(x532,x533)
var mapIdx = 0
while (mapIdx < x450.size) { // begin map loop x536
val x451 = x450.dcApply(mapIdx)
x534.dcUpdate(mapIdx,  {
val x452 = x449(x451)
var x471: Double = 0
var x466 = 0
while (x466 < x401) {  // begin fat loop x471
val x674 = x393(x452, x466)
val x675 = x674 - x674
val x676 = java.lang.Math.abs(x675)
val x467 = x471
val x468 = x676
val x470 = x467 + x468
x471 = x470
x466 += 1
} // end fat loop x471
val x472 = { 
x471
}
def x500_block = {
val x498 = new generated.scala.DoubleVectorImpl(x429,x432)
var mapIdx = 0
while (mapIdx < x428.size) { // begin map loop x500
val x473 = x428.dcApply(mapIdx)
x498.dcUpdate(mapIdx,  {
var x493: Double = 0
var x488 = 0
while (x488 < x401) {  // begin fat loop x493
val x682 = x393(x452, x488)
val x683 = x393(x473, x488)
val x684 = x682 - x683
val x685 = java.lang.Math.abs(x684)
val x489 = x493
val x490 = x685
val x492 = x489 + x490
x493 = x492
x488 += 1
} // end fat loop x493
val x494 = { 
x493
}
val x495 = x494==x472
val x496 = x495 && x159
val x497 = {
def x497thenb(): Double = {
val x161 = 2147483647.asInstanceOf[Double]
x161
}
def x497elseb(): Double = {
x494
}
if (x496) {
x497thenb()
} else {
x497elseb()
}
}
x497
})
mapIdx += 1
} // end map loop x500
x498
}
val x500 = x500_block
val x501 = x500.length
var x509: Int = 0
var x502 = 0
while (x502 < x501) {  // begin fat loop x509
val x503 = x509
val x504 = x502
val x505 = x500(x503)
val x506 = x500(x504)
val x507 = x505 < x506
val x508 = {
def x508thenb(): Int = {
x503
}
def x508elseb(): Int = {
x504
}
if (x507) {
x508thenb()
} else {
x508elseb()
}
}
x509 = x508
x502 += 1
} // end fat loop x509
var x529: Double = 0
var x524 = 0
while (x524 < x401) {  // begin fat loop x529
val x677 = x393(x452, x524)
val x678 = x393(x509, x524)
val x679 = x677 - x678
val x680 = java.lang.Math.abs(x679)
val x525 = x529
val x526 = x680
val x528 = x525 + x526
x529 = x528
x524 += 1
} // end fat loop x529
val x530 = { 
x529
}
x530
})
mapIdx += 1
} // end map loop x536
x534
}
val x536 = x536_block
val x537 = x536.sort
val x538 = x537.length
val x539 = x538 / 2
val x540 = x537(x539)
val x541 = { 
x540
}
val x542 = "   med_min_dist = "+x541
val x543 = println(x542)
val x545 = 1.5 * x541
val x544 = 5.0 * x541
val x546 = "   For this "+x398
val x547 = x546+" channel data, KERNEL WIDTH is "
val x548 = x547+x544
val x549 = x548+", APPRX WIDTH is "
val x550 = x549+x545
val x551 = println(x550)
val x552 = println("   finding local density for each cell ...")
val x581 = new generated.scala.IntVectorImpl(x398,true)
var x586: Int = 0
val x578 = 100000 / x398
val x579 = x578 + 1000
val x582 = x579.doubleValue()
val x583 = x404 / x582
val x584 = Math.ceil(x583)
val x585 = x584.asInstanceOf[Int]
val x261 = List()
val x577 = { (x553: Int, x554: Int) => 
var x575: Double = 0
var x570 = 0
while (x570 < x401) {  // begin fat loop x575
val x687 = x393(x553, x570)
val x688 = x393(x554, x570)
val x689 = x687 - x688
val x690 = java.lang.Math.abs(x689)
val x571 = x575
val x572 = x690
val x574 = x571 + x572
x575 = x574
x570 += 1
} // end fat loop x575
val x576 = { 
x575
}
x576: Double
}
val x580 = new generated.scala.DoubleStreamImpl(x398,x398,x579,x577,true)
val x656 = while ({val x587 = x586
val x588 = x587 < x585
x588}) {
val x590 = x586
val x594 = x586
val x591 = x580.rowsIn(x590)
val x592 = new generated.scala.IndexVectorRangeImpl(0,x591)
val x598 = x594 * x579
def x653_block = {
var forIdx = 0
while (forIdx < x592.size) { // begin foreach loop x653
val x593 = x592.dcApply(forIdx)
println("in x653: forIdx="+forIdx+",x593="+x593)
val x599 = x598 + x593
val x623 = x599 % 1000
val x624 = x623==0
val x628 = {
def x628thenb(): Unit = {
val x625 = "  (streaming) # processed node = "+x599
val x626 = println(x625)
x626
}
def x628elseb(): Unit = {
()
}
if (x624) {
x628thenb()
} else {
x628elseb()
}
}
val x629 = x581(x599)
val x630 = x629==0
val x651 = {
def x651thenb(): Unit = {
val x637 = {
val x632 = new generated.scala.IntVectorImpl(0,true)
val x633 = new generated.scala.IndexVectorSeqImpl(x632)
//TODO: buffer size might be wrong (loop has conditions)
x633
}
var x644: Int = 0
var x596 = 0
while (x596 < x398) {  // begin fat loop x637,x644
println("in x637,x644: x596="+x596)
var x620: Double = 0
var x615 = 0
while (x615 < x401) {  // begin fat loop x620
//print(".")
val x694 = x393(x599, x615)
val x695 = x393(x596, x615)
val x696 = x694 - x695
val x697 = java.lang.Math.abs(x696)
val x616 = x620
val x617 = x697
val x619 = x616 + x617
x620 = x619
x615 += 1
} // end fat loop x620
println("inner loop count "+615)
val x621 = { 
x620
}
val x691 = x621 < x545
val x692 = x621 < x544
if (x691) x637.insert(x637.length, x596)
if (x692) {
val x639 = x644
val x640 = 1
val x643 = x639 + x640
x644 = x643
}
x596 += 1
} // end fat loop x637,x644
println(x644)
def x649_block = {
var forIdx = 0
while (forIdx < x637.size) { // begin foreach loop x649
println("in x649: forIdx="+forIdx)
val x646 = x637.dcApply(forIdx)
val x647 = x581(x646) = x644
x647
forIdx += 1
} // end foreach loop x649
}
val x649 = x649_block
x649
}
def x651elseb(): Unit = {
()
}
if (x630) {
x651thenb()
} else {
x651elseb()
}
}
x651
forIdx += 1
} // end foreach loop x653
}
val x653 = x653_block
val x654 = x586 += 1
()
}
val x657 = Seq(x581)
val x658 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
var x659: Int = 0
val x669 = while ({val x660 = x659
val x661 = x660 < 9
x661}) {
val x663 = x659
val x664 = x581(x663)
val x665 = x664+" "
val x666 = print(x665)
val x667 = x659 += 1
()
}
val x670 = println(())
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
