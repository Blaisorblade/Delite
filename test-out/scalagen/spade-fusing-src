/*****************************************
  Emitting Generated Code                  
*******************************************/
class SpadeRunnerFusing extends ((Array[java.lang.String])=>(Unit)) {
def apply(x363:Array[java.lang.String]): Unit = {
val x364 = x363.length
val x365 = x364 < 2
val x369 = {
def x369thenb(): Nothing = {
val x366 = println("Usage: Spade <input data file> <output data file>")
val x367 = exit(-1)
x367
}
def x369elseb(): Unit = {
()
}
if (x365) {
x369thenb()
} else {
x369elseb()
}
}
val x370 = x363(0)
val x415 = { 
val x371 = new java.io.FileReader(x370)
val x372 = new java.io.BufferedReader(x371)
val x373 = x372.readLine()
var x374: java.lang.String = x373
val x375 = x374
val x376 = x375.trim()
x374 = x376
val x378 = x374
val x379 = x378.split("\\s+")
var x380: Array[java.lang.String] = x379
val x381 = x380
val x382 = x381.length
val x383 = new generated.scala.DoubleMatrixImpl(0,x382)
val x412 = while ({val x384 = x374
val x385 = x384 != null
x385}) {
val x387 = x380
val x388 = x387.length
val x389 = new generated.scala.DoubleVectorImpl(x388,true)
var x391 : Int = 0
val x397 = while (x391 < x388) {
val x392 = x380
val x393 = x392(x391)
val x394 = java.lang.Double.parseDouble(x393)
val x395 = x389(x391) = x394
x395
x391 = x391 + 1
}
val x398 = x383.numRows
val x399 = x383.insertRow(x398,x389)
val x400 = x372.readLine()
x374 = x400
val x402 = x374
val x403 = x402 != null
val x410 = {
def x410thenb(): Unit = {
val x404 = x402.trim()
x374 = x404
val x406 = x374
val x407 = x406.split("\\s+")
x380 = x407
()
}
def x410elseb(): Unit = {
()
}
if (x403) {
x410thenb()
} else {
x410elseb()
}
}
x410
}
val x413 = x372.close()
x383
}
val x416 = new generated.scala.IntVectorImpl(0,false)
val x417 = new generated.scala.IntLabelsImpl(x416)
val x418 = new generated.scala.DoubleIntTrainingSetImpl(x415,x417)
val x56 = Seq()
val x419 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
val x420 = new generated.scala.IntVectorImpl(0,true)
val x421 = x420.length
val x422 = x420.insert(x421, 0)
val x423 = x418.numRows
val x424 = "   Input matrix size: "+x423
val x425 = x424+"*"
val x426 = x418.numCols
val x427 = x425+x426
val x428 = println(x427)
val x434 = new generated.scala.IntVectorImpl(0,true)
val x435 = x434.length
val x436 = x434.insert(x435, x423)
val x437 = x434.length
val x438 = x434.insert(x437, 2000)
val x439 = x434.length
val x429 = x423
val x430 = 2.5E9f / x429
val x431 = x430
val x432 = Math.floor(x431)
val x433 = x432.asInstanceOf[Int]
val x440 = x434.insert(x439, x433)
val x441 = x434.length
// a *thin* loop follows: x449
var x449: Int = 2147483647
var x442 = 0
while (x442 < x441) {  // begin fat loop x449
val x445 = x434(x442)
val x443 = x449
val x444 = x445
val x447 = x443 < x444
val x448 = {
def x448thenb(): Int = {
x443
}
def x448elseb(): Int = {
x444
}
if (x447) {
x448thenb()
} else {
x448elseb()
}
}
x449 = x448
x442 += 1
} // end fat loop x449
val x450 = "   numSamples = "+x449
val x451 = println(x450)
val x452 = println("   finding empirical dist of the min distance between cells ...")
val x475 = new generated.scala.IndexVectorRangeImpl(0,x449)
val x453 = new generated.scala.IndexVectorRangeImpl(0,x423)
val x454 = x453.length
val x455 = new generated.scala.IndexVectorRangeImpl(0,x454)
val x457 = x453.isRow
val x474 = { 
val x456 = x455.cloneL
val x458 = new generated.scala.IntVectorImpl(0,x457)
var x460 : Int = 0
val x472 = while (x460 < x449) {
val x461 = x454 - x460
val x462 = generated.scala.Global.randRef.nextInt(x461)
val x463 = x460 + x462
val x464 = x456(x463)
val x466 = x458.length
val x465 = x453(x464)
val x467 = x458.insert(x466, x465)
val x468 = x456(x460)
val x469 = x456(x463) = x468
val x470 = x456(x460) = x464
x470
x460 = x460 + 1
}
x458
}
val x167 = !false
val x570 = x475.length
val x571 = x475.isRow
def x574_block = {
val x572 = new generated.scala.DoubleVectorImpl(x570,x571)
var mapIdx = 0
while (mapIdx < x475.size) { // begin map loop x574
val x476 = x475.dcApply(mapIdx)
x572.dcUpdate(mapIdx,  {
val x477 = x474(x476)
val x482 = x477 * x426
var x499: Double = 0
var x494 = 0
while (x494 < x426) {  // begin fat loop x499
val x724 = x482 + x494
val x725 = x418.dcApply(x724)
val x726 = { 
x725
}
val x727 = x726 - x726
val x728 = java.lang.Math.abs(x727)
val x495 = x499
val x496 = x728
val x498 = x495 + x496
x499 = x498
x494 += 1
} // end fat loop x499
val x500 = { 
x499
}
def x533_block = {
val x531 = new generated.scala.DoubleVectorImpl(x454,x457)
var mapIdx = 0
while (mapIdx < x453.size) { // begin map loop x533
val x501 = x453.dcApply(mapIdx)
x531.dcUpdate(mapIdx,  {
val x509 = x501 * x426
var x526: Double = 0
var x521 = 0
while (x521 < x426) {  // begin fat loop x526
val x738 = x482 + x521
val x739 = x418.dcApply(x738)
val x740 = { 
x739
}
val x741 = x509 + x521
val x742 = x418.dcApply(x741)
val x743 = { 
x742
}
val x744 = x740 - x743
val x745 = java.lang.Math.abs(x744)
val x522 = x526
val x523 = x745
val x525 = x522 + x523
x526 = x525
x521 += 1
} // end fat loop x526
val x527 = { 
x526
}
val x528 = x527==x500
val x529 = x528 && x167
val x530 = {
def x530thenb(): Double = {
val x169 = 2147483647.asInstanceOf[Double]
x169
}
def x530elseb(): Double = {
x527
}
if (x529) {
x530thenb()
} else {
x530elseb()
}
}
x530
})
mapIdx += 1
} // end map loop x533
x531
}
val x533 = x533_block
val x534 = x533.length
var x542: Int = 0
var x535 = 0
while (x535 < x534) {  // begin fat loop x542
val x536 = x542
val x537 = x535
val x538 = x533(x536)
val x539 = x533(x537)
val x540 = x538 < x539
val x541 = {
def x541thenb(): Int = {
x536
}
def x541elseb(): Int = {
x537
}
if (x540) {
x541thenb()
} else {
x541elseb()
}
}
x542 = x541
x535 += 1
} // end fat loop x542
val x550 = x542 * x426
var x567: Double = 0
var x562 = 0
while (x562 < x426) {  // begin fat loop x567
val x729 = x482 + x562
val x730 = x418.dcApply(x729)
val x731 = { 
x730
}
val x732 = x550 + x562
val x733 = x418.dcApply(x732)
val x734 = { 
x733
}
val x735 = x731 - x734
val x736 = java.lang.Math.abs(x735)
val x563 = x567
val x564 = x736
val x566 = x563 + x564
x567 = x566
x562 += 1
} // end fat loop x567
val x568 = { 
x567
}
x568
})
mapIdx += 1
} // end map loop x574
x572
}
val x574 = x574_block
val x575 = x574.sort
val x576 = x575.length
val x577 = x576 / 2
val x578 = x575(x577)
val x579 = { 
x578
}
val x580 = "   med_min_dist = "+x579
val x581 = println(x580)
val x583 = 1.5 * x579
val x582 = 5.0 * x579
val x584 = "   For this "+x423
val x585 = x584+" channel data, KERNEL WIDTH is "
val x586 = x585+x582
val x587 = x586+", APPRX WIDTH is "
val x588 = x587+x583
val x589 = println(x588)
val x590 = println("   finding local density for each cell ...")
val x625 = new generated.scala.IntVectorImpl(x423,true)
var x630: Int = 0
val x622 = 100000 / x423
val x623 = x622 + 1000
val x626 = x623.doubleValue()
val x627 = x429 / x626
val x628 = Math.ceil(x627)
val x629 = x628.asInstanceOf[Int]
val x280 = List()
val x621 = { (x591: Int, x592: Int) => 
val x598 = x591 * x426
val x602 = x592 * x426
var x619: Double = 0
var x614 = 0
while (x614 < x426) {  // begin fat loop x619
val x747 = x598 + x614
val x748 = x418.dcApply(x747)
val x749 = { 
x748
}
val x750 = x602 + x614
val x751 = x418.dcApply(x750)
val x752 = { 
x751
}
val x753 = x749 - x752
val x754 = java.lang.Math.abs(x753)
val x615 = x619
val x616 = x754
val x618 = x615 + x616
x619 = x618
x614 += 1
} // end fat loop x619
val x620 = { 
x619
}
x620: Double
}
val x624 = new generated.scala.DoubleStreamImpl(x423,x423,x623,x621,true)
val x706 = while ({val x631 = x630
val x632 = x631 < x629
x632}) {
val x634 = x630
val x638 = x630
val x635 = x624.rowsIn(x634)
val x636 = new generated.scala.IndexVectorRangeImpl(0,x635)
val x642 = x638 * x623
def x703_block = {
var forIdx = 0
while (forIdx < x636.size) { // begin foreach loop x703
val x637 = x636.dcApply(forIdx)
val x643 = x642 + x637
val x673 = x643 % 1000
val x674 = x673==0
val x678 = {
def x678thenb(): Unit = {
val x675 = "  (streaming) # processed node = "+x643
val x676 = println(x675)
x676
}
def x678elseb(): Unit = {
()
}
if (x674) {
x678thenb()
} else {
x678elseb()
}
}
val x679 = x625(x643)
val x680 = x679==0
val x701 = {
def x701thenb(): Unit = {
val x649 = x643 * x426
val x687 = {
val x682 = new generated.scala.IntVectorImpl(0,true)
val x683 = new generated.scala.IndexVectorSeqImpl(x682)
//TODO: buffer size might be wrong (loop has conditions)
x683
}
var x694: Int = 0
var x640 = 0
while (x640 < x423) {  // begin fat loop x687,x694
val x653 = x640 * x426
var x670: Double = 0
var x665 = 0
while (x665 < x426) {  // begin fat loop x670
val x758 = x649 + x665
val x759 = x418.dcApply(x758)
val x760 = { 
x759
}
val x761 = x653 + x665
val x762 = x418.dcApply(x761)
val x763 = { 
x762
}
val x764 = x760 - x763
val x765 = java.lang.Math.abs(x764)
val x666 = x670
val x667 = x765
val x669 = x666 + x667
x670 = x669
x665 += 1
} // end fat loop x670
val x671 = { 
x670
}
val x755 = x671 < x583
val x756 = x671 < x582
if (x755) x687.insert(x687.length, x640)
if (x756) {
val x689 = x694
val x690 = 1
val x693 = x689 + x690
x694 = x693
}
x640 += 1
} // end fat loop x687,x694
def x699_block = {
var forIdx = 0
while (forIdx < x687.size) { // begin foreach loop x699
val x696 = x687.dcApply(forIdx)
val x697 = x625(x696) = x694
x697
forIdx += 1
} // end foreach loop x699
}
val x699 = x699_block
x699
}
def x701elseb(): Unit = {
()
}
if (x680) {
x701thenb()
} else {
x701elseb()
}
}
x701
forIdx += 1
} // end foreach loop x703
}
val x703 = x703_block
val x704 = x630 += 1
()
}
val x707 = Seq(x625)
val x708 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
var x709: Int = 0
val x719 = while ({val x710 = x709
val x711 = x710 < 9
x711}) {
val x713 = x709
val x714 = x625(x713)
val x715 = x714+" "
val x716 = print(x715)
val x717 = x709 += 1
()
}
val x720 = println(())
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
