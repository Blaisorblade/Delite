/*****************************************
  Emitting Generated Code                  
*******************************************/
class SpadeRunnerFusing extends ((Array[java.lang.String])=>(Unit)) {
def apply(x249:Array[java.lang.String]): Unit = {
val x250 = x249.length
val x251 = x250 < 2
val x255 = {
def x255thenb(): Nothing = {
val x252 = println("Usage: Spade <input data file> <output data file>")
val x253 = exit(-1)
x253
}
if (x251) {
x255thenb()
}
}
val x256 = x249(0)
val x305 = { 
val x257 = new java.io.FileReader(x256)
val x258 = new java.io.BufferedReader(x257)
val x259 = x258.readLine()
var x260: java.lang.String = x259
val x261 = x260
val x262 = x261.trim()
x260 = x262
val x264 = x260
val x265 = x264.split("\\s+")
var x266: Array[java.lang.String] = x265
val x267 = x266
val x268 = x267.length
val x269 = new generated.scala.DoubleMatrixImpl(0,x268)
val x301 = while ({val x270 = x260
val x271 = x270 != null
x271}) {
val x273 = x266
val x274 = x273.length
val x275 = new generated.scala.IndexVectorRangeImpl(0,x274)
val x277 = x275.length
val x278 = x275.isRow
// a *thin* loop follows: x286
var x276 = 0
val x282 = x266
val x281 = x275.dcApply(x276)
val x283 = x282(x281)
val x284 = java.lang.Double.parseDouble(x283)
val x286 = {
val x279 = new generated.scala.DoubleVectorImpl(x277,x278)
x279
}
x286.dcUpdate(x276, x284)
x276 = 1
while (x276 < x277) {  // begin fat loop x286
val x282 = x266
val x281 = x275.dcApply(x276)
val x283 = x282(x281)
val x284 = java.lang.Double.parseDouble(x283)
x286.dcUpdate(x276, x284)
x276 += 1
} // end fat loop x286
val x287 = x269.numRows
val x288 = x269.insertRow(x287,x286)
val x289 = x258.readLine()
x260 = x289
val x291 = x260
val x292 = x291 != null
val x299 = {
def x299thenb(): Unit = {
val x293 = x291.trim()
x260 = x293
val x295 = x260
val x296 = x295.split("\\s+")
x266 = x296
()
}
if (x292) {
x299thenb()
}
}
x299
}
val x302 = x258.close()
val x303 = x269// unsafe immutable
x303
}
val x306 = new generated.scala.IntVectorImpl(0,false)
val x307 = x306// unsafe immutable
val x308 = new generated.scala.IntLabelsImpl(x307)
val x309 = new generated.scala.DoubleIntTrainingSetImpl(x305,x308)
val x61 = Seq()
val x310 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
val x311 = new generated.scala.IntVectorImpl(0,true)
val x312 = x311.length
val x313 = x311.insert(x312, 0)
val x314 = x311// unsafe immutable
val x315 = x309.numRows
val x316 = "   Input matrix size: "+x315
val x317 = x316+"*"
val x318 = x309.numCols
val x319 = x317+x318
val x320 = println(x319)
val x326 = new generated.scala.IntVectorImpl(0,true)
val x327 = x326.length
val x328 = x326.insert(x327, x315)
val x329 = x326.length
val x330 = x326.insert(x329, 2000)
val x331 = x326.length
val x321 = x315
val x322 = 2.5E9f / x321
val x323 = x322
val x324 = Math.floor(x323)
val x325 = x324.asInstanceOf[Int]
val x332 = x326.insert(x331, x325)
val x333 = x326// unsafe immutable
val x337 = x333.length
var x334 = 0
val x338 = x333.dcApply(x334)
var x341: Int = {
if (x337 == 0) {2147483647}
else {
val x338 = x333.dcApply(x334)
x338
}
}
x334 = 1
while (x334 < x337) {  // begin fat loop x341
val x338 = x333.dcApply(x334)
val x335 = x341
val x336 = x338
val x339 = x335 < x336
val x340 = {
def x340thenb(): Int = {
x335
}
def x340elseb(): Int = {
x336
}
if (x339) {
x340thenb()
} else { 
x340elseb()
}
}
x341 = x340
x334 += 1
} // end fat loop x341
val x342 = "   numSamples = "+x341
val x343 = println(x342)
val x344 = println("   finding empirical dist of the min distance between cells ...")
val x345 = println("   med_min_dist = 4.4593519740000005")
val x346 = "   For this "+x315
val x347 = x346+" channel data, KERNEL WIDTH is "
val x348 = x347+22.296759870000002
val x349 = x348+", APPRX WIDTH is "
val x350 = x349+6.689027961000001
val x351 = println(x350)
val x352 = println("   finding local density for each cell ...")
val x389 = new generated.scala.IntVectorImpl(x315,true)
var x394: Int = 0
val x386 = 100000 / x315
val x387 = x386 + 1000
val x390 = x387.doubleValue()
val x391 = x321 / x390
val x392 = Math.ceil(x391)
val x393 = x392.asInstanceOf[Int]
val x244 = List()
val x385 = { (x353: Int, x354: Int) => 
val x360 = x353 * x318
val x364 = x354 * x318
val x384 = { 
// a *thin* loop follows: x369
var x357 = 0
val x361 = x360 + x357
val x362 = x309.dcApply(x361)
val x363 = { 
x362
}
val x365 = x364 + x357
val x366 = x309.dcApply(x365)
val x367 = { 
x366
}
val x368 = x363 - x367
val x369 = {
val x358 = new generated.scala.DoubleVectorImpl(x318,true)
x358
}
x369.dcUpdate(x357, x368)
x357 = 1
while (x357 < x318) {  // begin fat loop x369
val x361 = x360 + x357
val x362 = x309.dcApply(x361)
val x363 = { 
x362
}
val x365 = x364 + x357
val x366 = x309.dcApply(x365)
val x367 = { 
x366
}
val x368 = x363 - x367
x369.dcUpdate(x357, x368)
x357 += 1
} // end fat loop x369
val x371 = x369.isRow
// a *thin* loop follows: x376
var x370 = 0
val x374 = x369.dcApply(x370)
val x375 = java.lang.Math.abs(x374)
val x376 = {
val x372 = new generated.scala.DoubleVectorImpl(x318,x371)
x372
}
x376.dcUpdate(x370, x375)
x370 = 1
while (x370 < x318) {  // begin fat loop x376
val x374 = x369.dcApply(x370)
val x375 = java.lang.Math.abs(x374)
x376.dcUpdate(x370, x375)
x370 += 1
} // end fat loop x376
var x377 = 0
val x380 = x376.dcApply(x377)
var x382: Double = {
if (x318 == 0) {0.0}
else {
val x380 = x376.dcApply(x377)
x380
}
}
x377 = 1
while (x377 < x318) {  // begin fat loop x382
val x380 = x376.dcApply(x377)
val x378 = x382
val x379 = x380
val x381 = x378 + x379
x382 = x381
x377 += 1
} // end fat loop x382
x382
}
x384: Double
}
val x388 = new generated.scala.DoubleStreamImpl(x315,x315,x387,x385,true)
val x414 = while ({val x395 = x394
val x396 = x395 < x393
x396}) {
val x398 = x394
val x407 = x394
val x399 = x398 * x387
val x400 = x315 - x399
val x401 = x400 < 0
val x402 = {
def x402thenb(): Int = {
x315
}
def x402elseb(): Int = {
x400
}
if (x401) {
x402thenb()
} else { 
x402elseb()
}
}
val x403 = Math.min(x387, x402)
val x404 = x403.asInstanceOf[Int]
val x405 = { 
x404
}
val x406 = new generated.scala.IndexVectorRangeImpl(0,x405)
val x410 = x406.length
val x433 = x407 * x387
// a *thin* loop follows: x411
var x408 = 0
var x411: Unit = {
val x430 = x406.dcApply(x408)
val x434 = x433 + x430
val x466 = x434 % 1000
val x467 = x466==0
val x471 = {
def x471thenb(): Unit = {
val x468 = "  (streaming) # processed node = "+x434
val x469 = println(x468)
x469
}
if (x467) {
x471thenb()
}
}
val x472 = x389(x434)
val x473 = x472==0
val x432 = x388.chunkRow(x430,x407)
val x440 = x434 * x318
var x431 = 0
val x444 = x431 * x318
val x464 = { 
// a *thin* loop follows: x449
var x437 = 0
val x441 = x440 + x437
val x442 = x309.dcApply(x441)
val x443 = { 
x442
}
val x445 = x444 + x437
val x446 = x309.dcApply(x445)
val x447 = { 
x446
}
val x448 = x443 - x447
val x449 = {
val x438 = new generated.scala.DoubleVectorImpl(x318,true)
x438
}
x449.dcUpdate(x437, x448)
x437 = 1
while (x437 < x318) {  // begin fat loop x449
val x441 = x440 + x437
val x442 = x309.dcApply(x441)
val x443 = { 
x442
}
val x445 = x444 + x437
val x446 = x309.dcApply(x445)
val x447 = { 
x446
}
val x448 = x443 - x447
x449.dcUpdate(x437, x448)
x437 += 1
} // end fat loop x449
val x451 = x449.isRow
// a *thin* loop follows: x456
var x450 = 0
val x454 = x449.dcApply(x450)
val x455 = java.lang.Math.abs(x454)
val x456 = {
val x452 = new generated.scala.DoubleVectorImpl(x318,x451)
x452
}
x456.dcUpdate(x450, x455)
x450 = 1
while (x450 < x318) {  // begin fat loop x456
val x454 = x449.dcApply(x450)
val x455 = java.lang.Math.abs(x454)
x456.dcUpdate(x450, x455)
x450 += 1
} // end fat loop x456
var x457 = 0
val x460 = x456.dcApply(x457)
var x462: Double = {
if (x318 == 0) {0.0}
else {
val x460 = x456.dcApply(x457)
x460
}
}
x457 = 1
while (x457 < x318) {  // begin fat loop x462
val x460 = x456.dcApply(x457)
val x458 = x462
val x459 = x460
val x461 = x458 + x459
x462 = x461
x457 += 1
} // end fat loop x462
x462
}
val x465 = {
x432
}
x465.dcUpdate(x431, x464)
x431 = 1
while (x431 < x315) {  // begin fat loop x465
val x444 = x431 * x318
val x464 = { 
// a *thin* loop follows: x449
var x437 = 0
val x441 = x440 + x437
val x442 = x309.dcApply(x441)
val x443 = { 
x442
}
val x445 = x444 + x437
val x446 = x309.dcApply(x445)
val x447 = { 
x446
}
val x448 = x443 - x447
val x449 = {
val x438 = new generated.scala.DoubleVectorImpl(x318,true)
x438
}
x449.dcUpdate(x437, x448)
x437 = 1
while (x437 < x318) {  // begin fat loop x449
val x441 = x440 + x437
val x442 = x309.dcApply(x441)
val x443 = { 
x442
}
val x445 = x444 + x437
val x446 = x309.dcApply(x445)
val x447 = { 
x446
}
val x448 = x443 - x447
x449.dcUpdate(x437, x448)
x437 += 1
} // end fat loop x449
val x451 = x449.isRow
// a *thin* loop follows: x456
var x450 = 0
val x454 = x449.dcApply(x450)
val x455 = java.lang.Math.abs(x454)
val x456 = {
val x452 = new generated.scala.DoubleVectorImpl(x318,x451)
x452
}
x456.dcUpdate(x450, x455)
x450 = 1
while (x450 < x318) {  // begin fat loop x456
val x454 = x449.dcApply(x450)
val x455 = java.lang.Math.abs(x454)
x456.dcUpdate(x450, x455)
x450 += 1
} // end fat loop x456
var x457 = 0
val x460 = x456.dcApply(x457)
var x462: Double = {
if (x318 == 0) {0.0}
else {
val x460 = x456.dcApply(x457)
x460
}
}
x457 = 1
while (x457 < x318) {  // begin fat loop x462
val x460 = x456.dcApply(x457)
val x458 = x462
val x459 = x460
val x461 = x458 + x459
x462 = x461
x457 += 1
} // end fat loop x462
x462
}
x465.dcUpdate(x431, x464)
x431 += 1
} // end fat loop x465
var x480 = 0
val x483 = x465.dcApply(x480)
val x484 = x483 < 22.296759870000002
var x486: Int = {
if (x315 == 0) {0}
else {
0
}
}
x480 = 1
while (x480 < x315) {  // begin fat loop x486
val x483 = x465.dcApply(x480)
val x484 = x483 < 22.296759870000002
if (x484) {
// TODO: we could optimize this check away with more convoluted runtime support if necessary
if (x486 == 0)x486 = {
1
}
else {
val x481 = x486
val x482 = 1
val x485 = x481 + x482
x486 = x485
}
}
x480 += 1
} // end fat loop x486
val x494 = {
def x494thenb(): Unit = {
// a *thin* loop follows: x479
var x474 = 0
val x477 = x465.dcApply(x474)
val x478 = x477 < 6.689027961000001
val x479 = {
val x475 = new generated.scala.IndexVectorSeqImpl(0)
//TODO: buffer size might be wrong (loop has conditions)
x475
}
if (x478) x479.insert(x479.length, x474)
x474 = 1
while (x474 < x315) {  // begin fat loop x479
val x477 = x465.dcApply(x474)
val x478 = x477 < 6.689027961000001
if (x478) x479.insert(x479.length, x474)
x474 += 1
} // end fat loop x479
// a *thin* loop follows: x492
var x487 = 0
var x492: Unit = {
val x489 = x479.dcApply(x487)
val x490 = x389(x489) = x486
x490
}
x487 = 1
while (x487 < x315) {  // begin fat loop x492
x492 = {
val x489 = x479.dcApply(x487)
val x490 = x389(x489) = x486
x490
}
x487 += 1
} // end fat loop x492
x492
}
if (x473) {
x494thenb()
}
}
x494
}
x408 = 1
while (x408 < x410) {  // begin fat loop x411
x411 = {
val x430 = x406.dcApply(x408)
val x434 = x433 + x430
val x466 = x434 % 1000
val x467 = x466==0
val x471 = {
def x471thenb(): Unit = {
val x468 = "  (streaming) # processed node = "+x434
val x469 = println(x468)
x469
}
if (x467) {
x471thenb()
}
}
val x472 = x389(x434)
val x473 = x472==0
val x432 = x388.chunkRow(x430,x407)
val x440 = x434 * x318
var x431 = 0
val x444 = x431 * x318
val x464 = { 
// a *thin* loop follows: x449
var x437 = 0
val x441 = x440 + x437
val x442 = x309.dcApply(x441)
val x443 = { 
x442
}
val x445 = x444 + x437
val x446 = x309.dcApply(x445)
val x447 = { 
x446
}
val x448 = x443 - x447
val x449 = {
val x438 = new generated.scala.DoubleVectorImpl(x318,true)
x438
}
x449.dcUpdate(x437, x448)
x437 = 1
while (x437 < x318) {  // begin fat loop x449
val x441 = x440 + x437
val x442 = x309.dcApply(x441)
val x443 = { 
x442
}
val x445 = x444 + x437
val x446 = x309.dcApply(x445)
val x447 = { 
x446
}
val x448 = x443 - x447
x449.dcUpdate(x437, x448)
x437 += 1
} // end fat loop x449
val x451 = x449.isRow
// a *thin* loop follows: x456
var x450 = 0
val x454 = x449.dcApply(x450)
val x455 = java.lang.Math.abs(x454)
val x456 = {
val x452 = new generated.scala.DoubleVectorImpl(x318,x451)
x452
}
x456.dcUpdate(x450, x455)
x450 = 1
while (x450 < x318) {  // begin fat loop x456
val x454 = x449.dcApply(x450)
val x455 = java.lang.Math.abs(x454)
x456.dcUpdate(x450, x455)
x450 += 1
} // end fat loop x456
var x457 = 0
val x460 = x456.dcApply(x457)
var x462: Double = {
if (x318 == 0) {0.0}
else {
val x460 = x456.dcApply(x457)
x460
}
}
x457 = 1
while (x457 < x318) {  // begin fat loop x462
val x460 = x456.dcApply(x457)
val x458 = x462
val x459 = x460
val x461 = x458 + x459
x462 = x461
x457 += 1
} // end fat loop x462
x462
}
val x465 = {
x432
}
x465.dcUpdate(x431, x464)
x431 = 1
while (x431 < x315) {  // begin fat loop x465
val x444 = x431 * x318
val x464 = { 
// a *thin* loop follows: x449
var x437 = 0
val x441 = x440 + x437
val x442 = x309.dcApply(x441)
val x443 = { 
x442
}
val x445 = x444 + x437
val x446 = x309.dcApply(x445)
val x447 = { 
x446
}
val x448 = x443 - x447
val x449 = {
val x438 = new generated.scala.DoubleVectorImpl(x318,true)
x438
}
x449.dcUpdate(x437, x448)
x437 = 1
while (x437 < x318) {  // begin fat loop x449
val x441 = x440 + x437
val x442 = x309.dcApply(x441)
val x443 = { 
x442
}
val x445 = x444 + x437
val x446 = x309.dcApply(x445)
val x447 = { 
x446
}
val x448 = x443 - x447
x449.dcUpdate(x437, x448)
x437 += 1
} // end fat loop x449
val x451 = x449.isRow
// a *thin* loop follows: x456
var x450 = 0
val x454 = x449.dcApply(x450)
val x455 = java.lang.Math.abs(x454)
val x456 = {
val x452 = new generated.scala.DoubleVectorImpl(x318,x451)
x452
}
x456.dcUpdate(x450, x455)
x450 = 1
while (x450 < x318) {  // begin fat loop x456
val x454 = x449.dcApply(x450)
val x455 = java.lang.Math.abs(x454)
x456.dcUpdate(x450, x455)
x450 += 1
} // end fat loop x456
var x457 = 0
val x460 = x456.dcApply(x457)
var x462: Double = {
if (x318 == 0) {0.0}
else {
val x460 = x456.dcApply(x457)
x460
}
}
x457 = 1
while (x457 < x318) {  // begin fat loop x462
val x460 = x456.dcApply(x457)
val x458 = x462
val x459 = x460
val x461 = x458 + x459
x462 = x461
x457 += 1
} // end fat loop x462
x462
}
x465.dcUpdate(x431, x464)
x431 += 1
} // end fat loop x465
var x480 = 0
val x483 = x465.dcApply(x480)
val x484 = x483 < 22.296759870000002
var x486: Int = {
if (x315 == 0) {0}
else {
0
}
}
x480 = 1
while (x480 < x315) {  // begin fat loop x486
val x483 = x465.dcApply(x480)
val x484 = x483 < 22.296759870000002
if (x484) {
// TODO: we could optimize this check away with more convoluted runtime support if necessary
if (x486 == 0)x486 = {
1
}
else {
val x481 = x486
val x482 = 1
val x485 = x481 + x482
x486 = x485
}
}
x480 += 1
} // end fat loop x486
val x494 = {
def x494thenb(): Unit = {
// a *thin* loop follows: x479
var x474 = 0
val x477 = x465.dcApply(x474)
val x478 = x477 < 6.689027961000001
val x479 = {
val x475 = new generated.scala.IndexVectorSeqImpl(0)
//TODO: buffer size might be wrong (loop has conditions)
x475
}
if (x478) x479.insert(x479.length, x474)
x474 = 1
while (x474 < x315) {  // begin fat loop x479
val x477 = x465.dcApply(x474)
val x478 = x477 < 6.689027961000001
if (x478) x479.insert(x479.length, x474)
x474 += 1
} // end fat loop x479
// a *thin* loop follows: x492
var x487 = 0
var x492: Unit = {
val x489 = x479.dcApply(x487)
val x490 = x389(x489) = x486
x490
}
x487 = 1
while (x487 < x315) {  // begin fat loop x492
x492 = {
val x489 = x479.dcApply(x487)
val x490 = x389(x489) = x486
x490
}
x487 += 1
} // end fat loop x492
x492
}
if (x473) {
x494thenb()
}
}
x494
}
x408 += 1
} // end fat loop x411
val x412 = x394 += 1
()
}
val x415 = Seq(x389)
val x416 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
var x417: Int = 0
val x427 = while ({val x418 = x417
val x419 = x418 < 9
x419}) {
val x421 = x417
val x422 = x389(x421)
val x423 = x422+" "
val x424 = print(x423)
val x425 = x417 += 1
()
}
val x428 = println(())
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
