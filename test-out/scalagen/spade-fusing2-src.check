/*****************************************
  Emitting Generated Code                  
*******************************************/
class SpadeRunnerFusing2 extends ((Array[java.lang.String])=>(Unit)) {
def apply(x320:Array[java.lang.String]): Unit = {
val x321 = x320.length
val x322 = x321 < 2
val x326 = {
def x326thenb(): Nothing = {
val x323 = println("Usage: Spade <input data file> <output data file>")
val x324 = exit(-1)
x324
}
def x326elseb(): Unit = {
()
}
if (x322) {
x326thenb()
} else {
x326elseb()
}
}
val x327 = x320(0)
val x372 = { 
val x328 = new java.io.FileReader(x327)
val x329 = new java.io.BufferedReader(x328)
val x330 = x329.readLine()
var x331: java.lang.String = x330
val x332 = x331
val x333 = x332.trim()
x331 = x333
val x335 = x331
val x336 = x335.split("\\s+")
var x337: Array[java.lang.String] = x336
val x338 = x337
val x339 = x338.length
val x340 = new generated.scala.DoubleMatrixImpl(0,x339)
val x369 = while ({val x341 = x331
val x342 = x341 != null
x342}) {
val x344 = x337
val x345 = x344.length
val x346 = new generated.scala.DoubleVectorImpl(x345,true)
var x348 : Int = 0
val x354 = while (x348 < x345) {
val x349 = x337
val x350 = x349(x348)
val x351 = java.lang.Double.parseDouble(x350)
val x352 = x346(x348) = x351
x352
x348 = x348 + 1
}
val x355 = x340.numRows
val x356 = x340.insertRow(x355,x346)
val x357 = x329.readLine()
x331 = x357
val x359 = x331
val x360 = x359 != null
val x367 = {
def x367thenb(): Unit = {
val x361 = x359.trim()
x331 = x361
val x363 = x331
val x364 = x363.split("\\s+")
x337 = x364
()
}
def x367elseb(): Unit = {
()
}
if (x360) {
x367thenb()
} else {
x367elseb()
}
}
x367
}
val x370 = x329.close()
x340
}
val x373 = new generated.scala.IntVectorImpl(0,false)
val x374 = new generated.scala.IntLabelsImpl(x373)
val x375 = new generated.scala.DoubleIntTrainingSetImpl(x372,x374)
val x56 = Seq()
val x376 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
val x377 = new generated.scala.IntVectorImpl(0,true)
val x378 = x377.length
val x379 = x377.insert(x378, 0)
val x380 = x375.numRows
val x381 = "   Input matrix size: "+x380
val x382 = x381+"*"
val x383 = x375.numCols
val x384 = x382+x383
val x385 = println(x384)
val x391 = new generated.scala.IntVectorImpl(0,true)
val x392 = x391.length
val x393 = x391.insert(x392, x380)
val x394 = x391.length
val x395 = x391.insert(x394, 2000)
val x396 = x391.length
val x386 = x380
val x387 = 2.5E9f / x386
val x388 = x387
val x389 = Math.floor(x388)
val x390 = x389.asInstanceOf[Int]
val x397 = x391.insert(x396, x390)
val x398 = x391.length
var x406: Int = 2147483647
var x399 = 0
while (x399 < x398) {  // begin fat loop x406
val x402 = x391(x399)
val x400 = x406
val x401 = x402
val x404 = x400 < x401
val x405 = {
def x405thenb(): Int = {
x400
}
def x405elseb(): Int = {
x401
}
if (x404) {
x405thenb()
} else {
x405elseb()
}
}
x406 = x405
x399 += 1
} // end fat loop x406
val x407 = "   numSamples = "+x406
val x408 = println(x407)
val x409 = println("   finding empirical dist of the min distance between cells ...")
val x432 = new generated.scala.IndexVectorRangeImpl(0,x406)
val x410 = new generated.scala.IndexVectorRangeImpl(0,x380)
val x411 = x410.length
val x412 = new generated.scala.IndexVectorRangeImpl(0,x411)
val x414 = x410.isRow
val x431 = { 
val x413 = x412.cloneL
val x415 = new generated.scala.IntVectorImpl(0,x414)
var x417 : Int = 0
val x429 = while (x417 < x406) {
val x418 = x411 - x417
val x419 = generated.scala.Global.randRef.nextInt(x418)
val x420 = x417 + x419
val x421 = x413(x420)
val x423 = x415.length
val x422 = x410(x421)
val x424 = x415.insert(x423, x422)
val x425 = x413(x417)
val x426 = x413(x420) = x425
val x427 = x413(x417) = x421
x427
x417 = x417 + 1
}
x415
}
val x159 = !false
val x514 = x432.length
val x515 = x432.isRow
def x518_block = {
val x516 = new generated.scala.DoubleVectorImpl(x514,x515)
var mapIdx = 0
while (mapIdx < x432.size) { // begin map loop x518
val x433 = x432.dcApply(mapIdx)
x516.dcUpdate(mapIdx,  {
val x434 = x431(x433)
var x453: Double = 0
var x448 = 0
while (x448 < x383) {  // begin fat loop x453
val x638 = x375(x434, x448)
val x639 = x638 - x638
val x640 = java.lang.Math.abs(x639)//java.lang.Double.longBitsToDouble((java.lang.Double.doubleToRawLongBits(x639)<<1)>>>1)
val x449 = x453
val x450 = x640
val x452 = x449 + x450
x453 = x452
x448 += 1
} // end fat loop x453
val x454 = { 
x453
}
def x482_block = {
val x480 = new generated.scala.DoubleVectorImpl(x411,x414)
var mapIdx = 0
while (mapIdx < x410.size) { // begin map loop x482
val x455 = x410.dcApply(mapIdx)
x480.dcUpdate(mapIdx,  {
var x475: Double = 0
var x470 = 0
while (x470 < x383) {  // begin fat loop x475
def inner = {
val x646 = x375(x434, x470)
val x647 = x375(x455, x470)
val x648 = x646 - x647
val x649 = java.lang.Math.abs(x648)//java.lang.Double.longBitsToDouble((java.lang.Double.doubleToRawLongBits(x648)<<1)>>>1)
val x471 = x475
val x472 = x649
val x474 = x471 + x472
x475 = x474
x470 += 1
}
inner
} // end fat loop x475
val x476 = { 
x475
}
val x477 = x476==x454
val x478 = x477 && x159
val x479 = {
def x479thenb(): Double = {
val x161 = 2147483647.asInstanceOf[Double]
x161
}
def x479elseb(): Double = {
x476
}
if (x478) {
x479thenb()
} else {
x479elseb()
}
}
x479
})
mapIdx += 1
} // end map loop x482
x480
}
val x482 = x482_block
val x483 = x482.length
var x491: Int = 0
var x484 = 0
while (x484 < x483) {  // begin fat loop x491
val x485 = x491
val x486 = x484
val x487 = x482(x485)
val x488 = x482(x486)
val x489 = x487 < x488
val x490 = {
def x490thenb(): Int = {
x485
}
def x490elseb(): Int = {
x486
}
if (x489) {
x490thenb()
} else {
x490elseb()
}
}
x491 = x490
x484 += 1
} // end fat loop x491
var x511: Double = 0
var x506 = 0
while (x506 < x383) {  // begin fat loop x511
val x641 = x375(x434, x506)
val x642 = x375(x491, x506)
val x643 = x641 - x642
val x644 = java.lang.Math.abs(x643)//java.lang.Double.longBitsToDouble((java.lang.Double.doubleToRawLongBits(x643)<<1)>>>1)
val x507 = x511
val x508 = x644
val x510 = x507 + x508
x511 = x510
x506 += 1
} // end fat loop x511
val x512 = { 
x511
}
x512
})
mapIdx += 1
} // end map loop x518
x516
}
val x518 = x518_block
val x519 = x518.sort
val x520 = x519.length
val x521 = x520 / 2
val x522 = x519(x521)
val x523 = { 
x522
}
val x524 = "   med_min_dist = "+x523
val x525 = println(x524)
val x527 = 1.5 * x523
val x526 = 5.0 * x523
val x528 = "   For this "+x380
val x529 = x528+" channel data, KERNEL WIDTH is "
val x530 = x529+x526
val x531 = x530+", APPRX WIDTH is "
val x532 = x531+x527
val x533 = println(x532)
val x534 = println("   finding local density for each cell ...")
val x563 = new generated.scala.IntVectorImpl(x380,true)
var x568: Int = 0
val x560 = 100000 / x380
val x561 = x560 + 1000
val x564 = x561.doubleValue()
val x565 = x386 / x564
val x566 = Math.ceil(x565)
val x567 = x566.asInstanceOf[Int]
val x261 = List()
val x559 = { (x535: Int, x536: Int) => 
var x557: Double = 0
var x552 = 0
while (x552 < x383) {  // begin fat loop x557
val x651 = x375(x535, x552)
val x652 = x375(x536, x552)
val x653 = x651 - x652
val x654 = java.lang.Math.abs(x653)//java.lang.Double.longBitsToDouble((java.lang.Double.doubleToRawLongBits(x653)<<1)>>>1)
val x553 = x557
val x554 = x654
val x556 = x553 + x554
x557 = x556
x552 += 1
} // end fat loop x557
val x558 = { 
x557
}
x558: Double
}
val x562 = new generated.scala.DoubleStreamImpl(x380,x380,x561,x559,true)
val x620 = while ({val x569 = x568
val x570 = x569 < x567
x570}) {
val x572 = x568
val x576 = x568
val x573 = x562.rowsIn(x572)
val x574 = new generated.scala.IndexVectorRangeImpl(0,x573)
val x580 = x576 * x561
def x617_block = {
var forIdx = 0
while (forIdx < x574.size) { // begin foreach loop x617
val x575 = x574.dcApply(forIdx)
println("in x617: forIdx="+forIdx+",x575="+x575)
val x578 = x562.initRow(x575,x576)
val x581 = x580 + x575
val x582 = x581 % 1000
val x583 = x582==0
val x587 = {
def x587thenb(): Unit = {
val x584 = "  (streaming) # processed node = "+x581
val x585 = println(x584)
x585
}
//def x587elseb(): Unit = {
//()
//}
if (x583) {
x587thenb()
} //else {
//x587elseb()
//}
}
val x588 = x563(x581)
val x589 = x588==0
val x615 = {
def x615thenb(): Unit = {
val x594 = x575 * x380
val x599 = {
val x591 = new generated.scala.IntVectorImpl(0,true)
val x592 = new generated.scala.IndexVectorSeqImpl(x591)
//TODO: buffer size might be wrong (loop has conditions)
x592
}
var x608: Int = 0
var x590 = 0
while (x590 < x380) {  // begin fat loop x599,x608
println("in x599,x608: x590="+x590)
val x595 = x594 + x590
val x596 = x562.rawElem(x595)
val x597 = { 
x596
}
val x598 = x597 < x527
val x655 = x597 < x526
if (x598) x599.insert(x599.length, x590)
if (x655) {
val x601 = x608
val x602 = 1
val x607 = x601 + x602
x608 = x607
}
x590 += 1
} // end fat loop x599,x608
def x613_block = {
var forIdx = 0
while (forIdx < x599.size) { // begin foreach loop x613
println("in x613: forIdx="+forIdx)
val x610 = x599.dcApply(forIdx)
val x611 = x563(x610) = x608
x611
forIdx += 1
} // end foreach loop x613
}
val x613 = x613_block
x613
}
//def x615elseb(): Unit = {
//()
//}
if (x589) {
x615thenb()
} //else {
//x615elseb()
//}
}
x615
forIdx += 1
} // end foreach loop x617
}
val x617 = x617_block
val x618 = x568 += 1
()
}
val x621 = Seq(x563)
val x622 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
var x623: Int = 0
val x633 = while ({val x624 = x623
val x625 = x624 < 9
x625}) {
val x627 = x623
val x628 = x563(x627)
val x629 = x628+" "
val x630 = print(x629)
val x631 = x623 += 1
()
}
val x634 = println(())
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
