/*****************************************
  Emitting Generated Code                  
*******************************************/
class SVMRunner extends ((Array[java.lang.String])=>(Unit)) {
def apply(x0:Array[java.lang.String]): Unit = {
val x1 = x0.length
val x2 = x1 < 1
val x6 = {
def x6thenb(): Nothing = {
val x3 = println("Usage: SVM <train data file> <test data file> <model filename> <num tests>")
val x4 = exit(-1)
x4
}
if (x2) {
x6thenb()
}
}
val x12 = { generated.scala.Global.randRef.setSeed(generated.scala.Global.INITIAL_SEED);   generated.scala.Global.intRandRef.setSeed(generated.scala.Global.INITIAL_SEED); }
val x7 = x0(0)
val x126 = { 
val x13 = new java.io.FileReader(x7)
val x14 = new java.io.BufferedReader(x13)
var x15: java.io.BufferedReader = x14
val x16 = x15
val x17 = x16.readLine()
var x18: java.lang.String = x17
val x19 = x15
val x20 = x19.readLine()
var x21: java.lang.String = x20
val x22 = x21
val x23 = x22.trim()
val x24 = x23.split("\\s+")
val x25 = x24(0)
val x26 = java.lang.Integer.parseInt(x25)
val x29 = x26 < 0
val x27 = x24(1)
val x28 = java.lang.Integer.parseInt(x27)
val x30 = x28 < 0
val x31 = x29 || x30
val x34 = {
def x34thenb(): Nothing = {
val x32 = error("Illegal input to readTokenMatrix")
x32
}
if (x31) {
x34thenb()
}
}
val x35 = x15
val x36 = x35.readLine()
val x37 = new generated.scala.DoubleVectorImpl(0,true)
val x38 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x40 : Int = 0
val x75 = while (x40 < x26) {
val x41 = x15
val x42 = x41.readLine()
x21 = x42
val x44 = x21
val x45 = x44.trim()
x21 = x45
val x47 = x21
val x49 = new generated.scala.DoubleVectorImpl(x28,true)
var x50: Int = 0
var x51: Int = 1
val x52 = x51
val x48 = x47.split("\\s+")
val x53 = x48.length
val x54 = x53 - 1
val x55 = x52 < x54
val x56 = x48(x52)
val x57 = java.lang.Integer.parseInt(x56)
val x59 = x50
val x60 = x52 + 1
val x61 = x48(x60)
val x62 = java.lang.Double.parseDouble(x61)
val x66 = while ({x55}) {
val x58 = x50 += x57
val x63 = x49(x59) = x62
val x64 = x51 += 2
()
}
val x69 = x37.length
val x67 = x48(0)
val x68 = java.lang.Double.parseDouble(x67)
val x70 = x37.insert(x69, x68)
val x71 = x49.cloneL
val x72 = x38.length
val x73 = x38.insert(x72, x71)
x73
x40 = x40 + 1
}
val x76 = x37.length
val x77 = x37.isRow
val x78 = !x77
// a *thin* loop follows: x84
val x84 = {
val x80 = new generated.scala.DoubleVectorImpl(x76,x78)
x80
}
var x79 = 0
while (x79 < x76) {  // begin fat loop x84
val x82 = x37(x79)
x84.dcUpdate(x79, x82)
x79 += 1
} // end fat loop x84
val x120 = { 
val x85 = x38.length
val x86 = x85==0
val x118 = {
def x118thenb(): generated.scala.Matrix[Double] = {
val x87 = new generated.scala.DoubleMatrixImpl(0,0)
x87
}
def x118elseb(): generated.scala.Matrix[Double] = {
val x89 = x38(0)
val x90 = x89.isRow
val x116 = {
def x116thenb(): generated.scala.Matrix[Double] = {
val x91 = x89.length
val x92 = new generated.scala.DoubleMatrixImpl(x85,x91)
var x94 : Int = 0
val x103 = while (x94 < x85) {
var x96 : Int = 0
val x101 = while (x96 < x91) {
val x97 = x38(x94)
val x98 = x97(x96)
val x99 = x92(x94, x96) = x98
x99
x96 = x96 + 1
}
x101
x94 = x94 + 1
}
x92
}
def x116elseb(): generated.scala.Matrix[Double] = {
val x91 = x89.length
val x105 = new generated.scala.DoubleMatrixImpl(x91,x85)
var x106 : Int = 0
val x114 = while (x106 < x85) {
var x107 : Int = 0
val x112 = while (x107 < x91) {
val x108 = x38(x106)
val x109 = x108(x107)
val x110 = x105(x107, x106) = x109
x110
x107 = x107 + 1
}
x112
x106 = x106 + 1
}
x105
}
if (x90) {
x116thenb()
} else { 
x116elseb()
}
}
x116
}
if (x86) {
x118thenb()
} else { 
x118elseb()
}
}
x118
}
val x121 = x15
val x122 = x121.close()
val x123 = new generated.scala.DoubleLabelsImpl(x84)
val x124 = new generated.scala.DoubleDoubleTrainingSetImpl(x120,x123)
x124
}
val x8 = x0(1)
val x240 = { 
val x127 = new java.io.FileReader(x8)
val x128 = new java.io.BufferedReader(x127)
var x129: java.io.BufferedReader = x128
val x130 = x129
val x131 = x130.readLine()
var x132: java.lang.String = x131
val x133 = x129
val x134 = x133.readLine()
var x135: java.lang.String = x134
val x136 = x135
val x137 = x136.trim()
val x138 = x137.split("\\s+")
val x139 = x138(0)
val x140 = java.lang.Integer.parseInt(x139)
val x143 = x140 < 0
val x141 = x138(1)
val x142 = java.lang.Integer.parseInt(x141)
val x144 = x142 < 0
val x145 = x143 || x144
val x148 = {
def x148thenb(): Nothing = {
val x146 = error("Illegal input to readTokenMatrix")
x146
}
if (x145) {
x148thenb()
}
}
val x149 = x129
val x150 = x149.readLine()
val x151 = new generated.scala.DoubleVectorImpl(0,true)
val x152 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x154 : Int = 0
val x189 = while (x154 < x140) {
val x155 = x129
val x156 = x155.readLine()
x135 = x156
val x158 = x135
val x159 = x158.trim()
x135 = x159
val x161 = x135
val x163 = new generated.scala.DoubleVectorImpl(x142,true)
var x164: Int = 0
var x165: Int = 1
val x166 = x165
val x162 = x161.split("\\s+")
val x167 = x162.length
val x168 = x167 - 1
val x169 = x166 < x168
val x170 = x162(x166)
val x171 = java.lang.Integer.parseInt(x170)
val x173 = x164
val x174 = x166 + 1
val x175 = x162(x174)
val x176 = java.lang.Double.parseDouble(x175)
val x180 = while ({x169}) {
val x172 = x164 += x171
val x177 = x163(x173) = x176
val x178 = x165 += 2
()
}
val x183 = x151.length
val x181 = x162(0)
val x182 = java.lang.Double.parseDouble(x181)
val x184 = x151.insert(x183, x182)
val x185 = x163.cloneL
val x186 = x152.length
val x187 = x152.insert(x186, x185)
x187
x154 = x154 + 1
}
val x190 = x151.length
val x191 = x151.isRow
val x192 = !x191
// a *thin* loop follows: x198
val x198 = {
val x194 = new generated.scala.DoubleVectorImpl(x190,x192)
x194
}
var x193 = 0
while (x193 < x190) {  // begin fat loop x198
val x196 = x151(x193)
x198.dcUpdate(x193, x196)
x193 += 1
} // end fat loop x198
val x234 = { 
val x199 = x152.length
val x200 = x199==0
val x232 = {
def x232thenb(): generated.scala.Matrix[Double] = {
val x201 = new generated.scala.DoubleMatrixImpl(0,0)
x201
}
def x232elseb(): generated.scala.Matrix[Double] = {
val x203 = x152(0)
val x204 = x203.isRow
val x230 = {
def x230thenb(): generated.scala.Matrix[Double] = {
val x205 = x203.length
val x206 = new generated.scala.DoubleMatrixImpl(x199,x205)
var x208 : Int = 0
val x217 = while (x208 < x199) {
var x210 : Int = 0
val x215 = while (x210 < x205) {
val x211 = x152(x208)
val x212 = x211(x210)
val x213 = x206(x208, x210) = x212
x213
x210 = x210 + 1
}
x215
x208 = x208 + 1
}
x206
}
def x230elseb(): generated.scala.Matrix[Double] = {
val x205 = x203.length
val x219 = new generated.scala.DoubleMatrixImpl(x205,x199)
var x220 : Int = 0
val x228 = while (x220 < x199) {
var x221 : Int = 0
val x226 = while (x221 < x205) {
val x222 = x152(x220)
val x223 = x222(x221)
val x224 = x219(x221, x220) = x223
x224
x221 = x221 + 1
}
x226
x220 = x220 + 1
}
x219
}
if (x204) {
x230thenb()
} else { 
x230elseb()
}
}
x230
}
if (x200) {
x232thenb()
} else { 
x232elseb()
}
}
x232
}
val x235 = x129
val x236 = x235.close()
val x237 = new generated.scala.DoubleLabelsImpl(x198)
val x238 = new generated.scala.DoubleDoubleTrainingSetImpl(x234,x237)
x238
}
val x241 = Seq()
val x242 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
val x243 = println("Training SVM using the SMO algorithm")
val x253 = x126.numCols
val x257 = { 
val x254 = new generated.scala.DoubleVectorImpl(x253,true)
x254
}
var x258: Double = 0.0
val x259 = x126.numRows
val x263 = { 
val x260 = new generated.scala.DoubleVectorImpl(x259,true)
x260
}
val x264 = x263.mtrans
var x265: Int = 0
var x266: Int = 0
val x267 = x265
val x268 = x267 < 10
val x244 = x126.labels
val x248 = x244.length
val x249 = x244.isRow
def x252_block = {
val x250 = new generated.scala.DoubleVectorImpl(x248,x249)
var mapIdx = 0
while (mapIdx < x244.size) { // begin map loop x252
val x245 = x244.dcApply(mapIdx)
x250.dcUpdate(mapIdx,  {
val x246 = x245==0
val x247 = {
def x247thenb(): Double = {
-1.0
}
def x247elseb(): Double = {
1.0
}
if (x246) {
x247thenb()
} else { 
x247elseb()
}
}
x247
})
mapIdx += 1
} // end map loop x252
x250
}
val x252 = x252_block
val x285 = !true
val x295 = new generated.scala.IndexVectorRangeImpl(0,x259)
val x319 = List()
val x336 = x258
val x633 = while ({x268}) {
val x269 = print(".")
val x270 = x266 += 1
var x271: Int = 0
var x272: Int = 0
val x273 = x272
val x274 = x273 < x259
val x338 = x252(x273)
val x289 = x273 * x253
val x293 = {
val x287 = new generated.scala.DoubleVectorImpl(x253,x285)
x287
}
var x286 = 0
while (x286 < x253) {  // begin fat loop x293
val x290 = x289 + x286
val x291 = x126.dcApply(x290)
val x292 = { 
x291
}
x293.dcUpdate(x286, x292)
x286 += 1
} // end fat loop x293
val x624 = while ({x274}) {
val x275 = x263.cloneL
val x276 = x275.isRow
val x283 = {
val x278 = new generated.scala.DoubleVectorImpl(x259,x276)
x278
}
var x277 = 0
while (x277 < x259) {  // begin fat loop x283
val x280 = x275(x277)
val x281 = x252(x277)
val x282 = x280 * x281
x283.dcUpdate(x277, x282)
x277 += 1
} // end fat loop x283
val x322 = { 
val x294 = new generated.scala.DoubleVectorImpl(x259,false)
val x320 = {
var forIdx = 0
while (forIdx < x295.size) { // begin foreach loop x320
val x296 = x295.dcApply(forIdx)
val x301 = x296 * x253
val x309 = {
val x299 = new generated.scala.DoubleVectorImpl(x253,true)
x299
}
var x298 = 0
while (x298 < x253) {  // begin fat loop x309
val x302 = x301 + x298
val x303 = x126.dcApply(x302)
val x304 = { 
x303
}
val x305 = x289 + x298
val x306 = x126.dcApply(x305)
val x307 = { 
x306
}
val x308 = x304 * x307
x309.dcUpdate(x298, x308)
x298 += 1
} // end fat loop x309
var x315: Double = 0
var x310 = 0
while (x310 < x253) {  // begin fat loop x315
val x313 = x309(x310)
val x311 = x315
val x312 = x313
val x314 = x311 + x312
x315 = x314
x310 += 1
} // end fat loop x315
val x316 = x294(x296) = x315
x316
forIdx += 1
} // end foreach loop x320
}
x294
}
val x329 = {
val x324 = new generated.scala.DoubleVectorImpl(x259,x276)
x324
}
var x323 = 0
while (x323 < x259) {  // begin fat loop x329
val x326 = x283(x323)
val x327 = x322(x323)
val x328 = x326 * x327
x329.dcUpdate(x323, x328)
x323 += 1
} // end fat loop x329
var x335: Double = 0
var x330 = 0
while (x330 < x259) {  // begin fat loop x335
val x333 = x329(x330)
val x331 = x335
val x332 = x333
val x334 = x331 + x332
x335 = x334
x330 += 1
} // end fat loop x335
val x337 = x335 + x336
val x339 = x337 - x338
val x340 = x338 * x339
val x341 = x340 < -0.0010
val x342 = x275(x273)
val x343 = x342 < 1.0
val x344 = x341 && x343
val x345 = x340 > 0.0010
val x346 = x342 > 0.0
val x347 = x345 && x346
val x348 = x344 || x347
val x621 = {
def x621thenb(): Unit = {
val x349 = generated.scala.Global.randRef.nextDouble()
val x350 = x349.asInstanceOf[Double]
val x351 = x259 - 1
val x352 = x351
val x353 = x350 * x352
val x354 = Math.floor(x353)
val x355 = x354.asInstanceOf[Int]
val x356 = x355 + 1
var x357: Int = x356
val x358 = x357
val x359 = x358==x273
val x368 = while ({x359}) {
val x360 = generated.scala.Global.randRef.nextDouble()
val x361 = x360.asInstanceOf[Double]
val x362 = x361 * x352
val x363 = Math.floor(x362)
val x364 = x363.asInstanceOf[Int]
val x365 = x364 + 1
x357 = x365
()
}
var x428: Double = 0.0
var x429: Double = 0.0
val x425 = x252(x358)
val x430 = x338 != x425
val x446 = {
def x446thenb(): Unit = {
val x427 = x275(x358)
val x431 = x427 - x342
val x432 = Math.max(0.0, x431)
x428 = x432
val x434 = 1.0 + x427
val x435 = x434 - x342
val x436 = Math.min(1.0, x435)
x429 = x436
()
}
def x446elseb(): Unit = {
val x427 = x275(x358)
val x439 = x342 + x427
val x440 = x439 - 1.0
val x441 = Math.max(0.0, x440)
x428 = x441
val x443 = Math.min(1.0, x439)
x429 = x443
()
}
if (x430) {
x446thenb()
} else { 
x446elseb()
}
}
val x447 = x428
val x448 = x429
val x449 = x447 != x448
val x619 = {
def x619thenb(): Unit = {
val x379 = x358 * x253
val x460 = {
val x451 = new generated.scala.DoubleVectorImpl(x253,true)
x451
}
var x450 = 0
while (x450 < x253) {  // begin fat loop x460
val x453 = x289 + x450
val x454 = x126.dcApply(x453)
val x455 = { 
x454
}
val x456 = x379 + x450
val x457 = x126.dcApply(x456)
val x458 = { 
x457
}
val x459 = x455 * x458
x460.dcUpdate(x450, x459)
x450 += 1
} // end fat loop x460
var x466: Double = 0
var x461 = 0
while (x461 < x253) {  // begin fat loop x466
val x464 = x460(x461)
val x462 = x466
val x463 = x464
val x465 = x462 + x463
x466 = x465
x461 += 1
} // end fat loop x466
val x467 = x466 * 2.0
val x475 = {
val x469 = new generated.scala.DoubleVectorImpl(x253,true)
x469
}
var x468 = 0
while (x468 < x253) {  // begin fat loop x475
val x471 = x289 + x468
val x472 = x126.dcApply(x471)
val x473 = { 
x472
}
val x474 = x473 * x473
x475.dcUpdate(x468, x474)
x468 += 1
} // end fat loop x475
var x481: Double = 0
var x476 = 0
while (x476 < x253) {  // begin fat loop x481
val x479 = x475(x476)
val x477 = x481
val x478 = x479
val x480 = x477 + x478
x481 = x480
x476 += 1
} // end fat loop x481
val x482 = x467 - x481
val x490 = {
val x484 = new generated.scala.DoubleVectorImpl(x253,true)
x484
}
var x483 = 0
while (x483 < x253) {  // begin fat loop x490
val x486 = x379 + x483
val x487 = x126.dcApply(x486)
val x488 = { 
x487
}
val x489 = x488 * x488
x490.dcUpdate(x483, x489)
x483 += 1
} // end fat loop x490
var x496: Double = 0
var x491 = 0
while (x491 < x253) {  // begin fat loop x496
val x494 = x490(x491)
val x492 = x496
val x493 = x494
val x495 = x492 + x493
x496 = x495
x491 += 1
} // end fat loop x496
val x497 = x482 - x496
val x498 = x497 < 0.0
val x617 = {
def x617thenb(): Unit = {
val x427 = x275(x358)
val x383 = {
val x377 = new generated.scala.DoubleVectorImpl(x253,x285)
x377
}
var x376 = 0
while (x376 < x253) {  // begin fat loop x383
val x380 = x379 + x376
val x381 = x126.dcApply(x380)
val x382 = { 
x381
}
x383.dcUpdate(x376, x382)
x376 += 1
} // end fat loop x383
val x410 = { 
val x384 = new generated.scala.DoubleVectorImpl(x259,false)
val x408 = {
var forIdx = 0
while (forIdx < x295.size) { // begin foreach loop x408
val x385 = x295.dcApply(forIdx)
val x390 = x385 * x253
val x398 = {
val x388 = new generated.scala.DoubleVectorImpl(x253,true)
x388
}
var x387 = 0
while (x387 < x253) {  // begin fat loop x398
val x391 = x390 + x387
val x392 = x126.dcApply(x391)
val x393 = { 
x392
}
val x394 = x379 + x387
val x395 = x126.dcApply(x394)
val x396 = { 
x395
}
val x397 = x393 * x396
x398.dcUpdate(x387, x397)
x387 += 1
} // end fat loop x398
var x404: Double = 0
var x399 = 0
while (x399 < x253) {  // begin fat loop x404
val x402 = x398(x399)
val x400 = x404
val x401 = x402
val x403 = x400 + x401
x404 = x403
x399 += 1
} // end fat loop x404
val x405 = x384(x385) = x404
x405
forIdx += 1
} // end foreach loop x408
}
x384
}
val x417 = {
val x412 = new generated.scala.DoubleVectorImpl(x259,x276)
x412
}
var x411 = 0
while (x411 < x259) {  // begin fat loop x417
val x414 = x283(x411)
val x415 = x410(x411)
val x416 = x414 * x415
x417.dcUpdate(x411, x416)
x411 += 1
} // end fat loop x417
var x423: Double = 0
var x418 = 0
while (x418 < x259) {  // begin fat loop x423
val x421 = x417(x418)
val x419 = x423
val x420 = x421
val x422 = x419 + x420
x423 = x422
x418 += 1
} // end fat loop x423
val x424 = x423 + x336
val x426 = x424 - x425
val x499 = x339 - x426
val x500 = x425 * x499
val x501 = x500 / x497
val x502 = x427 - x501
val x503 = x263(x358) = x502
val x504 = x263(x358)
val x505 = x504 > x448
val x513 = {
def x513thenb(): Unit = {
val x506 = x263(x358) = x448
x506
}
def x513elseb(): Unit = {
val x508 = x504 < x447
val x511 = {
def x511thenb(): Unit = {
val x509 = x263(x358) = x447
x509
}
if (x508) {
x511thenb()
}
}
x511
}
if (x505) {
x513thenb()
} else { 
x513elseb()
}
}
val x514 = x263(x358)
val x515 = x514 - x427
val x516 = Math.abs(x515)
val x517 = x516 > 1.0E-5
val x615 = {
def x615thenb(): Unit = {
val x518 = x338 * x425
val x519 = x427 - x514
val x520 = x518 * x519
val x521 = x342 + x520
val x522 = x263(x273) = x521
val x537 = x263(x273)
val x557 = x263(x358)
val x595 = x537 > 0.0
val x596 = x537 < 1.0
val x597 = x595 && x596
val x600 = {
def x600thenb(): Unit = {
val x523 = x336 - x339
val x536 = x481 * x338
val x538 = x537 - x342
val x539 = x536 * x538
val x540 = x523 - x539
val x556 = x466 * x425
val x558 = x557 - x427
val x559 = x556 * x558
val x560 = x540 - x559
x258 = x560
()
}
if (x597) {
x600thenb()
}
}
val x601 = x557 > 0.0
val x602 = x557 < 1.0
val x603 = x601 && x602
val x606 = {
def x606thenb(): Unit = {
val x561 = x336 - x426
val x538 = x537 - x342
val x577 = x466 * x338
val x578 = x577 * x538
val x579 = x561 - x578
val x558 = x557 - x427
val x592 = x496 * x425
val x593 = x592 * x558
val x594 = x579 - x593
x258 = x594
()
}
if (x603) {
x606thenb()
}
}
val x607 = x336==x336
val x612 = {
def x612thenb(): Unit = {
val x523 = x336 - x339
val x536 = x481 * x338
val x538 = x537 - x342
val x539 = x536 * x538
val x540 = x523 - x539
val x556 = x466 * x425
val x558 = x557 - x427
val x559 = x556 * x558
val x560 = x540 - x559
val x561 = x336 - x426
val x577 = x466 * x338
val x578 = x577 * x538
val x579 = x561 - x578
val x592 = x496 * x425
val x593 = x592 * x558
val x594 = x579 - x593
val x608 = x560 + x594
val x609 = x608 / 2.0
x258 = x609
()
}
if (x607) {
x612thenb()
}
}
val x613 = x271 += 1
()
}
if (x517) {
x615thenb()
}
}
x615
}
if (x498) {
x617thenb()
}
}
x617
}
if (x449) {
x619thenb()
}
}
x619
}
if (x348) {
x621thenb()
}
}
val x622 = x272 += 1
()
}
val x625 = x271
val x626 = x625==0
val x631 = {
def x631thenb(): Unit = {
val x627 = x265 += 1
()
}
def x631elseb(): Unit = {
x265 = 0
()
}
if (x626) {
x631thenb()
} else { 
x631elseb()
}
}
x631
}
val x634 = x266
val x635 = "num iterations: "+x634
val x636 = println(x635)
var x637: Int = 0
val x638 = x637
val x639 = x638 < x259
val x651 = x252(x638)
val x645 = x638 * x253
val x664 = while ({x639}) {
val x641 = x263(x638)
val x650 = {
val x643 = new generated.scala.DoubleVectorImpl(x253,true)
x643
}
var x642 = 0
while (x642 < x253) {  // begin fat loop x650
val x646 = x645 + x642
val x647 = x126.dcApply(x646)
val x648 = { 
x647
}
val x649 = x648 * x641
x650.dcUpdate(x642, x649)
x642 += 1
} // end fat loop x650
val x657 = {
val x653 = new generated.scala.DoubleVectorImpl(x253,true)
x653
}
var x652 = 0
while (x652 < x253) {  // begin fat loop x657
val x655 = x650(x652)
val x656 = x655 * x651
x657.dcUpdate(x652, x656)
x652 += 1
} // end fat loop x657
def x661_block = {
var zipIdx = 0
while (zipIdx < x257.size) { // begin zip loop x661
val x658 = x257.dcApply(zipIdx)
val x659 = x657.dcApply(zipIdx)
x257.dcUpdate(zipIdx,  {
val x660 = x658 + x659
x660
})
zipIdx += 1
} // end zip loop x661
x257
}
val x661 = x661_block
val x662 = x637 += 1
()
}
val x665 = print("\n")
val x666 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
val x676 = x240.numRows
val x677 = new generated.scala.IndexVectorRangeImpl(0,x676)
val x685 = x240.numCols
val x704 = x677.length
val x705 = x677.isRow
def x708_block = {
val x706 = new generated.scala.IntVectorImpl(x704,x705)
var mapIdx = 0
while (mapIdx < x677.size) { // begin map loop x708
val x678 = x677.dcApply(mapIdx)
x706.dcUpdate(mapIdx,  {
val x680 = x257.isRow
val x686 = x678 * x685
// a *thin* loop follows: x692
val x692 = {
val x682 = new generated.scala.DoubleVectorImpl(x253,x680)
x682
}
var x681 = 0
while (x681 < x253) {  // begin fat loop x692
val x684 = x257(x681)
val x687 = x686 + x681
val x688 = x240.dcApply(x687)
val x689 = { 
x688
}
val x690 = x684 * x689
x692.dcUpdate(x681, x690)
x681 += 1
} // end fat loop x692
// a *thin* loop follows: x699
var x699: Double = 0
var x693 = 0
while (x693 < x253) {  // begin fat loop x699
val x696 = x692(x693)
val x694 = x699
val x695 = x696
val x698 = x694 + x695
x699 = x698
x693 += 1
} // end fat loop x699
val x700 = x699 + x336
val x701 = x700 < 0.0
val x702 = {
def x702thenb(): Int = {
-1
}
def x702elseb(): Int = {
1
}
if (x701) {
x702thenb()
} else { 
x702elseb()
}
}
x702
})
mapIdx += 1
} // end map loop x708
x706
}
val x708 = x708_block
val x709 = println("SVM testing finished. Calculating error..")
val x667 = x240.labels
val x671 = x667.length
val x672 = x667.isRow
def x675_block = {
val x673 = new generated.scala.DoubleVectorImpl(x671,x672)
var mapIdx = 0
while (mapIdx < x667.size) { // begin map loop x675
val x668 = x667.dcApply(mapIdx)
x673.dcUpdate(mapIdx,  {
val x669 = x668==0
val x670 = {
def x670thenb(): Double = {
-1.0
}
def x670elseb(): Double = {
1.0
}
if (x669) {
x670thenb()
} else { 
x670elseb()
}
}
x670
})
mapIdx += 1
} // end map loop x675
x673
}
val x675 = x675_block
val x715 = new generated.scala.RangeVectorImpl(0,x676,1,true)
def x719_block = {
val x710 = x715.dcApply(0)
var x716 = {
val x711 = x675(x710)
val x712 = x708(x710)
val x713 = x711 != x712
val x714 = {
def x714thenb(): Int = {
1
}
def x714elseb(): Int = {
0
}
if (x713) {
x714thenb()
} else { 
x714elseb()
}
}
x714
}
var mapReduceIdx = 1
while (mapReduceIdx < x715.size) { // begin mapReduce loop x719
val x710 = x715.dcApply(mapReduceIdx)
val x717 = {
val x711 = x675(x710)
val x712 = x708(x710)
val x713 = x711 != x712
val x714 = {
def x714thenb(): Int = {
1
}
def x714elseb(): Int = {
0
}
if (x713) {
x714thenb()
} else { 
x714elseb()
}
}
x714
}
x716 = {
val x718 = x716 + x717
x718
}
mapReduceIdx += 1
} // end mapReduce loop x719
x716
}
val x719 = x719_block
val x720 = x719.doubleValue()
val x721 = x676.doubleValue()
val x722 = x720 / x721
val x723 = "Classification error: "+x722
val x724 = println(x723)
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
