/*****************************************
  Emitting Generated Code                  
*******************************************/
class SVMRunner extends ((Array[java.lang.String])=>(Unit)) {
def apply(x0:Array[java.lang.String]): Unit = {
val x1 = x0.length
val x2 = x1 < 1
val x6 = {
def x6thenb(): Nothing = {
val x3 = println("Usage: SVM <train data file> <test data file> <model filename> <num tests>")
val x4 = exit(-1)
x4
}
def x6elseb(): Unit = {
()
}
if (x2) {
x6thenb()
} else {
x6elseb()
}
}
val x12 = { generated.scala.Global.randRef.setSeed(generated.scala.Global.INITIAL_SEED);   generated.scala.Global.intRandRef.setSeed(generated.scala.Global.INITIAL_SEED); }
val x7 = x0(0)
val x150 = { 
val x13 = new java.io.FileReader(x7)
val x14 = new java.io.BufferedReader(x13)
var x15: java.io.BufferedReader = x14
val x16 = x15
val x17 = x16.readLine()
var x18: java.lang.String = x17
val x19 = x15
val x20 = x19.readLine()
var x21: java.lang.String = x20
val x22 = x21
val x23 = x22.trim()
val x24 = x23.split("\\s+")
val x25 = x24(0)
val x26 = java.lang.Integer.parseInt(x25)
val x29 = x26 < 0
val x27 = x24(1)
val x28 = java.lang.Integer.parseInt(x27)
val x30 = x28 < 0
val x31 = x29 || x30
val x34 = {
def x34thenb(): Nothing = {
val x32 = error("Illegal input to readTokenMatrix")
x32
}
def x34elseb(): Unit = {
()
}
if (x31) {
x34thenb()
} else {
x34elseb()
}
}
val x35 = x15
val x36 = x35.readLine()
val x37 = new generated.scala.DoubleVectorImpl(0,true)
var x39 : Int = 0
val x53 = while (x39 < x26) {
val x40 = x15
val x41 = x40.readLine()
x21 = x41
val x43 = x21
val x44 = x43.trim()
x21 = x44
val x46 = x21
val x50 = x37.length
val x47 = x46.split("\\s+")
val x48 = x47(0)
val x49 = java.lang.Double.parseDouble(x48)
val x51 = x37.insert(x50, x49)
x51
x39 = x39 + 1
}
val x54 = x37.length
val x55 = x37.isRow
val x56 = !x55
// a *thin* loop follows: x62
val x62 = {
val x58 = new generated.scala.DoubleVectorImpl(x54,x56)
x58
}
var x57 = 0
while (x57 < x54) {  // begin fat loop x62
val x60 = x37(x57)
x62.dcUpdate(x57, x60)
x57 += 1
} // end fat loop x62
val x63 = x15
val x64 = x63.close()
val x65 = new java.io.FileReader(x7)
val x66 = new java.io.BufferedReader(x65)
x15 = x66
val x68 = x15
val x69 = x68.readLine()
val x70 = x15
val x71 = x70.readLine()
val x72 = x15
val x73 = x72.readLine()
val x74 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x75 : Int = 0
val x108 = while (x75 < x26) {
val x76 = x15
val x77 = x76.readLine()
x21 = x77
val x79 = x21
val x80 = x79.trim()
x21 = x80
val x82 = x21
val x84 = new generated.scala.DoubleVectorImpl(x28,true)
var x85: Int = 0
var x86: Int = 1
val x83 = x82.split("\\s+")
val x88 = x83.length
val x89 = x88 - 1
val x104 = while ({val x87 = x86
val x90 = x87 < x89
x90}) {
val x92 = x86
val x93 = x83(x92)
val x94 = java.lang.Integer.parseInt(x93)
val x95 = x85 += x94
val x96 = x85
val x97 = x86
val x98 = x97 + 1
val x99 = x83(x98)
val x100 = java.lang.Double.parseDouble(x99)
val x101 = x84(x96) = x100
val x102 = x86 += 2
()
}
val x105 = x74.length
val x106 = x74.insert(x105, x84)
x106
x75 = x75 + 1
}
val x144 = { 
val x109 = x74.length
val x110 = x109==0
val x142 = {
def x142thenb(): generated.scala.Matrix[Double] = {
val x111 = new generated.scala.DoubleMatrixImpl(0,0)
x111
}
def x142elseb(): generated.scala.Matrix[Double] = {
val x113 = x74(0)
val x114 = x113.isRow
val x140 = {
def x140thenb(): generated.scala.Matrix[Double] = {
val x115 = x113.length
val x116 = new generated.scala.DoubleMatrixImpl(x109,x115)
var x118 : Int = 0
val x127 = while (x118 < x109) {
var x120 : Int = 0
val x125 = while (x120 < x115) {
val x121 = x74(x118)
val x122 = x121(x120)
val x123 = x116(x118, x120) = x122
x123
x120 = x120 + 1
}
x125
x118 = x118 + 1
}
x116
}
def x140elseb(): generated.scala.Matrix[Double] = {
val x115 = x113.length
val x129 = new generated.scala.DoubleMatrixImpl(x115,x109)
var x130 : Int = 0
val x138 = while (x130 < x109) {
var x131 : Int = 0
val x136 = while (x131 < x115) {
val x132 = x74(x130)
val x133 = x132(x131)
val x134 = x129(x131, x130) = x133
x134
x131 = x131 + 1
}
x136
x130 = x130 + 1
}
x129
}
if (x114) {
x140thenb()
} else {
x140elseb()
}
}
x140
}
if (x110) {
x142thenb()
} else {
x142elseb()
}
}
x142
}
val x145 = x15
val x146 = x145.close()
val x147 = new generated.scala.DoubleLabelsImpl(x62)
val x148 = new generated.scala.DoubleDoubleTrainingSetImpl(x144,x147)
x148
}
val x8 = x0(1)
val x288 = { 
val x151 = new java.io.FileReader(x8)
val x152 = new java.io.BufferedReader(x151)
var x153: java.io.BufferedReader = x152
val x154 = x153
val x155 = x154.readLine()
var x156: java.lang.String = x155
val x157 = x153
val x158 = x157.readLine()
var x159: java.lang.String = x158
val x160 = x159
val x161 = x160.trim()
val x162 = x161.split("\\s+")
val x163 = x162(0)
val x164 = java.lang.Integer.parseInt(x163)
val x167 = x164 < 0
val x165 = x162(1)
val x166 = java.lang.Integer.parseInt(x165)
val x168 = x166 < 0
val x169 = x167 || x168
val x172 = {
def x172thenb(): Nothing = {
val x170 = error("Illegal input to readTokenMatrix")
x170
}
def x172elseb(): Unit = {
()
}
if (x169) {
x172thenb()
} else {
x172elseb()
}
}
val x173 = x153
val x174 = x173.readLine()
val x175 = new generated.scala.DoubleVectorImpl(0,true)
var x177 : Int = 0
val x191 = while (x177 < x164) {
val x178 = x153
val x179 = x178.readLine()
x159 = x179
val x181 = x159
val x182 = x181.trim()
x159 = x182
val x184 = x159
val x188 = x175.length
val x185 = x184.split("\\s+")
val x186 = x185(0)
val x187 = java.lang.Double.parseDouble(x186)
val x189 = x175.insert(x188, x187)
x189
x177 = x177 + 1
}
val x192 = x175.length
val x193 = x175.isRow
val x194 = !x193
// a *thin* loop follows: x200
val x200 = {
val x196 = new generated.scala.DoubleVectorImpl(x192,x194)
x196
}
var x195 = 0
while (x195 < x192) {  // begin fat loop x200
val x198 = x175(x195)
x200.dcUpdate(x195, x198)
x195 += 1
} // end fat loop x200
val x201 = x153
val x202 = x201.close()
val x203 = new java.io.FileReader(x8)
val x204 = new java.io.BufferedReader(x203)
x153 = x204
val x206 = x153
val x207 = x206.readLine()
val x208 = x153
val x209 = x208.readLine()
val x210 = x153
val x211 = x210.readLine()
val x212 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x213 : Int = 0
val x246 = while (x213 < x164) {
val x214 = x153
val x215 = x214.readLine()
x159 = x215
val x217 = x159
val x218 = x217.trim()
x159 = x218
val x220 = x159
val x222 = new generated.scala.DoubleVectorImpl(x166,true)
var x223: Int = 0
var x224: Int = 1
val x221 = x220.split("\\s+")
val x226 = x221.length
val x227 = x226 - 1
val x242 = while ({val x225 = x224
val x228 = x225 < x227
x228}) {
val x230 = x224
val x231 = x221(x230)
val x232 = java.lang.Integer.parseInt(x231)
val x233 = x223 += x232
val x234 = x223
val x235 = x224
val x236 = x235 + 1
val x237 = x221(x236)
val x238 = java.lang.Double.parseDouble(x237)
val x239 = x222(x234) = x238
val x240 = x224 += 2
()
}
val x243 = x212.length
val x244 = x212.insert(x243, x222)
x244
x213 = x213 + 1
}
val x282 = { 
val x247 = x212.length
val x248 = x247==0
val x280 = {
def x280thenb(): generated.scala.Matrix[Double] = {
val x249 = new generated.scala.DoubleMatrixImpl(0,0)
x249
}
def x280elseb(): generated.scala.Matrix[Double] = {
val x251 = x212(0)
val x252 = x251.isRow
val x278 = {
def x278thenb(): generated.scala.Matrix[Double] = {
val x253 = x251.length
val x254 = new generated.scala.DoubleMatrixImpl(x247,x253)
var x256 : Int = 0
val x265 = while (x256 < x247) {
var x258 : Int = 0
val x263 = while (x258 < x253) {
val x259 = x212(x256)
val x260 = x259(x258)
val x261 = x254(x256, x258) = x260
x261
x258 = x258 + 1
}
x263
x256 = x256 + 1
}
x254
}
def x278elseb(): generated.scala.Matrix[Double] = {
val x253 = x251.length
val x267 = new generated.scala.DoubleMatrixImpl(x253,x247)
var x268 : Int = 0
val x276 = while (x268 < x247) {
var x269 : Int = 0
val x274 = while (x269 < x253) {
val x270 = x212(x268)
val x271 = x270(x269)
val x272 = x267(x269, x268) = x271
x272
x269 = x269 + 1
}
x274
x268 = x268 + 1
}
x267
}
if (x252) {
x278thenb()
} else {
x278elseb()
}
}
x278
}
if (x248) {
x280thenb()
} else {
x280elseb()
}
}
x280
}
val x283 = x153
val x284 = x283.close()
val x285 = new generated.scala.DoubleLabelsImpl(x200)
val x286 = new generated.scala.DoubleDoubleTrainingSetImpl(x282,x285)
x286
}
val x289 = x150.labels
def x293_block = {
var mapIdx = 0
while (mapIdx < x289.size) { // begin map loop x293
val x290 = x289.dcApply(mapIdx)
x289.dcUpdate(mapIdx,  {
val x291 = x290==0
val x292 = {
def x292thenb(): Double = {
-1.0
}
def x292elseb(): Double = {
1.0
}
if (x291) {
x292thenb()
} else {
x292elseb()
}
}
x292
})
mapIdx += 1
} // end map loop x293
x289
}
val x293 = x293_block
val x294 = x288.labels
def x298_block = {
var mapIdx = 0
while (mapIdx < x294.size) { // begin map loop x298
val x295 = x294.dcApply(mapIdx)
x294.dcUpdate(mapIdx,  {
val x296 = x295==0
val x297 = {
def x297thenb(): Double = {
-1.0
}
def x297elseb(): Double = {
1.0
}
if (x296) {
x297thenb()
} else {
x297elseb()
}
}
x297
})
mapIdx += 1
} // end map loop x298
x294
}
val x298 = x298_block
val x299 = Seq()
val x300 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
val x301 = println("Training SVM using the SMO algorithm")
val x302 = x150.numCols
val x305 = { 
val x303 = new generated.scala.DoubleVectorImpl(x302,true)
x303
}
var x306: generated.scala.Vector[Double] = x305
var x307: Double = 0.0
val x308 = x150.numRows
val x311 = { 
val x309 = new generated.scala.DoubleVectorImpl(x308,true)
x309
}
val x312 = x311.mtrans
var x313: Int = 0
val x654 = while ({val x314 = x313
val x315 = x314 < 10
x315}) {
val x317 = print(".")
var x318: Int = 0
var x319: Int = 0
val x645 = while ({val x320 = x319
val x321 = x320 < x308
x321}) {
val x323 = x311.cloneL
val x332 = x319
val x371 = x307
val x373 = x319
val x376 = x319
val x380 = x319
val x384 = x319
val x388 = x319
val x324 = x323.isRow
val x331 = {
val x326 = new generated.scala.DoubleVectorImpl(x308,x324)
x326
}
var x325 = 0
while (x325 < x308) {  // begin fat loop x331
val x328 = x323(x325)
val x329 = x289(x325)
val x330 = x328 * x329
x331.dcUpdate(x325, x330)
x325 += 1
} // end fat loop x331
val x357 = {
val x341 = new generated.scala.DoubleVectorImpl(x308,false)
x341
}
var x340 = 0
while (x340 < x308) {  // begin fat loop x357
val x350 = {
val x345 = new generated.scala.DoubleVectorImpl(x302,true)
x345
}
var x344 = 0
while (x344 < x302) {  // begin fat loop x350
val x347 = x150(x340, x344)
val x348 = x150(x332, x344)
val x349 = x347 * x348
x350.dcUpdate(x344, x349)
x344 += 1
} // end fat loop x350
var x356: Double = 0
var x351 = 0
while (x351 < x302) {  // begin fat loop x356
val x354 = x350(x351)
val x352 = x356
val x353 = x354
val x355 = x352 + x353
x356 = x355
x351 += 1
} // end fat loop x356
x357.dcUpdate(x340, x356)
x340 += 1
} // end fat loop x357
val x364 = {
val x359 = new generated.scala.DoubleVectorImpl(x308,x324)
x359
}
var x358 = 0
while (x358 < x308) {  // begin fat loop x364
val x361 = x331(x358)
val x362 = x357(x358)
val x363 = x361 * x362
x364.dcUpdate(x358, x363)
x358 += 1
} // end fat loop x364
var x370: Double = 0
var x365 = 0
while (x365 < x308) {  // begin fat loop x370
val x368 = x364(x365)
val x366 = x370
val x367 = x368
val x369 = x366 + x367
x370 = x369
x365 += 1
} // end fat loop x370
val x372 = x370 + x371
val x374 = x289(x373)
val x375 = x372 - x374
val x377 = x289(x376)
val x378 = x377 * x375
val x379 = x378 < -1.0E-4
val x381 = x323(x380)
val x382 = x381 < 1.0
val x383 = x379 && x382
val x385 = x289(x384)
val x386 = x385 * x375
val x387 = x386 > 1.0E-4
val x389 = x323(x388)
val x390 = x389 > 0.0
val x391 = x387 && x390
val x392 = x383 || x391
val x642 = {
def x642thenb(): Unit = {
val x393 = generated.scala.Global.randRef.nextDouble()
val x394 = x393.asInstanceOf[Double]
val x395 = x308 - 1
val x396 = x395
val x397 = x394 * x396
val x398 = Math.floor(x397)
val x399 = x398.asInstanceOf[Int]
val x400 = x399 + 1
var x401: Int = x400
val x414 = while ({val x402 = x401
val x403 = x319
val x404 = x402==x403
x404}) {
val x406 = generated.scala.Global.randRef.nextDouble()
val x407 = x406.asInstanceOf[Double]
val x408 = x407 * x396
val x409 = Math.floor(x408)
val x410 = x409.asInstanceOf[Int]
val x411 = x410 + 1
x401 = x411
()
}
val x421 = x401
val x459 = x307
var x464: Double = 0.0
var x465: Double = 0.0
val x466 = x319
val x461 = x289(x421)
val x467 = x289(x466)
val x468 = x467 != x461
val x485 = {
def x485thenb(): Unit = {
val x463 = x323(x421)
val x469 = x323(x466)
val x470 = x463 - x469
val x471 = Math.max(0.0, x470)
x464 = x471
val x473 = 1.0 + x463
val x474 = x473 - x469
val x475 = Math.min(1.0, x474)
x465 = x475
()
}
def x485elseb(): Unit = {
val x463 = x323(x421)
val x469 = x323(x466)
val x478 = x469 + x463
val x479 = x478 - 1.0
val x480 = Math.max(0.0, x479)
x464 = x480
val x482 = Math.min(1.0, x478)
x465 = x482
()
}
if (x468) {
x485thenb()
} else {
x485elseb()
}
}
val x486 = x464
val x487 = x465
val x488 = x486 != x487
val x640 = {
def x640thenb(): Unit = {
val x496 = {
val x491 = new generated.scala.DoubleVectorImpl(x302,true)
x491
}
var x490 = 0
while (x490 < x302) {  // begin fat loop x496
val x493 = x150(x466, x490)
val x494 = x150(x421, x490)
val x495 = x493 * x494
x496.dcUpdate(x490, x495)
x490 += 1
} // end fat loop x496
var x502: Double = 0
var x497 = 0
while (x497 < x302) {  // begin fat loop x502
val x500 = x496(x497)
val x498 = x502
val x499 = x500
val x501 = x498 + x499
x502 = x501
x497 += 1
} // end fat loop x502
val x503 = x502 * 2.0
val x509 = {
val x505 = new generated.scala.DoubleVectorImpl(x302,true)
x505
}
var x504 = 0
while (x504 < x302) {  // begin fat loop x509
val x507 = x150(x466, x504)
val x508 = x507 * x507
x509.dcUpdate(x504, x508)
x504 += 1
} // end fat loop x509
var x515: Double = 0
var x510 = 0
while (x510 < x302) {  // begin fat loop x515
val x513 = x509(x510)
val x511 = x515
val x512 = x513
val x514 = x511 + x512
x515 = x514
x510 += 1
} // end fat loop x515
val x516 = x503 - x515
val x522 = {
val x518 = new generated.scala.DoubleVectorImpl(x302,true)
x518
}
var x517 = 0
while (x517 < x302) {  // begin fat loop x522
val x520 = x150(x421, x517)
val x521 = x520 * x520
x522.dcUpdate(x517, x521)
x517 += 1
} // end fat loop x522
var x528: Double = 0
var x523 = 0
while (x523 < x302) {  // begin fat loop x528
val x526 = x522(x523)
val x524 = x528
val x525 = x526
val x527 = x524 + x525
x528 = x527
x523 += 1
} // end fat loop x528
val x529 = x516 - x528
val x530 = x529 < 0.0
val x638 = {
def x638thenb(): Unit = {
val x463 = x323(x421)
val x445 = {
val x429 = new generated.scala.DoubleVectorImpl(x308,false)
x429
}
var x428 = 0
while (x428 < x308) {  // begin fat loop x445
val x438 = {
val x433 = new generated.scala.DoubleVectorImpl(x302,true)
x433
}
var x432 = 0
while (x432 < x302) {  // begin fat loop x438
val x435 = x150(x428, x432)
val x436 = x150(x421, x432)
val x437 = x435 * x436
x438.dcUpdate(x432, x437)
x432 += 1
} // end fat loop x438
var x444: Double = 0
var x439 = 0
while (x439 < x302) {  // begin fat loop x444
val x442 = x438(x439)
val x440 = x444
val x441 = x442
val x443 = x440 + x441
x444 = x443
x439 += 1
} // end fat loop x444
x445.dcUpdate(x428, x444)
x428 += 1
} // end fat loop x445
val x452 = {
val x447 = new generated.scala.DoubleVectorImpl(x308,x324)
x447
}
var x446 = 0
while (x446 < x308) {  // begin fat loop x452
val x449 = x331(x446)
val x450 = x445(x446)
val x451 = x449 * x450
x452.dcUpdate(x446, x451)
x446 += 1
} // end fat loop x452
var x458: Double = 0
var x453 = 0
while (x453 < x308) {  // begin fat loop x458
val x456 = x452(x453)
val x454 = x458
val x455 = x456
val x457 = x454 + x455
x458 = x457
x453 += 1
} // end fat loop x458
val x460 = x458 + x459
val x462 = x460 - x461
val x531 = x375 - x462
val x532 = x461 * x531
val x533 = x532 / x529
val x534 = x463 - x533
val x535 = x311(x421) = x534
val x536 = x311(x421)
val x537 = x536 > x487
val x545 = {
def x545thenb(): Unit = {
val x538 = x311(x421) = x487
x538
}
def x545elseb(): Unit = {
val x540 = x536 < x486
val x543 = {
def x543thenb(): Unit = {
val x541 = x311(x421) = x486
x541
}
def x543elseb(): Unit = {
()
}
if (x540) {
x543thenb()
} else {
x543elseb()
}
}
x543
}
if (x537) {
x545thenb()
} else {
x545elseb()
}
}
val x546 = x311(x421)
val x547 = x546 - x463
val x548 = Math.abs(x547)
val x549 = x548 > 1.0E-4
val x636 = {
def x636thenb(): Unit = {
val x469 = x323(x466)
val x550 = x467 * x461
val x551 = x463 - x546
val x552 = x550 * x551
val x553 = x469 + x552
val x554 = x311(x466) = x553
val x567 = x311(x466)
val x583 = x311(x421)
val x615 = x567 > 0.0
val x616 = x567 < 1.0
val x617 = x615 && x616
val x620 = {
def x620thenb(): Unit = {
val x555 = x459 - x375
val x566 = x515 * x467
val x568 = x567 - x469
val x569 = x566 * x568
val x570 = x555 - x569
val x582 = x502 * x461
val x584 = x583 - x463
val x585 = x582 * x584
val x586 = x570 - x585
x307 = x586
()
}
def x620elseb(): Unit = {
()
}
if (x617) {
x620thenb()
} else {
x620elseb()
}
}
val x621 = x583 > 0.0
val x622 = x583 < 1.0
val x623 = x621 && x622
val x626 = {
def x626thenb(): Unit = {
val x587 = x459 - x462
val x568 = x567 - x469
val x599 = x502 * x467
val x600 = x599 * x568
val x601 = x587 - x600
val x584 = x583 - x463
val x612 = x528 * x461
val x613 = x612 * x584
val x614 = x601 - x613
x307 = x614
()
}
def x626elseb(): Unit = {
()
}
if (x623) {
x626thenb()
} else {
x626elseb()
}
}
val x627 = x307
val x628 = x627==x627
val x633 = {
def x633thenb(): Unit = {
val x555 = x459 - x375
val x566 = x515 * x467
val x568 = x567 - x469
val x569 = x566 * x568
val x570 = x555 - x569
val x582 = x502 * x461
val x584 = x583 - x463
val x585 = x582 * x584
val x586 = x570 - x585
val x587 = x459 - x462
val x599 = x502 * x467
val x600 = x599 * x568
val x601 = x587 - x600
val x612 = x528 * x461
val x613 = x612 * x584
val x614 = x601 - x613
val x629 = x586 + x614
val x630 = x629 / 2.0
x307 = x630
()
}
def x633elseb(): Unit = {
()
}
if (x628) {
x633thenb()
} else {
x633elseb()
}
}
val x634 = x318 += 1
()
}
def x636elseb(): Unit = {
()
}
if (x549) {
x636thenb()
} else {
x636elseb()
}
}
x636
}
def x638elseb(): Unit = {
()
}
if (x530) {
x638thenb()
} else {
x638elseb()
}
}
x638
}
def x640elseb(): Unit = {
()
}
if (x488) {
x640thenb()
} else {
x640elseb()
}
}
x640
}
def x642elseb(): Unit = {
()
}
if (x392) {
x642thenb()
} else {
x642elseb()
}
}
val x643 = x319 += 1
()
}
val x646 = x318
val x647 = x646==0
val x652 = {
def x652thenb(): Unit = {
val x648 = x313 += 1
()
}
def x652elseb(): Unit = {
x313 = 0
()
}
if (x647) {
x652thenb()
} else {
x652elseb()
}
}
x652
}
var x655: Int = 0
val x690 = while ({val x656 = x655
val x657 = x656 < x308
x657}) {
val x659 = x306
val x660 = x655
val x662 = x655
val x663 = x311(x662)
val x670 = x655
val x678 = x659.length
val x679 = x659.isRow
val x671 = x289(x670)
val x669 = {
val x665 = new generated.scala.DoubleVectorImpl(x302,true)
x665
}
var x664 = 0
while (x664 < x302) {  // begin fat loop x669
val x667 = x150(x660, x664)
val x668 = x667 * x663
x669.dcUpdate(x664, x668)
x664 += 1
} // end fat loop x669
val x677 = {
val x673 = new generated.scala.DoubleVectorImpl(x302,true)
x673
}
var x672 = 0
while (x672 < x302) {  // begin fat loop x677
val x675 = x669(x672)
val x676 = x675 * x671
x677.dcUpdate(x672, x676)
x672 += 1
} // end fat loop x677
val x686 = {
val x681 = new generated.scala.DoubleVectorImpl(x678,x679)
x681
}
var x680 = 0
while (x680 < x678) {  // begin fat loop x686
val x683 = x659(x680)
val x684 = x677(x680)
val x685 = x683 + x684
x686.dcUpdate(x680, x685)
x680 += 1
} // end fat loop x686
x306 = x686
val x688 = x655 += 1
()
}
val x691 = print("\n")
val x692 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
val x693 = x288.numRows
val x694 = new generated.scala.IndexVectorRangeImpl(0,x693)
val x718 = x694.length
val x719 = x694.isRow
def x722_block = {
val x720 = new generated.scala.IntVectorImpl(x718,x719)
var mapIdx = 0
while (mapIdx < x694.size) { // begin map loop x722
val x695 = x694.dcApply(mapIdx)
x720.dcUpdate(mapIdx,  {
val x696 = x306
val x697 = x307
val x699 = x696.length
val x700 = x696.isRow
val x707 = {
val x702 = new generated.scala.DoubleVectorImpl(x699,x700)
x702
}
var x701 = 0
while (x701 < x699) {  // begin fat loop x707
val x704 = x696(x701)
val x705 = x288(x695, x701)
val x706 = x704 * x705
x707.dcUpdate(x701, x706)
x701 += 1
} // end fat loop x707
var x713: Double = 0
var x708 = 0
while (x708 < x699) {  // begin fat loop x713
val x711 = x707(x708)
val x709 = x713
val x710 = x711
val x712 = x709 + x710
x713 = x712
x708 += 1
} // end fat loop x713
val x714 = x713 + x697
val x715 = x714 < 0.0
val x716 = {
def x716thenb(): Int = {
-1
}
def x716elseb(): Int = {
1
}
if (x715) {
x716thenb()
} else {
x716elseb()
}
}
x716
})
mapIdx += 1
} // end map loop x722
x720
}
val x722 = x722_block
val x723 = println("SVM testing finished. Calculating error..")
val x729 = new generated.scala.RangeVectorImpl(0,x693,1,true)
def x733_block = {
val x724 = x729.dcApply(0)
var x730 = {
val x725 = x294(x724)
val x726 = x722(x724)
val x727 = x725 != x726
val x728 = {
def x728thenb(): Int = {
1
}
def x728elseb(): Int = {
0
}
if (x727) {
x728thenb()
} else {
x728elseb()
}
}
x728
}
var mapReduceIdx = 1
while (mapReduceIdx < x729.size) { // begin mapReduce loop x733
val x724 = x729.dcApply(mapReduceIdx)
val x731 = {
val x725 = x294(x724)
val x726 = x722(x724)
val x727 = x725 != x726
val x728 = {
def x728thenb(): Int = {
1
}
def x728elseb(): Int = {
0
}
if (x727) {
x728thenb()
} else {
x728elseb()
}
}
x728
}
x730 = {
val x732 = x730 + x731
x732
}
mapReduceIdx += 1
} // end mapReduce loop x733
x730
}
val x733 = x733_block
val x734 = x733.doubleValue()
val x735 = x693.doubleValue()
val x736 = x734 / x735
val x737 = "Classification error: "+x736
val x738 = println(x737)
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
