/*****************************************
  Emitting Generated Code                  
*******************************************/
class SVMRunner extends ((Array[java.lang.String])=>(Unit)) {
def apply(x0:Array[java.lang.String]): Unit = {
val x1 = x0.length
val x2 = x1 < 1
val x6 = {
def x6thenb(): Nothing = {
val x3 = println("Usage: SVM <train data file> <test data file> <model filename> <num tests>")
val x4 = exit(-1)
x4
}
if (x2) {
x6thenb()
}
}
val x12 = { generated.scala.Global.randRef.setSeed(generated.scala.Global.INITIAL_SEED);   generated.scala.Global.intRandRef.setSeed(generated.scala.Global.INITIAL_SEED); }
val x7 = x0(0)
val x131 = { 
val x13 = new java.io.FileReader(x7)
val x14 = new java.io.BufferedReader(x13)
var x15: java.io.BufferedReader = x14
val x16 = x15
val x17 = x16.readLine()
var x18: java.lang.String = x17
val x19 = x15
val x20 = x19.readLine()
var x21: java.lang.String = x20
val x22 = x21
val x23 = x22.trim()
val x24 = x23.split("\\s+")
val x25 = x24(0)
val x26 = java.lang.Integer.parseInt(x25)
val x29 = x26 < 0
val x27 = x24(1)
val x28 = java.lang.Integer.parseInt(x27)
val x30 = x28 < 0
val x31 = x29 || x30
val x34 = {
def x34thenb(): Nothing = {
val x32 = error("Illegal input to readTokenMatrix")
x32
}
if (x31) {
x34thenb()
}
}
val x35 = x15
val x36 = x35.readLine()
val x37 = new generated.scala.DoubleVectorImpl(0,true)
val x38 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x40 : Int = 0
val x75 = while (x40 < x26) {
val x41 = x15
val x42 = x41.readLine()
x21 = x42
val x44 = x21
val x45 = x44.trim()
x21 = x45
val x47 = x21
val x49 = new generated.scala.DoubleVectorImpl(x28,true)
var x50: Int = 0
var x51: Int = 1
val x52 = x51
val x48 = x47.split("\\s+")
val x53 = x48.length
val x54 = x53 - 1
val x55 = x52 < x54
val x56 = x48(x52)
val x57 = java.lang.Integer.parseInt(x56)
val x59 = x50
val x60 = x52 + 1
val x61 = x48(x60)
val x62 = java.lang.Double.parseDouble(x61)
val x66 = while ({x55}) {
val x58 = x50 += x57
val x63 = x49(x59) = x62
val x64 = x51 += 2
()
}
val x69 = x37.length
val x67 = x48(0)
val x68 = java.lang.Double.parseDouble(x67)
val x70 = x37.insert(x69, x68)
val x71 = x49// unsafe immutable
val x72 = x38.length
val x73 = x38.insert(x72, x71)
x73
x40 = x40 + 1
}
val x76 = x37.length
val x77 = x37.isRow
val x78 = !x77
// a *thin* loop follows: x84
val x84 = {
val x80 = new generated.scala.DoubleVectorImpl(x76,x78)
x80
}
var x79 = 0
while (x79 < x76) {  // begin fat loop x84
val x82 = x37(x79)
x84.dcUpdate(x79, x82)
x79 += 1
} // end fat loop x84
val x123 = { 
val x85 = x38.length
val x86 = x85==0
val x121 = {
def x121thenb(): generated.scala.Matrix[Double] = {
val x87 = new generated.scala.DoubleMatrixImpl(0,0)
val x88 = x87// unsafe immutable
x88
}
def x121elseb(): generated.scala.Matrix[Double] = {
val x90 = x38(0)
val x91 = x90.isRow
val x92 = x90.length
val x119 = {
def x119thenb(): generated.scala.Matrix[Double] = {
val x93 = new generated.scala.DoubleMatrixImpl(x85,x92)
var x95 : Int = 0
val x104 = while (x95 < x85) {
var x97 : Int = 0
val x102 = while (x97 < x92) {
val x98 = x38(x95)
val x99 = x98(x97)
val x100 = x93(x95, x97) = x99
x100
x97 = x97 + 1
}
x102
x95 = x95 + 1
}
val x105 = x93// unsafe immutable
x105
}
def x119elseb(): generated.scala.Matrix[Double] = {
val x107 = new generated.scala.DoubleMatrixImpl(x92,x85)
var x108 : Int = 0
val x116 = while (x108 < x85) {
var x109 : Int = 0
val x114 = while (x109 < x92) {
val x110 = x38(x108)
val x111 = x110(x109)
val x112 = x107(x109, x108) = x111
x112
x109 = x109 + 1
}
x114
x108 = x108 + 1
}
val x117 = x107// unsafe immutable
x117
}
if (x91) {
x119thenb()
} else { 
x119elseb()
}
}
x119
}
if (x86) {
x121thenb()
} else { 
x121elseb()
}
}
x121
}
val x124 = x15
val x125 = x124.close()
val x126 = x123// unsafe immutable
val x127 = x84// unsafe immutable
val x128 = new generated.scala.DoubleLabelsImpl(x127)
val x129 = new generated.scala.DoubleDoubleTrainingSetImpl(x126,x128)
x129
}
val x8 = x0(1)
val x250 = { 
val x132 = new java.io.FileReader(x8)
val x133 = new java.io.BufferedReader(x132)
var x134: java.io.BufferedReader = x133
val x135 = x134
val x136 = x135.readLine()
var x137: java.lang.String = x136
val x138 = x134
val x139 = x138.readLine()
var x140: java.lang.String = x139
val x141 = x140
val x142 = x141.trim()
val x143 = x142.split("\\s+")
val x144 = x143(0)
val x145 = java.lang.Integer.parseInt(x144)
val x148 = x145 < 0
val x146 = x143(1)
val x147 = java.lang.Integer.parseInt(x146)
val x149 = x147 < 0
val x150 = x148 || x149
val x153 = {
def x153thenb(): Nothing = {
val x151 = error("Illegal input to readTokenMatrix")
x151
}
if (x150) {
x153thenb()
}
}
val x154 = x134
val x155 = x154.readLine()
val x156 = new generated.scala.DoubleVectorImpl(0,true)
val x157 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x159 : Int = 0
val x194 = while (x159 < x145) {
val x160 = x134
val x161 = x160.readLine()
x140 = x161
val x163 = x140
val x164 = x163.trim()
x140 = x164
val x166 = x140
val x168 = new generated.scala.DoubleVectorImpl(x147,true)
var x169: Int = 0
var x170: Int = 1
val x171 = x170
val x167 = x166.split("\\s+")
val x172 = x167.length
val x173 = x172 - 1
val x174 = x171 < x173
val x175 = x167(x171)
val x176 = java.lang.Integer.parseInt(x175)
val x178 = x169
val x179 = x171 + 1
val x180 = x167(x179)
val x181 = java.lang.Double.parseDouble(x180)
val x185 = while ({x174}) {
val x177 = x169 += x176
val x182 = x168(x178) = x181
val x183 = x170 += 2
()
}
val x188 = x156.length
val x186 = x167(0)
val x187 = java.lang.Double.parseDouble(x186)
val x189 = x156.insert(x188, x187)
val x190 = x168// unsafe immutable
val x191 = x157.length
val x192 = x157.insert(x191, x190)
x192
x159 = x159 + 1
}
val x195 = x156.length
val x196 = x156.isRow
val x197 = !x196
// a *thin* loop follows: x203
val x203 = {
val x199 = new generated.scala.DoubleVectorImpl(x195,x197)
x199
}
var x198 = 0
while (x198 < x195) {  // begin fat loop x203
val x201 = x156(x198)
x203.dcUpdate(x198, x201)
x198 += 1
} // end fat loop x203
val x242 = { 
val x204 = x157.length
val x205 = x204==0
val x240 = {
def x240thenb(): generated.scala.Matrix[Double] = {
val x206 = new generated.scala.DoubleMatrixImpl(0,0)
val x207 = x206// unsafe immutable
x207
}
def x240elseb(): generated.scala.Matrix[Double] = {
val x209 = x157(0)
val x210 = x209.isRow
val x211 = x209.length
val x238 = {
def x238thenb(): generated.scala.Matrix[Double] = {
val x212 = new generated.scala.DoubleMatrixImpl(x204,x211)
var x214 : Int = 0
val x223 = while (x214 < x204) {
var x216 : Int = 0
val x221 = while (x216 < x211) {
val x217 = x157(x214)
val x218 = x217(x216)
val x219 = x212(x214, x216) = x218
x219
x216 = x216 + 1
}
x221
x214 = x214 + 1
}
val x224 = x212// unsafe immutable
x224
}
def x238elseb(): generated.scala.Matrix[Double] = {
val x226 = new generated.scala.DoubleMatrixImpl(x211,x204)
var x227 : Int = 0
val x235 = while (x227 < x204) {
var x228 : Int = 0
val x233 = while (x228 < x211) {
val x229 = x157(x227)
val x230 = x229(x228)
val x231 = x226(x228, x227) = x230
x231
x228 = x228 + 1
}
x233
x227 = x227 + 1
}
val x236 = x226// unsafe immutable
x236
}
if (x210) {
x238thenb()
} else { 
x238elseb()
}
}
x238
}
if (x205) {
x240thenb()
} else { 
x240elseb()
}
}
x240
}
val x243 = x134
val x244 = x243.close()
val x245 = x242// unsafe immutable
val x246 = x203// unsafe immutable
val x247 = new generated.scala.DoubleLabelsImpl(x246)
val x248 = new generated.scala.DoubleDoubleTrainingSetImpl(x245,x247)
x248
}
val x251 = Seq()
val x252 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
val x253 = println("Training SVM using the SMO algorithm")
val x263 = x131.numCols
val x267 = { 
val x264 = new generated.scala.DoubleVectorImpl(x263,true)
x264
}
var x268: Double = 0.0
val x269 = x131.numRows
val x273 = { 
val x270 = new generated.scala.DoubleVectorImpl(x269,true)
x270
}
val x274 = x273.mtrans
var x275: Int = 0
var x276: Int = 0
val x277 = x275
val x278 = x277 < 10
val x254 = x131.labels
val x258 = x254.length
val x259 = x254.isRow
def x262_block = {
val x260 = new generated.scala.DoubleVectorImpl(x258,x259)
var mapIdx = 0
while (mapIdx < x254.size) { // begin map loop x262
val x255 = x254.dcApply(mapIdx)
x260.dcUpdate(mapIdx,  {
val x256 = x255==0
val x257 = {
def x257thenb(): Double = {
-1.0
}
def x257elseb(): Double = {
1.0
}
if (x256) {
x257thenb()
} else { 
x257elseb()
}
}
x257
})
mapIdx += 1
} // end map loop x262
x260
}
val x262 = x262_block
val x295 = !true
val x305 = new generated.scala.IndexVectorRangeImpl(0,x269)
val x329 = List()
val x347 = x268
val x362 = x269 - 1
val x363 = x362
val x619 = x347==x347
val x645 = while ({x278}) {
val x279 = print(".")
val x280 = x276 += 1
var x281: Int = 0
var x282: Int = 0
val x283 = x282
val x284 = x283 < x269
val x349 = x262(x283)
val x299 = x283 * x263
val x303 = {
val x297 = new generated.scala.DoubleVectorImpl(x263,x295)
x297
}
var x296 = 0
while (x296 < x263) {  // begin fat loop x303
val x300 = x299 + x296
val x301 = x131.dcApply(x300)
val x302 = { 
x301
}
x303.dcUpdate(x296, x302)
x296 += 1
} // end fat loop x303
val x487 = {
val x481 = new generated.scala.DoubleVectorImpl(x263,true)
x481
}
var x480 = 0
while (x480 < x263) {  // begin fat loop x487
val x483 = x299 + x480
val x484 = x131.dcApply(x483)
val x485 = { 
x484
}
val x486 = x485 * x485
x487.dcUpdate(x480, x486)
x480 += 1
} // end fat loop x487
var x493: Double = 0
var x488 = 0
while (x488 < x263) {  // begin fat loop x493
val x491 = x487(x488)
val x489 = x493
val x490 = x491
val x492 = x489 + x490
x493 = x492
x488 += 1
} // end fat loop x493
val x548 = x493 * x349
val x636 = while ({x284}) {
val x285 = x273.cloneL
val x286 = x285.isRow
val x293 = {
val x288 = new generated.scala.DoubleVectorImpl(x269,x286)
x288
}
var x287 = 0
while (x287 < x269) {  // begin fat loop x293
val x290 = x285(x287)
val x291 = x262(x287)
val x292 = x290 * x291
x293.dcUpdate(x287, x292)
x287 += 1
} // end fat loop x293
val x333 = { 
val x304 = new generated.scala.DoubleVectorImpl(x269,false)
val x330 = {
var forIdx = 0
while (forIdx < x305.size) { // begin foreach loop x330
val x306 = x305.dcApply(forIdx)
val x311 = x306 * x263
val x319 = {
val x309 = new generated.scala.DoubleVectorImpl(x263,true)
x309
}
var x308 = 0
while (x308 < x263) {  // begin fat loop x319
val x312 = x311 + x308
val x313 = x131.dcApply(x312)
val x314 = { 
x313
}
val x315 = x299 + x308
val x316 = x131.dcApply(x315)
val x317 = { 
x316
}
val x318 = x314 * x317
x319.dcUpdate(x308, x318)
x308 += 1
} // end fat loop x319
var x325: Double = 0
var x320 = 0
while (x320 < x263) {  // begin fat loop x325
val x323 = x319(x320)
val x321 = x325
val x322 = x323
val x324 = x321 + x322
x325 = x324
x320 += 1
} // end fat loop x325
val x326 = x304(x306) = x325
x326
forIdx += 1
} // end foreach loop x330
}
val x331 = x304// unsafe immutable
x331
}
val x340 = {
val x335 = new generated.scala.DoubleVectorImpl(x269,x286)
x335
}
var x334 = 0
while (x334 < x269) {  // begin fat loop x340
val x337 = x293(x334)
val x338 = x333(x334)
val x339 = x337 * x338
x340.dcUpdate(x334, x339)
x334 += 1
} // end fat loop x340
var x346: Double = 0
var x341 = 0
while (x341 < x269) {  // begin fat loop x346
val x344 = x340(x341)
val x342 = x346
val x343 = x344
val x345 = x342 + x343
x346 = x345
x341 += 1
} // end fat loop x346
val x348 = x346 + x347
val x350 = x348 - x349
val x351 = x349 * x350
val x352 = x351 < -0.0010
val x353 = x285(x283)
val x354 = x353 < 1.0
val x355 = x352 && x354
val x356 = x351 > 0.0010
val x357 = x353 > 0.0
val x358 = x356 && x357
val x359 = x355 || x358
val x535 = x347 - x350
val x633 = {
def x633thenb(): Unit = {
val x360 = generated.scala.Global.randRef.nextDouble()
val x361 = x360.asInstanceOf[Double]
val x364 = x361 * x363
val x365 = Math.floor(x364)
val x366 = x365.asInstanceOf[Int]
val x367 = x366 + 1
var x368: Int = x367
val x369 = x368
val x370 = x369==x283
val x379 = while ({x370}) {
val x371 = generated.scala.Global.randRef.nextDouble()
val x372 = x371.asInstanceOf[Double]
val x373 = x372 * x363
val x374 = Math.floor(x373)
val x375 = x374.asInstanceOf[Int]
val x376 = x375 + 1
x368 = x376
()
}
var x440: Double = 0.0
var x441: Double = 0.0
val x437 = x262(x369)
val x442 = x349 != x437
val x439 = x285(x369)
val x443 = x439 - x353
val x444 = Math.max(0.0, x443)
val x446 = 1.0 + x439
val x447 = x446 - x353
val x448 = Math.min(1.0, x447)
val x451 = x353 + x439
val x452 = x451 - 1.0
val x453 = Math.max(0.0, x452)
val x455 = Math.min(1.0, x451)
val x458 = {
def x458thenb(): Unit = {
x440 = x444
x441 = x448
()
}
def x458elseb(): Unit = {
x440 = x453
x441 = x455
()
}
if (x442) {
x458thenb()
} else { 
x458elseb()
}
}
val x459 = x440
val x460 = x441
val x461 = x459 != x460
val x390 = x369 * x263
val x472 = {
val x463 = new generated.scala.DoubleVectorImpl(x263,true)
x463
}
var x462 = 0
while (x462 < x263) {  // begin fat loop x472
val x465 = x299 + x462
val x466 = x131.dcApply(x465)
val x467 = { 
x466
}
val x468 = x390 + x462
val x469 = x131.dcApply(x468)
val x470 = { 
x469
}
val x471 = x467 * x470
x472.dcUpdate(x462, x471)
x462 += 1
} // end fat loop x472
var x478: Double = 0
var x473 = 0
while (x473 < x263) {  // begin fat loop x478
val x476 = x472(x473)
val x474 = x478
val x475 = x476
val x477 = x474 + x475
x478 = x477
x473 += 1
} // end fat loop x478
val x479 = x478 * 2.0
val x494 = x479 - x493
val x502 = {
val x496 = new generated.scala.DoubleVectorImpl(x263,true)
x496
}
var x495 = 0
while (x495 < x263) {  // begin fat loop x502
val x498 = x390 + x495
val x499 = x131.dcApply(x498)
val x500 = { 
x499
}
val x501 = x500 * x500
x502.dcUpdate(x495, x501)
x495 += 1
} // end fat loop x502
var x508: Double = 0
var x503 = 0
while (x503 < x263) {  // begin fat loop x508
val x506 = x502(x503)
val x504 = x508
val x505 = x506
val x507 = x504 + x505
x508 = x507
x503 += 1
} // end fat loop x508
val x509 = x494 - x508
val x510 = x509 < 0.0
val x394 = {
val x388 = new generated.scala.DoubleVectorImpl(x263,x295)
x388
}
var x387 = 0
while (x387 < x263) {  // begin fat loop x394
val x391 = x390 + x387
val x392 = x131.dcApply(x391)
val x393 = { 
x392
}
x394.dcUpdate(x387, x393)
x387 += 1
} // end fat loop x394
val x422 = { 
val x395 = new generated.scala.DoubleVectorImpl(x269,false)
val x419 = {
var forIdx = 0
while (forIdx < x305.size) { // begin foreach loop x419
val x396 = x305.dcApply(forIdx)
val x401 = x396 * x263
val x409 = {
val x399 = new generated.scala.DoubleVectorImpl(x263,true)
x399
}
var x398 = 0
while (x398 < x263) {  // begin fat loop x409
val x402 = x401 + x398
val x403 = x131.dcApply(x402)
val x404 = { 
x403
}
val x405 = x390 + x398
val x406 = x131.dcApply(x405)
val x407 = { 
x406
}
val x408 = x404 * x407
x409.dcUpdate(x398, x408)
x398 += 1
} // end fat loop x409
var x415: Double = 0
var x410 = 0
while (x410 < x263) {  // begin fat loop x415
val x413 = x409(x410)
val x411 = x415
val x412 = x413
val x414 = x411 + x412
x415 = x414
x410 += 1
} // end fat loop x415
val x416 = x395(x396) = x415
x416
forIdx += 1
} // end foreach loop x419
}
val x420 = x395// unsafe immutable
x420
}
val x429 = {
val x424 = new generated.scala.DoubleVectorImpl(x269,x286)
x424
}
var x423 = 0
while (x423 < x269) {  // begin fat loop x429
val x426 = x293(x423)
val x427 = x422(x423)
val x428 = x426 * x427
x429.dcUpdate(x423, x428)
x423 += 1
} // end fat loop x429
var x435: Double = 0
var x430 = 0
while (x430 < x269) {  // begin fat loop x435
val x433 = x429(x430)
val x431 = x435
val x432 = x433
val x434 = x431 + x432
x435 = x434
x430 += 1
} // end fat loop x435
val x436 = x435 + x347
val x438 = x436 - x437
val x511 = x350 - x438
val x512 = x437 * x511
val x513 = x512 / x509
val x514 = x439 - x513
val x530 = x349 * x437
val x568 = x478 * x437
val x573 = x347 - x438
val x589 = x478 * x349
val x604 = x508 * x437
val x631 = {
def x631thenb(): Unit = {
val x629 = {
def x629thenb(): Unit = {
val x515 = x273(x369) = x514
val x516 = x273(x369)
val x517 = x516 > x460
val x520 = x516 < x459
val x525 = {
def x525thenb(): Unit = {
val x518 = x273(x369) = x460
x518
}
def x525elseb(): Unit = {
val x523 = {
def x523thenb(): Unit = {
val x521 = x273(x369) = x459
x521
}
if (x520) {
x523thenb()
}
}
x523
}
if (x517) {
x525thenb()
} else { 
x525elseb()
}
}
val x526 = x273(x369)
val x527 = x526 - x439
val x528 = Math.abs(x527)
val x529 = x528 > 1.0E-5
val x531 = x439 - x526
val x532 = x530 * x531
val x533 = x353 + x532
val x627 = {
def x627thenb(): Unit = {
val x534 = x273(x283) = x533
val x549 = x273(x283)
val x569 = x273(x369)
val x607 = x549 > 0.0
val x608 = x549 < 1.0
val x609 = x607 && x608
val x550 = x549 - x353
val x551 = x548 * x550
val x552 = x535 - x551
val x570 = x569 - x439
val x571 = x568 * x570
val x572 = x552 - x571
val x612 = {
def x612thenb(): Unit = {
x268 = x572
()
}
if (x609) {
x612thenb()
}
}
val x613 = x569 > 0.0
val x614 = x569 < 1.0
val x615 = x613 && x614
val x590 = x589 * x550
val x591 = x573 - x590
val x605 = x604 * x570
val x606 = x591 - x605
val x618 = {
def x618thenb(): Unit = {
x268 = x606
()
}
if (x615) {
x618thenb()
}
}
val x620 = x572 + x606
val x621 = x620 / 2.0
val x624 = {
def x624thenb(): Unit = {
x268 = x621
()
}
if (x619) {
x624thenb()
}
}
val x625 = x281 += 1
()
}
if (x529) {
x627thenb()
}
}
x627
}
if (x510) {
x629thenb()
}
}
x629
}
if (x461) {
x631thenb()
}
}
x631
}
if (x359) {
x633thenb()
}
}
val x634 = x282 += 1
()
}
val x637 = x281
val x638 = x637==0
val x643 = {
def x643thenb(): Unit = {
val x639 = x275 += 1
()
}
def x643elseb(): Unit = {
x275 = 0
()
}
if (x638) {
x643thenb()
} else { 
x643elseb()
}
}
x643
}
val x646 = x276
val x647 = "num iterations: "+x646
val x648 = println(x647)
var x649: Int = 0
val x650 = x649
val x651 = x650 < x269
val x663 = x262(x650)
val x657 = x650 * x263
val x676 = while ({x651}) {
val x653 = x273(x650)
val x662 = {
val x655 = new generated.scala.DoubleVectorImpl(x263,true)
x655
}
var x654 = 0
while (x654 < x263) {  // begin fat loop x662
val x658 = x657 + x654
val x659 = x131.dcApply(x658)
val x660 = { 
x659
}
val x661 = x660 * x653
x662.dcUpdate(x654, x661)
x654 += 1
} // end fat loop x662
val x669 = {
val x665 = new generated.scala.DoubleVectorImpl(x263,true)
x665
}
var x664 = 0
while (x664 < x263) {  // begin fat loop x669
val x667 = x662(x664)
val x668 = x667 * x663
x669.dcUpdate(x664, x668)
x664 += 1
} // end fat loop x669
def x673_block = {
var zipIdx = 0
while (zipIdx < x267.size) { // begin zip loop x673
val x670 = x267.dcApply(zipIdx)
val x671 = x669.dcApply(zipIdx)
x267.dcUpdate(zipIdx,  {
val x672 = x670 + x671
x672
})
zipIdx += 1
} // end zip loop x673
x267
}
val x673 = x673_block
val x674 = x649 += 1
()
}
val x677 = print("\n")
val x678 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
val x688 = x250.numRows
val x689 = new generated.scala.IndexVectorRangeImpl(0,x688)
val x697 = x250.numCols
val x716 = x689.length
val x717 = x689.isRow
def x720_block = {
val x718 = new generated.scala.IntVectorImpl(x716,x717)
var mapIdx = 0
while (mapIdx < x689.size) { // begin map loop x720
val x690 = x689.dcApply(mapIdx)
x718.dcUpdate(mapIdx,  {
val x692 = x267.isRow
val x698 = x690 * x697
// a *thin* loop follows: x704
val x704 = {
val x694 = new generated.scala.DoubleVectorImpl(x263,x692)
x694
}
var x693 = 0
while (x693 < x263) {  // begin fat loop x704
val x696 = x267(x693)
val x699 = x698 + x693
val x700 = x250.dcApply(x699)
val x701 = { 
x700
}
val x702 = x696 * x701
x704.dcUpdate(x693, x702)
x693 += 1
} // end fat loop x704
// a *thin* loop follows: x711
var x711: Double = 0
var x705 = 0
while (x705 < x263) {  // begin fat loop x711
val x708 = x704(x705)
val x706 = x711
val x707 = x708
val x710 = x706 + x707
x711 = x710
x705 += 1
} // end fat loop x711
val x712 = x711 + x347
val x713 = x712 < 0.0
val x714 = {
def x714thenb(): Int = {
-1
}
def x714elseb(): Int = {
1
}
if (x713) {
x714thenb()
} else { 
x714elseb()
}
}
x714
})
mapIdx += 1
} // end map loop x720
x718
}
val x720 = x720_block
val x721 = println("SVM testing finished. Calculating error..")
val x679 = x250.labels
val x683 = x679.length
val x684 = x679.isRow
def x687_block = {
val x685 = new generated.scala.DoubleVectorImpl(x683,x684)
var mapIdx = 0
while (mapIdx < x679.size) { // begin map loop x687
val x680 = x679.dcApply(mapIdx)
x685.dcUpdate(mapIdx,  {
val x681 = x680==0
val x682 = {
def x682thenb(): Double = {
-1.0
}
def x682elseb(): Double = {
1.0
}
if (x681) {
x682thenb()
} else { 
x682elseb()
}
}
x682
})
mapIdx += 1
} // end map loop x687
x685
}
val x687 = x687_block
val x727 = new generated.scala.RangeVectorImpl(0,x688,1,true)
def x731_block = {
val x722 = x727.dcApply(0)
var x728 = {
val x723 = x687(x722)
val x724 = x720(x722)
val x725 = x723 != x724
val x726 = {
def x726thenb(): Int = {
1
}
def x726elseb(): Int = {
0
}
if (x725) {
x726thenb()
} else { 
x726elseb()
}
}
x726
}
var mapReduceIdx = 1
while (mapReduceIdx < x727.size) { // begin mapReduce loop x731
val x722 = x727.dcApply(mapReduceIdx)
val x729 = {
val x723 = x687(x722)
val x724 = x720(x722)
val x725 = x723 != x724
val x726 = {
def x726thenb(): Int = {
1
}
def x726elseb(): Int = {
0
}
if (x725) {
x726thenb()
} else { 
x726elseb()
}
}
x726
}
x728 = {
val x730 = x728 + x729
x730
}
mapReduceIdx += 1
} // end mapReduce loop x731
x728
}
val x731 = x731_block
val x732 = x731.doubleValue()
val x733 = x688.doubleValue()
val x734 = x732 / x733
val x735 = "Classification error: "+x734
val x736 = println(x735)
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
