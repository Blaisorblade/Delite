/*****************************************
  Emitting Generated Code                  
*******************************************/
class SVMRunner extends ((Array[java.lang.String])=>(Unit)) {
def apply(x0:Array[java.lang.String]): Unit = {
val x1 = x0.length
val x2 = x1 < 1
val x6 = {
def x6thenb(): Nothing = {
val x3 = println("Usage: SVM <train data file> <test data file> <model filename> <num tests>")
val x4 = exit(-1)
x4
}
def x6elseb(): Unit = {
()
}
if (x2) {
x6thenb()
} else {
x6elseb()
}
}
val x12 = { generated.scala.Global.randRef.setSeed(generated.scala.Global.INITIAL_SEED);   generated.scala.Global.intRandRef.setSeed(generated.scala.Global.INITIAL_SEED); }
val x7 = x0(0)
def x134_block = { 
val x13 = new java.io.FileReader(x7)
val x14 = new java.io.BufferedReader(x13)
var x15: java.io.BufferedReader = x14
val x16 = x15
val x17 = x16.readLine()
var x18: java.lang.String = x17
val x19 = x15
val x20 = x19.readLine()
var x21: java.lang.String = x20
val x22 = x21
val x23 = x22.trim()
val x24 = x23.split("\\s+")
val x25 = x24(0)
val x26 = java.lang.Integer.parseInt(x25)
val x29 = x26 < 0
val x27 = x24(1)
val x28 = java.lang.Integer.parseInt(x27)
val x30 = x28 < 0
val x31 = x29 || x30
val x34 = {
def x34thenb(): Nothing = {
val x32 = error("Illegal input to readTokenMatrix")
x32
}
def x34elseb(): Unit = {
()
}
if (x31) {
x34thenb()
} else {
x34elseb()
}
}
val x35 = x15
val x36 = x35.readLine()
val x37 = new generated.scala.DoubleVectorImpl(0,true)
var x39 : Int = 0
val x53 = while (x39 < x26) {
val x40 = x15
val x41 = x40.readLine()
x21 = x41
val x43 = x21
val x44 = x43.trim()
x21 = x44
val x46 = x21
val x50 = x37.length
val x47 = x46.split("\\s+")
val x48 = x47(0)
val x49 = java.lang.Double.parseDouble(x48)
val x51 = x37.insert(x50, x49)
x51
x39 = x39 + 1
}
val x54 = x37.length
val x55 = x37.isRow
val x56 = !x55
val x62 = {
val x58 = new generated.scala.DoubleVectorImpl(x54,x56)
x58
}
var x57 = 0
while (x57 < x54) {  // begin thin loop x62
val x60 = x37(x57)
x62.dcUpdate(x57, x60)
x57 += 1
} // end thin loop x62
val x63 = x15
val x64 = x63.close()
val x65 = new java.io.FileReader(x7)
val x66 = new java.io.BufferedReader(x65)
x15 = x66
val x68 = x15
val x69 = x68.readLine()
val x70 = x15
val x71 = x70.readLine()
val x72 = x15
val x73 = x72.readLine()
val x74 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x75 : Int = 0
val x108 = while (x75 < x26) {
val x76 = x15
val x77 = x76.readLine()
x21 = x77
val x79 = x21
val x80 = x79.trim()
x21 = x80
val x82 = x21
val x84 = new generated.scala.DoubleVectorImpl(x28,true)
var x85: Int = 0
var x86: Int = 1
val x83 = x82.split("\\s+")
val x88 = x83.length
val x89 = x88 - 1
val x104 = while ({val x87 = x86
val x90 = x87 < x89
x90}) {
val x92 = x86
val x93 = x83(x92)
val x94 = java.lang.Integer.parseInt(x93)
val x95 = x85 += x94
val x96 = x85
val x97 = x86
val x98 = x97 + 1
val x99 = x83(x98)
val x100 = java.lang.Double.parseDouble(x99)
val x101 = x84(x96) = x100
val x102 = x86 += 2
()
}
val x105 = x74.length
val x106 = x74.insert(x105, x84)
x106
x75 = x75 + 1
}
def x128_block = { 
val x109 = x74.length
val x110 = x109 > 0
val x114 = {
def x114thenb(): Int = {
val x111 = x74(0)
val x112 = x111.length
x112
}
def x114elseb(): Int = {
0
}
if (x110) {
x114thenb()
} else {
x114elseb()
}
}
val x115 = new generated.scala.DoubleMatrixImpl(x109,x114)
var x117 : Int = 0
val x126 = while (x117 < x109) {
var x119 : Int = 0
val x124 = while (x119 < x114) {
val x120 = x74(x117)
val x121 = x120(x119)
val x122 = x115(x117, x119) = x121
x122
x119 = x119 + 1
}
x124
x117 = x117 + 1
}
x115
}
val x128 = x128_block
val x129 = x15
val x130 = x129.close()
val x131 = new generated.scala.DoubleLabelsImpl(x62)
val x132 = new generated.scala.DoubleDoubleTrainingSetImpl(x128,x131)
x132
}
val x134 = x134_block
val x8 = x0(1)
def x256_block = { 
val x135 = new java.io.FileReader(x8)
val x136 = new java.io.BufferedReader(x135)
var x137: java.io.BufferedReader = x136
val x138 = x137
val x139 = x138.readLine()
var x140: java.lang.String = x139
val x141 = x137
val x142 = x141.readLine()
var x143: java.lang.String = x142
val x144 = x143
val x145 = x144.trim()
val x146 = x145.split("\\s+")
val x147 = x146(0)
val x148 = java.lang.Integer.parseInt(x147)
val x151 = x148 < 0
val x149 = x146(1)
val x150 = java.lang.Integer.parseInt(x149)
val x152 = x150 < 0
val x153 = x151 || x152
val x156 = {
def x156thenb(): Nothing = {
val x154 = error("Illegal input to readTokenMatrix")
x154
}
def x156elseb(): Unit = {
()
}
if (x153) {
x156thenb()
} else {
x156elseb()
}
}
val x157 = x137
val x158 = x157.readLine()
val x159 = new generated.scala.DoubleVectorImpl(0,true)
var x161 : Int = 0
val x175 = while (x161 < x148) {
val x162 = x137
val x163 = x162.readLine()
x143 = x163
val x165 = x143
val x166 = x165.trim()
x143 = x166
val x168 = x143
val x172 = x159.length
val x169 = x168.split("\\s+")
val x170 = x169(0)
val x171 = java.lang.Double.parseDouble(x170)
val x173 = x159.insert(x172, x171)
x173
x161 = x161 + 1
}
val x176 = x159.length
val x177 = x159.isRow
val x178 = !x177
val x184 = {
val x180 = new generated.scala.DoubleVectorImpl(x176,x178)
x180
}
var x179 = 0
while (x179 < x176) {  // begin thin loop x184
val x182 = x159(x179)
x184.dcUpdate(x179, x182)
x179 += 1
} // end thin loop x184
val x185 = x137
val x186 = x185.close()
val x187 = new java.io.FileReader(x8)
val x188 = new java.io.BufferedReader(x187)
x137 = x188
val x190 = x137
val x191 = x190.readLine()
val x192 = x137
val x193 = x192.readLine()
val x194 = x137
val x195 = x194.readLine()
val x196 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x197 : Int = 0
val x230 = while (x197 < x148) {
val x198 = x137
val x199 = x198.readLine()
x143 = x199
val x201 = x143
val x202 = x201.trim()
x143 = x202
val x204 = x143
val x206 = new generated.scala.DoubleVectorImpl(x150,true)
var x207: Int = 0
var x208: Int = 1
val x205 = x204.split("\\s+")
val x210 = x205.length
val x211 = x210 - 1
val x226 = while ({val x209 = x208
val x212 = x209 < x211
x212}) {
val x214 = x208
val x215 = x205(x214)
val x216 = java.lang.Integer.parseInt(x215)
val x217 = x207 += x216
val x218 = x207
val x219 = x208
val x220 = x219 + 1
val x221 = x205(x220)
val x222 = java.lang.Double.parseDouble(x221)
val x223 = x206(x218) = x222
val x224 = x208 += 2
()
}
val x227 = x196.length
val x228 = x196.insert(x227, x206)
x228
x197 = x197 + 1
}
def x250_block = { 
val x231 = x196.length
val x232 = x231 > 0
val x236 = {
def x236thenb(): Int = {
val x233 = x196(0)
val x234 = x233.length
x234
}
def x236elseb(): Int = {
0
}
if (x232) {
x236thenb()
} else {
x236elseb()
}
}
val x237 = new generated.scala.DoubleMatrixImpl(x231,x236)
var x239 : Int = 0
val x248 = while (x239 < x231) {
var x241 : Int = 0
val x246 = while (x241 < x236) {
val x242 = x196(x239)
val x243 = x242(x241)
val x244 = x237(x239, x241) = x243
x244
x241 = x241 + 1
}
x246
x239 = x239 + 1
}
x237
}
val x250 = x250_block
val x251 = x137
val x252 = x251.close()
val x253 = new generated.scala.DoubleLabelsImpl(x184)
val x254 = new generated.scala.DoubleDoubleTrainingSetImpl(x250,x253)
x254
}
val x256 = x256_block
val x257 = x134.labels
def x261_block = {
var mapIdx = 0
while (mapIdx < x257.size) {
val x258 = x257.dcApply(mapIdx)
x257.dcUpdate(mapIdx,  {
val x259 = x258==0
val x260 = {
def x260thenb(): Double = {
-1.0
}
def x260elseb(): Double = {
1.0
}
if (x259) {
x260thenb()
} else {
x260elseb()
}
}
x260
})
mapIdx += 1
} // end while
x257
}
val x261 = x261_block
val x262 = x256.labels
def x266_block = {
var mapIdx = 0
while (mapIdx < x262.size) {
val x263 = x262.dcApply(mapIdx)
x262.dcUpdate(mapIdx,  {
val x264 = x263==0
val x265 = {
def x265thenb(): Double = {
-1.0
}
def x265elseb(): Double = {
1.0
}
if (x264) {
x265thenb()
} else {
x265elseb()
}
}
x265
})
mapIdx += 1
} // end while
x262
}
val x266 = x266_block
val x267 = Seq()
val x268 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
val x269 = println("Training SVM using the SMO algorithm")
val x270 = x134.numCols
def x273_block = { 
val x271 = new generated.scala.DoubleVectorImpl(x270,true)
x271
}
val x273 = x273_block
var x274: generated.scala.Vector[Double] = x273
var x275: Double = 0.0
val x276 = x134.numRows
def x279_block = { 
val x277 = new generated.scala.DoubleVectorImpl(x276,true)
x277
}
val x279 = x279_block
val x280 = x279.mtrans
var x281: Int = 0
val x622 = while ({val x282 = x281
val x283 = x282 < 10
x283}) {
val x285 = print(".")
var x286: Int = 0
var x287: Int = 0
val x613 = while ({val x288 = x287
val x289 = x288 < x276
x289}) {
val x291 = x279.cloneL
val x300 = x287
val x339 = x275
val x341 = x287
val x344 = x287
val x348 = x287
val x352 = x287
val x356 = x287
val x292 = x291.isRow
val x299 = {
val x294 = new generated.scala.DoubleVectorImpl(x276,x292)
x294
}
var x293 = 0
while (x293 < x276) {  // begin fat loop x299
val x296 = x291(x293)
val x297 = x257(x293)
val x298 = x296 * x297
x299.dcUpdate(x293, x298)
x293 += 1
} // end fat loop x299
val x325 = {
val x309 = new generated.scala.DoubleVectorImpl(x276,false)
x309
}
var x308 = 0
while (x308 < x276) {  // begin fat loop x325
val x318 = {
val x313 = new generated.scala.DoubleVectorImpl(x270,true)
x313
}
var x312 = 0
while (x312 < x270) {  // begin fat loop x318
val x315 = x134(x308, x312)
val x316 = x134(x300, x312)
val x317 = x315 * x316
x318.dcUpdate(x312, x317)
x312 += 1
} // end fat loop x318
var x324: Double = 0
var x319 = 0
while (x319 < x270) {  // begin fat loop x324
val x322 = x318(x319)
val x320 = x324
val x321 = x322
val x323 = x320 + x321
x324 = x323
x319 += 1
} // end fat loop x324
x325.dcUpdate(x308, x324)
x308 += 1
} // end fat loop x325
val x332 = {
val x327 = new generated.scala.DoubleVectorImpl(x276,x292)
x327
}
var x326 = 0
while (x326 < x276) {  // begin fat loop x332
val x329 = x299(x326)
val x330 = x325(x326)
val x331 = x329 * x330
x332.dcUpdate(x326, x331)
x326 += 1
} // end fat loop x332
var x338: Double = 0
var x333 = 0
while (x333 < x276) {  // begin fat loop x338
val x336 = x332(x333)
val x334 = x338
val x335 = x336
val x337 = x334 + x335
x338 = x337
x333 += 1
} // end fat loop x338
val x340 = x338 + x339
val x342 = x257(x341)
val x343 = x340 - x342
val x345 = x257(x344)
val x346 = x345 * x343
val x347 = x346 < -1.0E-4
val x349 = x291(x348)
val x350 = x349 < 1.0
val x351 = x347 && x350
val x353 = x257(x352)
val x354 = x353 * x343
val x355 = x354 > 1.0E-4
val x357 = x291(x356)
val x358 = x357 > 0.0
val x359 = x355 && x358
val x360 = x351 || x359
val x610 = {
def x610thenb(): Unit = {
val x361 = generated.scala.Global.randRef.nextDouble()
val x362 = x361.asInstanceOf[Double]
val x363 = x276 - 1
val x364 = x363
val x365 = x362 * x364
val x366 = Math.floor(x365)
val x367 = x366.asInstanceOf[Int]
val x368 = x367 + 1
var x369: Int = x368
val x382 = while ({val x370 = x369
val x371 = x287
val x372 = x370==x371
x372}) {
val x374 = generated.scala.Global.randRef.nextDouble()
val x375 = x374.asInstanceOf[Double]
val x376 = x375 * x364
val x377 = Math.floor(x376)
val x378 = x377.asInstanceOf[Int]
val x379 = x378 + 1
x369 = x379
()
}
val x389 = x369
val x427 = x275
var x432: Double = 0.0
var x433: Double = 0.0
val x434 = x287
val x429 = x257(x389)
val x435 = x257(x434)
val x436 = x435 != x429
val x453 = {
def x453thenb(): Unit = {
val x431 = x291(x389)
val x437 = x291(x434)
val x438 = x431 - x437
val x439 = Math.max(0.0, x438)
x432 = x439
val x441 = 1.0 + x431
val x442 = x441 - x437
val x443 = Math.min(1.0, x442)
x433 = x443
()
}
def x453elseb(): Unit = {
val x431 = x291(x389)
val x437 = x291(x434)
val x446 = x437 + x431
val x447 = x446 - 1.0
val x448 = Math.max(0.0, x447)
x432 = x448
val x450 = Math.min(1.0, x446)
x433 = x450
()
}
if (x436) {
x453thenb()
} else {
x453elseb()
}
}
val x454 = x432
val x455 = x433
val x456 = x454 != x455
val x608 = {
def x608thenb(): Unit = {
val x464 = {
val x459 = new generated.scala.DoubleVectorImpl(x270,true)
x459
}
var x458 = 0
while (x458 < x270) {  // begin fat loop x464
val x461 = x134(x434, x458)
val x462 = x134(x389, x458)
val x463 = x461 * x462
x464.dcUpdate(x458, x463)
x458 += 1
} // end fat loop x464
var x470: Double = 0
var x465 = 0
while (x465 < x270) {  // begin fat loop x470
val x468 = x464(x465)
val x466 = x470
val x467 = x468
val x469 = x466 + x467
x470 = x469
x465 += 1
} // end fat loop x470
val x471 = x470 * 2.0
val x477 = {
val x473 = new generated.scala.DoubleVectorImpl(x270,true)
x473
}
var x472 = 0
while (x472 < x270) {  // begin fat loop x477
val x475 = x134(x434, x472)
val x476 = x475 * x475
x477.dcUpdate(x472, x476)
x472 += 1
} // end fat loop x477
var x483: Double = 0
var x478 = 0
while (x478 < x270) {  // begin fat loop x483
val x481 = x477(x478)
val x479 = x483
val x480 = x481
val x482 = x479 + x480
x483 = x482
x478 += 1
} // end fat loop x483
val x484 = x471 - x483
val x490 = {
val x486 = new generated.scala.DoubleVectorImpl(x270,true)
x486
}
var x485 = 0
while (x485 < x270) {  // begin fat loop x490
val x488 = x134(x389, x485)
val x489 = x488 * x488
x490.dcUpdate(x485, x489)
x485 += 1
} // end fat loop x490
var x496: Double = 0
var x491 = 0
while (x491 < x270) {  // begin fat loop x496
val x494 = x490(x491)
val x492 = x496
val x493 = x494
val x495 = x492 + x493
x496 = x495
x491 += 1
} // end fat loop x496
val x497 = x484 - x496
val x498 = x497 < 0.0
val x606 = {
def x606thenb(): Unit = {
val x431 = x291(x389)
val x413 = {
val x397 = new generated.scala.DoubleVectorImpl(x276,false)
x397
}
var x396 = 0
while (x396 < x276) {  // begin fat loop x413
val x406 = {
val x401 = new generated.scala.DoubleVectorImpl(x270,true)
x401
}
var x400 = 0
while (x400 < x270) {  // begin fat loop x406
val x403 = x134(x396, x400)
val x404 = x134(x389, x400)
val x405 = x403 * x404
x406.dcUpdate(x400, x405)
x400 += 1
} // end fat loop x406
var x412: Double = 0
var x407 = 0
while (x407 < x270) {  // begin fat loop x412
val x410 = x406(x407)
val x408 = x412
val x409 = x410
val x411 = x408 + x409
x412 = x411
x407 += 1
} // end fat loop x412
x413.dcUpdate(x396, x412)
x396 += 1
} // end fat loop x413
val x420 = {
val x415 = new generated.scala.DoubleVectorImpl(x276,x292)
x415
}
var x414 = 0
while (x414 < x276) {  // begin fat loop x420
val x417 = x299(x414)
val x418 = x413(x414)
val x419 = x417 * x418
x420.dcUpdate(x414, x419)
x414 += 1
} // end fat loop x420
var x426: Double = 0
var x421 = 0
while (x421 < x276) {  // begin fat loop x426
val x424 = x420(x421)
val x422 = x426
val x423 = x424
val x425 = x422 + x423
x426 = x425
x421 += 1
} // end fat loop x426
val x428 = x426 + x427
val x430 = x428 - x429
val x499 = x343 - x430
val x500 = x429 * x499
val x501 = x500 / x497
val x502 = x431 - x501
val x503 = x279(x389) = x502
val x504 = x279(x389)
val x505 = x504 > x455
val x513 = {
def x513thenb(): Unit = {
val x506 = x279(x389) = x455
x506
}
def x513elseb(): Unit = {
val x508 = x504 < x454
val x511 = {
def x511thenb(): Unit = {
val x509 = x279(x389) = x454
x509
}
def x511elseb(): Unit = {
()
}
if (x508) {
x511thenb()
} else {
x511elseb()
}
}
x511
}
if (x505) {
x513thenb()
} else {
x513elseb()
}
}
val x514 = x279(x389)
val x515 = x514 - x431
val x516 = Math.abs(x515)
val x517 = x516 > 1.0E-4
val x604 = {
def x604thenb(): Unit = {
val x437 = x291(x434)
val x518 = x435 * x429
val x519 = x431 - x514
val x520 = x518 * x519
val x521 = x437 + x520
val x522 = x279(x434) = x521
val x535 = x279(x434)
val x551 = x279(x389)
val x583 = x535 > 0.0
val x584 = x535 < 1.0
val x585 = x583 && x584
val x588 = {
def x588thenb(): Unit = {
val x523 = x427 - x343
val x534 = x483 * x435
val x536 = x535 - x437
val x537 = x534 * x536
val x538 = x523 - x537
val x550 = x470 * x429
val x552 = x551 - x431
val x553 = x550 * x552
val x554 = x538 - x553
x275 = x554
()
}
def x588elseb(): Unit = {
()
}
if (x585) {
x588thenb()
} else {
x588elseb()
}
}
val x589 = x551 > 0.0
val x590 = x551 < 1.0
val x591 = x589 && x590
val x594 = {
def x594thenb(): Unit = {
val x555 = x427 - x430
val x536 = x535 - x437
val x567 = x470 * x435
val x568 = x567 * x536
val x569 = x555 - x568
val x552 = x551 - x431
val x580 = x496 * x429
val x581 = x580 * x552
val x582 = x569 - x581
x275 = x582
()
}
def x594elseb(): Unit = {
()
}
if (x591) {
x594thenb()
} else {
x594elseb()
}
}
val x595 = x275
val x596 = x595==x595
val x601 = {
def x601thenb(): Unit = {
val x523 = x427 - x343
val x534 = x483 * x435
val x536 = x535 - x437
val x537 = x534 * x536
val x538 = x523 - x537
val x550 = x470 * x429
val x552 = x551 - x431
val x553 = x550 * x552
val x554 = x538 - x553
val x555 = x427 - x430
val x567 = x470 * x435
val x568 = x567 * x536
val x569 = x555 - x568
val x580 = x496 * x429
val x581 = x580 * x552
val x582 = x569 - x581
val x597 = x554 + x582
val x598 = x597 / 2.0
x275 = x598
()
}
def x601elseb(): Unit = {
()
}
if (x596) {
x601thenb()
} else {
x601elseb()
}
}
val x602 = x286 += 1
()
}
def x604elseb(): Unit = {
()
}
if (x517) {
x604thenb()
} else {
x604elseb()
}
}
x604
}
def x606elseb(): Unit = {
()
}
if (x498) {
x606thenb()
} else {
x606elseb()
}
}
x606
}
def x608elseb(): Unit = {
()
}
if (x456) {
x608thenb()
} else {
x608elseb()
}
}
x608
}
def x610elseb(): Unit = {
()
}
if (x360) {
x610thenb()
} else {
x610elseb()
}
}
val x611 = x287 += 1
()
}
val x614 = x286
val x615 = x614==0
val x620 = {
def x620thenb(): Unit = {
val x616 = x281 += 1
()
}
def x620elseb(): Unit = {
x281 = 0
()
}
if (x615) {
x620thenb()
} else {
x620elseb()
}
}
x620
}
var x623: Int = 0
val x658 = while ({val x624 = x623
val x625 = x624 < x276
x625}) {
val x627 = x274
val x628 = x623
val x630 = x623
val x631 = x279(x630)
val x638 = x623
val x646 = x627.length
val x647 = x627.isRow
val x639 = x257(x638)
val x637 = {
val x633 = new generated.scala.DoubleVectorImpl(x270,true)
x633
}
var x632 = 0
while (x632 < x270) {  // begin fat loop x637
val x635 = x134(x628, x632)
val x636 = x635 * x631
x637.dcUpdate(x632, x636)
x632 += 1
} // end fat loop x637
val x645 = {
val x641 = new generated.scala.DoubleVectorImpl(x270,true)
x641
}
var x640 = 0
while (x640 < x270) {  // begin fat loop x645
val x643 = x637(x640)
val x644 = x643 * x639
x645.dcUpdate(x640, x644)
x640 += 1
} // end fat loop x645
val x654 = {
val x649 = new generated.scala.DoubleVectorImpl(x646,x647)
x649
}
var x648 = 0
while (x648 < x646) {  // begin fat loop x654
val x651 = x627(x648)
val x652 = x645(x648)
val x653 = x651 + x652
x654.dcUpdate(x648, x653)
x648 += 1
} // end fat loop x654
x274 = x654
val x656 = x623 += 1
()
}
val x659 = print("\n")
val x660 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
val x661 = x256.numRows
val x662 = new generated.scala.IndexVectorRangeImpl(0,x661)
val x686 = x662.length
val x687 = x662.isRow
def x690_block = {
val x688 = new generated.scala.IntVectorImpl(x686,x687)
var mapIdx = 0
while (mapIdx < x662.size) {
val x663 = x662.dcApply(mapIdx)
x688.dcUpdate(mapIdx,  {
val x664 = x274
val x665 = x275
val x667 = x664.length
val x668 = x664.isRow
val x675 = {
val x670 = new generated.scala.DoubleVectorImpl(x667,x668)
x670
}
var x669 = 0
while (x669 < x667) {  // begin fat loop x675
val x672 = x664(x669)
val x673 = x256(x663, x669)
val x674 = x672 * x673
x675.dcUpdate(x669, x674)
x669 += 1
} // end fat loop x675
var x681: Double = 0
var x676 = 0
while (x676 < x667) {  // begin fat loop x681
val x679 = x675(x676)
val x677 = x681
val x678 = x679
val x680 = x677 + x678
x681 = x680
x676 += 1
} // end fat loop x681
val x682 = x681 + x665
val x683 = x682 < 0.0
val x684 = {
def x684thenb(): Int = {
-1
}
def x684elseb(): Int = {
1
}
if (x683) {
x684thenb()
} else {
x684elseb()
}
}
x684
})
mapIdx += 1
} // end while
x688
}
val x690 = x690_block
val x691 = println("SVM testing finished. Calculating error..")
val x697 = new generated.scala.RangeVectorImpl(0,x661,1,true)
def x701_block = {
val x692 = x697.dcApply(0)
var x698 = {
val x693 = x262(x692)
val x694 = x690(x692)
val x695 = x693 != x694
val x696 = {
def x696thenb(): Int = {
1
}
def x696elseb(): Int = {
0
}
if (x695) {
x696thenb()
} else {
x696elseb()
}
}
x696
}
var mapReduceIdx = 1
while (mapReduceIdx < x697.size) {
val x692 = x697.dcApply(mapReduceIdx)
val x699 = {
val x693 = x262(x692)
val x694 = x690(x692)
val x695 = x693 != x694
val x696 = {
def x696thenb(): Int = {
1
}
def x696elseb(): Int = {
0
}
if (x695) {
x696thenb()
} else {
x696elseb()
}
}
x696
}
x698 = {
val x700 = x698 + x699
x700
}
mapReduceIdx += 1
} // end while
x698
}
val x701 = x701_block
val x702 = x701.doubleValue()
val x703 = x661.doubleValue()
val x704 = x702 / x703
val x705 = "Classification error: "+x704
val x706 = println(x705)
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
