/*****************************************
  Emitting Generated Code                  
*******************************************/
class SVMRunner extends ((Array[java.lang.String])=>(Unit)) {
def apply(x0:Array[java.lang.String]): Unit = {
val x1 = x0.length
val x2 = x1 < 1
val x6 = {
def x6thenb(): Nothing = {
val x3 = println("Usage: SVM <train data file> <test data file> <model filename> <num tests>")
val x4 = exit(-1)
x4
}
if (x2) {
x6thenb()
}
}
val x12 = { generated.scala.Global.randRef.setSeed(generated.scala.Global.INITIAL_SEED);   generated.scala.Global.intRandRef.setSeed(generated.scala.Global.INITIAL_SEED); }
val x7 = x0(0)
val x129 = { 
val x13 = new java.io.FileReader(x7)
val x14 = new java.io.BufferedReader(x13)
val x15 = x14.readLine()
var x16: java.lang.String = x15
val x17 = x14.readLine()
var x18: java.lang.String = x17
val x19 = x18
val x20 = x19.trim()
val x21 = x20.split("\\s+")
val x22 = x21(0)
val x23 = java.lang.Integer.parseInt(x22)
val x26 = x23 < 0
val x24 = x21(1)
val x25 = java.lang.Integer.parseInt(x24)
val x27 = x25 < 0
val x28 = x26 || x27
val x31 = {
def x31thenb(): Nothing = {
val x29 = error("Illegal input to readTokenMatrix")
x29
}
if (x28) {
x31thenb()
}
}
val x32 = x14.readLine()
val x33 = new generated.scala.DoubleVectorImpl(0,true)
val x34 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x36 : Int = 0
val x73 = while (x36 < x23) {
val x37 = x14.readLine()
x18 = x37
val x39 = x18
val x40 = x39.trim()
x18 = x40
val x42 = x18
val x44 = new generated.scala.DoubleVectorImpl(x25,true)
var x45: Int = 0
var x46: Int = 1
val x43 = x42.split("\\s+")
val x48 = x43.length
val x49 = x48 - 1
val x64 = while ({val x47 = x46
val x50 = x47 < x49
x50}) {
val x52 = x46
val x53 = x43(x52)
val x54 = java.lang.Integer.parseInt(x53)
val x55 = x45 += x54
val x56 = x45
val x57 = x46
val x58 = x57 + 1
val x59 = x43(x58)
val x60 = java.lang.Double.parseDouble(x59)
val x61 = x44(x56) = x60
val x62 = x46 += 2
()
}
val x67 = x33.length
val x65 = x43(0)
val x66 = java.lang.Double.parseDouble(x65)
val x68 = x33.insert(x67, x66)
val x69 = x44// unsafe immutable
val x70 = x34.length
val x71 = x34.insert(x70, x69)
x71
x36 = x36 + 1
}
val x75 = x33.length
// a *thin* loop follows: x83
var x74 = 0
val x81 = x33.dcApply(x74)
val x83 = {
val x76 = x33.length
val x77 = x33.isRow
val x78 = !x77
val x79 = new generated.scala.DoubleVectorImpl(x76,x78)
x79
}
x83.dcUpdate(x74, x81)
x74 = 1
while (x74 < x75) {  // begin fat loop x83
val x81 = x33.dcApply(x74)
x83.dcUpdate(x74, x81)
x74 += 1
} // end fat loop x83
val x122 = { 
val x84 = x34.length
val x85 = x84==0
val x120 = {
def x120thenb(): generated.scala.Matrix[Double] = {
val x86 = new generated.scala.DoubleMatrixImpl(0,0)
val x87 = x86// unsafe immutable
x87
}
def x120elseb(): generated.scala.Matrix[Double] = {
val x89 = x34(0)
val x90 = x89.isRow
val x118 = {
def x118thenb(): generated.scala.Matrix[Double] = {
val x91 = x89.length
val x92 = new generated.scala.DoubleMatrixImpl(x84,x91)
var x94 : Int = 0
val x103 = while (x94 < x84) {
var x96 : Int = 0
val x101 = while (x96 < x91) {
val x97 = x34(x94)
val x98 = x97(x96)
val x99 = x92(x94, x96) = x98
x99
x96 = x96 + 1
}
x101
x94 = x94 + 1
}
val x104 = x92// unsafe immutable
x104
}
def x118elseb(): generated.scala.Matrix[Double] = {
val x91 = x89.length
val x106 = new generated.scala.DoubleMatrixImpl(x91,x84)
var x107 : Int = 0
val x115 = while (x107 < x84) {
var x108 : Int = 0
val x113 = while (x108 < x91) {
val x109 = x34(x107)
val x110 = x109(x108)
val x111 = x106(x108, x107) = x110
x111
x108 = x108 + 1
}
x113
x107 = x107 + 1
}
val x116 = x106// unsafe immutable
x116
}
if (x90) {
x118thenb()
} else { 
x118elseb()
}
}
x118
}
if (x85) {
x120thenb()
} else { 
x120elseb()
}
}
x120
}
val x123 = x14.close()
val x124 = x122// unsafe immutable
val x125 = x83// unsafe immutable
val x126 = new generated.scala.DoubleLabelsImpl(x125)
val x127 = new generated.scala.DoubleDoubleTrainingSetImpl(x124,x126)
x127
}
val x8 = x0(1)
val x246 = { 
val x130 = new java.io.FileReader(x8)
val x131 = new java.io.BufferedReader(x130)
val x132 = x131.readLine()
var x133: java.lang.String = x132
val x134 = x131.readLine()
var x135: java.lang.String = x134
val x136 = x135
val x137 = x136.trim()
val x138 = x137.split("\\s+")
val x139 = x138(0)
val x140 = java.lang.Integer.parseInt(x139)
val x143 = x140 < 0
val x141 = x138(1)
val x142 = java.lang.Integer.parseInt(x141)
val x144 = x142 < 0
val x145 = x143 || x144
val x148 = {
def x148thenb(): Nothing = {
val x146 = error("Illegal input to readTokenMatrix")
x146
}
if (x145) {
x148thenb()
}
}
val x149 = x131.readLine()
val x150 = new generated.scala.DoubleVectorImpl(0,true)
val x151 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
var x153 : Int = 0
val x190 = while (x153 < x140) {
val x154 = x131.readLine()
x135 = x154
val x156 = x135
val x157 = x156.trim()
x135 = x157
val x159 = x135
val x161 = new generated.scala.DoubleVectorImpl(x142,true)
var x162: Int = 0
var x163: Int = 1
val x160 = x159.split("\\s+")
val x165 = x160.length
val x166 = x165 - 1
val x181 = while ({val x164 = x163
val x167 = x164 < x166
x167}) {
val x169 = x163
val x170 = x160(x169)
val x171 = java.lang.Integer.parseInt(x170)
val x172 = x162 += x171
val x173 = x162
val x174 = x163
val x175 = x174 + 1
val x176 = x160(x175)
val x177 = java.lang.Double.parseDouble(x176)
val x178 = x161(x173) = x177
val x179 = x163 += 2
()
}
val x184 = x150.length
val x182 = x160(0)
val x183 = java.lang.Double.parseDouble(x182)
val x185 = x150.insert(x184, x183)
val x186 = x161// unsafe immutable
val x187 = x151.length
val x188 = x151.insert(x187, x186)
x188
x153 = x153 + 1
}
val x192 = x150.length
// a *thin* loop follows: x200
var x191 = 0
val x198 = x150.dcApply(x191)
val x200 = {
val x193 = x150.length
val x194 = x150.isRow
val x195 = !x194
val x196 = new generated.scala.DoubleVectorImpl(x193,x195)
x196
}
x200.dcUpdate(x191, x198)
x191 = 1
while (x191 < x192) {  // begin fat loop x200
val x198 = x150.dcApply(x191)
x200.dcUpdate(x191, x198)
x191 += 1
} // end fat loop x200
val x239 = { 
val x201 = x151.length
val x202 = x201==0
val x237 = {
def x237thenb(): generated.scala.Matrix[Double] = {
val x203 = new generated.scala.DoubleMatrixImpl(0,0)
val x204 = x203// unsafe immutable
x204
}
def x237elseb(): generated.scala.Matrix[Double] = {
val x206 = x151(0)
val x207 = x206.isRow
val x235 = {
def x235thenb(): generated.scala.Matrix[Double] = {
val x208 = x206.length
val x209 = new generated.scala.DoubleMatrixImpl(x201,x208)
var x211 : Int = 0
val x220 = while (x211 < x201) {
var x213 : Int = 0
val x218 = while (x213 < x208) {
val x214 = x151(x211)
val x215 = x214(x213)
val x216 = x209(x211, x213) = x215
x216
x213 = x213 + 1
}
x218
x211 = x211 + 1
}
val x221 = x209// unsafe immutable
x221
}
def x235elseb(): generated.scala.Matrix[Double] = {
val x208 = x206.length
val x223 = new generated.scala.DoubleMatrixImpl(x208,x201)
var x224 : Int = 0
val x232 = while (x224 < x201) {
var x225 : Int = 0
val x230 = while (x225 < x208) {
val x226 = x151(x224)
val x227 = x226(x225)
val x228 = x223(x225, x224) = x227
x228
x225 = x225 + 1
}
x230
x224 = x224 + 1
}
val x233 = x223// unsafe immutable
x233
}
if (x207) {
x235thenb()
} else { 
x235elseb()
}
}
x235
}
if (x202) {
x237thenb()
} else { 
x237elseb()
}
}
x237
}
val x240 = x131.close()
val x241 = x239// unsafe immutable
val x242 = x200// unsafe immutable
val x243 = new generated.scala.DoubleLabelsImpl(x242)
val x244 = new generated.scala.DoubleDoubleTrainingSetImpl(x241,x243)
x244
}
val x247 = Seq()
val x248 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
val x249 = println("Training SVM using the SMO algorithm")
val x250 = x129.labels
val x252 = x250.length
val x253 = x250.isRow
// a *thin* loop follows: x259
var x251 = 0
val x256 = x250.dcApply(x251)
val x257 = x256==0
val x258 = {
def x258thenb(): Double = {
-1.0
}
def x258elseb(): Double = {
1.0
}
if (x257) {
x258thenb()
} else { 
x258elseb()
}
}
val x259 = {
val x254 = new generated.scala.DoubleVectorImpl(x252,x253)
x254
}
x259.dcUpdate(x251, x258)
x251 = 1
while (x251 < x252) {  // begin fat loop x259
val x256 = x250.dcApply(x251)
val x257 = x256==0
val x258 = {
def x258thenb(): Double = {
-1.0
}
def x258elseb(): Double = {
1.0
}
if (x257) {
x258thenb()
} else { 
x258elseb()
}
}
x259.dcUpdate(x251, x258)
x251 += 1
} // end fat loop x259
val x260 = x129.numCols
val x264 = { 
val x261 = new generated.scala.DoubleVectorImpl(x260,true)
x261
}
var x265: Double = 0.0
val x266 = x129.numRows
val x270 = { 
val x267 = new generated.scala.DoubleVectorImpl(x266,true)
x267
}
val x271 = x270.mtrans
var x272: Int = 0
var x273: Int = 0
val x296 = !true
val x305 = new generated.scala.IndexVectorRangeImpl(0,x266)
val x308 = x305.length
val x810 = List()
val x351 = x266 - 1
val x352 = x351
val x684 = while ({val x274 = x272
val x275 = x274 < 10
x275}) {
val x277 = print(".")
val x278 = x273 += 1
var x279: Int = 0
var x280: Int = 0
val x675 = while ({val x281 = x280
val x282 = x281 < x266
x282}) {
val x284 = x270.cloneL
val x286 = x284.isRow
// a *thin* loop follows: x292
var x285 = 0
val x289 = x284.dcApply(x285)
val x290 = x259.dcApply(x285)
val x291 = x289 * x290
val x292 = {
val x287 = new generated.scala.DoubleVectorImpl(x266,x286)
x287
}
x292.dcUpdate(x285, x291)
x285 = 1
while (x285 < x266) {  // begin fat loop x292
val x289 = x284.dcApply(x285)
val x290 = x259.dcApply(x285)
val x291 = x289 * x290
x292.dcUpdate(x285, x291)
x285 += 1
} // end fat loop x292
val x293 = x280
val x299 = x293 * x260
// a *thin* loop follows: x303
var x295 = 0
val x300 = x299 + x295
val x301 = x129.dcApply(x300)
val x302 = { 
x301
}
val x303 = {
val x297 = new generated.scala.DoubleVectorImpl(x260,x296)
x297
}
x303.dcUpdate(x295, x302)
x295 = 1
while (x295 < x260) {  // begin fat loop x303
val x300 = x299 + x295
val x301 = x129.dcApply(x300)
val x302 = { 
x301
}
x303.dcUpdate(x295, x302)
x295 += 1
} // end fat loop x303
val x314 = x292.isRow
val x312 = { 
val x304 = new generated.scala.DoubleVectorImpl(x266,false)
// a *thin* loop follows: x309
var x306 = 0
var x309: Unit = {
val x790 = x305.dcApply(x306)
val x795 = x790 * x260
// a *thin* loop follows: x801
var x792 = 0
val x796 = x795 + x792
val x797 = x129.dcApply(x796)
val x798 = { 
x797
}
val x799 = x303.dcApply(x792)
val x800 = x798 * x799
val x801 = {
val x793 = new generated.scala.DoubleVectorImpl(x260,true)
x793
}
x801.dcUpdate(x792, x800)
x792 = 1
while (x792 < x260) {  // begin fat loop x801
val x796 = x795 + x792
val x797 = x129.dcApply(x796)
val x798 = { 
x797
}
val x799 = x303.dcApply(x792)
val x800 = x798 * x799
x801.dcUpdate(x792, x800)
x792 += 1
} // end fat loop x801
var x802 = 0
val x805 = x801.dcApply(x802)
var x807: Double = {
if (x260 == 0) {0.0}
else {
val x805 = x801.dcApply(x802)
x805
}
}
x802 = 1
while (x802 < x260) {  // begin fat loop x807
val x805 = x801.dcApply(x802)
val x803 = x807
val x804 = x805
val x806 = x803 + x804
x807 = x806
x802 += 1
} // end fat loop x807
val x808 = x304(x790) = x807
x808
}
x306 = 1
while (x306 < x308) {  // begin fat loop x309
x309 = {
val x790 = x305.dcApply(x306)
val x795 = x790 * x260
// a *thin* loop follows: x801
var x792 = 0
val x796 = x795 + x792
val x797 = x129.dcApply(x796)
val x798 = { 
x797
}
val x799 = x303.dcApply(x792)
val x800 = x798 * x799
val x801 = {
val x793 = new generated.scala.DoubleVectorImpl(x260,true)
x793
}
x801.dcUpdate(x792, x800)
x792 = 1
while (x792 < x260) {  // begin fat loop x801
val x796 = x795 + x792
val x797 = x129.dcApply(x796)
val x798 = { 
x797
}
val x799 = x303.dcApply(x792)
val x800 = x798 * x799
x801.dcUpdate(x792, x800)
x792 += 1
} // end fat loop x801
var x802 = 0
val x805 = x801.dcApply(x802)
var x807: Double = {
if (x260 == 0) {0.0}
else {
val x805 = x801.dcApply(x802)
x805
}
}
x802 = 1
while (x802 < x260) {  // begin fat loop x807
val x805 = x801.dcApply(x802)
val x803 = x807
val x804 = x805
val x806 = x803 + x804
x807 = x806
x802 += 1
} // end fat loop x807
val x808 = x304(x790) = x807
x808
}
x306 += 1
} // end fat loop x309
val x310 = x304// unsafe immutable
x310
}
// a *thin* loop follows: x320
var x313 = 0
val x317 = x292.dcApply(x313)
val x318 = x312.dcApply(x313)
val x319 = x317 * x318
val x320 = {
val x315 = new generated.scala.DoubleVectorImpl(x266,x314)
x315
}
x320.dcUpdate(x313, x319)
x313 = 1
while (x313 < x266) {  // begin fat loop x320
val x317 = x292.dcApply(x313)
val x318 = x312.dcApply(x313)
val x319 = x317 * x318
x320.dcUpdate(x313, x319)
x313 += 1
} // end fat loop x320
val x327 = x265
val x329 = x280
val x332 = x280
val x336 = x280
val x340 = x280
val x344 = x280
var x321 = 0
val x324 = x320.dcApply(x321)
var x326: Double = {
if (x266 == 0) {0.0}
else {
val x324 = x320.dcApply(x321)
x324
}
}
x321 = 1
while (x321 < x266) {  // begin fat loop x326
val x324 = x320.dcApply(x321)
val x322 = x326
val x323 = x324
val x325 = x322 + x323
x326 = x325
x321 += 1
} // end fat loop x326
val x328 = x326 + x327
val x330 = x259(x329)
val x331 = x328 - x330
val x333 = x259(x332)
val x334 = x333 * x331
val x335 = x334 < -0.0010
val x337 = x284(x336)
val x338 = x337 < 1.0
val x339 = x335 && x338
val x341 = x259(x340)
val x342 = x341 * x331
val x343 = x342 > 0.0010
val x345 = x284(x344)
val x346 = x345 > 0.0
val x347 = x343 && x346
val x348 = x339 || x347
val x672 = {
def x672thenb(): Unit = {
val x349 = generated.scala.Global.randRef.nextDouble()
val x350 = x349.asInstanceOf[Double]
val x353 = x350 * x352
val x354 = Math.floor(x353)
val x355 = x354.asInstanceOf[Int]
val x356 = x355 + 1
var x357: Int = x356
val x370 = while ({val x358 = x357
val x359 = x280
val x360 = x358==x359
x360}) {
val x362 = generated.scala.Global.randRef.nextDouble()
val x363 = x362.asInstanceOf[Double]
val x364 = x363 * x352
val x365 = Math.floor(x364)
val x366 = x365.asInstanceOf[Int]
val x367 = x366 + 1
x357 = x367
()
}
// a *thin* loop follows: x377
var x371 = 0
val x374 = x284.dcApply(x371)
val x375 = x259.dcApply(x371)
val x376 = x374 * x375
val x377 = {
val x372 = new generated.scala.DoubleVectorImpl(x266,x286)
x372
}
x377.dcUpdate(x371, x376)
x371 = 1
while (x371 < x266) {  // begin fat loop x377
val x374 = x284.dcApply(x371)
val x375 = x259.dcApply(x371)
val x376 = x374 * x375
x377.dcUpdate(x371, x376)
x371 += 1
} // end fat loop x377
val x378 = x357
val x383 = x378 * x260
// a *thin* loop follows: x387
var x380 = 0
val x384 = x383 + x380
val x385 = x129.dcApply(x384)
val x386 = { 
x385
}
val x387 = {
val x381 = new generated.scala.DoubleVectorImpl(x260,x296)
x381
}
x387.dcUpdate(x380, x386)
x380 = 1
while (x380 < x260) {  // begin fat loop x387
val x384 = x383 + x380
val x385 = x129.dcApply(x384)
val x386 = { 
x385
}
x387.dcUpdate(x380, x386)
x380 += 1
} // end fat loop x387
val x396 = x377.isRow
val x394 = { 
val x388 = new generated.scala.DoubleVectorImpl(x266,false)
// a *thin* loop follows: x391
var x389 = 0
var x391: Unit = {
val x811 = x305.dcApply(x389)
val x816 = x811 * x260
// a *thin* loop follows: x822
var x813 = 0
val x817 = x816 + x813
val x818 = x129.dcApply(x817)
val x819 = { 
x818
}
val x820 = x387.dcApply(x813)
val x821 = x819 * x820
val x822 = {
val x814 = new generated.scala.DoubleVectorImpl(x260,true)
x814
}
x822.dcUpdate(x813, x821)
x813 = 1
while (x813 < x260) {  // begin fat loop x822
val x817 = x816 + x813
val x818 = x129.dcApply(x817)
val x819 = { 
x818
}
val x820 = x387.dcApply(x813)
val x821 = x819 * x820
x822.dcUpdate(x813, x821)
x813 += 1
} // end fat loop x822
var x823 = 0
val x826 = x822.dcApply(x823)
var x828: Double = {
if (x260 == 0) {0.0}
else {
val x826 = x822.dcApply(x823)
x826
}
}
x823 = 1
while (x823 < x260) {  // begin fat loop x828
val x826 = x822.dcApply(x823)
val x824 = x828
val x825 = x826
val x827 = x824 + x825
x828 = x827
x823 += 1
} // end fat loop x828
val x829 = x388(x811) = x828
x829
}
x389 = 1
while (x389 < x308) {  // begin fat loop x391
x391 = {
val x811 = x305.dcApply(x389)
val x816 = x811 * x260
// a *thin* loop follows: x822
var x813 = 0
val x817 = x816 + x813
val x818 = x129.dcApply(x817)
val x819 = { 
x818
}
val x820 = x387.dcApply(x813)
val x821 = x819 * x820
val x822 = {
val x814 = new generated.scala.DoubleVectorImpl(x260,true)
x814
}
x822.dcUpdate(x813, x821)
x813 = 1
while (x813 < x260) {  // begin fat loop x822
val x817 = x816 + x813
val x818 = x129.dcApply(x817)
val x819 = { 
x818
}
val x820 = x387.dcApply(x813)
val x821 = x819 * x820
x822.dcUpdate(x813, x821)
x813 += 1
} // end fat loop x822
var x823 = 0
val x826 = x822.dcApply(x823)
var x828: Double = {
if (x260 == 0) {0.0}
else {
val x826 = x822.dcApply(x823)
x826
}
}
x823 = 1
while (x823 < x260) {  // begin fat loop x828
val x826 = x822.dcApply(x823)
val x824 = x828
val x825 = x826
val x827 = x824 + x825
x828 = x827
x823 += 1
} // end fat loop x828
val x829 = x388(x811) = x828
x829
}
x389 += 1
} // end fat loop x391
val x392 = x388// unsafe immutable
x392
}
// a *thin* loop follows: x402
var x395 = 0
val x399 = x377.dcApply(x395)
val x400 = x394.dcApply(x395)
val x401 = x399 * x400
val x402 = {
val x397 = new generated.scala.DoubleVectorImpl(x266,x396)
x397
}
x402.dcUpdate(x395, x401)
x395 = 1
while (x395 < x266) {  // begin fat loop x402
val x399 = x377.dcApply(x395)
val x400 = x394.dcApply(x395)
val x401 = x399 * x400
x402.dcUpdate(x395, x401)
x395 += 1
} // end fat loop x402
var x413: Double = 0.0
var x414: Double = 0.0
val x415 = x280
val x410 = x259(x378)
val x416 = x259(x415)
val x417 = x416 != x410
val x442 = {
def x442thenb(): Unit = {
val x418 = x280
val x412 = x284(x378)
val x419 = x284(x418)
val x420 = x412 - x419
val x421 = Math.max(0.0, x420)
x413 = x421
val x424 = x280
val x423 = 1.0 + x412
val x425 = x284(x424)
val x426 = x423 - x425
val x427 = Math.min(1.0, x426)
x414 = x427
()
}
def x442elseb(): Unit = {
val x430 = x280
val x412 = x284(x378)
val x431 = x284(x430)
val x432 = x431 + x412
val x433 = x432 - 1.0
val x434 = Math.max(0.0, x433)
x413 = x434
val x436 = x280
val x437 = x284(x436)
val x438 = x437 + x412
val x439 = Math.min(1.0, x438)
x414 = x439
()
}
if (x417) {
x442thenb()
} else { 
x442elseb()
}
}
val x443 = x413
val x444 = x414
val x445 = x443 != x444
val x670 = {
def x670thenb(): Unit = {
val x446 = x280
val x451 = x446 * x260
// a *thin* loop follows: x459
var x448 = 0
val x452 = x451 + x448
val x453 = x129.dcApply(x452)
val x454 = { 
x453
}
val x455 = x383 + x448
val x456 = x129.dcApply(x455)
val x457 = { 
x456
}
val x458 = x454 * x457
val x459 = {
val x449 = new generated.scala.DoubleVectorImpl(x260,true)
x449
}
x459.dcUpdate(x448, x458)
x448 = 1
while (x448 < x260) {  // begin fat loop x459
val x452 = x451 + x448
val x453 = x129.dcApply(x452)
val x454 = { 
x453
}
val x455 = x383 + x448
val x456 = x129.dcApply(x455)
val x457 = { 
x456
}
val x458 = x454 * x457
x459.dcUpdate(x448, x458)
x448 += 1
} // end fat loop x459
val x467 = x280
val x469 = x280
val x474 = x467 * x260
val x478 = x469 * x260
// a *thin* loop follows: x483
var x471 = 0
val x475 = x474 + x471
val x476 = x129.dcApply(x475)
val x477 = { 
x476
}
val x479 = x478 + x471
val x480 = x129.dcApply(x479)
val x481 = { 
x480
}
val x482 = x477 * x481
val x483 = {
val x472 = new generated.scala.DoubleVectorImpl(x260,true)
x472
}
x483.dcUpdate(x471, x482)
x471 = 1
while (x471 < x260) {  // begin fat loop x483
val x475 = x474 + x471
val x476 = x129.dcApply(x475)
val x477 = { 
x476
}
val x479 = x478 + x471
val x480 = x129.dcApply(x479)
val x481 = { 
x480
}
val x482 = x477 * x481
x483.dcUpdate(x471, x482)
x471 += 1
} // end fat loop x483
// a *thin* loop follows: x498
var x491 = 0
val x494 = x383 + x491
val x495 = x129.dcApply(x494)
val x496 = { 
x495
}
val x497 = x496 * x496
val x498 = {
val x492 = new generated.scala.DoubleVectorImpl(x260,true)
x492
}
x498.dcUpdate(x491, x497)
x491 = 1
while (x491 < x260) {  // begin fat loop x498
val x494 = x383 + x491
val x495 = x129.dcApply(x494)
val x496 = { 
x495
}
val x497 = x496 * x496
x498.dcUpdate(x491, x497)
x491 += 1
} // end fat loop x498
var x460 = 0
val x463 = x459.dcApply(x460)
var x465: Double = {
if (x260 == 0) {0.0}
else {
val x463 = x459.dcApply(x460)
x463
}
}
x460 = 1
while (x460 < x260) {  // begin fat loop x465
val x463 = x459.dcApply(x460)
val x461 = x465
val x462 = x463
val x464 = x461 + x462
x465 = x464
x460 += 1
} // end fat loop x465
val x466 = x465 * 2.0
var x484 = 0
val x487 = x483.dcApply(x484)
var x489: Double = {
if (x260 == 0) {0.0}
else {
val x487 = x483.dcApply(x484)
x487
}
}
x484 = 1
while (x484 < x260) {  // begin fat loop x489
val x487 = x483.dcApply(x484)
val x485 = x489
val x486 = x487
val x488 = x485 + x486
x489 = x488
x484 += 1
} // end fat loop x489
val x490 = x466 - x489
var x499 = 0
val x502 = x498.dcApply(x499)
var x504: Double = {
if (x260 == 0) {0.0}
else {
val x502 = x498.dcApply(x499)
x502
}
}
x499 = 1
while (x499 < x260) {  // begin fat loop x504
val x502 = x498.dcApply(x499)
val x500 = x504
val x501 = x502
val x503 = x500 + x501
x504 = x503
x499 += 1
} // end fat loop x504
val x505 = x490 - x504
val x506 = x505 < 0.0
val x668 = {
def x668thenb(): Unit = {
val x412 = x284(x378)
var x403 = 0
val x406 = x402.dcApply(x403)
var x408: Double = {
if (x266 == 0) {0.0}
else {
val x406 = x402.dcApply(x403)
x406
}
}
x403 = 1
while (x403 < x266) {  // begin fat loop x408
val x406 = x402.dcApply(x403)
val x404 = x408
val x405 = x406
val x407 = x404 + x405
x408 = x407
x403 += 1
} // end fat loop x408
val x409 = x408 + x327
val x411 = x409 - x410
val x507 = x331 - x411
val x508 = x410 * x507
val x509 = x508 / x505
val x510 = x412 - x509
val x511 = x270(x378) = x510
val x512 = x270(x378)
val x513 = x512 > x444
val x521 = {
def x521thenb(): Unit = {
val x514 = x270(x378) = x444
x514
}
def x521elseb(): Unit = {
val x516 = x512 < x443
val x519 = {
def x519thenb(): Unit = {
val x517 = x270(x378) = x443
x517
}
if (x516) {
x519thenb()
}
}
x519
}
if (x513) {
x521thenb()
} else { 
x521elseb()
}
}
val x522 = x270(x378)
val x523 = x522 - x412
val x524 = Math.abs(x523)
val x525 = x524 > 1.0E-5
val x666 = {
def x666thenb(): Unit = {
val x526 = x280
val x528 = x280
val x529 = x280
val x531 = x280
val x530 = x284(x529)
val x532 = x259(x531)
val x533 = x532 * x410
val x534 = x412 - x522
val x535 = x533 * x534
val x536 = x530 + x535
val x537 = x270(x528) = x536
val x539 = x280
val x541 = x280
val x546 = x539 * x260
val x550 = x541 * x260
// a *thin* loop follows: x555
var x543 = 0
val x547 = x546 + x543
val x548 = x129.dcApply(x547)
val x549 = { 
x548
}
val x551 = x550 + x543
val x552 = x129.dcApply(x551)
val x553 = { 
x552
}
val x554 = x549 * x553
val x555 = {
val x544 = new generated.scala.DoubleVectorImpl(x260,true)
x544
}
x555.dcUpdate(x543, x554)
x543 = 1
while (x543 < x260) {  // begin fat loop x555
val x547 = x546 + x543
val x548 = x129.dcApply(x547)
val x549 = { 
x548
}
val x551 = x550 + x543
val x552 = x129.dcApply(x551)
val x553 = { 
x552
}
val x554 = x549 * x553
x555.dcUpdate(x543, x554)
x543 += 1
} // end fat loop x555
val x562 = x280
val x565 = x280
val x566 = x270(x565)
val x570 = x280
val x575 = x570 * x260
// a *thin* loop follows: x583
var x572 = 0
val x576 = x575 + x572
val x577 = x129.dcApply(x576)
val x578 = { 
x577
}
val x579 = x383 + x572
val x580 = x129.dcApply(x579)
val x581 = { 
x580
}
val x582 = x578 * x581
val x583 = {
val x573 = new generated.scala.DoubleVectorImpl(x260,true)
x573
}
x583.dcUpdate(x572, x582)
x572 = 1
while (x572 < x260) {  // begin fat loop x583
val x576 = x575 + x572
val x577 = x129.dcApply(x576)
val x578 = { 
x577
}
val x579 = x383 + x572
val x580 = x129.dcApply(x579)
val x581 = { 
x580
}
val x582 = x578 * x581
x583.dcUpdate(x572, x582)
x572 += 1
} // end fat loop x583
val x591 = x270(x378)
val x596 = x280
val x601 = x596 * x260
// a *thin* loop follows: x609
var x598 = 0
val x602 = x601 + x598
val x603 = x129.dcApply(x602)
val x604 = { 
x603
}
val x605 = x383 + x598
val x606 = x129.dcApply(x605)
val x607 = { 
x606
}
val x608 = x604 * x607
val x609 = {
val x599 = new generated.scala.DoubleVectorImpl(x260,true)
x599
}
x609.dcUpdate(x598, x608)
x598 = 1
while (x598 < x260) {  // begin fat loop x609
val x602 = x601 + x598
val x603 = x129.dcApply(x602)
val x604 = { 
x603
}
val x605 = x383 + x598
val x606 = x129.dcApply(x605)
val x607 = { 
x606
}
val x608 = x604 * x607
x609.dcUpdate(x598, x608)
x598 += 1
} // end fat loop x609
val x616 = x280
val x619 = x280
val x620 = x270(x619)
// a *thin* loop follows: x631
var x624 = 0
val x627 = x383 + x624
val x628 = x129.dcApply(x627)
val x629 = { 
x628
}
val x630 = x629 * x629
val x631 = {
val x625 = new generated.scala.DoubleVectorImpl(x260,true)
x625
}
x631.dcUpdate(x624, x630)
x624 = 1
while (x624 < x260) {  // begin fat loop x631
val x627 = x383 + x624
val x628 = x129.dcApply(x627)
val x629 = { 
x628
}
val x630 = x629 * x629
x631.dcUpdate(x624, x630)
x624 += 1
} // end fat loop x631
val x641 = x280
val x642 = x270(x641)
val x644 = x280
val x645 = x270(x644)
val x643 = x642 > 0.0
val x646 = x645 < 1.0
val x647 = x643 && x646
val x650 = {
def x650thenb(): Unit = {
val x538 = x327 - x331
var x556 = 0
val x559 = x555.dcApply(x556)
var x561: Double = {
if (x260 == 0) {0.0}
else {
val x559 = x555.dcApply(x556)
x559
}
}
x556 = 1
while (x556 < x260) {  // begin fat loop x561
val x559 = x555.dcApply(x556)
val x557 = x561
val x558 = x559
val x560 = x557 + x558
x561 = x560
x556 += 1
} // end fat loop x561
val x563 = x259(x562)
val x564 = x561 * x563
val x527 = x284(x526)
val x567 = x566 - x527
val x568 = x564 * x567
val x569 = x538 - x568
var x584 = 0
val x587 = x583.dcApply(x584)
var x589: Double = {
if (x260 == 0) {0.0}
else {
val x587 = x583.dcApply(x584)
x587
}
}
x584 = 1
while (x584 < x260) {  // begin fat loop x589
val x587 = x583.dcApply(x584)
val x585 = x589
val x586 = x587
val x588 = x585 + x586
x589 = x588
x584 += 1
} // end fat loop x589
val x590 = x589 * x410
val x592 = x591 - x412
val x593 = x590 * x592
val x594 = x569 - x593
x265 = x594
()
}
if (x647) {
x650thenb()
}
}
val x651 = x591 > 0.0
val x652 = x591 < 1.0
val x653 = x651 && x652
val x656 = {
def x656thenb(): Unit = {
val x595 = x327 - x411
var x610 = 0
val x613 = x609.dcApply(x610)
var x615: Double = {
if (x260 == 0) {0.0}
else {
val x613 = x609.dcApply(x610)
x613
}
}
x610 = 1
while (x610 < x260) {  // begin fat loop x615
val x613 = x609.dcApply(x610)
val x611 = x615
val x612 = x613
val x614 = x611 + x612
x615 = x614
x610 += 1
} // end fat loop x615
val x617 = x259(x616)
val x618 = x615 * x617
val x527 = x284(x526)
val x621 = x620 - x527
val x622 = x618 * x621
val x623 = x595 - x622
val x592 = x591 - x412
var x632 = 0
val x635 = x631.dcApply(x632)
var x637: Double = {
if (x260 == 0) {0.0}
else {
val x635 = x631.dcApply(x632)
x635
}
}
x632 = 1
while (x632 < x260) {  // begin fat loop x637
val x635 = x631.dcApply(x632)
val x633 = x637
val x634 = x635
val x636 = x633 + x634
x637 = x636
x632 += 1
} // end fat loop x637
val x638 = x637 * x410
val x639 = x638 * x592
val x640 = x623 - x639
x265 = x640
()
}
if (x653) {
x656thenb()
}
}
val x657 = x265
val x658 = x657==x657
val x663 = {
def x663thenb(): Unit = {
val x538 = x327 - x331
var x556 = 0
val x559 = x555.dcApply(x556)
var x561: Double = {
if (x260 == 0) {0.0}
else {
val x559 = x555.dcApply(x556)
x559
}
}
x556 = 1
while (x556 < x260) {  // begin fat loop x561
val x559 = x555.dcApply(x556)
val x557 = x561
val x558 = x559
val x560 = x557 + x558
x561 = x560
x556 += 1
} // end fat loop x561
val x563 = x259(x562)
val x564 = x561 * x563
val x527 = x284(x526)
val x567 = x566 - x527
val x568 = x564 * x567
val x569 = x538 - x568
var x584 = 0
val x587 = x583.dcApply(x584)
var x589: Double = {
if (x260 == 0) {0.0}
else {
val x587 = x583.dcApply(x584)
x587
}
}
x584 = 1
while (x584 < x260) {  // begin fat loop x589
val x587 = x583.dcApply(x584)
val x585 = x589
val x586 = x587
val x588 = x585 + x586
x589 = x588
x584 += 1
} // end fat loop x589
val x590 = x589 * x410
val x592 = x591 - x412
val x593 = x590 * x592
val x594 = x569 - x593
val x595 = x327 - x411
var x610 = 0
val x613 = x609.dcApply(x610)
var x615: Double = {
if (x260 == 0) {0.0}
else {
val x613 = x609.dcApply(x610)
x613
}
}
x610 = 1
while (x610 < x260) {  // begin fat loop x615
val x613 = x609.dcApply(x610)
val x611 = x615
val x612 = x613
val x614 = x611 + x612
x615 = x614
x610 += 1
} // end fat loop x615
val x617 = x259(x616)
val x618 = x615 * x617
val x621 = x620 - x527
val x622 = x618 * x621
val x623 = x595 - x622
var x632 = 0
val x635 = x631.dcApply(x632)
var x637: Double = {
if (x260 == 0) {0.0}
else {
val x635 = x631.dcApply(x632)
x635
}
}
x632 = 1
while (x632 < x260) {  // begin fat loop x637
val x635 = x631.dcApply(x632)
val x633 = x637
val x634 = x635
val x636 = x633 + x634
x637 = x636
x632 += 1
} // end fat loop x637
val x638 = x637 * x410
val x639 = x638 * x592
val x640 = x623 - x639
val x659 = x594 + x640
val x660 = x659 / 2.0
x265 = x660
()
}
if (x658) {
x663thenb()
}
}
val x664 = x279 += 1
()
}
if (x525) {
x666thenb()
}
}
x666
}
if (x506) {
x668thenb()
}
}
x668
}
if (x445) {
x670thenb()
}
}
x670
}
if (x348) {
x672thenb()
}
}
val x673 = x280 += 1
()
}
val x676 = x279
val x677 = x676==0
val x682 = {
def x682thenb(): Unit = {
val x678 = x272 += 1
()
}
def x682elseb(): Unit = {
x272 = 0
()
}
if (x677) {
x682thenb()
} else { 
x682elseb()
}
}
x682
}
val x685 = x273
val x686 = "ITER "+x685
val x687 = println(x686)
val x688 = "num iterations: "+x685
val x689 = println(x688)
var x690: Int = 0
val x724 = while ({val x691 = x690
val x692 = x691 < x266
x692}) {
val x694 = x690
val x696 = x690
val x697 = x270(x696)
val x701 = x694 * x260
// a *thin* loop follows: x706
var x698 = 0
val x702 = x701 + x698
val x703 = x129.dcApply(x702)
val x704 = { 
x703
}
val x705 = x704 * x697
val x706 = {
val x699 = new generated.scala.DoubleVectorImpl(x260,true)
x699
}
x706.dcUpdate(x698, x705)
x698 = 1
while (x698 < x260) {  // begin fat loop x706
val x702 = x701 + x698
val x703 = x129.dcApply(x702)
val x704 = { 
x703
}
val x705 = x704 * x697
x706.dcUpdate(x698, x705)
x698 += 1
} // end fat loop x706
val x707 = x690
val x710 = x706.isRow
val x708 = x259(x707)
// a *thin* loop follows: x715
var x709 = 0
val x713 = x706.dcApply(x709)
val x714 = x713 * x708
val x715 = {
val x711 = new generated.scala.DoubleVectorImpl(x260,x710)
x711
}
x715.dcUpdate(x709, x714)
x709 = 1
while (x709 < x260) {  // begin fat loop x715
val x713 = x706.dcApply(x709)
val x714 = x713 * x708
x715.dcUpdate(x709, x714)
x709 += 1
} // end fat loop x715
// a *thin* loop follows: x721
var x716 = 0
val x717 = x264.dcApply(x716)
val x718 = x715.dcApply(x716)
val x719 = x717 + x718
val x721 = {
x264
}
x721.dcUpdate(x716, x719)
x716 = 1
while (x716 < x260) {  // begin fat loop x721
val x717 = x264.dcApply(x716)
val x718 = x715.dcApply(x716)
val x719 = x717 + x718
x721.dcUpdate(x716, x719)
x716 += 1
} // end fat loop x721
val x722 = x690 += 1
()
}
val x725 = print("\n")
val x726 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
val x727 = x246.labels
val x729 = x727.length
val x730 = x727.isRow
// a *thin* loop follows: x736
var x728 = 0
val x733 = x727.dcApply(x728)
val x734 = x733==0
val x735 = {
def x735thenb(): Double = {
-1.0
}
def x735elseb(): Double = {
1.0
}
if (x734) {
x735thenb()
} else { 
x735elseb()
}
}
val x736 = {
val x731 = new generated.scala.DoubleVectorImpl(x729,x730)
x731
}
x736.dcUpdate(x728, x735)
x728 = 1
while (x728 < x729) {  // begin fat loop x736
val x733 = x727.dcApply(x728)
val x734 = x733==0
val x735 = {
def x735thenb(): Double = {
-1.0
}
def x735elseb(): Double = {
1.0
}
if (x734) {
x735thenb()
} else { 
x735elseb()
}
}
x736.dcUpdate(x728, x735)
x728 += 1
} // end fat loop x736
val x737 = x246.numRows
val x738 = new generated.scala.IndexVectorRangeImpl(0,x737)
val x740 = x738.length
val x741 = x738.isRow
val x752 = x246.numCols
// a *thin* loop follows: x771
var x739 = 0
val x745 = x265
val x744 = x738.dcApply(x739)
val x753 = x744 * x752
// a *thin* loop follows: x759
var x747 = 0
val x751 = x264.dcApply(x747)
val x754 = x753 + x747
val x755 = x246.dcApply(x754)
val x756 = { 
x755
}
val x757 = x751 * x756
val x759 = {
val x748 = x264.isRow
val x749 = new generated.scala.DoubleVectorImpl(x260,x748)
x749
}
x759.dcUpdate(x747, x757)
x747 = 1
while (x747 < x260) {  // begin fat loop x759
val x751 = x264.dcApply(x747)
val x754 = x753 + x747
val x755 = x246.dcApply(x754)
val x756 = { 
x755
}
val x757 = x751 * x756
x759.dcUpdate(x747, x757)
x747 += 1
} // end fat loop x759
var x760 = 0
val x763 = x759.dcApply(x760)
var x766: Double = {
if (x260 == 0) {0.0}
else {
val x763 = x759.dcApply(x760)
x763
}
}
x760 = 1
while (x760 < x260) {  // begin fat loop x766
val x763 = x759.dcApply(x760)
val x761 = x766
val x762 = x763
val x765 = x761 + x762
x766 = x765
x760 += 1
} // end fat loop x766
val x767 = x766 + x745
val x768 = x767 < 0.0
val x769 = {
def x769thenb(): Int = {
-1
}
def x769elseb(): Int = {
1
}
if (x768) {
x769thenb()
} else { 
x769elseb()
}
}
val x771 = {
val x742 = new generated.scala.IntVectorImpl(x740,x741)
x742
}
x771.dcUpdate(x739, x769)
x739 = 1
while (x739 < x740) {  // begin fat loop x771
val x745 = x265
val x744 = x738.dcApply(x739)
val x753 = x744 * x752
// a *thin* loop follows: x759
var x747 = 0
val x751 = x264.dcApply(x747)
val x754 = x753 + x747
val x755 = x246.dcApply(x754)
val x756 = { 
x755
}
val x757 = x751 * x756
val x759 = {
val x748 = x264.isRow
val x749 = new generated.scala.DoubleVectorImpl(x260,x748)
x749
}
x759.dcUpdate(x747, x757)
x747 = 1
while (x747 < x260) {  // begin fat loop x759
val x751 = x264.dcApply(x747)
val x754 = x753 + x747
val x755 = x246.dcApply(x754)
val x756 = { 
x755
}
val x757 = x751 * x756
x759.dcUpdate(x747, x757)
x747 += 1
} // end fat loop x759
var x760 = 0
val x763 = x759.dcApply(x760)
var x766: Double = {
if (x260 == 0) {0.0}
else {
val x763 = x759.dcApply(x760)
x763
}
}
x760 = 1
while (x760 < x260) {  // begin fat loop x766
val x763 = x759.dcApply(x760)
val x761 = x766
val x762 = x763
val x765 = x761 + x762
x766 = x765
x760 += 1
} // end fat loop x766
val x767 = x766 + x745
val x768 = x767 < 0.0
val x769 = {
def x769thenb(): Int = {
-1
}
def x769elseb(): Int = {
1
}
if (x768) {
x769thenb()
} else { 
x769elseb()
}
}
x771.dcUpdate(x739, x769)
x739 += 1
} // end fat loop x771
val x772 = println("SVM testing finished. Calculating error..")
val x776 = x737 - 0
var x773 = 0
val x777 = x738.dcApply(x773)
val x778 = x736(x777)
val x779 = x771(x777)
val x780 = x778 != x779
val x781 = {
def x781thenb(): Int = {
1
}
def x781elseb(): Int = {
0
}
if (x780) {
x781thenb()
} else { 
x781elseb()
}
}
var x783: Int = {
if (x776 == 0) {0}
else {
val x777 = x738.dcApply(x773)
val x778 = x736(x777)
val x779 = x771(x777)
val x780 = x778 != x779
val x781 = {
def x781thenb(): Int = {
1
}
def x781elseb(): Int = {
0
}
if (x780) {
x781thenb()
} else { 
x781elseb()
}
}
x781
}
}
x773 = 1
while (x773 < x776) {  // begin fat loop x783
val x777 = x738.dcApply(x773)
val x778 = x736(x777)
val x779 = x771(x777)
val x780 = x778 != x779
val x781 = {
def x781thenb(): Int = {
1
}
def x781elseb(): Int = {
0
}
if (x780) {
x781thenb()
} else { 
x781elseb()
}
}
val x774 = x783
val x775 = x781
val x782 = x774 + x775
x783 = x782
x773 += 1
} // end fat loop x783
val x784 = x783.doubleValue()
val x785 = x737.doubleValue()
val x786 = x784 / x785
val x787 = "Classification error: "+x786
val x788 = println(x787)
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
