/*****************************************
  Emitting Generated Code                  
*******************************************/
class gradientRunner extends ((Array[java.lang.String])=>(Unit)) {
def apply(x0:Array[java.lang.String]): Unit = {
val x1 = x0(0)
val x52 = { 
val x2 = new java.io.FileReader(x1)
val x3 = new java.io.BufferedReader(x2)
val x4 = x3.readLine()
var x5: java.lang.String = x4
val x6 = x5
val x7 = x6.trim()
x5 = x7
val x9 = x5
val x10 = x9.split("\\s+")
var x11: Array[java.lang.String] = x10
val x12 = x11
val x13 = x12.length
val x14 = new generated.scala.IntMatrixImpl(0,x13)
val x47 = while ({val x15 = x5
val x16 = x15 != null
x16}) {
val x18 = x11
val x19 = x18.length
val x20 = new generated.scala.IndexVectorRangeImpl(0,x19)
val x22 = x20.length
val x23 = x20.isRow
// a *thin* loop follows: x31
var x21 = 0
val x27 = x11
val x26 = x20.dcApply(x21)
val x28 = x27(x26)
val x29 = java.lang.Integer.parseInt(x28)
val x31 = {
val x24 = new generated.scala.IntVectorImpl(x22,x23)
x24
}
x31.dcUpdate(x21, x29)
x21 = 1
while (x21 < x22) {  // begin fat loop x31
val x27 = x11
val x26 = x20.dcApply(x21)
val x28 = x27(x26)
val x29 = java.lang.Integer.parseInt(x28)
x31.dcUpdate(x21, x29)
x21 += 1
} // end fat loop x31
val x33 = x14.numRows
val x32 = x31// unsafe immutable
val x34 = x14.insertRow(x33,x32)
val x35 = x3.readLine()
x5 = x35
val x37 = x5
val x38 = x37 != null
val x45 = {
def x45thenb(): Unit = {
val x39 = x37.trim()
x5 = x39
val x41 = x5
val x42 = x41.split("\\s+")
x11 = x42
()
}
if (x38) {
x45thenb()
}
}
x45
}
val x48 = x3.close()
val x49 = x14// unsafe immutable
val x50 = new generated.scala.GrayscaleImageImpl(x49)
x50
}
val x53 = x0(1)
val x59 = x58.getPath()
val x225 = { 
val x54 = new generated.scala.VectorImpl[java.lang.String](0,true)
val x55 = new java.io.File(x53)
val x56 = x55.getCanonicalFile()
val x57 = x56.listFiles()
val x60 = x54.length
val x61 = x54.insert(x60, x59)
val x63=x57.foreach{
x58 => 
x61
}
val x65 = x54.length
// a *thin* loop follows: x223
var x64 = 0
val x70 = x54.dcApply(x64)
val x71 = "Loading model: "+x70
val x72 = println(x71)
val x73 = new generated.scala.VectorImpl[generated.scala.BinarizedGradientTemplate](0,true)
val x74 = new java.io.FileReader(x70)
val x75 = new java.io.BufferedReader(x74)
val x76 = x75.readLine()
val x77 = x76 != "bigg_object:"
val x80 = {
def x80thenb(): Nothing = {
val x78 = error("Illegal data format")
x78
}
if (x77) {
x80thenb()
}
}
val x81 = x75.readLine()
val x82 = x75.readLine()
val x83 = x82.trim()
val x84 = x83.split(" ")
val x85 = x84(0)
val x86 = x85 != "obj_name/obj_num/num_objs:"
val x89 = {
def x89thenb(): Nothing = {
val x87 = error("Illegal data format")
x87
}
if (x86) {
x89thenb()
}
}
val x90 = x84(1)
val x91 = x84(2)
val x92 = x84(3)
val x93 = java.lang.Integer.parseInt(x92)
var x94: Int = 0
val x219 = while ({val x95 = x94
val x96 = x95 < x93
x96}) {
val x98 = x75.readLine()
val x99 = x98.trim()
val x100 = x99 != "====OneBiGG====:"
val x103 = {
def x103thenb(): Nothing = {
val x101 = error("Illegal data format")
x101
}
if (x100) {
x103thenb()
}
}
val x104 = x75.readLine()
val x105 = x104.trim()
val x106 = x105.split(" ")
var x107: Array[java.lang.String] = x106
val x108 = x107
val x109 = x108(0)
val x110 = x109 != "view/radius/reduction:"
val x113 = {
def x113thenb(): Nothing = {
val x111 = error("Illegal data format")
x111
}
if (x110) {
x113thenb()
}
}
val x114 = x108(1)
val x115 = java.lang.Integer.parseInt(x114)
val x116 = x108(2)
val x117 = java.lang.Integer.parseInt(x116)
val x118 = x108(3)
val x119 = java.lang.Integer.parseInt(x118)
val x120 = x75.readLine()
val x121 = x120.trim()
val x122 = x121.split(" ")
x107 = x122
val x124 = x107
val x125 = x124(0)
val x126 = x125 != "Gradients:"
val x129 = {
def x129thenb(): Nothing = {
val x127 = error("Illegal data format")
x127
}
if (x126) {
x129thenb()
}
}
val x130 = x124(1)
val x131 = java.lang.Integer.parseInt(x130)
val x132 = new generated.scala.IntVectorImpl(x131,true)
val x133 = x75.readLine()
val x134 = x133.trim()
val x135 = x134.split(" ")
var x136: Int = 0
val x147 = while ({val x137 = x136
val x138 = x137 < x131
x138}) {
val x140 = x136
val x141 = x136
val x142 = x135(x141)
val x143 = java.lang.Integer.parseInt(x142)
val x144 = x132(x140) = x143
val x145 = x136 += 1
()
}
val x148 = x75.readLine()
val x149 = x148.trim()
val x150 = x149.split(" ")
x107 = x150
val x152 = x107
val x153 = x152(0)
val x154 = x153 != "Match_list:"
val x157 = {
def x157thenb(): Nothing = {
val x155 = error("Illegal data format")
x155
}
if (x154) {
x157thenb()
}
}
val x158 = x152(1)
val x159 = java.lang.Integer.parseInt(x158)
val x160 = new generated.scala.IndexVectorSeqImpl(0)
val x161 = x75.readLine()
val x162 = x161.trim()
val x163 = x162.split(" ")
x136 = 0
val x175 = while ({val x165 = x136
val x166 = x165 < x159
x166}) {
val x168 = x136
val x169 = x163(x168)
val x170 = java.lang.Integer.parseInt(x169)
val x171 = x160.length
val x172 = x160.insert(x171, x170)
val x173 = x136 += 1
()
}
val x176 = x75.readLine()
val x177 = x176.trim()
val x178 = x177.split(" ")
x107 = x178
val x180 = x107
val x181 = x180(0)
val x182 = x181 != "Occlusions:"
val x185 = {
def x185thenb(): Nothing = {
val x183 = error("Illegal data format")
x183
}
if (x182) {
x185thenb()
}
}
val x186 = x180(1)
val x187 = java.lang.Integer.parseInt(x186)
val x188 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](0,true)
val x189 = x75.readLine()
val x190 = x189.trim()
val x191 = x190.split(" ")
val x192 = x187 != 0
val x195 = {
def x195thenb(): Nothing = {
val x193 = error("Occlusions not supported.")
x193
}
if (x192) {
x195thenb()
}
}
val x196 = x75.readLine()
val x197 = x196.trim()
val x198 = x197 != "BoundingBox:"
val x201 = {
def x201thenb(): Nothing = {
val x199 = error("Illegal data format")
x199
}
if (x198) {
x201thenb()
}
}
val x202 = x75.readLine()
val x203 = x202.trim()
val x204 = x203.split(" ")
val x205 = x204(0)
val x206 = java.lang.Integer.parseInt(x205)
val x207 = x204(1)
val x208 = java.lang.Integer.parseInt(x207)
val x209 = x204(2)
val x210 = java.lang.Integer.parseInt(x209)
val x211 = x204(3)
val x212 = java.lang.Integer.parseInt(x211)
val x213 = new generated.scala.Rect(x206,x208,x210,x212)
val x214 = new generated.scala.BinarizedGradientTemplate(x117,x213,null,0,x132,x160,x188,null,null)
val x215 = x73.length
val x216 = x73.insert(x215, x214)
val x217 = x94 += 1
()
}
val x220 = x73// unsafe immutable
val x221 = (x90,x220)
val x223 = {
val x66 = x54.length
val x67 = x54.isRow
val x68 = new generated.scala.VectorImpl[scala.Tuple2[java.lang.String, generated.scala.Vector[generated.scala.BinarizedGradientTemplate]]](x66,x67)
x68
}
x223.dcUpdate(x64, x221)
x64 = 1
while (x64 < x65) {  // begin fat loop x223
val x70 = x54.dcApply(x64)
val x71 = "Loading model: "+x70
val x72 = println(x71)
val x73 = new generated.scala.VectorImpl[generated.scala.BinarizedGradientTemplate](0,true)
val x74 = new java.io.FileReader(x70)
val x75 = new java.io.BufferedReader(x74)
val x76 = x75.readLine()
val x77 = x76 != "bigg_object:"
val x80 = {
def x80thenb(): Nothing = {
val x78 = error("Illegal data format")
x78
}
if (x77) {
x80thenb()
}
}
val x81 = x75.readLine()
val x82 = x75.readLine()
val x83 = x82.trim()
val x84 = x83.split(" ")
val x85 = x84(0)
val x86 = x85 != "obj_name/obj_num/num_objs:"
val x89 = {
def x89thenb(): Nothing = {
val x87 = error("Illegal data format")
x87
}
if (x86) {
x89thenb()
}
}
val x90 = x84(1)
val x91 = x84(2)
val x92 = x84(3)
val x93 = java.lang.Integer.parseInt(x92)
var x94: Int = 0
val x219 = while ({val x95 = x94
val x96 = x95 < x93
x96}) {
val x98 = x75.readLine()
val x99 = x98.trim()
val x100 = x99 != "====OneBiGG====:"
val x103 = {
def x103thenb(): Nothing = {
val x101 = error("Illegal data format")
x101
}
if (x100) {
x103thenb()
}
}
val x104 = x75.readLine()
val x105 = x104.trim()
val x106 = x105.split(" ")
var x107: Array[java.lang.String] = x106
val x108 = x107
val x109 = x108(0)
val x110 = x109 != "view/radius/reduction:"
val x113 = {
def x113thenb(): Nothing = {
val x111 = error("Illegal data format")
x111
}
if (x110) {
x113thenb()
}
}
val x114 = x108(1)
val x115 = java.lang.Integer.parseInt(x114)
val x116 = x108(2)
val x117 = java.lang.Integer.parseInt(x116)
val x118 = x108(3)
val x119 = java.lang.Integer.parseInt(x118)
val x120 = x75.readLine()
val x121 = x120.trim()
val x122 = x121.split(" ")
x107 = x122
val x124 = x107
val x125 = x124(0)
val x126 = x125 != "Gradients:"
val x129 = {
def x129thenb(): Nothing = {
val x127 = error("Illegal data format")
x127
}
if (x126) {
x129thenb()
}
}
val x130 = x124(1)
val x131 = java.lang.Integer.parseInt(x130)
val x132 = new generated.scala.IntVectorImpl(x131,true)
val x133 = x75.readLine()
val x134 = x133.trim()
val x135 = x134.split(" ")
var x136: Int = 0
val x147 = while ({val x137 = x136
val x138 = x137 < x131
x138}) {
val x140 = x136
val x141 = x136
val x142 = x135(x141)
val x143 = java.lang.Integer.parseInt(x142)
val x144 = x132(x140) = x143
val x145 = x136 += 1
()
}
val x148 = x75.readLine()
val x149 = x148.trim()
val x150 = x149.split(" ")
x107 = x150
val x152 = x107
val x153 = x152(0)
val x154 = x153 != "Match_list:"
val x157 = {
def x157thenb(): Nothing = {
val x155 = error("Illegal data format")
x155
}
if (x154) {
x157thenb()
}
}
val x158 = x152(1)
val x159 = java.lang.Integer.parseInt(x158)
val x160 = new generated.scala.IndexVectorSeqImpl(0)
val x161 = x75.readLine()
val x162 = x161.trim()
val x163 = x162.split(" ")
x136 = 0
val x175 = while ({val x165 = x136
val x166 = x165 < x159
x166}) {
val x168 = x136
val x169 = x163(x168)
val x170 = java.lang.Integer.parseInt(x169)
val x171 = x160.length
val x172 = x160.insert(x171, x170)
val x173 = x136 += 1
()
}
val x176 = x75.readLine()
val x177 = x176.trim()
val x178 = x177.split(" ")
x107 = x178
val x180 = x107
val x181 = x180(0)
val x182 = x181 != "Occlusions:"
val x185 = {
def x185thenb(): Nothing = {
val x183 = error("Illegal data format")
x183
}
if (x182) {
x185thenb()
}
}
val x186 = x180(1)
val x187 = java.lang.Integer.parseInt(x186)
val x188 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](0,true)
val x189 = x75.readLine()
val x190 = x189.trim()
val x191 = x190.split(" ")
val x192 = x187 != 0
val x195 = {
def x195thenb(): Nothing = {
val x193 = error("Occlusions not supported.")
x193
}
if (x192) {
x195thenb()
}
}
val x196 = x75.readLine()
val x197 = x196.trim()
val x198 = x197 != "BoundingBox:"
val x201 = {
def x201thenb(): Nothing = {
val x199 = error("Illegal data format")
x199
}
if (x198) {
x201thenb()
}
}
val x202 = x75.readLine()
val x203 = x202.trim()
val x204 = x203.split(" ")
val x205 = x204(0)
val x206 = java.lang.Integer.parseInt(x205)
val x207 = x204(1)
val x208 = java.lang.Integer.parseInt(x207)
val x209 = x204(2)
val x210 = java.lang.Integer.parseInt(x209)
val x211 = x204(3)
val x212 = java.lang.Integer.parseInt(x211)
val x213 = new generated.scala.Rect(x206,x208,x210,x212)
val x214 = new generated.scala.BinarizedGradientTemplate(x117,x213,null,0,x132,x160,x188,null,null)
val x215 = x73.length
val x216 = x73.insert(x215, x214)
val x217 = x94 += 1
()
}
val x220 = x73// unsafe immutable
val x221 = (x90,x220)
x223.dcUpdate(x64, x221)
x64 += 1
} // end fat loop x223
x223
}
val x226 = Seq()
val x227 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
var x228: Int = 0
val x268 = x52.numRows
val x269 = new generated.scala.IndexVectorRangeImpl(0,x268)
val x270 = x52.numCols
val x271 = new generated.scala.IndexVectorRangeImpl(0,x270)
val x272 = new generated.scala.IndexVector2Impl(x269,x271)
val x273 = x272.rowInd
val x274 = x273.length
val x275 = x272.colInd
val x276 = x275.length
val x282 = x275.isRow
val x353 = 0.asInstanceOf[Int]
val x364 = List()
val x493 = Math.Pi
val x574 = 2 / 2
val x831 = x225.length
val x832 = new generated.scala.EmptyVectorImpl[generated.scala.BiGGDetection]
val x1306 = while ({val x229 = x228
val x230 = x229 < 3
x230}) {
val x232 = new generated.scala.IntMatrixImpl(3,3)
val x233 = x232(0, 0) = -3
val x234 = x232(0, 1) = -10
val x235 = x232(0, 2) = -3
val x236 = x232(2, 0) = 3
val x237 = x232(2, 1) = 10
val x238 = x232(2, 2) = 3
val x261 = { 
val x239 = x232.numCols
val x240 = x232.numRows
val x241 = new generated.scala.IntMatrixImpl(x239,x240)
val x242 = x241.numRows
var x244 : Int = 0
val x258 = while (x244 < x242) {
val x245 = x241.numCols
var x247 : Int = 0
val x256 = while (x247 < x245) {
val x253 = { 
val x248 = x232.numCols
val x249 = x247 * x248
val x250 = x249 + x244
val x251 = x232.dcApply(x250)
x251
}
val x254 = x241(x244, x247) = x253
x254
x247 = x247 + 1
}
x256
x244 = x244 + 1
}
val x259 = x241// unsafe immutable
x259
}
val x262 = x261.numRows
val x263 = x261.numCols
val x277 = new generated.scala.IntMatrixImpl(x274,x276)
val x264 = x262 - 1
val x265 = x264 / 2
val x287 = x268 - x265
val x266 = x263 - 1
val x267 = x266 / 2
val x292 = x270 - x267
// a *thin* loop follows: x365
var x278 = 0
var x365: Unit = {
val x280 = x273.dcApply(x278)
val x286 = x280 >= x265
val x288 = x280 < x287
val x289 = x286 && x288
val x295 = x280 - x265
val x296 = x280 + x265
val x297 = x296 + 1
val x301 = x297 - x295
// a *thin* loop follows: x356
var x281 = 0
val x285 = x275.dcApply(x281)
val x290 = x285 >= x267
val x291 = x289 && x290
val x293 = x285 < x292
val x294 = x291 && x293
val x354 = {
def x354thenb(): Int = {
val x298 = x285 - x267
val x299 = x285 + x267
val x300 = x299 + 1
val x302 = x300 - x298
val x331 = { 
val x303 = new generated.scala.IntMatrixImpl(x301,x302)
var x304: Int = x295
val x328 = while ({val x305 = x304
val x306 = x305 < x297
x306}) {
var x308: Int = x298
val x325 = while ({val x309 = x308
val x310 = x309 < x300
x310}) {
val x312 = x304
val x314 = x308
val x316 = x304
val x317 = x308
val x313 = x312 - x295
val x315 = x314 - x298
val x318 = x316 * x270
val x319 = x318 + x317
val x320 = x52.dcApply(x319)
val x321 = { 
x320
}
val x322 = x303(x313, x315) = x321
val x323 = x308 += 1
()
}
val x326 = x304 += 1
()
}
val x329 = x303// unsafe immutable
x329
}
val x333 = x331.numRows
val x334 = x331.numCols
val x335 = x333 * x334
// a *thin* loop follows: x342
var x332 = 0
val x339 = x261.dcApply(x332)
val x338 = x331.dcApply(x332)
val x340 = x338 * x339
val x342 = {
val x336 = new generated.scala.IntMatrixImpl(x333,x334)
x336
}
x342.dcUpdate(x332, x340)
x332 = 1
while (x332 < x335) {  // begin fat loop x342
val x339 = x261.dcApply(x332)
val x338 = x331.dcApply(x332)
val x340 = x338 * x339
x342.dcUpdate(x332, x340)
x332 += 1
} // end fat loop x342
val x346 = x342.numRows
val x347 = x342.numCols
val x348 = x346 * x347
var x343 = 0
val x349 = x342.dcApply(x343)
var x351: Int = {
if (x348 == 0) {0}
else {
val x349 = x342.dcApply(x343)
x349
}
}
x343 = 1
while (x343 < x348) {  // begin fat loop x351
val x349 = x342.dcApply(x343)
val x344 = x351
val x345 = x349
val x350 = x344 + x345
x351 = x350
x343 += 1
} // end fat loop x351
x351
}
def x354elseb(): Int = {
x353
}
if (x294) {
x354thenb()
} else { 
x354elseb()
}
}
val x356 = {
val x283 = new generated.scala.IntVectorImpl(x276,x282)
x283
}
x356.dcUpdate(x281, x354)
x281 = 1
while (x281 < x276) {  // begin fat loop x356
val x285 = x275.dcApply(x281)
val x290 = x285 >= x267
val x291 = x289 && x290
val x293 = x285 < x292
val x294 = x291 && x293
val x354 = {
def x354thenb(): Int = {
val x298 = x285 - x267
val x299 = x285 + x267
val x300 = x299 + 1
val x302 = x300 - x298
val x331 = { 
val x303 = new generated.scala.IntMatrixImpl(x301,x302)
var x304: Int = x295
val x328 = while ({val x305 = x304
val x306 = x305 < x297
x306}) {
var x308: Int = x298
val x325 = while ({val x309 = x308
val x310 = x309 < x300
x310}) {
val x312 = x304
val x314 = x308
val x316 = x304
val x317 = x308
val x313 = x312 - x295
val x315 = x314 - x298
val x318 = x316 * x270
val x319 = x318 + x317
val x320 = x52.dcApply(x319)
val x321 = { 
x320
}
val x322 = x303(x313, x315) = x321
val x323 = x308 += 1
()
}
val x326 = x304 += 1
()
}
val x329 = x303// unsafe immutable
x329
}
val x333 = x331.numRows
val x334 = x331.numCols
val x335 = x333 * x334
// a *thin* loop follows: x342
var x332 = 0
val x339 = x261.dcApply(x332)
val x338 = x331.dcApply(x332)
val x340 = x338 * x339
val x342 = {
val x336 = new generated.scala.IntMatrixImpl(x333,x334)
x336
}
x342.dcUpdate(x332, x340)
x332 = 1
while (x332 < x335) {  // begin fat loop x342
val x339 = x261.dcApply(x332)
val x338 = x331.dcApply(x332)
val x340 = x338 * x339
x342.dcUpdate(x332, x340)
x332 += 1
} // end fat loop x342
val x346 = x342.numRows
val x347 = x342.numCols
val x348 = x346 * x347
var x343 = 0
val x349 = x342.dcApply(x343)
var x351: Int = {
if (x348 == 0) {0}
else {
val x349 = x342.dcApply(x343)
x349
}
}
x343 = 1
while (x343 < x348) {  // begin fat loop x351
val x349 = x342.dcApply(x343)
val x344 = x351
val x345 = x349
val x350 = x344 + x345
x351 = x350
x343 += 1
} // end fat loop x351
x351
}
def x354elseb(): Int = {
x353
}
if (x294) {
x354thenb()
} else { 
x354elseb()
}
}
x356.dcUpdate(x281, x354)
x281 += 1
} // end fat loop x356
val x358 = x277.numCols
// a *thin* loop follows: x362
var x357 = 0
var x362: Unit = {
val x359 = x356(x357)
val x360 = x277(x280, x357) = x359
x360
}
x357 = 1
while (x357 < x358) {  // begin fat loop x362
x362 = {
val x359 = x356(x357)
val x360 = x277(x280, x357) = x359
x360
}
x357 += 1
} // end fat loop x362
x362
}
x278 = 1
while (x278 < x274) {  // begin fat loop x365
x365 = {
val x280 = x273.dcApply(x278)
val x286 = x280 >= x265
val x288 = x280 < x287
val x289 = x286 && x288
val x295 = x280 - x265
val x296 = x280 + x265
val x297 = x296 + 1
val x301 = x297 - x295
// a *thin* loop follows: x356
var x281 = 0
val x285 = x275.dcApply(x281)
val x290 = x285 >= x267
val x291 = x289 && x290
val x293 = x285 < x292
val x294 = x291 && x293
val x354 = {
def x354thenb(): Int = {
val x298 = x285 - x267
val x299 = x285 + x267
val x300 = x299 + 1
val x302 = x300 - x298
val x331 = { 
val x303 = new generated.scala.IntMatrixImpl(x301,x302)
var x304: Int = x295
val x328 = while ({val x305 = x304
val x306 = x305 < x297
x306}) {
var x308: Int = x298
val x325 = while ({val x309 = x308
val x310 = x309 < x300
x310}) {
val x312 = x304
val x314 = x308
val x316 = x304
val x317 = x308
val x313 = x312 - x295
val x315 = x314 - x298
val x318 = x316 * x270
val x319 = x318 + x317
val x320 = x52.dcApply(x319)
val x321 = { 
x320
}
val x322 = x303(x313, x315) = x321
val x323 = x308 += 1
()
}
val x326 = x304 += 1
()
}
val x329 = x303// unsafe immutable
x329
}
val x333 = x331.numRows
val x334 = x331.numCols
val x335 = x333 * x334
// a *thin* loop follows: x342
var x332 = 0
val x339 = x261.dcApply(x332)
val x338 = x331.dcApply(x332)
val x340 = x338 * x339
val x342 = {
val x336 = new generated.scala.IntMatrixImpl(x333,x334)
x336
}
x342.dcUpdate(x332, x340)
x332 = 1
while (x332 < x335) {  // begin fat loop x342
val x339 = x261.dcApply(x332)
val x338 = x331.dcApply(x332)
val x340 = x338 * x339
x342.dcUpdate(x332, x340)
x332 += 1
} // end fat loop x342
val x346 = x342.numRows
val x347 = x342.numCols
val x348 = x346 * x347
var x343 = 0
val x349 = x342.dcApply(x343)
var x351: Int = {
if (x348 == 0) {0}
else {
val x349 = x342.dcApply(x343)
x349
}
}
x343 = 1
while (x343 < x348) {  // begin fat loop x351
val x349 = x342.dcApply(x343)
val x344 = x351
val x345 = x349
val x350 = x344 + x345
x351 = x350
x343 += 1
} // end fat loop x351
x351
}
def x354elseb(): Int = {
x353
}
if (x294) {
x354thenb()
} else { 
x354elseb()
}
}
val x356 = {
val x283 = new generated.scala.IntVectorImpl(x276,x282)
x283
}
x356.dcUpdate(x281, x354)
x281 = 1
while (x281 < x276) {  // begin fat loop x356
val x285 = x275.dcApply(x281)
val x290 = x285 >= x267
val x291 = x289 && x290
val x293 = x285 < x292
val x294 = x291 && x293
val x354 = {
def x354thenb(): Int = {
val x298 = x285 - x267
val x299 = x285 + x267
val x300 = x299 + 1
val x302 = x300 - x298
val x331 = { 
val x303 = new generated.scala.IntMatrixImpl(x301,x302)
var x304: Int = x295
val x328 = while ({val x305 = x304
val x306 = x305 < x297
x306}) {
var x308: Int = x298
val x325 = while ({val x309 = x308
val x310 = x309 < x300
x310}) {
val x312 = x304
val x314 = x308
val x316 = x304
val x317 = x308
val x313 = x312 - x295
val x315 = x314 - x298
val x318 = x316 * x270
val x319 = x318 + x317
val x320 = x52.dcApply(x319)
val x321 = { 
x320
}
val x322 = x303(x313, x315) = x321
val x323 = x308 += 1
()
}
val x326 = x304 += 1
()
}
val x329 = x303// unsafe immutable
x329
}
val x333 = x331.numRows
val x334 = x331.numCols
val x335 = x333 * x334
// a *thin* loop follows: x342
var x332 = 0
val x339 = x261.dcApply(x332)
val x338 = x331.dcApply(x332)
val x340 = x338 * x339
val x342 = {
val x336 = new generated.scala.IntMatrixImpl(x333,x334)
x336
}
x342.dcUpdate(x332, x340)
x332 = 1
while (x332 < x335) {  // begin fat loop x342
val x339 = x261.dcApply(x332)
val x338 = x331.dcApply(x332)
val x340 = x338 * x339
x342.dcUpdate(x332, x340)
x332 += 1
} // end fat loop x342
val x346 = x342.numRows
val x347 = x342.numCols
val x348 = x346 * x347
var x343 = 0
val x349 = x342.dcApply(x343)
var x351: Int = {
if (x348 == 0) {0}
else {
val x349 = x342.dcApply(x343)
x349
}
}
x343 = 1
while (x343 < x348) {  // begin fat loop x351
val x349 = x342.dcApply(x343)
val x344 = x351
val x345 = x349
val x350 = x344 + x345
x351 = x350
x343 += 1
} // end fat loop x351
x351
}
def x354elseb(): Int = {
x353
}
if (x294) {
x354thenb()
} else { 
x354elseb()
}
}
x356.dcUpdate(x281, x354)
x281 += 1
} // end fat loop x356
val x358 = x277.numCols
// a *thin* loop follows: x362
var x357 = 0
var x362: Unit = {
val x359 = x356(x357)
val x360 = x277(x280, x357) = x359
x360
}
x357 = 1
while (x357 < x358) {  // begin fat loop x362
x362 = {
val x359 = x356(x357)
val x360 = x277(x280, x357) = x359
x360
}
x357 += 1
} // end fat loop x362
x362
}
x278 += 1
} // end fat loop x365
val x366 = x277// unsafe immutable
val x367 = new generated.scala.IntImageImpl(x366)
val x368 = x232.numRows
val x369 = x232.numCols
val x374 = new generated.scala.IntMatrixImpl(x274,x276)
val x370 = x368 - 1
val x371 = x370 / 2
val x383 = x268 - x371
val x372 = x369 - 1
val x373 = x372 / 2
val x388 = x270 - x373
// a *thin* loop follows: x459
var x375 = 0
var x459: Unit = {
val x377 = x273.dcApply(x375)
val x382 = x377 >= x371
val x384 = x377 < x383
val x385 = x382 && x384
val x391 = x377 - x371
val x392 = x377 + x371
val x393 = x392 + 1
val x397 = x393 - x391
// a *thin* loop follows: x451
var x378 = 0
val x381 = x275.dcApply(x378)
val x386 = x381 >= x373
val x387 = x385 && x386
val x389 = x381 < x388
val x390 = x387 && x389
val x449 = {
def x449thenb(): Int = {
val x394 = x381 - x373
val x395 = x381 + x373
val x396 = x395 + 1
val x398 = x396 - x394
val x427 = { 
val x399 = new generated.scala.IntMatrixImpl(x397,x398)
var x400: Int = x391
val x424 = while ({val x401 = x400
val x402 = x401 < x393
x402}) {
var x404: Int = x394
val x421 = while ({val x405 = x404
val x406 = x405 < x396
x406}) {
val x408 = x400
val x410 = x404
val x412 = x400
val x413 = x404
val x409 = x408 - x391
val x411 = x410 - x394
val x414 = x412 * x270
val x415 = x414 + x413
val x416 = x52.dcApply(x415)
val x417 = { 
x416
}
val x418 = x399(x409, x411) = x417
val x419 = x404 += 1
()
}
val x422 = x400 += 1
()
}
val x425 = x399// unsafe immutable
x425
}
val x429 = x427.numRows
val x430 = x427.numCols
val x431 = x429 * x430
// a *thin* loop follows: x438
var x428 = 0
val x435 = x232.dcApply(x428)
val x434 = x427.dcApply(x428)
val x436 = x434 * x435
val x438 = {
val x432 = new generated.scala.IntMatrixImpl(x429,x430)
x432
}
x438.dcUpdate(x428, x436)
x428 = 1
while (x428 < x431) {  // begin fat loop x438
val x435 = x232.dcApply(x428)
val x434 = x427.dcApply(x428)
val x436 = x434 * x435
x438.dcUpdate(x428, x436)
x428 += 1
} // end fat loop x438
val x442 = x438.numRows
val x443 = x438.numCols
val x444 = x442 * x443
var x439 = 0
val x445 = x438.dcApply(x439)
var x447: Int = {
if (x444 == 0) {0}
else {
val x445 = x438.dcApply(x439)
x445
}
}
x439 = 1
while (x439 < x444) {  // begin fat loop x447
val x445 = x438.dcApply(x439)
val x440 = x447
val x441 = x445
val x446 = x440 + x441
x447 = x446
x439 += 1
} // end fat loop x447
x447
}
def x449elseb(): Int = {
x353
}
if (x390) {
x449thenb()
} else { 
x449elseb()
}
}
val x451 = {
val x379 = new generated.scala.IntVectorImpl(x276,x282)
x379
}
x451.dcUpdate(x378, x449)
x378 = 1
while (x378 < x276) {  // begin fat loop x451
val x381 = x275.dcApply(x378)
val x386 = x381 >= x373
val x387 = x385 && x386
val x389 = x381 < x388
val x390 = x387 && x389
val x449 = {
def x449thenb(): Int = {
val x394 = x381 - x373
val x395 = x381 + x373
val x396 = x395 + 1
val x398 = x396 - x394
val x427 = { 
val x399 = new generated.scala.IntMatrixImpl(x397,x398)
var x400: Int = x391
val x424 = while ({val x401 = x400
val x402 = x401 < x393
x402}) {
var x404: Int = x394
val x421 = while ({val x405 = x404
val x406 = x405 < x396
x406}) {
val x408 = x400
val x410 = x404
val x412 = x400
val x413 = x404
val x409 = x408 - x391
val x411 = x410 - x394
val x414 = x412 * x270
val x415 = x414 + x413
val x416 = x52.dcApply(x415)
val x417 = { 
x416
}
val x418 = x399(x409, x411) = x417
val x419 = x404 += 1
()
}
val x422 = x400 += 1
()
}
val x425 = x399// unsafe immutable
x425
}
val x429 = x427.numRows
val x430 = x427.numCols
val x431 = x429 * x430
// a *thin* loop follows: x438
var x428 = 0
val x435 = x232.dcApply(x428)
val x434 = x427.dcApply(x428)
val x436 = x434 * x435
val x438 = {
val x432 = new generated.scala.IntMatrixImpl(x429,x430)
x432
}
x438.dcUpdate(x428, x436)
x428 = 1
while (x428 < x431) {  // begin fat loop x438
val x435 = x232.dcApply(x428)
val x434 = x427.dcApply(x428)
val x436 = x434 * x435
x438.dcUpdate(x428, x436)
x428 += 1
} // end fat loop x438
val x442 = x438.numRows
val x443 = x438.numCols
val x444 = x442 * x443
var x439 = 0
val x445 = x438.dcApply(x439)
var x447: Int = {
if (x444 == 0) {0}
else {
val x445 = x438.dcApply(x439)
x445
}
}
x439 = 1
while (x439 < x444) {  // begin fat loop x447
val x445 = x438.dcApply(x439)
val x440 = x447
val x441 = x445
val x446 = x440 + x441
x447 = x446
x439 += 1
} // end fat loop x447
x447
}
def x449elseb(): Int = {
x353
}
if (x390) {
x449thenb()
} else { 
x449elseb()
}
}
x451.dcUpdate(x378, x449)
x378 += 1
} // end fat loop x451
val x453 = x374.numCols
// a *thin* loop follows: x457
var x452 = 0
var x457: Unit = {
val x454 = x451(x452)
val x455 = x374(x377, x452) = x454
x455
}
x452 = 1
while (x452 < x453) {  // begin fat loop x457
x457 = {
val x454 = x451(x452)
val x455 = x374(x377, x452) = x454
x455
}
x452 += 1
} // end fat loop x457
x457
}
x375 = 1
while (x375 < x274) {  // begin fat loop x459
x459 = {
val x377 = x273.dcApply(x375)
val x382 = x377 >= x371
val x384 = x377 < x383
val x385 = x382 && x384
val x391 = x377 - x371
val x392 = x377 + x371
val x393 = x392 + 1
val x397 = x393 - x391
// a *thin* loop follows: x451
var x378 = 0
val x381 = x275.dcApply(x378)
val x386 = x381 >= x373
val x387 = x385 && x386
val x389 = x381 < x388
val x390 = x387 && x389
val x449 = {
def x449thenb(): Int = {
val x394 = x381 - x373
val x395 = x381 + x373
val x396 = x395 + 1
val x398 = x396 - x394
val x427 = { 
val x399 = new generated.scala.IntMatrixImpl(x397,x398)
var x400: Int = x391
val x424 = while ({val x401 = x400
val x402 = x401 < x393
x402}) {
var x404: Int = x394
val x421 = while ({val x405 = x404
val x406 = x405 < x396
x406}) {
val x408 = x400
val x410 = x404
val x412 = x400
val x413 = x404
val x409 = x408 - x391
val x411 = x410 - x394
val x414 = x412 * x270
val x415 = x414 + x413
val x416 = x52.dcApply(x415)
val x417 = { 
x416
}
val x418 = x399(x409, x411) = x417
val x419 = x404 += 1
()
}
val x422 = x400 += 1
()
}
val x425 = x399// unsafe immutable
x425
}
val x429 = x427.numRows
val x430 = x427.numCols
val x431 = x429 * x430
// a *thin* loop follows: x438
var x428 = 0
val x435 = x232.dcApply(x428)
val x434 = x427.dcApply(x428)
val x436 = x434 * x435
val x438 = {
val x432 = new generated.scala.IntMatrixImpl(x429,x430)
x432
}
x438.dcUpdate(x428, x436)
x428 = 1
while (x428 < x431) {  // begin fat loop x438
val x435 = x232.dcApply(x428)
val x434 = x427.dcApply(x428)
val x436 = x434 * x435
x438.dcUpdate(x428, x436)
x428 += 1
} // end fat loop x438
val x442 = x438.numRows
val x443 = x438.numCols
val x444 = x442 * x443
var x439 = 0
val x445 = x438.dcApply(x439)
var x447: Int = {
if (x444 == 0) {0}
else {
val x445 = x438.dcApply(x439)
x445
}
}
x439 = 1
while (x439 < x444) {  // begin fat loop x447
val x445 = x438.dcApply(x439)
val x440 = x447
val x441 = x445
val x446 = x440 + x441
x447 = x446
x439 += 1
} // end fat loop x447
x447
}
def x449elseb(): Int = {
x353
}
if (x390) {
x449thenb()
} else { 
x449elseb()
}
}
val x451 = {
val x379 = new generated.scala.IntVectorImpl(x276,x282)
x379
}
x451.dcUpdate(x378, x449)
x378 = 1
while (x378 < x276) {  // begin fat loop x451
val x381 = x275.dcApply(x378)
val x386 = x381 >= x373
val x387 = x385 && x386
val x389 = x381 < x388
val x390 = x387 && x389
val x449 = {
def x449thenb(): Int = {
val x394 = x381 - x373
val x395 = x381 + x373
val x396 = x395 + 1
val x398 = x396 - x394
val x427 = { 
val x399 = new generated.scala.IntMatrixImpl(x397,x398)
var x400: Int = x391
val x424 = while ({val x401 = x400
val x402 = x401 < x393
x402}) {
var x404: Int = x394
val x421 = while ({val x405 = x404
val x406 = x405 < x396
x406}) {
val x408 = x400
val x410 = x404
val x412 = x400
val x413 = x404
val x409 = x408 - x391
val x411 = x410 - x394
val x414 = x412 * x270
val x415 = x414 + x413
val x416 = x52.dcApply(x415)
val x417 = { 
x416
}
val x418 = x399(x409, x411) = x417
val x419 = x404 += 1
()
}
val x422 = x400 += 1
()
}
val x425 = x399// unsafe immutable
x425
}
val x429 = x427.numRows
val x430 = x427.numCols
val x431 = x429 * x430
// a *thin* loop follows: x438
var x428 = 0
val x435 = x232.dcApply(x428)
val x434 = x427.dcApply(x428)
val x436 = x434 * x435
val x438 = {
val x432 = new generated.scala.IntMatrixImpl(x429,x430)
x432
}
x438.dcUpdate(x428, x436)
x428 = 1
while (x428 < x431) {  // begin fat loop x438
val x435 = x232.dcApply(x428)
val x434 = x427.dcApply(x428)
val x436 = x434 * x435
x438.dcUpdate(x428, x436)
x428 += 1
} // end fat loop x438
val x442 = x438.numRows
val x443 = x438.numCols
val x444 = x442 * x443
var x439 = 0
val x445 = x438.dcApply(x439)
var x447: Int = {
if (x444 == 0) {0}
else {
val x445 = x438.dcApply(x439)
x445
}
}
x439 = 1
while (x439 < x444) {  // begin fat loop x447
val x445 = x438.dcApply(x439)
val x440 = x447
val x441 = x445
val x446 = x440 + x441
x447 = x446
x439 += 1
} // end fat loop x447
x447
}
def x449elseb(): Int = {
x353
}
if (x390) {
x449thenb()
} else { 
x449elseb()
}
}
x451.dcUpdate(x378, x449)
x378 += 1
} // end fat loop x451
val x453 = x374.numCols
// a *thin* loop follows: x457
var x452 = 0
var x457: Unit = {
val x454 = x451(x452)
val x455 = x374(x377, x452) = x454
x455
}
x452 = 1
while (x452 < x453) {  // begin fat loop x457
x457 = {
val x454 = x451(x452)
val x455 = x374(x377, x452) = x454
x455
}
x452 += 1
} // end fat loop x457
x457
}
x375 += 1
} // end fat loop x459
val x460 = x374// unsafe immutable
val x461 = new generated.scala.IntImageImpl(x460)
val x463 = x367.numRows
val x464 = x367.numCols
val x465 = x463 * x464
// a *thin* loop follows: x470
var x462 = 0
val x468 = x367.dcApply(x462)
val x469 = x468
val x470 = {
val x466 = new generated.scala.FloatMatrixImpl(x463,x464)
x466
}
x470.dcUpdate(x462, x469)
x462 = 1
while (x462 < x465) {  // begin fat loop x470
val x468 = x367.dcApply(x462)
val x469 = x468
x470.dcUpdate(x462, x469)
x462 += 1
} // end fat loop x470
val x472 = x461.numRows
val x473 = x461.numCols
val x474 = x472 * x473
// a *thin* loop follows: x479
var x471 = 0
val x477 = x461.dcApply(x471)
val x478 = x477
val x479 = {
val x475 = new generated.scala.FloatMatrixImpl(x472,x473)
x475
}
x479.dcUpdate(x471, x478)
x471 = 1
while (x471 < x474) {  // begin fat loop x479
val x477 = x461.dcApply(x471)
val x478 = x477
x479.dcUpdate(x471, x478)
x471 += 1
} // end fat loop x479
val x481 = x470.numRows
val x482 = x470.numCols
val x483 = x481 * x482
// a *thin* loop follows: x496
var x484 = 0
val x488 = x479.dcApply(x484)
val x489 = x488
val x487 = x470.dcApply(x484)
val x490 = x487
val x491 = Math.atan2(x489, x490)
val x492 = x491 * 180.0
val x494 = x492 / x493
val x495 = x494.asInstanceOf[Float]
val x496 = {
val x485 = new generated.scala.FloatMatrixImpl(x481,x482)
x485
}
x496.dcUpdate(x484, x495)
x484 = 1
while (x484 < x483) {  // begin fat loop x496
val x488 = x479.dcApply(x484)
val x489 = x488
val x487 = x470.dcApply(x484)
val x490 = x487
val x491 = Math.atan2(x489, x490)
val x492 = x491 * 180.0
val x494 = x492 / x493
val x495 = x494.asInstanceOf[Float]
x496.dcUpdate(x484, x495)
x484 += 1
} // end fat loop x496
val x498 = x496.numRows
val x499 = x496.numCols
val x500 = x498 * x499
// a *thin* loop follows: x505
var x497 = 0
val x501 = x496.dcApply(x497)
val x502 = x501 < 0.0f
val x504 = {
def x504thenb(): Float = {
val x503 = x501 + 360.0f
x503
}
def x504elseb(): Float = {
x501
}
if (x502) {
x504thenb()
} else { 
x504elseb()
}
}
val x505 = {
x496
}
x505.dcUpdate(x497, x504)
x497 = 1
while (x497 < x500) {  // begin fat loop x505
val x501 = x496.dcApply(x497)
val x502 = x501 < 0.0f
val x504 = {
def x504thenb(): Float = {
val x503 = x501 + 360.0f
x503
}
def x504elseb(): Float = {
x501
}
if (x502) {
x504thenb()
} else { 
x504elseb()
}
}
x505.dcUpdate(x497, x504)
x497 += 1
} // end fat loop x505
// a *thin* loop follows: x516
var x480 = 0
val x508 = x470.dcApply(x480)
val x510 = x508 * x508
val x509 = x479.dcApply(x480)
val x511 = x509 * x509
val x512 = x510 + x511
val x513 = x512
val x514 = Math.sqrt(x513)
val x515 = x514.asInstanceOf[Float]
val x516 = {
val x506 = new generated.scala.FloatMatrixImpl(x481,x482)
x506
}
x516.dcUpdate(x480, x515)
x480 = 1
while (x480 < x483) {  // begin fat loop x516
val x508 = x470.dcApply(x480)
val x510 = x508 * x508
val x509 = x479.dcApply(x480)
val x511 = x509 * x509
val x512 = x510 + x511
val x513 = x512
val x514 = Math.sqrt(x513)
val x515 = x514.asInstanceOf[Float]
x516.dcUpdate(x480, x515)
x480 += 1
} // end fat loop x516
val x519 = x516.numRows
val x520 = x516.numCols
val x521 = x519 * x520
// a *thin* loop follows: x544
var x518 = 0
val x524 = x516.dcApply(x518)
val x526 = x524 >= 200.0f
val x542 = {
def x542thenb(): Int = {
val x525 = x505.dcApply(x518)
var x527: Float = x525
val x528 = x527
val x529 = x528 >= 180.0f
val x533 = {
def x533thenb(): Unit = {
val x530 = x528 - 180.0f
x527 = x530
()
}
if (x529) {
x533thenb()
}
}
val x534 = x527
val x535 = x534.asInstanceOf[Double]
val x536 = x535 / 22.5
val x537 = x536.asInstanceOf[Int]
val x538 = x537
val x539 = Math.pow(2.0,x538)
val x540 = x539.asInstanceOf[Int]
x540
}
def x542elseb(): Int = {
0
}
if (x526) {
x542thenb()
} else { 
x542elseb()
}
}
val x544 = {
val x522 = new generated.scala.IntMatrixImpl(x519,x520)
x522
}
x544.dcUpdate(x518, x542)
x518 = 1
while (x518 < x521) {  // begin fat loop x544
val x524 = x516.dcApply(x518)
val x526 = x524 >= 200.0f
val x542 = {
def x542thenb(): Int = {
val x525 = x505.dcApply(x518)
var x527: Float = x525
val x528 = x527
val x529 = x528 >= 180.0f
val x533 = {
def x533thenb(): Unit = {
val x530 = x528 - 180.0f
x527 = x530
()
}
if (x529) {
x533thenb()
}
}
val x534 = x527
val x535 = x534.asInstanceOf[Double]
val x536 = x535 / 22.5
val x537 = x536.asInstanceOf[Int]
val x538 = x537
val x539 = Math.pow(2.0,x538)
val x540 = x539.asInstanceOf[Int]
x540
}
def x542elseb(): Int = {
0
}
if (x526) {
x542thenb()
} else { 
x542elseb()
}
}
x544.dcUpdate(x518, x542)
x518 += 1
} // end fat loop x544
val x545 = new generated.scala.GrayscaleImageImpl(x544)
val x546 = x545.getRow(0)
val x548 = x545.numCols
// a *thin* loop follows: x553
var x547 = 0
val x553 = {
x546
}
x553.dcUpdate(x547, 0)
x547 = 1
while (x547 < x548) {  // begin fat loop x553
x553.dcUpdate(x547, 0)
x547 += 1
} // end fat loop x553
val x554 = x545.numRows
val x555 = x554 - 1
val x556 = x545.getRow(x555)
// a *thin* loop follows: x562
var x557 = 0
val x562 = {
x556
}
x562.dcUpdate(x557, 0)
x557 = 1
while (x557 < x548) {  // begin fat loop x562
x562.dcUpdate(x557, 0)
x557 += 1
} // end fat loop x562
val x563 = x545.getCol(0)
val x565 = x563.length
// a *thin* loop follows: x567
var x564 = 0
val x567 = {
x563
}
x567.dcUpdate(x564, 0)
x564 = 1
while (x564 < x565) {  // begin fat loop x567
x567.dcUpdate(x564, 0)
x564 += 1
} // end fat loop x567
val x568 = x548 - 1
val x569 = x545.getCol(x568)
val x571 = x569.length
// a *thin* loop follows: x573
var x570 = 0
val x573 = {
x569
}
x573.dcUpdate(x570, 0)
x570 = 1
while (x570 < x571) {  // begin fat loop x573
x573.dcUpdate(x570, 0)
x570 += 1
} // end fat loop x573
val x575 = new generated.scala.IndexVectorRangeImpl(0,x554)
val x576 = new generated.scala.IndexVectorRangeImpl(0,x548)
val x577 = new generated.scala.IndexVector2Impl(x575,x576)
val x578 = x577.rowInd
val x579 = x578.length
val x580 = x577.colInd
val x581 = x580.length
val x582 = new generated.scala.IntMatrixImpl(x579,x581)
val x587 = x580.isRow
val x592 = x554 - x574
val x597 = x548 - x574
// a *thin* loop follows: x707
var x583 = 0
var x707: Unit = {
val x585 = x578.dcApply(x583)
val x591 = x585 >= x574
val x593 = x585 < x592
val x594 = x591 && x593
val x600 = x585 - x574
val x601 = x585 + x574
val x602 = x601 + 1
val x606 = x602 - x600
// a *thin* loop follows: x699
var x586 = 0
val x590 = x580.dcApply(x586)
val x595 = x590 >= x574
val x596 = x594 && x595
val x598 = x590 < x597
val x599 = x596 && x598
val x603 = x590 - x574
val x604 = x590 + x574
val x605 = x604 + 1
val x607 = x605 - x603
val x636 = { 
val x608 = new generated.scala.IntMatrixImpl(x606,x607)
var x609: Int = x600
val x633 = while ({val x610 = x609
val x611 = x610 < x602
x611}) {
var x613: Int = x603
val x630 = while ({val x614 = x613
val x615 = x614 < x605
x615}) {
val x617 = x609
val x619 = x613
val x621 = x609
val x622 = x613
val x618 = x617 - x600
val x620 = x619 - x603
val x623 = x621 * x548
val x624 = x623 + x622
val x625 = x545.dcApply(x624)
val x626 = { 
x625
}
val x627 = x608(x618, x620) = x626
val x628 = x613 += 1
()
}
val x631 = x609 += 1
()
}
val x634 = x608// unsafe immutable
x634
}
val x640 = x636.numRows
val x645 = x636.numCols
val x697 = {
def x697thenb(): Int = {
val x637 = new generated.scala.IntVectorImpl(256,true)
var x638: Int = 0
val x668 = while ({val x639 = x638
val x641 = x639 < x640
x641}) {
var x643: Int = 0
val x665 = while ({val x644 = x643
val x646 = x644 < x645
x646}) {
val x648 = x638
val x649 = x643
val x654 = x638
val x655 = x643
val x656 = x654 * x645
val x657 = x656 + x655
val x658 = x636.dcApply(x657)
val x659 = { 
x658
}
val x660 = x637(x659)
val x650 = x648 * x645
val x651 = x650 + x649
val x652 = x636.dcApply(x651)
val x653 = { 
x652
}
val x661 = x660 + 1
val x662 = x637(x653) = x661
val x663 = x643 += 1
()
}
val x666 = x638 += 1
()
}
var x669: Int = 2
val x670 = x637(1)
var x671: Int = x670
var x672: Int = 1
val x690 = while ({val x673 = x669
val x674 = x637.length
val x675 = x673 < x674
x675}) {
val x677 = x669
val x678 = x637(x677)
val x679 = x671
val x680 = x678 > x679
val x687 = {
def x687thenb(): Unit = {
val x681 = x669
val x682 = x637(x681)
x671 = x682
val x684 = x669
x672 = x684
()
}
if (x680) {
x687thenb()
}
}
val x688 = x669 += 1
()
}
val x691 = x671
val x692 = x691 > 1
val x695 = {
def x695thenb(): Int = {
val x693 = x672
x693
}
def x695elseb(): Int = {
0
}
if (x692) {
x695thenb()
} else { 
x695elseb()
}
}
x695
}
def x697elseb(): Int = {
x353
}
if (x599) {
x697thenb()
} else { 
x697elseb()
}
}
val x699 = {
val x588 = new generated.scala.IntVectorImpl(x581,x587)
x588
}
x699.dcUpdate(x586, x697)
x586 = 1
while (x586 < x581) {  // begin fat loop x699
val x590 = x580.dcApply(x586)
val x595 = x590 >= x574
val x596 = x594 && x595
val x598 = x590 < x597
val x599 = x596 && x598
val x603 = x590 - x574
val x604 = x590 + x574
val x605 = x604 + 1
val x607 = x605 - x603
val x636 = { 
val x608 = new generated.scala.IntMatrixImpl(x606,x607)
var x609: Int = x600
val x633 = while ({val x610 = x609
val x611 = x610 < x602
x611}) {
var x613: Int = x603
val x630 = while ({val x614 = x613
val x615 = x614 < x605
x615}) {
val x617 = x609
val x619 = x613
val x621 = x609
val x622 = x613
val x618 = x617 - x600
val x620 = x619 - x603
val x623 = x621 * x548
val x624 = x623 + x622
val x625 = x545.dcApply(x624)
val x626 = { 
x625
}
val x627 = x608(x618, x620) = x626
val x628 = x613 += 1
()
}
val x631 = x609 += 1
()
}
val x634 = x608// unsafe immutable
x634
}
val x640 = x636.numRows
val x645 = x636.numCols
val x697 = {
def x697thenb(): Int = {
val x637 = new generated.scala.IntVectorImpl(256,true)
var x638: Int = 0
val x668 = while ({val x639 = x638
val x641 = x639 < x640
x641}) {
var x643: Int = 0
val x665 = while ({val x644 = x643
val x646 = x644 < x645
x646}) {
val x648 = x638
val x649 = x643
val x654 = x638
val x655 = x643
val x656 = x654 * x645
val x657 = x656 + x655
val x658 = x636.dcApply(x657)
val x659 = { 
x658
}
val x660 = x637(x659)
val x650 = x648 * x645
val x651 = x650 + x649
val x652 = x636.dcApply(x651)
val x653 = { 
x652
}
val x661 = x660 + 1
val x662 = x637(x653) = x661
val x663 = x643 += 1
()
}
val x666 = x638 += 1
()
}
var x669: Int = 2
val x670 = x637(1)
var x671: Int = x670
var x672: Int = 1
val x690 = while ({val x673 = x669
val x674 = x637.length
val x675 = x673 < x674
x675}) {
val x677 = x669
val x678 = x637(x677)
val x679 = x671
val x680 = x678 > x679
val x687 = {
def x687thenb(): Unit = {
val x681 = x669
val x682 = x637(x681)
x671 = x682
val x684 = x669
x672 = x684
()
}
if (x680) {
x687thenb()
}
}
val x688 = x669 += 1
()
}
val x691 = x671
val x692 = x691 > 1
val x695 = {
def x695thenb(): Int = {
val x693 = x672
x693
}
def x695elseb(): Int = {
0
}
if (x692) {
x695thenb()
} else { 
x695elseb()
}
}
x695
}
def x697elseb(): Int = {
x353
}
if (x599) {
x697thenb()
} else { 
x697elseb()
}
}
x699.dcUpdate(x586, x697)
x586 += 1
} // end fat loop x699
val x701 = x582.numCols
// a *thin* loop follows: x705
var x700 = 0
var x705: Unit = {
val x702 = x699(x700)
val x703 = x582(x585, x700) = x702
x703
}
x700 = 1
while (x700 < x701) {  // begin fat loop x705
x705 = {
val x702 = x699(x700)
val x703 = x582(x585, x700) = x702
x703
}
x700 += 1
} // end fat loop x705
x705
}
x583 = 1
while (x583 < x579) {  // begin fat loop x707
x707 = {
val x585 = x578.dcApply(x583)
val x591 = x585 >= x574
val x593 = x585 < x592
val x594 = x591 && x593
val x600 = x585 - x574
val x601 = x585 + x574
val x602 = x601 + 1
val x606 = x602 - x600
// a *thin* loop follows: x699
var x586 = 0
val x590 = x580.dcApply(x586)
val x595 = x590 >= x574
val x596 = x594 && x595
val x598 = x590 < x597
val x599 = x596 && x598
val x603 = x590 - x574
val x604 = x590 + x574
val x605 = x604 + 1
val x607 = x605 - x603
val x636 = { 
val x608 = new generated.scala.IntMatrixImpl(x606,x607)
var x609: Int = x600
val x633 = while ({val x610 = x609
val x611 = x610 < x602
x611}) {
var x613: Int = x603
val x630 = while ({val x614 = x613
val x615 = x614 < x605
x615}) {
val x617 = x609
val x619 = x613
val x621 = x609
val x622 = x613
val x618 = x617 - x600
val x620 = x619 - x603
val x623 = x621 * x548
val x624 = x623 + x622
val x625 = x545.dcApply(x624)
val x626 = { 
x625
}
val x627 = x608(x618, x620) = x626
val x628 = x613 += 1
()
}
val x631 = x609 += 1
()
}
val x634 = x608// unsafe immutable
x634
}
val x640 = x636.numRows
val x645 = x636.numCols
val x697 = {
def x697thenb(): Int = {
val x637 = new generated.scala.IntVectorImpl(256,true)
var x638: Int = 0
val x668 = while ({val x639 = x638
val x641 = x639 < x640
x641}) {
var x643: Int = 0
val x665 = while ({val x644 = x643
val x646 = x644 < x645
x646}) {
val x648 = x638
val x649 = x643
val x654 = x638
val x655 = x643
val x656 = x654 * x645
val x657 = x656 + x655
val x658 = x636.dcApply(x657)
val x659 = { 
x658
}
val x660 = x637(x659)
val x650 = x648 * x645
val x651 = x650 + x649
val x652 = x636.dcApply(x651)
val x653 = { 
x652
}
val x661 = x660 + 1
val x662 = x637(x653) = x661
val x663 = x643 += 1
()
}
val x666 = x638 += 1
()
}
var x669: Int = 2
val x670 = x637(1)
var x671: Int = x670
var x672: Int = 1
val x690 = while ({val x673 = x669
val x674 = x637.length
val x675 = x673 < x674
x675}) {
val x677 = x669
val x678 = x637(x677)
val x679 = x671
val x680 = x678 > x679
val x687 = {
def x687thenb(): Unit = {
val x681 = x669
val x682 = x637(x681)
x671 = x682
val x684 = x669
x672 = x684
()
}
if (x680) {
x687thenb()
}
}
val x688 = x669 += 1
()
}
val x691 = x671
val x692 = x691 > 1
val x695 = {
def x695thenb(): Int = {
val x693 = x672
x693
}
def x695elseb(): Int = {
0
}
if (x692) {
x695thenb()
} else { 
x695elseb()
}
}
x695
}
def x697elseb(): Int = {
x353
}
if (x599) {
x697thenb()
} else { 
x697elseb()
}
}
val x699 = {
val x588 = new generated.scala.IntVectorImpl(x581,x587)
x588
}
x699.dcUpdate(x586, x697)
x586 = 1
while (x586 < x581) {  // begin fat loop x699
val x590 = x580.dcApply(x586)
val x595 = x590 >= x574
val x596 = x594 && x595
val x598 = x590 < x597
val x599 = x596 && x598
val x603 = x590 - x574
val x604 = x590 + x574
val x605 = x604 + 1
val x607 = x605 - x603
val x636 = { 
val x608 = new generated.scala.IntMatrixImpl(x606,x607)
var x609: Int = x600
val x633 = while ({val x610 = x609
val x611 = x610 < x602
x611}) {
var x613: Int = x603
val x630 = while ({val x614 = x613
val x615 = x614 < x605
x615}) {
val x617 = x609
val x619 = x613
val x621 = x609
val x622 = x613
val x618 = x617 - x600
val x620 = x619 - x603
val x623 = x621 * x548
val x624 = x623 + x622
val x625 = x545.dcApply(x624)
val x626 = { 
x625
}
val x627 = x608(x618, x620) = x626
val x628 = x613 += 1
()
}
val x631 = x609 += 1
()
}
val x634 = x608// unsafe immutable
x634
}
val x640 = x636.numRows
val x645 = x636.numCols
val x697 = {
def x697thenb(): Int = {
val x637 = new generated.scala.IntVectorImpl(256,true)
var x638: Int = 0
val x668 = while ({val x639 = x638
val x641 = x639 < x640
x641}) {
var x643: Int = 0
val x665 = while ({val x644 = x643
val x646 = x644 < x645
x646}) {
val x648 = x638
val x649 = x643
val x654 = x638
val x655 = x643
val x656 = x654 * x645
val x657 = x656 + x655
val x658 = x636.dcApply(x657)
val x659 = { 
x658
}
val x660 = x637(x659)
val x650 = x648 * x645
val x651 = x650 + x649
val x652 = x636.dcApply(x651)
val x653 = { 
x652
}
val x661 = x660 + 1
val x662 = x637(x653) = x661
val x663 = x643 += 1
()
}
val x666 = x638 += 1
()
}
var x669: Int = 2
val x670 = x637(1)
var x671: Int = x670
var x672: Int = 1
val x690 = while ({val x673 = x669
val x674 = x637.length
val x675 = x673 < x674
x675}) {
val x677 = x669
val x678 = x637(x677)
val x679 = x671
val x680 = x678 > x679
val x687 = {
def x687thenb(): Unit = {
val x681 = x669
val x682 = x637(x681)
x671 = x682
val x684 = x669
x672 = x684
()
}
if (x680) {
x687thenb()
}
}
val x688 = x669 += 1
()
}
val x691 = x671
val x692 = x691 > 1
val x695 = {
def x695thenb(): Int = {
val x693 = x672
x693
}
def x695elseb(): Int = {
0
}
if (x692) {
x695thenb()
} else { 
x695elseb()
}
}
x695
}
def x697elseb(): Int = {
x353
}
if (x599) {
x697thenb()
} else { 
x697elseb()
}
}
x699.dcUpdate(x586, x697)
x586 += 1
} // end fat loop x699
val x701 = x582.numCols
// a *thin* loop follows: x705
var x700 = 0
var x705: Unit = {
val x702 = x699(x700)
val x703 = x582(x585, x700) = x702
x703
}
x700 = 1
while (x700 < x701) {  // begin fat loop x705
x705 = {
val x702 = x699(x700)
val x703 = x582(x585, x700) = x702
x703
}
x700 += 1
} // end fat loop x705
x705
}
x583 += 1
} // end fat loop x707
val x708 = x582// unsafe immutable
val x709 = new generated.scala.IntImageImpl(x708)
val x710 = new generated.scala.GrayscaleImageImpl(x709)
var x711: generated.scala.GrayscaleImage = x710
var x712: Int = 0
val x713 = new generated.scala.VectorImpl[generated.scala.GrayscaleImage](0,true)
val x714 = new generated.scala.BinarizedGradientPyramid(x713,3,1,3)
val x827 = while ({val x715 = x712
val x716 = x714.start_level
val x717 = x714.levels
val x718 = x716 + x717
val x719 = x715 < x718
x719}) {
val x721 = x712
val x722 = x714.start_level
val x723 = x721 >= x722
val x729 = {
def x729thenb(): Unit = {
val x724 = x714.pyramid
val x725 = x711
val x726 = x724.length
val x727 = x724.insert(x726, x725)
x727
}
if (x723) {
x729thenb()
}
}
val x730 = x714.start_level
val x731 = x714.levels
val x734 = x712
val x732 = x730 + x731
val x733 = x732 - 1
val x735 = x734 != x733
val x824 = {
def x824thenb(): Unit = {
val x736 = x711
val x737 = x736.numRows
val x738 = x737 / 2
val x739 = new generated.scala.IndexVectorRangeImpl(0,x738)
val x740 = x736.numCols
val x741 = x740 / 2
val x742 = new generated.scala.IndexVectorRangeImpl(0,x741)
val x743 = new generated.scala.IndexVector2Impl(x739,x742)
val x744 = x743.rowInd
val x745 = x744.length
val x746 = x743.colInd
val x747 = x746.length
val x748 = new generated.scala.IntMatrixImpl(x745,x747)
val x753 = x746.isRow
// a *thin* loop follows: x818
var x749 = 0
var x818: Unit = {
val x751 = x744.dcApply(x749)
val x757 = 2 * x751
val x758 = x757 + 2
val x761 = x758 - x757
// a *thin* loop follows: x810
var x752 = 0
val x756 = x746.dcApply(x752)
val x759 = 2 * x756
val x760 = x759 + 2
val x762 = x760 - x759
val x791 = { 
val x763 = new generated.scala.IntMatrixImpl(x761,x762)
var x764: Int = x757
val x788 = while ({val x765 = x764
val x766 = x765 < x758
x766}) {
var x768: Int = x759
val x785 = while ({val x769 = x768
val x770 = x769 < x760
x770}) {
val x772 = x764
val x774 = x768
val x776 = x764
val x777 = x768
val x773 = x772 - x757
val x775 = x774 - x759
val x778 = x776 * x740
val x779 = x778 + x777
val x780 = x736.dcApply(x779)
val x781 = { 
x780
}
val x782 = x763(x773, x775) = x781
val x783 = x768 += 1
()
}
val x786 = x764 += 1
()
}
val x789 = x763// unsafe immutable
x789
}
val x792 = x791.numCols
val x793 = 0 * x792
val x794 = x793 + 0
val x795 = x791.dcApply(x794)
val x796 = { 
x795
}
val x797 = 1 * x792
val x798 = x797 + 0
val x799 = x791.dcApply(x798)
val x800 = { 
x799
}
val x801 = x796 | x800
val x802 = x793 + 1
val x803 = x791.dcApply(x802)
val x804 = { 
x803
}
val x805 = x801 | x804
val x806 = x797 + 1
val x807 = x791.dcApply(x806)
val x808 = { 
x807
}
val x809 = x805 | x808
val x810 = {
val x754 = new generated.scala.IntVectorImpl(x747,x753)
x754
}
x810.dcUpdate(x752, x809)
x752 = 1
while (x752 < x747) {  // begin fat loop x810
val x756 = x746.dcApply(x752)
val x759 = 2 * x756
val x760 = x759 + 2
val x762 = x760 - x759
val x791 = { 
val x763 = new generated.scala.IntMatrixImpl(x761,x762)
var x764: Int = x757
val x788 = while ({val x765 = x764
val x766 = x765 < x758
x766}) {
var x768: Int = x759
val x785 = while ({val x769 = x768
val x770 = x769 < x760
x770}) {
val x772 = x764
val x774 = x768
val x776 = x764
val x777 = x768
val x773 = x772 - x757
val x775 = x774 - x759
val x778 = x776 * x740
val x779 = x778 + x777
val x780 = x736.dcApply(x779)
val x781 = { 
x780
}
val x782 = x763(x773, x775) = x781
val x783 = x768 += 1
()
}
val x786 = x764 += 1
()
}
val x789 = x763// unsafe immutable
x789
}
val x792 = x791.numCols
val x793 = 0 * x792
val x794 = x793 + 0
val x795 = x791.dcApply(x794)
val x796 = { 
x795
}
val x797 = 1 * x792
val x798 = x797 + 0
val x799 = x791.dcApply(x798)
val x800 = { 
x799
}
val x801 = x796 | x800
val x802 = x793 + 1
val x803 = x791.dcApply(x802)
val x804 = { 
x803
}
val x805 = x801 | x804
val x806 = x797 + 1
val x807 = x791.dcApply(x806)
val x808 = { 
x807
}
val x809 = x805 | x808
x810.dcUpdate(x752, x809)
x752 += 1
} // end fat loop x810
val x812 = x748.numCols
// a *thin* loop follows: x816
var x811 = 0
var x816: Unit = {
val x813 = x810(x811)
val x814 = x748(x751, x811) = x813
x814
}
x811 = 1
while (x811 < x812) {  // begin fat loop x816
x816 = {
val x813 = x810(x811)
val x814 = x748(x751, x811) = x813
x814
}
x811 += 1
} // end fat loop x816
x816
}
x749 = 1
while (x749 < x745) {  // begin fat loop x818
x818 = {
val x751 = x744.dcApply(x749)
val x757 = 2 * x751
val x758 = x757 + 2
val x761 = x758 - x757
// a *thin* loop follows: x810
var x752 = 0
val x756 = x746.dcApply(x752)
val x759 = 2 * x756
val x760 = x759 + 2
val x762 = x760 - x759
val x791 = { 
val x763 = new generated.scala.IntMatrixImpl(x761,x762)
var x764: Int = x757
val x788 = while ({val x765 = x764
val x766 = x765 < x758
x766}) {
var x768: Int = x759
val x785 = while ({val x769 = x768
val x770 = x769 < x760
x770}) {
val x772 = x764
val x774 = x768
val x776 = x764
val x777 = x768
val x773 = x772 - x757
val x775 = x774 - x759
val x778 = x776 * x740
val x779 = x778 + x777
val x780 = x736.dcApply(x779)
val x781 = { 
x780
}
val x782 = x763(x773, x775) = x781
val x783 = x768 += 1
()
}
val x786 = x764 += 1
()
}
val x789 = x763// unsafe immutable
x789
}
val x792 = x791.numCols
val x793 = 0 * x792
val x794 = x793 + 0
val x795 = x791.dcApply(x794)
val x796 = { 
x795
}
val x797 = 1 * x792
val x798 = x797 + 0
val x799 = x791.dcApply(x798)
val x800 = { 
x799
}
val x801 = x796 | x800
val x802 = x793 + 1
val x803 = x791.dcApply(x802)
val x804 = { 
x803
}
val x805 = x801 | x804
val x806 = x797 + 1
val x807 = x791.dcApply(x806)
val x808 = { 
x807
}
val x809 = x805 | x808
val x810 = {
val x754 = new generated.scala.IntVectorImpl(x747,x753)
x754
}
x810.dcUpdate(x752, x809)
x752 = 1
while (x752 < x747) {  // begin fat loop x810
val x756 = x746.dcApply(x752)
val x759 = 2 * x756
val x760 = x759 + 2
val x762 = x760 - x759
val x791 = { 
val x763 = new generated.scala.IntMatrixImpl(x761,x762)
var x764: Int = x757
val x788 = while ({val x765 = x764
val x766 = x765 < x758
x766}) {
var x768: Int = x759
val x785 = while ({val x769 = x768
val x770 = x769 < x760
x770}) {
val x772 = x764
val x774 = x768
val x776 = x764
val x777 = x768
val x773 = x772 - x757
val x775 = x774 - x759
val x778 = x776 * x740
val x779 = x778 + x777
val x780 = x736.dcApply(x779)
val x781 = { 
x780
}
val x782 = x763(x773, x775) = x781
val x783 = x768 += 1
()
}
val x786 = x764 += 1
()
}
val x789 = x763// unsafe immutable
x789
}
val x792 = x791.numCols
val x793 = 0 * x792
val x794 = x793 + 0
val x795 = x791.dcApply(x794)
val x796 = { 
x795
}
val x797 = 1 * x792
val x798 = x797 + 0
val x799 = x791.dcApply(x798)
val x800 = { 
x799
}
val x801 = x796 | x800
val x802 = x793 + 1
val x803 = x791.dcApply(x802)
val x804 = { 
x803
}
val x805 = x801 | x804
val x806 = x797 + 1
val x807 = x791.dcApply(x806)
val x808 = { 
x807
}
val x809 = x805 | x808
x810.dcUpdate(x752, x809)
x752 += 1
} // end fat loop x810
val x812 = x748.numCols
// a *thin* loop follows: x816
var x811 = 0
var x816: Unit = {
val x813 = x810(x811)
val x814 = x748(x751, x811) = x813
x814
}
x811 = 1
while (x811 < x812) {  // begin fat loop x816
x816 = {
val x813 = x810(x811)
val x814 = x748(x751, x811) = x813
x814
}
x811 += 1
} // end fat loop x816
x816
}
x749 += 1
} // end fat loop x818
val x819 = x748// unsafe immutable
val x820 = new generated.scala.IntImageImpl(x819)
val x821 = new generated.scala.GrayscaleImageImpl(x820)
x711 = x821
()
}
if (x735) {
x824thenb()
}
}
val x825 = x712 += 1
()
}
var x828 = 0
val x833 = x225.dcApply(x828)
val x834 = x833._1
val x836 = "Name: "+x834
val x837 = println(x836)
val x835 = x833._2
val x838 = x835.length
val x839 = "Templates: "+x838
val x840 = println(x839)
val x841 = x714.fixedLevelIndex
val x842 = x714.pyramid
val x843 = x714.start_level
val x844 = x841 - x843
val x845 = x842(x844)
val x846 = x845.numRows
val x847 = x846 - 5
val x848 = new generated.scala.IndexVectorRangeImpl(5,x847)
val x852 = x848.length
val x940 = new generated.scala.IndexVectorRangeImpl(0,x838)
val x944 = x940.length
val x862 = x841
val x863 = Math.pow(2.0,x862)
val x864 = x863.asInstanceOf[Int]
var x849 = 0
val x854 = x845.numCols
val x855 = x854 - 5
val x856 = new generated.scala.IndexVectorRangeImpl(5,x855)
val x860 = x856.length
val x853 = x848.dcApply(x849)
val x890 = x853 + 15
val x882 = x853 - 15
val x883 = x882 < 0
val x887 = {
def x887thenb(): scala.Tuple2[Int, Int] = {
val x884 = 15 - x853
val x885 = (0,x884)
x885
}
def x887elseb(): scala.Tuple2[Int, Int] = {
val x886 = (x882,0)
x886
}
if (x883) {
x887thenb()
} else { 
x887elseb()
}
}
val x888 = x887._1
val x889 = x887._2
val x1036 = x864 * x853
var x857 = 0
val x865 = new generated.scala.IntVectorImpl(900,false)
val x866 = new generated.scala.IndexVectorSeqImpl(0)
val x867 = new generated.scala.BinarizedGradientTemplate(15,null,null,x841,x865,x866,null,null,null)
val x877 = x845.numCols
val x861 = x856.dcApply(x857)
val x876 = x861 + 15
val x878 = x876 > x877
val x881 = {
def x881thenb(): Int = {
val x879 = x845.numCols
x879
}
def x881elseb(): Int = {
x876
}
if (x878) {
x881thenb()
} else { 
x881elseb()
}
}
val x891 = x845.numRows
val x892 = x890 > x891
val x895 = {
def x895thenb(): Int = {
val x893 = x845.numRows
x893
}
def x895elseb(): Int = {
x890
}
if (x892) {
x895thenb()
} else { 
x895elseb()
}
}
var x896: Int = x888
val x868 = x861 - 15
val x869 = x868 < 0
val x873 = {
def x873thenb(): scala.Tuple2[Int, Int] = {
val x870 = 15 - x861
val x871 = (0,x870)
x871
}
def x873elseb(): scala.Tuple2[Int, Int] = {
val x872 = (x868,0)
x872
}
if (x869) {
x873thenb()
} else { 
x873elseb()
}
}
val x874 = x873._1
val x875 = x873._2
val x933 = while ({val x897 = x896
val x898 = x897 < x895
x898}) {
val x900 = x896
val x901 = x845.getRow(x900)
var x902: Int = x874
val x930 = while ({val x903 = x902
val x904 = x903 < x881
x904}) {
val x906 = x896
val x910 = x902
val x907 = x889 + x906
val x908 = x907 - x888
val x909 = x908 * 30
val x911 = x875 + x910
val x912 = x911 - x874
val x913 = x909 + x912
var x914: Int = x913
val x915 = x867.binary_gradients
val x916 = x914
val x917 = x902
val x918 = x901(x917)
val x919 = x915(x916) = x918
val x920 = x902
val x921 = x901(x920)
val x922 = x921 > 0
val x927 = {
def x927thenb(): Unit = {
val x923 = x867.match_list
val x924 = x923.length
val x925 = x923.insert(x924, x916)
x925
}
if (x922) {
x927thenb()
}
}
val x928 = x902 += 1
()
}
val x931 = x896 += 1
()
}
val x934 = x867.match_list
val x935 = x934.length
val x936 = x935 < 0
val x939 = {
def x939thenb(): Unit = {
val x937 = println("dummy")
x937
}
if (x936) {
x939thenb()
}
}
val x1031 = x864 * x861
// a *thin* loop follows: x1077
var x941 = 0
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
var x1077: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x944 == 0) {x832}
else {
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
}
x941 = 1
while (x941 < x944) {  // begin fat loop x1077
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
val x942 = x1077
val x943 = x1048
val x1050 = x942.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1076 = { 
val x1074 = {
def x1074thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x943
}
def x1074elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1051 = x943.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x942
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1052 = x942.length
val x1053 = x943.length
val x1054 = x1052 + x1053
val x1055 = x942.isRow
val x1056 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1054,x1055)
var x1058 : Int = 0
val x1062 = while (x1058 < x1052) {
val x1059 = x942(x1058)
val x1060 = x1056(x1058) = x1059
x1060
x1058 = x1058 + 1
}
var x1064 : Int = 0
val x1069 = while (x1064 < x1053) {
val x1065 = x1064 + x1052
val x1066 = x943(x1064)
val x1067 = x1056(x1065) = x1066
x1067
x1064 = x1064 + 1
}
val x1070 = x1056// unsafe immutable
x1070
}
if (x1051) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
if (x1050) {
x1074thenb()
} else { 
x1074elseb()
}
}
x1074
}
x1077 = x1076
x941 += 1
} // end fat loop x1077
var x1106: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x860 == 0) {x832}
else {
val x865 = new generated.scala.IntVectorImpl(900,false)
val x866 = new generated.scala.IndexVectorSeqImpl(0)
val x867 = new generated.scala.BinarizedGradientTemplate(15,null,null,x841,x865,x866,null,null,null)
val x877 = x845.numCols
val x861 = x856.dcApply(x857)
val x876 = x861 + 15
val x878 = x876 > x877
val x881 = {
def x881thenb(): Int = {
val x879 = x845.numCols
x879
}
def x881elseb(): Int = {
x876
}
if (x878) {
x881thenb()
} else { 
x881elseb()
}
}
val x891 = x845.numRows
val x892 = x890 > x891
val x895 = {
def x895thenb(): Int = {
val x893 = x845.numRows
x893
}
def x895elseb(): Int = {
x890
}
if (x892) {
x895thenb()
} else { 
x895elseb()
}
}
var x896: Int = x888
val x868 = x861 - 15
val x869 = x868 < 0
val x873 = {
def x873thenb(): scala.Tuple2[Int, Int] = {
val x870 = 15 - x861
val x871 = (0,x870)
x871
}
def x873elseb(): scala.Tuple2[Int, Int] = {
val x872 = (x868,0)
x872
}
if (x869) {
x873thenb()
} else { 
x873elseb()
}
}
val x874 = x873._1
val x875 = x873._2
val x933 = while ({val x897 = x896
val x898 = x897 < x895
x898}) {
val x900 = x896
val x901 = x845.getRow(x900)
var x902: Int = x874
val x930 = while ({val x903 = x902
val x904 = x903 < x881
x904}) {
val x906 = x896
val x910 = x902
val x907 = x889 + x906
val x908 = x907 - x888
val x909 = x908 * 30
val x911 = x875 + x910
val x912 = x911 - x874
val x913 = x909 + x912
var x914: Int = x913
val x915 = x867.binary_gradients
val x916 = x914
val x917 = x902
val x918 = x901(x917)
val x919 = x915(x916) = x918
val x920 = x902
val x921 = x901(x920)
val x922 = x921 > 0
val x927 = {
def x927thenb(): Unit = {
val x923 = x867.match_list
val x924 = x923.length
val x925 = x923.insert(x924, x916)
x925
}
if (x922) {
x927thenb()
}
}
val x928 = x902 += 1
()
}
val x931 = x896 += 1
()
}
val x934 = x867.match_list
val x935 = x934.length
val x936 = x935 < 0
val x939 = {
def x939thenb(): Unit = {
val x937 = println("dummy")
x937
}
if (x936) {
x939thenb()
}
}
val x1031 = x864 * x861
// a *thin* loop follows: x1077
var x941 = 0
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
var x1077: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x944 == 0) {x832}
else {
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
}
x941 = 1
while (x941 < x944) {  // begin fat loop x1077
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
val x942 = x1077
val x943 = x1048
val x1050 = x942.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1076 = { 
val x1074 = {
def x1074thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x943
}
def x1074elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1051 = x943.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x942
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1052 = x942.length
val x1053 = x943.length
val x1054 = x1052 + x1053
val x1055 = x942.isRow
val x1056 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1054,x1055)
var x1058 : Int = 0
val x1062 = while (x1058 < x1052) {
val x1059 = x942(x1058)
val x1060 = x1056(x1058) = x1059
x1060
x1058 = x1058 + 1
}
var x1064 : Int = 0
val x1069 = while (x1064 < x1053) {
val x1065 = x1064 + x1052
val x1066 = x943(x1064)
val x1067 = x1056(x1065) = x1066
x1067
x1064 = x1064 + 1
}
val x1070 = x1056// unsafe immutable
x1070
}
if (x1051) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
if (x1050) {
x1074thenb()
} else { 
x1074elseb()
}
}
x1074
}
x1077 = x1076
x941 += 1
} // end fat loop x1077
x1077
}
}
x857 = 1
while (x857 < x860) {  // begin fat loop x1106
val x865 = new generated.scala.IntVectorImpl(900,false)
val x866 = new generated.scala.IndexVectorSeqImpl(0)
val x867 = new generated.scala.BinarizedGradientTemplate(15,null,null,x841,x865,x866,null,null,null)
val x877 = x845.numCols
val x861 = x856.dcApply(x857)
val x876 = x861 + 15
val x878 = x876 > x877
val x881 = {
def x881thenb(): Int = {
val x879 = x845.numCols
x879
}
def x881elseb(): Int = {
x876
}
if (x878) {
x881thenb()
} else { 
x881elseb()
}
}
val x891 = x845.numRows
val x892 = x890 > x891
val x895 = {
def x895thenb(): Int = {
val x893 = x845.numRows
x893
}
def x895elseb(): Int = {
x890
}
if (x892) {
x895thenb()
} else { 
x895elseb()
}
}
var x896: Int = x888
val x868 = x861 - 15
val x869 = x868 < 0
val x873 = {
def x873thenb(): scala.Tuple2[Int, Int] = {
val x870 = 15 - x861
val x871 = (0,x870)
x871
}
def x873elseb(): scala.Tuple2[Int, Int] = {
val x872 = (x868,0)
x872
}
if (x869) {
x873thenb()
} else { 
x873elseb()
}
}
val x874 = x873._1
val x875 = x873._2
val x933 = while ({val x897 = x896
val x898 = x897 < x895
x898}) {
val x900 = x896
val x901 = x845.getRow(x900)
var x902: Int = x874
val x930 = while ({val x903 = x902
val x904 = x903 < x881
x904}) {
val x906 = x896
val x910 = x902
val x907 = x889 + x906
val x908 = x907 - x888
val x909 = x908 * 30
val x911 = x875 + x910
val x912 = x911 - x874
val x913 = x909 + x912
var x914: Int = x913
val x915 = x867.binary_gradients
val x916 = x914
val x917 = x902
val x918 = x901(x917)
val x919 = x915(x916) = x918
val x920 = x902
val x921 = x901(x920)
val x922 = x921 > 0
val x927 = {
def x927thenb(): Unit = {
val x923 = x867.match_list
val x924 = x923.length
val x925 = x923.insert(x924, x916)
x925
}
if (x922) {
x927thenb()
}
}
val x928 = x902 += 1
()
}
val x931 = x896 += 1
()
}
val x934 = x867.match_list
val x935 = x934.length
val x936 = x935 < 0
val x939 = {
def x939thenb(): Unit = {
val x937 = println("dummy")
x937
}
if (x936) {
x939thenb()
}
}
val x1031 = x864 * x861
// a *thin* loop follows: x1077
var x941 = 0
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
var x1077: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x944 == 0) {x832}
else {
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
}
x941 = 1
while (x941 < x944) {  // begin fat loop x1077
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
val x942 = x1077
val x943 = x1048
val x1050 = x942.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1076 = { 
val x1074 = {
def x1074thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x943
}
def x1074elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1051 = x943.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x942
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1052 = x942.length
val x1053 = x943.length
val x1054 = x1052 + x1053
val x1055 = x942.isRow
val x1056 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1054,x1055)
var x1058 : Int = 0
val x1062 = while (x1058 < x1052) {
val x1059 = x942(x1058)
val x1060 = x1056(x1058) = x1059
x1060
x1058 = x1058 + 1
}
var x1064 : Int = 0
val x1069 = while (x1064 < x1053) {
val x1065 = x1064 + x1052
val x1066 = x943(x1064)
val x1067 = x1056(x1065) = x1066
x1067
x1064 = x1064 + 1
}
val x1070 = x1056// unsafe immutable
x1070
}
if (x1051) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
if (x1050) {
x1074thenb()
} else { 
x1074elseb()
}
}
x1074
}
x1077 = x1076
x941 += 1
} // end fat loop x1077
val x858 = x1106
val x859 = x1077
val x1079 = x858.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1105 = { 
val x1103 = {
def x1103thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x859
}
def x1103elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1080 = x859.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1101 = {
def x1101thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x858
}
def x1101elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1081 = x858.length
val x1082 = x859.length
val x1083 = x1081 + x1082
val x1084 = x858.isRow
val x1085 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1083,x1084)
var x1087 : Int = 0
val x1091 = while (x1087 < x1081) {
val x1088 = x858(x1087)
val x1089 = x1085(x1087) = x1088
x1089
x1087 = x1087 + 1
}
var x1093 : Int = 0
val x1098 = while (x1093 < x1082) {
val x1094 = x1093 + x1081
val x1095 = x859(x1093)
val x1096 = x1085(x1094) = x1095
x1096
x1093 = x1093 + 1
}
val x1099 = x1085// unsafe immutable
x1099
}
if (x1080) {
x1101thenb()
} else { 
x1101elseb()
}
}
x1101
}
if (x1079) {
x1103thenb()
} else { 
x1103elseb()
}
}
x1103
}
x1106 = x1105
x857 += 1
} // end fat loop x1106
var x1135: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x852 == 0) {x832}
else {
val x854 = x845.numCols
val x855 = x854 - 5
val x856 = new generated.scala.IndexVectorRangeImpl(5,x855)
val x860 = x856.length
val x853 = x848.dcApply(x849)
val x890 = x853 + 15
val x882 = x853 - 15
val x883 = x882 < 0
val x887 = {
def x887thenb(): scala.Tuple2[Int, Int] = {
val x884 = 15 - x853
val x885 = (0,x884)
x885
}
def x887elseb(): scala.Tuple2[Int, Int] = {
val x886 = (x882,0)
x886
}
if (x883) {
x887thenb()
} else { 
x887elseb()
}
}
val x888 = x887._1
val x889 = x887._2
val x1036 = x864 * x853
var x857 = 0
val x865 = new generated.scala.IntVectorImpl(900,false)
val x866 = new generated.scala.IndexVectorSeqImpl(0)
val x867 = new generated.scala.BinarizedGradientTemplate(15,null,null,x841,x865,x866,null,null,null)
val x877 = x845.numCols
val x861 = x856.dcApply(x857)
val x876 = x861 + 15
val x878 = x876 > x877
val x881 = {
def x881thenb(): Int = {
val x879 = x845.numCols
x879
}
def x881elseb(): Int = {
x876
}
if (x878) {
x881thenb()
} else { 
x881elseb()
}
}
val x891 = x845.numRows
val x892 = x890 > x891
val x895 = {
def x895thenb(): Int = {
val x893 = x845.numRows
x893
}
def x895elseb(): Int = {
x890
}
if (x892) {
x895thenb()
} else { 
x895elseb()
}
}
var x896: Int = x888
val x868 = x861 - 15
val x869 = x868 < 0
val x873 = {
def x873thenb(): scala.Tuple2[Int, Int] = {
val x870 = 15 - x861
val x871 = (0,x870)
x871
}
def x873elseb(): scala.Tuple2[Int, Int] = {
val x872 = (x868,0)
x872
}
if (x869) {
x873thenb()
} else { 
x873elseb()
}
}
val x874 = x873._1
val x875 = x873._2
val x933 = while ({val x897 = x896
val x898 = x897 < x895
x898}) {
val x900 = x896
val x901 = x845.getRow(x900)
var x902: Int = x874
val x930 = while ({val x903 = x902
val x904 = x903 < x881
x904}) {
val x906 = x896
val x910 = x902
val x907 = x889 + x906
val x908 = x907 - x888
val x909 = x908 * 30
val x911 = x875 + x910
val x912 = x911 - x874
val x913 = x909 + x912
var x914: Int = x913
val x915 = x867.binary_gradients
val x916 = x914
val x917 = x902
val x918 = x901(x917)
val x919 = x915(x916) = x918
val x920 = x902
val x921 = x901(x920)
val x922 = x921 > 0
val x927 = {
def x927thenb(): Unit = {
val x923 = x867.match_list
val x924 = x923.length
val x925 = x923.insert(x924, x916)
x925
}
if (x922) {
x927thenb()
}
}
val x928 = x902 += 1
()
}
val x931 = x896 += 1
()
}
val x934 = x867.match_list
val x935 = x934.length
val x936 = x935 < 0
val x939 = {
def x939thenb(): Unit = {
val x937 = println("dummy")
x937
}
if (x936) {
x939thenb()
}
}
val x1031 = x864 * x861
// a *thin* loop follows: x1077
var x941 = 0
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
var x1077: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x944 == 0) {x832}
else {
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
}
x941 = 1
while (x941 < x944) {  // begin fat loop x1077
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
val x942 = x1077
val x943 = x1048
val x1050 = x942.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1076 = { 
val x1074 = {
def x1074thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x943
}
def x1074elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1051 = x943.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x942
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1052 = x942.length
val x1053 = x943.length
val x1054 = x1052 + x1053
val x1055 = x942.isRow
val x1056 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1054,x1055)
var x1058 : Int = 0
val x1062 = while (x1058 < x1052) {
val x1059 = x942(x1058)
val x1060 = x1056(x1058) = x1059
x1060
x1058 = x1058 + 1
}
var x1064 : Int = 0
val x1069 = while (x1064 < x1053) {
val x1065 = x1064 + x1052
val x1066 = x943(x1064)
val x1067 = x1056(x1065) = x1066
x1067
x1064 = x1064 + 1
}
val x1070 = x1056// unsafe immutable
x1070
}
if (x1051) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
if (x1050) {
x1074thenb()
} else { 
x1074elseb()
}
}
x1074
}
x1077 = x1076
x941 += 1
} // end fat loop x1077
var x1106: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x860 == 0) {x832}
else {
val x865 = new generated.scala.IntVectorImpl(900,false)
val x866 = new generated.scala.IndexVectorSeqImpl(0)
val x867 = new generated.scala.BinarizedGradientTemplate(15,null,null,x841,x865,x866,null,null,null)
val x877 = x845.numCols
val x861 = x856.dcApply(x857)
val x876 = x861 + 15
val x878 = x876 > x877
val x881 = {
def x881thenb(): Int = {
val x879 = x845.numCols
x879
}
def x881elseb(): Int = {
x876
}
if (x878) {
x881thenb()
} else { 
x881elseb()
}
}
val x891 = x845.numRows
val x892 = x890 > x891
val x895 = {
def x895thenb(): Int = {
val x893 = x845.numRows
x893
}
def x895elseb(): Int = {
x890
}
if (x892) {
x895thenb()
} else { 
x895elseb()
}
}
var x896: Int = x888
val x868 = x861 - 15
val x869 = x868 < 0
val x873 = {
def x873thenb(): scala.Tuple2[Int, Int] = {
val x870 = 15 - x861
val x871 = (0,x870)
x871
}
def x873elseb(): scala.Tuple2[Int, Int] = {
val x872 = (x868,0)
x872
}
if (x869) {
x873thenb()
} else { 
x873elseb()
}
}
val x874 = x873._1
val x875 = x873._2
val x933 = while ({val x897 = x896
val x898 = x897 < x895
x898}) {
val x900 = x896
val x901 = x845.getRow(x900)
var x902: Int = x874
val x930 = while ({val x903 = x902
val x904 = x903 < x881
x904}) {
val x906 = x896
val x910 = x902
val x907 = x889 + x906
val x908 = x907 - x888
val x909 = x908 * 30
val x911 = x875 + x910
val x912 = x911 - x874
val x913 = x909 + x912
var x914: Int = x913
val x915 = x867.binary_gradients
val x916 = x914
val x917 = x902
val x918 = x901(x917)
val x919 = x915(x916) = x918
val x920 = x902
val x921 = x901(x920)
val x922 = x921 > 0
val x927 = {
def x927thenb(): Unit = {
val x923 = x867.match_list
val x924 = x923.length
val x925 = x923.insert(x924, x916)
x925
}
if (x922) {
x927thenb()
}
}
val x928 = x902 += 1
()
}
val x931 = x896 += 1
()
}
val x934 = x867.match_list
val x935 = x934.length
val x936 = x935 < 0
val x939 = {
def x939thenb(): Unit = {
val x937 = println("dummy")
x937
}
if (x936) {
x939thenb()
}
}
val x1031 = x864 * x861
// a *thin* loop follows: x1077
var x941 = 0
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
var x1077: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x944 == 0) {x832}
else {
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
}
x941 = 1
while (x941 < x944) {  // begin fat loop x1077
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
val x942 = x1077
val x943 = x1048
val x1050 = x942.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1076 = { 
val x1074 = {
def x1074thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x943
}
def x1074elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1051 = x943.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x942
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1052 = x942.length
val x1053 = x943.length
val x1054 = x1052 + x1053
val x1055 = x942.isRow
val x1056 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1054,x1055)
var x1058 : Int = 0
val x1062 = while (x1058 < x1052) {
val x1059 = x942(x1058)
val x1060 = x1056(x1058) = x1059
x1060
x1058 = x1058 + 1
}
var x1064 : Int = 0
val x1069 = while (x1064 < x1053) {
val x1065 = x1064 + x1052
val x1066 = x943(x1064)
val x1067 = x1056(x1065) = x1066
x1067
x1064 = x1064 + 1
}
val x1070 = x1056// unsafe immutable
x1070
}
if (x1051) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
if (x1050) {
x1074thenb()
} else { 
x1074elseb()
}
}
x1074
}
x1077 = x1076
x941 += 1
} // end fat loop x1077
x1077
}
}
x857 = 1
while (x857 < x860) {  // begin fat loop x1106
val x865 = new generated.scala.IntVectorImpl(900,false)
val x866 = new generated.scala.IndexVectorSeqImpl(0)
val x867 = new generated.scala.BinarizedGradientTemplate(15,null,null,x841,x865,x866,null,null,null)
val x877 = x845.numCols
val x861 = x856.dcApply(x857)
val x876 = x861 + 15
val x878 = x876 > x877
val x881 = {
def x881thenb(): Int = {
val x879 = x845.numCols
x879
}
def x881elseb(): Int = {
x876
}
if (x878) {
x881thenb()
} else { 
x881elseb()
}
}
val x891 = x845.numRows
val x892 = x890 > x891
val x895 = {
def x895thenb(): Int = {
val x893 = x845.numRows
x893
}
def x895elseb(): Int = {
x890
}
if (x892) {
x895thenb()
} else { 
x895elseb()
}
}
var x896: Int = x888
val x868 = x861 - 15
val x869 = x868 < 0
val x873 = {
def x873thenb(): scala.Tuple2[Int, Int] = {
val x870 = 15 - x861
val x871 = (0,x870)
x871
}
def x873elseb(): scala.Tuple2[Int, Int] = {
val x872 = (x868,0)
x872
}
if (x869) {
x873thenb()
} else { 
x873elseb()
}
}
val x874 = x873._1
val x875 = x873._2
val x933 = while ({val x897 = x896
val x898 = x897 < x895
x898}) {
val x900 = x896
val x901 = x845.getRow(x900)
var x902: Int = x874
val x930 = while ({val x903 = x902
val x904 = x903 < x881
x904}) {
val x906 = x896
val x910 = x902
val x907 = x889 + x906
val x908 = x907 - x888
val x909 = x908 * 30
val x911 = x875 + x910
val x912 = x911 - x874
val x913 = x909 + x912
var x914: Int = x913
val x915 = x867.binary_gradients
val x916 = x914
val x917 = x902
val x918 = x901(x917)
val x919 = x915(x916) = x918
val x920 = x902
val x921 = x901(x920)
val x922 = x921 > 0
val x927 = {
def x927thenb(): Unit = {
val x923 = x867.match_list
val x924 = x923.length
val x925 = x923.insert(x924, x916)
x925
}
if (x922) {
x927thenb()
}
}
val x928 = x902 += 1
()
}
val x931 = x896 += 1
()
}
val x934 = x867.match_list
val x935 = x934.length
val x936 = x935 < 0
val x939 = {
def x939thenb(): Unit = {
val x937 = println("dummy")
x937
}
if (x936) {
x939thenb()
}
}
val x1031 = x864 * x861
// a *thin* loop follows: x1077
var x941 = 0
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
var x1077: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x944 == 0) {x832}
else {
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
}
x941 = 1
while (x941 < x944) {  // begin fat loop x1077
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
val x942 = x1077
val x943 = x1048
val x1050 = x942.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1076 = { 
val x1074 = {
def x1074thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x943
}
def x1074elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1051 = x943.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x942
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1052 = x942.length
val x1053 = x943.length
val x1054 = x1052 + x1053
val x1055 = x942.isRow
val x1056 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1054,x1055)
var x1058 : Int = 0
val x1062 = while (x1058 < x1052) {
val x1059 = x942(x1058)
val x1060 = x1056(x1058) = x1059
x1060
x1058 = x1058 + 1
}
var x1064 : Int = 0
val x1069 = while (x1064 < x1053) {
val x1065 = x1064 + x1052
val x1066 = x943(x1064)
val x1067 = x1056(x1065) = x1066
x1067
x1064 = x1064 + 1
}
val x1070 = x1056// unsafe immutable
x1070
}
if (x1051) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
if (x1050) {
x1074thenb()
} else { 
x1074elseb()
}
}
x1074
}
x1077 = x1076
x941 += 1
} // end fat loop x1077
val x858 = x1106
val x859 = x1077
val x1079 = x858.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1105 = { 
val x1103 = {
def x1103thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x859
}
def x1103elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1080 = x859.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1101 = {
def x1101thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x858
}
def x1101elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1081 = x858.length
val x1082 = x859.length
val x1083 = x1081 + x1082
val x1084 = x858.isRow
val x1085 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1083,x1084)
var x1087 : Int = 0
val x1091 = while (x1087 < x1081) {
val x1088 = x858(x1087)
val x1089 = x1085(x1087) = x1088
x1089
x1087 = x1087 + 1
}
var x1093 : Int = 0
val x1098 = while (x1093 < x1082) {
val x1094 = x1093 + x1081
val x1095 = x859(x1093)
val x1096 = x1085(x1094) = x1095
x1096
x1093 = x1093 + 1
}
val x1099 = x1085// unsafe immutable
x1099
}
if (x1080) {
x1101thenb()
} else { 
x1101elseb()
}
}
x1101
}
if (x1079) {
x1103thenb()
} else { 
x1103elseb()
}
}
x1103
}
x1106 = x1105
x857 += 1
} // end fat loop x1106
x1106
}
}
x849 = 1
while (x849 < x852) {  // begin fat loop x1135
val x854 = x845.numCols
val x855 = x854 - 5
val x856 = new generated.scala.IndexVectorRangeImpl(5,x855)
val x860 = x856.length
val x853 = x848.dcApply(x849)
val x890 = x853 + 15
val x882 = x853 - 15
val x883 = x882 < 0
val x887 = {
def x887thenb(): scala.Tuple2[Int, Int] = {
val x884 = 15 - x853
val x885 = (0,x884)
x885
}
def x887elseb(): scala.Tuple2[Int, Int] = {
val x886 = (x882,0)
x886
}
if (x883) {
x887thenb()
} else { 
x887elseb()
}
}
val x888 = x887._1
val x889 = x887._2
val x1036 = x864 * x853
var x857 = 0
val x865 = new generated.scala.IntVectorImpl(900,false)
val x866 = new generated.scala.IndexVectorSeqImpl(0)
val x867 = new generated.scala.BinarizedGradientTemplate(15,null,null,x841,x865,x866,null,null,null)
val x877 = x845.numCols
val x861 = x856.dcApply(x857)
val x876 = x861 + 15
val x878 = x876 > x877
val x881 = {
def x881thenb(): Int = {
val x879 = x845.numCols
x879
}
def x881elseb(): Int = {
x876
}
if (x878) {
x881thenb()
} else { 
x881elseb()
}
}
val x891 = x845.numRows
val x892 = x890 > x891
val x895 = {
def x895thenb(): Int = {
val x893 = x845.numRows
x893
}
def x895elseb(): Int = {
x890
}
if (x892) {
x895thenb()
} else { 
x895elseb()
}
}
var x896: Int = x888
val x868 = x861 - 15
val x869 = x868 < 0
val x873 = {
def x873thenb(): scala.Tuple2[Int, Int] = {
val x870 = 15 - x861
val x871 = (0,x870)
x871
}
def x873elseb(): scala.Tuple2[Int, Int] = {
val x872 = (x868,0)
x872
}
if (x869) {
x873thenb()
} else { 
x873elseb()
}
}
val x874 = x873._1
val x875 = x873._2
val x933 = while ({val x897 = x896
val x898 = x897 < x895
x898}) {
val x900 = x896
val x901 = x845.getRow(x900)
var x902: Int = x874
val x930 = while ({val x903 = x902
val x904 = x903 < x881
x904}) {
val x906 = x896
val x910 = x902
val x907 = x889 + x906
val x908 = x907 - x888
val x909 = x908 * 30
val x911 = x875 + x910
val x912 = x911 - x874
val x913 = x909 + x912
var x914: Int = x913
val x915 = x867.binary_gradients
val x916 = x914
val x917 = x902
val x918 = x901(x917)
val x919 = x915(x916) = x918
val x920 = x902
val x921 = x901(x920)
val x922 = x921 > 0
val x927 = {
def x927thenb(): Unit = {
val x923 = x867.match_list
val x924 = x923.length
val x925 = x923.insert(x924, x916)
x925
}
if (x922) {
x927thenb()
}
}
val x928 = x902 += 1
()
}
val x931 = x896 += 1
()
}
val x934 = x867.match_list
val x935 = x934.length
val x936 = x935 < 0
val x939 = {
def x939thenb(): Unit = {
val x937 = println("dummy")
x937
}
if (x936) {
x939thenb()
}
}
val x1031 = x864 * x861
// a *thin* loop follows: x1077
var x941 = 0
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
var x1077: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x944 == 0) {x832}
else {
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
}
x941 = 1
while (x941 < x944) {  // begin fat loop x1077
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
val x942 = x1077
val x943 = x1048
val x1050 = x942.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1076 = { 
val x1074 = {
def x1074thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x943
}
def x1074elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1051 = x943.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x942
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1052 = x942.length
val x1053 = x943.length
val x1054 = x1052 + x1053
val x1055 = x942.isRow
val x1056 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1054,x1055)
var x1058 : Int = 0
val x1062 = while (x1058 < x1052) {
val x1059 = x942(x1058)
val x1060 = x1056(x1058) = x1059
x1060
x1058 = x1058 + 1
}
var x1064 : Int = 0
val x1069 = while (x1064 < x1053) {
val x1065 = x1064 + x1052
val x1066 = x943(x1064)
val x1067 = x1056(x1065) = x1066
x1067
x1064 = x1064 + 1
}
val x1070 = x1056// unsafe immutable
x1070
}
if (x1051) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
if (x1050) {
x1074thenb()
} else { 
x1074elseb()
}
}
x1074
}
x1077 = x1076
x941 += 1
} // end fat loop x1077
var x1106: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x860 == 0) {x832}
else {
val x865 = new generated.scala.IntVectorImpl(900,false)
val x866 = new generated.scala.IndexVectorSeqImpl(0)
val x867 = new generated.scala.BinarizedGradientTemplate(15,null,null,x841,x865,x866,null,null,null)
val x877 = x845.numCols
val x861 = x856.dcApply(x857)
val x876 = x861 + 15
val x878 = x876 > x877
val x881 = {
def x881thenb(): Int = {
val x879 = x845.numCols
x879
}
def x881elseb(): Int = {
x876
}
if (x878) {
x881thenb()
} else { 
x881elseb()
}
}
val x891 = x845.numRows
val x892 = x890 > x891
val x895 = {
def x895thenb(): Int = {
val x893 = x845.numRows
x893
}
def x895elseb(): Int = {
x890
}
if (x892) {
x895thenb()
} else { 
x895elseb()
}
}
var x896: Int = x888
val x868 = x861 - 15
val x869 = x868 < 0
val x873 = {
def x873thenb(): scala.Tuple2[Int, Int] = {
val x870 = 15 - x861
val x871 = (0,x870)
x871
}
def x873elseb(): scala.Tuple2[Int, Int] = {
val x872 = (x868,0)
x872
}
if (x869) {
x873thenb()
} else { 
x873elseb()
}
}
val x874 = x873._1
val x875 = x873._2
val x933 = while ({val x897 = x896
val x898 = x897 < x895
x898}) {
val x900 = x896
val x901 = x845.getRow(x900)
var x902: Int = x874
val x930 = while ({val x903 = x902
val x904 = x903 < x881
x904}) {
val x906 = x896
val x910 = x902
val x907 = x889 + x906
val x908 = x907 - x888
val x909 = x908 * 30
val x911 = x875 + x910
val x912 = x911 - x874
val x913 = x909 + x912
var x914: Int = x913
val x915 = x867.binary_gradients
val x916 = x914
val x917 = x902
val x918 = x901(x917)
val x919 = x915(x916) = x918
val x920 = x902
val x921 = x901(x920)
val x922 = x921 > 0
val x927 = {
def x927thenb(): Unit = {
val x923 = x867.match_list
val x924 = x923.length
val x925 = x923.insert(x924, x916)
x925
}
if (x922) {
x927thenb()
}
}
val x928 = x902 += 1
()
}
val x931 = x896 += 1
()
}
val x934 = x867.match_list
val x935 = x934.length
val x936 = x935 < 0
val x939 = {
def x939thenb(): Unit = {
val x937 = println("dummy")
x937
}
if (x936) {
x939thenb()
}
}
val x1031 = x864 * x861
// a *thin* loop follows: x1077
var x941 = 0
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
var x1077: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x944 == 0) {x832}
else {
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
}
x941 = 1
while (x941 < x944) {  // begin fat loop x1077
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
val x942 = x1077
val x943 = x1048
val x1050 = x942.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1076 = { 
val x1074 = {
def x1074thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x943
}
def x1074elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1051 = x943.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x942
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1052 = x942.length
val x1053 = x943.length
val x1054 = x1052 + x1053
val x1055 = x942.isRow
val x1056 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1054,x1055)
var x1058 : Int = 0
val x1062 = while (x1058 < x1052) {
val x1059 = x942(x1058)
val x1060 = x1056(x1058) = x1059
x1060
x1058 = x1058 + 1
}
var x1064 : Int = 0
val x1069 = while (x1064 < x1053) {
val x1065 = x1064 + x1052
val x1066 = x943(x1064)
val x1067 = x1056(x1065) = x1066
x1067
x1064 = x1064 + 1
}
val x1070 = x1056// unsafe immutable
x1070
}
if (x1051) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
if (x1050) {
x1074thenb()
} else { 
x1074elseb()
}
}
x1074
}
x1077 = x1076
x941 += 1
} // end fat loop x1077
x1077
}
}
x857 = 1
while (x857 < x860) {  // begin fat loop x1106
val x865 = new generated.scala.IntVectorImpl(900,false)
val x866 = new generated.scala.IndexVectorSeqImpl(0)
val x867 = new generated.scala.BinarizedGradientTemplate(15,null,null,x841,x865,x866,null,null,null)
val x877 = x845.numCols
val x861 = x856.dcApply(x857)
val x876 = x861 + 15
val x878 = x876 > x877
val x881 = {
def x881thenb(): Int = {
val x879 = x845.numCols
x879
}
def x881elseb(): Int = {
x876
}
if (x878) {
x881thenb()
} else { 
x881elseb()
}
}
val x891 = x845.numRows
val x892 = x890 > x891
val x895 = {
def x895thenb(): Int = {
val x893 = x845.numRows
x893
}
def x895elseb(): Int = {
x890
}
if (x892) {
x895thenb()
} else { 
x895elseb()
}
}
var x896: Int = x888
val x868 = x861 - 15
val x869 = x868 < 0
val x873 = {
def x873thenb(): scala.Tuple2[Int, Int] = {
val x870 = 15 - x861
val x871 = (0,x870)
x871
}
def x873elseb(): scala.Tuple2[Int, Int] = {
val x872 = (x868,0)
x872
}
if (x869) {
x873thenb()
} else { 
x873elseb()
}
}
val x874 = x873._1
val x875 = x873._2
val x933 = while ({val x897 = x896
val x898 = x897 < x895
x898}) {
val x900 = x896
val x901 = x845.getRow(x900)
var x902: Int = x874
val x930 = while ({val x903 = x902
val x904 = x903 < x881
x904}) {
val x906 = x896
val x910 = x902
val x907 = x889 + x906
val x908 = x907 - x888
val x909 = x908 * 30
val x911 = x875 + x910
val x912 = x911 - x874
val x913 = x909 + x912
var x914: Int = x913
val x915 = x867.binary_gradients
val x916 = x914
val x917 = x902
val x918 = x901(x917)
val x919 = x915(x916) = x918
val x920 = x902
val x921 = x901(x920)
val x922 = x921 > 0
val x927 = {
def x927thenb(): Unit = {
val x923 = x867.match_list
val x924 = x923.length
val x925 = x923.insert(x924, x916)
x925
}
if (x922) {
x927thenb()
}
}
val x928 = x902 += 1
()
}
val x931 = x896 += 1
()
}
val x934 = x867.match_list
val x935 = x934.length
val x936 = x935 < 0
val x939 = {
def x939thenb(): Unit = {
val x937 = println("dummy")
x937
}
if (x936) {
x939thenb()
}
}
val x1031 = x864 * x861
// a *thin* loop follows: x1077
var x941 = 0
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
var x1077: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x944 == 0) {x832}
else {
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
}
x941 = 1
while (x941 < x944) {  // begin fat loop x1077
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
val x942 = x1077
val x943 = x1048
val x1050 = x942.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1076 = { 
val x1074 = {
def x1074thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x943
}
def x1074elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1051 = x943.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x942
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1052 = x942.length
val x1053 = x943.length
val x1054 = x1052 + x1053
val x1055 = x942.isRow
val x1056 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1054,x1055)
var x1058 : Int = 0
val x1062 = while (x1058 < x1052) {
val x1059 = x942(x1058)
val x1060 = x1056(x1058) = x1059
x1060
x1058 = x1058 + 1
}
var x1064 : Int = 0
val x1069 = while (x1064 < x1053) {
val x1065 = x1064 + x1052
val x1066 = x943(x1064)
val x1067 = x1056(x1065) = x1066
x1067
x1064 = x1064 + 1
}
val x1070 = x1056// unsafe immutable
x1070
}
if (x1051) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
if (x1050) {
x1074thenb()
} else { 
x1074elseb()
}
}
x1074
}
x1077 = x1076
x941 += 1
} // end fat loop x1077
val x858 = x1106
val x859 = x1077
val x1079 = x858.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1105 = { 
val x1103 = {
def x1103thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x859
}
def x1103elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1080 = x859.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1101 = {
def x1101thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x858
}
def x1101elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1081 = x858.length
val x1082 = x859.length
val x1083 = x1081 + x1082
val x1084 = x858.isRow
val x1085 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1083,x1084)
var x1087 : Int = 0
val x1091 = while (x1087 < x1081) {
val x1088 = x858(x1087)
val x1089 = x1085(x1087) = x1088
x1089
x1087 = x1087 + 1
}
var x1093 : Int = 0
val x1098 = while (x1093 < x1082) {
val x1094 = x1093 + x1081
val x1095 = x859(x1093)
val x1096 = x1085(x1094) = x1095
x1096
x1093 = x1093 + 1
}
val x1099 = x1085// unsafe immutable
x1099
}
if (x1080) {
x1101thenb()
} else { 
x1101elseb()
}
}
x1101
}
if (x1079) {
x1103thenb()
} else { 
x1103elseb()
}
}
x1103
}
x1106 = x1105
x857 += 1
} // end fat loop x1106
val x850 = x1135
val x851 = x1106
val x1108 = x850.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1134 = { 
val x1132 = {
def x1132thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x851
}
def x1132elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1109 = x851.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1130 = {
def x1130thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x850
}
def x1130elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1110 = x850.length
val x1111 = x851.length
val x1112 = x1110 + x1111
val x1113 = x850.isRow
val x1114 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1112,x1113)
var x1116 : Int = 0
val x1120 = while (x1116 < x1110) {
val x1117 = x850(x1116)
val x1118 = x1114(x1116) = x1117
x1118
x1116 = x1116 + 1
}
var x1122 : Int = 0
val x1127 = while (x1122 < x1111) {
val x1123 = x1122 + x1110
val x1124 = x851(x1122)
val x1125 = x1114(x1123) = x1124
x1125
x1122 = x1122 + 1
}
val x1128 = x1114// unsafe immutable
x1128
}
if (x1109) {
x1130thenb()
} else { 
x1130elseb()
}
}
x1130
}
if (x1108) {
x1132thenb()
} else { 
x1132elseb()
}
}
x1132
}
x1135 = x1134
x849 += 1
} // end fat loop x1135
val x1136 = x1135.length
val x1137 = "Detections: "+x1136
val x1138 = println(x1137)
var x1167: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x831 == 0) {x832}
else {
val x833 = x225.dcApply(x828)
val x834 = x833._1
val x836 = "Name: "+x834
val x837 = println(x836)
val x835 = x833._2
val x838 = x835.length
val x839 = "Templates: "+x838
val x840 = println(x839)
val x841 = x714.fixedLevelIndex
val x842 = x714.pyramid
val x843 = x714.start_level
val x844 = x841 - x843
val x845 = x842(x844)
val x846 = x845.numRows
val x847 = x846 - 5
val x848 = new generated.scala.IndexVectorRangeImpl(5,x847)
val x852 = x848.length
val x940 = new generated.scala.IndexVectorRangeImpl(0,x838)
val x944 = x940.length
val x862 = x841
val x863 = Math.pow(2.0,x862)
val x864 = x863.asInstanceOf[Int]
var x849 = 0
val x854 = x845.numCols
val x855 = x854 - 5
val x856 = new generated.scala.IndexVectorRangeImpl(5,x855)
val x860 = x856.length
val x853 = x848.dcApply(x849)
val x890 = x853 + 15
val x882 = x853 - 15
val x883 = x882 < 0
val x887 = {
def x887thenb(): scala.Tuple2[Int, Int] = {
val x884 = 15 - x853
val x885 = (0,x884)
x885
}
def x887elseb(): scala.Tuple2[Int, Int] = {
val x886 = (x882,0)
x886
}
if (x883) {
x887thenb()
} else { 
x887elseb()
}
}
val x888 = x887._1
val x889 = x887._2
val x1036 = x864 * x853
var x857 = 0
val x865 = new generated.scala.IntVectorImpl(900,false)
val x866 = new generated.scala.IndexVectorSeqImpl(0)
val x867 = new generated.scala.BinarizedGradientTemplate(15,null,null,x841,x865,x866,null,null,null)
val x877 = x845.numCols
val x861 = x856.dcApply(x857)
val x876 = x861 + 15
val x878 = x876 > x877
val x881 = {
def x881thenb(): Int = {
val x879 = x845.numCols
x879
}
def x881elseb(): Int = {
x876
}
if (x878) {
x881thenb()
} else { 
x881elseb()
}
}
val x891 = x845.numRows
val x892 = x890 > x891
val x895 = {
def x895thenb(): Int = {
val x893 = x845.numRows
x893
}
def x895elseb(): Int = {
x890
}
if (x892) {
x895thenb()
} else { 
x895elseb()
}
}
var x896: Int = x888
val x868 = x861 - 15
val x869 = x868 < 0
val x873 = {
def x873thenb(): scala.Tuple2[Int, Int] = {
val x870 = 15 - x861
val x871 = (0,x870)
x871
}
def x873elseb(): scala.Tuple2[Int, Int] = {
val x872 = (x868,0)
x872
}
if (x869) {
x873thenb()
} else { 
x873elseb()
}
}
val x874 = x873._1
val x875 = x873._2
val x933 = while ({val x897 = x896
val x898 = x897 < x895
x898}) {
val x900 = x896
val x901 = x845.getRow(x900)
var x902: Int = x874
val x930 = while ({val x903 = x902
val x904 = x903 < x881
x904}) {
val x906 = x896
val x910 = x902
val x907 = x889 + x906
val x908 = x907 - x888
val x909 = x908 * 30
val x911 = x875 + x910
val x912 = x911 - x874
val x913 = x909 + x912
var x914: Int = x913
val x915 = x867.binary_gradients
val x916 = x914
val x917 = x902
val x918 = x901(x917)
val x919 = x915(x916) = x918
val x920 = x902
val x921 = x901(x920)
val x922 = x921 > 0
val x927 = {
def x927thenb(): Unit = {
val x923 = x867.match_list
val x924 = x923.length
val x925 = x923.insert(x924, x916)
x925
}
if (x922) {
x927thenb()
}
}
val x928 = x902 += 1
()
}
val x931 = x896 += 1
()
}
val x934 = x867.match_list
val x935 = x934.length
val x936 = x935 < 0
val x939 = {
def x939thenb(): Unit = {
val x937 = println("dummy")
x937
}
if (x936) {
x939thenb()
}
}
val x1031 = x864 * x861
// a *thin* loop follows: x1077
var x941 = 0
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
var x1077: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x944 == 0) {x832}
else {
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
}
x941 = 1
while (x941 < x944) {  // begin fat loop x1077
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
val x942 = x1077
val x943 = x1048
val x1050 = x942.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1076 = { 
val x1074 = {
def x1074thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x943
}
def x1074elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1051 = x943.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x942
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1052 = x942.length
val x1053 = x943.length
val x1054 = x1052 + x1053
val x1055 = x942.isRow
val x1056 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1054,x1055)
var x1058 : Int = 0
val x1062 = while (x1058 < x1052) {
val x1059 = x942(x1058)
val x1060 = x1056(x1058) = x1059
x1060
x1058 = x1058 + 1
}
var x1064 : Int = 0
val x1069 = while (x1064 < x1053) {
val x1065 = x1064 + x1052
val x1066 = x943(x1064)
val x1067 = x1056(x1065) = x1066
x1067
x1064 = x1064 + 1
}
val x1070 = x1056// unsafe immutable
x1070
}
if (x1051) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
if (x1050) {
x1074thenb()
} else { 
x1074elseb()
}
}
x1074
}
x1077 = x1076
x941 += 1
} // end fat loop x1077
var x1106: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x860 == 0) {x832}
else {
val x865 = new generated.scala.IntVectorImpl(900,false)
val x866 = new generated.scala.IndexVectorSeqImpl(0)
val x867 = new generated.scala.BinarizedGradientTemplate(15,null,null,x841,x865,x866,null,null,null)
val x877 = x845.numCols
val x861 = x856.dcApply(x857)
val x876 = x861 + 15
val x878 = x876 > x877
val x881 = {
def x881thenb(): Int = {
val x879 = x845.numCols
x879
}
def x881elseb(): Int = {
x876
}
if (x878) {
x881thenb()
} else { 
x881elseb()
}
}
val x891 = x845.numRows
val x892 = x890 > x891
val x895 = {
def x895thenb(): Int = {
val x893 = x845.numRows
x893
}
def x895elseb(): Int = {
x890
}
if (x892) {
x895thenb()
} else { 
x895elseb()
}
}
var x896: Int = x888
val x868 = x861 - 15
val x869 = x868 < 0
val x873 = {
def x873thenb(): scala.Tuple2[Int, Int] = {
val x870 = 15 - x861
val x871 = (0,x870)
x871
}
def x873elseb(): scala.Tuple2[Int, Int] = {
val x872 = (x868,0)
x872
}
if (x869) {
x873thenb()
} else { 
x873elseb()
}
}
val x874 = x873._1
val x875 = x873._2
val x933 = while ({val x897 = x896
val x898 = x897 < x895
x898}) {
val x900 = x896
val x901 = x845.getRow(x900)
var x902: Int = x874
val x930 = while ({val x903 = x902
val x904 = x903 < x881
x904}) {
val x906 = x896
val x910 = x902
val x907 = x889 + x906
val x908 = x907 - x888
val x909 = x908 * 30
val x911 = x875 + x910
val x912 = x911 - x874
val x913 = x909 + x912
var x914: Int = x913
val x915 = x867.binary_gradients
val x916 = x914
val x917 = x902
val x918 = x901(x917)
val x919 = x915(x916) = x918
val x920 = x902
val x921 = x901(x920)
val x922 = x921 > 0
val x927 = {
def x927thenb(): Unit = {
val x923 = x867.match_list
val x924 = x923.length
val x925 = x923.insert(x924, x916)
x925
}
if (x922) {
x927thenb()
}
}
val x928 = x902 += 1
()
}
val x931 = x896 += 1
()
}
val x934 = x867.match_list
val x935 = x934.length
val x936 = x935 < 0
val x939 = {
def x939thenb(): Unit = {
val x937 = println("dummy")
x937
}
if (x936) {
x939thenb()
}
}
val x1031 = x864 * x861
// a *thin* loop follows: x1077
var x941 = 0
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
var x1077: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x944 == 0) {x832}
else {
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
}
x941 = 1
while (x941 < x944) {  // begin fat loop x1077
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
val x942 = x1077
val x943 = x1048
val x1050 = x942.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1076 = { 
val x1074 = {
def x1074thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x943
}
def x1074elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1051 = x943.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x942
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1052 = x942.length
val x1053 = x943.length
val x1054 = x1052 + x1053
val x1055 = x942.isRow
val x1056 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1054,x1055)
var x1058 : Int = 0
val x1062 = while (x1058 < x1052) {
val x1059 = x942(x1058)
val x1060 = x1056(x1058) = x1059
x1060
x1058 = x1058 + 1
}
var x1064 : Int = 0
val x1069 = while (x1064 < x1053) {
val x1065 = x1064 + x1052
val x1066 = x943(x1064)
val x1067 = x1056(x1065) = x1066
x1067
x1064 = x1064 + 1
}
val x1070 = x1056// unsafe immutable
x1070
}
if (x1051) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
if (x1050) {
x1074thenb()
} else { 
x1074elseb()
}
}
x1074
}
x1077 = x1076
x941 += 1
} // end fat loop x1077
x1077
}
}
x857 = 1
while (x857 < x860) {  // begin fat loop x1106
val x865 = new generated.scala.IntVectorImpl(900,false)
val x866 = new generated.scala.IndexVectorSeqImpl(0)
val x867 = new generated.scala.BinarizedGradientTemplate(15,null,null,x841,x865,x866,null,null,null)
val x877 = x845.numCols
val x861 = x856.dcApply(x857)
val x876 = x861 + 15
val x878 = x876 > x877
val x881 = {
def x881thenb(): Int = {
val x879 = x845.numCols
x879
}
def x881elseb(): Int = {
x876
}
if (x878) {
x881thenb()
} else { 
x881elseb()
}
}
val x891 = x845.numRows
val x892 = x890 > x891
val x895 = {
def x895thenb(): Int = {
val x893 = x845.numRows
x893
}
def x895elseb(): Int = {
x890
}
if (x892) {
x895thenb()
} else { 
x895elseb()
}
}
var x896: Int = x888
val x868 = x861 - 15
val x869 = x868 < 0
val x873 = {
def x873thenb(): scala.Tuple2[Int, Int] = {
val x870 = 15 - x861
val x871 = (0,x870)
x871
}
def x873elseb(): scala.Tuple2[Int, Int] = {
val x872 = (x868,0)
x872
}
if (x869) {
x873thenb()
} else { 
x873elseb()
}
}
val x874 = x873._1
val x875 = x873._2
val x933 = while ({val x897 = x896
val x898 = x897 < x895
x898}) {
val x900 = x896
val x901 = x845.getRow(x900)
var x902: Int = x874
val x930 = while ({val x903 = x902
val x904 = x903 < x881
x904}) {
val x906 = x896
val x910 = x902
val x907 = x889 + x906
val x908 = x907 - x888
val x909 = x908 * 30
val x911 = x875 + x910
val x912 = x911 - x874
val x913 = x909 + x912
var x914: Int = x913
val x915 = x867.binary_gradients
val x916 = x914
val x917 = x902
val x918 = x901(x917)
val x919 = x915(x916) = x918
val x920 = x902
val x921 = x901(x920)
val x922 = x921 > 0
val x927 = {
def x927thenb(): Unit = {
val x923 = x867.match_list
val x924 = x923.length
val x925 = x923.insert(x924, x916)
x925
}
if (x922) {
x927thenb()
}
}
val x928 = x902 += 1
()
}
val x931 = x896 += 1
()
}
val x934 = x867.match_list
val x935 = x934.length
val x936 = x935 < 0
val x939 = {
def x939thenb(): Unit = {
val x937 = println("dummy")
x937
}
if (x936) {
x939thenb()
}
}
val x1031 = x864 * x861
// a *thin* loop follows: x1077
var x941 = 0
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
var x1077: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x944 == 0) {x832}
else {
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
}
x941 = 1
while (x941 < x944) {  // begin fat loop x1077
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
val x942 = x1077
val x943 = x1048
val x1050 = x942.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1076 = { 
val x1074 = {
def x1074thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x943
}
def x1074elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1051 = x943.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x942
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1052 = x942.length
val x1053 = x943.length
val x1054 = x1052 + x1053
val x1055 = x942.isRow
val x1056 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1054,x1055)
var x1058 : Int = 0
val x1062 = while (x1058 < x1052) {
val x1059 = x942(x1058)
val x1060 = x1056(x1058) = x1059
x1060
x1058 = x1058 + 1
}
var x1064 : Int = 0
val x1069 = while (x1064 < x1053) {
val x1065 = x1064 + x1052
val x1066 = x943(x1064)
val x1067 = x1056(x1065) = x1066
x1067
x1064 = x1064 + 1
}
val x1070 = x1056// unsafe immutable
x1070
}
if (x1051) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
if (x1050) {
x1074thenb()
} else { 
x1074elseb()
}
}
x1074
}
x1077 = x1076
x941 += 1
} // end fat loop x1077
val x858 = x1106
val x859 = x1077
val x1079 = x858.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1105 = { 
val x1103 = {
def x1103thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x859
}
def x1103elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1080 = x859.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1101 = {
def x1101thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x858
}
def x1101elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1081 = x858.length
val x1082 = x859.length
val x1083 = x1081 + x1082
val x1084 = x858.isRow
val x1085 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1083,x1084)
var x1087 : Int = 0
val x1091 = while (x1087 < x1081) {
val x1088 = x858(x1087)
val x1089 = x1085(x1087) = x1088
x1089
x1087 = x1087 + 1
}
var x1093 : Int = 0
val x1098 = while (x1093 < x1082) {
val x1094 = x1093 + x1081
val x1095 = x859(x1093)
val x1096 = x1085(x1094) = x1095
x1096
x1093 = x1093 + 1
}
val x1099 = x1085// unsafe immutable
x1099
}
if (x1080) {
x1101thenb()
} else { 
x1101elseb()
}
}
x1101
}
if (x1079) {
x1103thenb()
} else { 
x1103elseb()
}
}
x1103
}
x1106 = x1105
x857 += 1
} // end fat loop x1106
var x1135: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x852 == 0) {x832}
else {
val x854 = x845.numCols
val x855 = x854 - 5
val x856 = new generated.scala.IndexVectorRangeImpl(5,x855)
val x860 = x856.length
val x853 = x848.dcApply(x849)
val x890 = x853 + 15
val x882 = x853 - 15
val x883 = x882 < 0
val x887 = {
def x887thenb(): scala.Tuple2[Int, Int] = {
val x884 = 15 - x853
val x885 = (0,x884)
x885
}
def x887elseb(): scala.Tuple2[Int, Int] = {
val x886 = (x882,0)
x886
}
if (x883) {
x887thenb()
} else { 
x887elseb()
}
}
val x888 = x887._1
val x889 = x887._2
val x1036 = x864 * x853
var x857 = 0
val x865 = new generated.scala.IntVectorImpl(900,false)
val x866 = new generated.scala.IndexVectorSeqImpl(0)
val x867 = new generated.scala.BinarizedGradientTemplate(15,null,null,x841,x865,x866,null,null,null)
val x877 = x845.numCols
val x861 = x856.dcApply(x857)
val x876 = x861 + 15
val x878 = x876 > x877
val x881 = {
def x881thenb(): Int = {
val x879 = x845.numCols
x879
}
def x881elseb(): Int = {
x876
}
if (x878) {
x881thenb()
} else { 
x881elseb()
}
}
val x891 = x845.numRows
val x892 = x890 > x891
val x895 = {
def x895thenb(): Int = {
val x893 = x845.numRows
x893
}
def x895elseb(): Int = {
x890
}
if (x892) {
x895thenb()
} else { 
x895elseb()
}
}
var x896: Int = x888
val x868 = x861 - 15
val x869 = x868 < 0
val x873 = {
def x873thenb(): scala.Tuple2[Int, Int] = {
val x870 = 15 - x861
val x871 = (0,x870)
x871
}
def x873elseb(): scala.Tuple2[Int, Int] = {
val x872 = (x868,0)
x872
}
if (x869) {
x873thenb()
} else { 
x873elseb()
}
}
val x874 = x873._1
val x875 = x873._2
val x933 = while ({val x897 = x896
val x898 = x897 < x895
x898}) {
val x900 = x896
val x901 = x845.getRow(x900)
var x902: Int = x874
val x930 = while ({val x903 = x902
val x904 = x903 < x881
x904}) {
val x906 = x896
val x910 = x902
val x907 = x889 + x906
val x908 = x907 - x888
val x909 = x908 * 30
val x911 = x875 + x910
val x912 = x911 - x874
val x913 = x909 + x912
var x914: Int = x913
val x915 = x867.binary_gradients
val x916 = x914
val x917 = x902
val x918 = x901(x917)
val x919 = x915(x916) = x918
val x920 = x902
val x921 = x901(x920)
val x922 = x921 > 0
val x927 = {
def x927thenb(): Unit = {
val x923 = x867.match_list
val x924 = x923.length
val x925 = x923.insert(x924, x916)
x925
}
if (x922) {
x927thenb()
}
}
val x928 = x902 += 1
()
}
val x931 = x896 += 1
()
}
val x934 = x867.match_list
val x935 = x934.length
val x936 = x935 < 0
val x939 = {
def x939thenb(): Unit = {
val x937 = println("dummy")
x937
}
if (x936) {
x939thenb()
}
}
val x1031 = x864 * x861
// a *thin* loop follows: x1077
var x941 = 0
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
var x1077: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x944 == 0) {x832}
else {
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
}
x941 = 1
while (x941 < x944) {  // begin fat loop x1077
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
val x942 = x1077
val x943 = x1048
val x1050 = x942.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1076 = { 
val x1074 = {
def x1074thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x943
}
def x1074elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1051 = x943.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x942
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1052 = x942.length
val x1053 = x943.length
val x1054 = x1052 + x1053
val x1055 = x942.isRow
val x1056 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1054,x1055)
var x1058 : Int = 0
val x1062 = while (x1058 < x1052) {
val x1059 = x942(x1058)
val x1060 = x1056(x1058) = x1059
x1060
x1058 = x1058 + 1
}
var x1064 : Int = 0
val x1069 = while (x1064 < x1053) {
val x1065 = x1064 + x1052
val x1066 = x943(x1064)
val x1067 = x1056(x1065) = x1066
x1067
x1064 = x1064 + 1
}
val x1070 = x1056// unsafe immutable
x1070
}
if (x1051) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
if (x1050) {
x1074thenb()
} else { 
x1074elseb()
}
}
x1074
}
x1077 = x1076
x941 += 1
} // end fat loop x1077
var x1106: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x860 == 0) {x832}
else {
val x865 = new generated.scala.IntVectorImpl(900,false)
val x866 = new generated.scala.IndexVectorSeqImpl(0)
val x867 = new generated.scala.BinarizedGradientTemplate(15,null,null,x841,x865,x866,null,null,null)
val x877 = x845.numCols
val x861 = x856.dcApply(x857)
val x876 = x861 + 15
val x878 = x876 > x877
val x881 = {
def x881thenb(): Int = {
val x879 = x845.numCols
x879
}
def x881elseb(): Int = {
x876
}
if (x878) {
x881thenb()
} else { 
x881elseb()
}
}
val x891 = x845.numRows
val x892 = x890 > x891
val x895 = {
def x895thenb(): Int = {
val x893 = x845.numRows
x893
}
def x895elseb(): Int = {
x890
}
if (x892) {
x895thenb()
} else { 
x895elseb()
}
}
var x896: Int = x888
val x868 = x861 - 15
val x869 = x868 < 0
val x873 = {
def x873thenb(): scala.Tuple2[Int, Int] = {
val x870 = 15 - x861
val x871 = (0,x870)
x871
}
def x873elseb(): scala.Tuple2[Int, Int] = {
val x872 = (x868,0)
x872
}
if (x869) {
x873thenb()
} else { 
x873elseb()
}
}
val x874 = x873._1
val x875 = x873._2
val x933 = while ({val x897 = x896
val x898 = x897 < x895
x898}) {
val x900 = x896
val x901 = x845.getRow(x900)
var x902: Int = x874
val x930 = while ({val x903 = x902
val x904 = x903 < x881
x904}) {
val x906 = x896
val x910 = x902
val x907 = x889 + x906
val x908 = x907 - x888
val x909 = x908 * 30
val x911 = x875 + x910
val x912 = x911 - x874
val x913 = x909 + x912
var x914: Int = x913
val x915 = x867.binary_gradients
val x916 = x914
val x917 = x902
val x918 = x901(x917)
val x919 = x915(x916) = x918
val x920 = x902
val x921 = x901(x920)
val x922 = x921 > 0
val x927 = {
def x927thenb(): Unit = {
val x923 = x867.match_list
val x924 = x923.length
val x925 = x923.insert(x924, x916)
x925
}
if (x922) {
x927thenb()
}
}
val x928 = x902 += 1
()
}
val x931 = x896 += 1
()
}
val x934 = x867.match_list
val x935 = x934.length
val x936 = x935 < 0
val x939 = {
def x939thenb(): Unit = {
val x937 = println("dummy")
x937
}
if (x936) {
x939thenb()
}
}
val x1031 = x864 * x861
// a *thin* loop follows: x1077
var x941 = 0
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
var x1077: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x944 == 0) {x832}
else {
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
}
x941 = 1
while (x941 < x944) {  // begin fat loop x1077
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
val x942 = x1077
val x943 = x1048
val x1050 = x942.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1076 = { 
val x1074 = {
def x1074thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x943
}
def x1074elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1051 = x943.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x942
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1052 = x942.length
val x1053 = x943.length
val x1054 = x1052 + x1053
val x1055 = x942.isRow
val x1056 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1054,x1055)
var x1058 : Int = 0
val x1062 = while (x1058 < x1052) {
val x1059 = x942(x1058)
val x1060 = x1056(x1058) = x1059
x1060
x1058 = x1058 + 1
}
var x1064 : Int = 0
val x1069 = while (x1064 < x1053) {
val x1065 = x1064 + x1052
val x1066 = x943(x1064)
val x1067 = x1056(x1065) = x1066
x1067
x1064 = x1064 + 1
}
val x1070 = x1056// unsafe immutable
x1070
}
if (x1051) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
if (x1050) {
x1074thenb()
} else { 
x1074elseb()
}
}
x1074
}
x1077 = x1076
x941 += 1
} // end fat loop x1077
x1077
}
}
x857 = 1
while (x857 < x860) {  // begin fat loop x1106
val x865 = new generated.scala.IntVectorImpl(900,false)
val x866 = new generated.scala.IndexVectorSeqImpl(0)
val x867 = new generated.scala.BinarizedGradientTemplate(15,null,null,x841,x865,x866,null,null,null)
val x877 = x845.numCols
val x861 = x856.dcApply(x857)
val x876 = x861 + 15
val x878 = x876 > x877
val x881 = {
def x881thenb(): Int = {
val x879 = x845.numCols
x879
}
def x881elseb(): Int = {
x876
}
if (x878) {
x881thenb()
} else { 
x881elseb()
}
}
val x891 = x845.numRows
val x892 = x890 > x891
val x895 = {
def x895thenb(): Int = {
val x893 = x845.numRows
x893
}
def x895elseb(): Int = {
x890
}
if (x892) {
x895thenb()
} else { 
x895elseb()
}
}
var x896: Int = x888
val x868 = x861 - 15
val x869 = x868 < 0
val x873 = {
def x873thenb(): scala.Tuple2[Int, Int] = {
val x870 = 15 - x861
val x871 = (0,x870)
x871
}
def x873elseb(): scala.Tuple2[Int, Int] = {
val x872 = (x868,0)
x872
}
if (x869) {
x873thenb()
} else { 
x873elseb()
}
}
val x874 = x873._1
val x875 = x873._2
val x933 = while ({val x897 = x896
val x898 = x897 < x895
x898}) {
val x900 = x896
val x901 = x845.getRow(x900)
var x902: Int = x874
val x930 = while ({val x903 = x902
val x904 = x903 < x881
x904}) {
val x906 = x896
val x910 = x902
val x907 = x889 + x906
val x908 = x907 - x888
val x909 = x908 * 30
val x911 = x875 + x910
val x912 = x911 - x874
val x913 = x909 + x912
var x914: Int = x913
val x915 = x867.binary_gradients
val x916 = x914
val x917 = x902
val x918 = x901(x917)
val x919 = x915(x916) = x918
val x920 = x902
val x921 = x901(x920)
val x922 = x921 > 0
val x927 = {
def x927thenb(): Unit = {
val x923 = x867.match_list
val x924 = x923.length
val x925 = x923.insert(x924, x916)
x925
}
if (x922) {
x927thenb()
}
}
val x928 = x902 += 1
()
}
val x931 = x896 += 1
()
}
val x934 = x867.match_list
val x935 = x934.length
val x936 = x935 < 0
val x939 = {
def x939thenb(): Unit = {
val x937 = println("dummy")
x937
}
if (x936) {
x939thenb()
}
}
val x1031 = x864 * x861
// a *thin* loop follows: x1077
var x941 = 0
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
var x1077: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x944 == 0) {x832}
else {
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
}
x941 = 1
while (x941 < x944) {  // begin fat loop x1077
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
val x942 = x1077
val x943 = x1048
val x1050 = x942.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1076 = { 
val x1074 = {
def x1074thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x943
}
def x1074elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1051 = x943.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x942
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1052 = x942.length
val x1053 = x943.length
val x1054 = x1052 + x1053
val x1055 = x942.isRow
val x1056 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1054,x1055)
var x1058 : Int = 0
val x1062 = while (x1058 < x1052) {
val x1059 = x942(x1058)
val x1060 = x1056(x1058) = x1059
x1060
x1058 = x1058 + 1
}
var x1064 : Int = 0
val x1069 = while (x1064 < x1053) {
val x1065 = x1064 + x1052
val x1066 = x943(x1064)
val x1067 = x1056(x1065) = x1066
x1067
x1064 = x1064 + 1
}
val x1070 = x1056// unsafe immutable
x1070
}
if (x1051) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
if (x1050) {
x1074thenb()
} else { 
x1074elseb()
}
}
x1074
}
x1077 = x1076
x941 += 1
} // end fat loop x1077
val x858 = x1106
val x859 = x1077
val x1079 = x858.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1105 = { 
val x1103 = {
def x1103thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x859
}
def x1103elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1080 = x859.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1101 = {
def x1101thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x858
}
def x1101elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1081 = x858.length
val x1082 = x859.length
val x1083 = x1081 + x1082
val x1084 = x858.isRow
val x1085 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1083,x1084)
var x1087 : Int = 0
val x1091 = while (x1087 < x1081) {
val x1088 = x858(x1087)
val x1089 = x1085(x1087) = x1088
x1089
x1087 = x1087 + 1
}
var x1093 : Int = 0
val x1098 = while (x1093 < x1082) {
val x1094 = x1093 + x1081
val x1095 = x859(x1093)
val x1096 = x1085(x1094) = x1095
x1096
x1093 = x1093 + 1
}
val x1099 = x1085// unsafe immutable
x1099
}
if (x1080) {
x1101thenb()
} else { 
x1101elseb()
}
}
x1101
}
if (x1079) {
x1103thenb()
} else { 
x1103elseb()
}
}
x1103
}
x1106 = x1105
x857 += 1
} // end fat loop x1106
x1106
}
}
x849 = 1
while (x849 < x852) {  // begin fat loop x1135
val x854 = x845.numCols
val x855 = x854 - 5
val x856 = new generated.scala.IndexVectorRangeImpl(5,x855)
val x860 = x856.length
val x853 = x848.dcApply(x849)
val x890 = x853 + 15
val x882 = x853 - 15
val x883 = x882 < 0
val x887 = {
def x887thenb(): scala.Tuple2[Int, Int] = {
val x884 = 15 - x853
val x885 = (0,x884)
x885
}
def x887elseb(): scala.Tuple2[Int, Int] = {
val x886 = (x882,0)
x886
}
if (x883) {
x887thenb()
} else { 
x887elseb()
}
}
val x888 = x887._1
val x889 = x887._2
val x1036 = x864 * x853
var x857 = 0
val x865 = new generated.scala.IntVectorImpl(900,false)
val x866 = new generated.scala.IndexVectorSeqImpl(0)
val x867 = new generated.scala.BinarizedGradientTemplate(15,null,null,x841,x865,x866,null,null,null)
val x877 = x845.numCols
val x861 = x856.dcApply(x857)
val x876 = x861 + 15
val x878 = x876 > x877
val x881 = {
def x881thenb(): Int = {
val x879 = x845.numCols
x879
}
def x881elseb(): Int = {
x876
}
if (x878) {
x881thenb()
} else { 
x881elseb()
}
}
val x891 = x845.numRows
val x892 = x890 > x891
val x895 = {
def x895thenb(): Int = {
val x893 = x845.numRows
x893
}
def x895elseb(): Int = {
x890
}
if (x892) {
x895thenb()
} else { 
x895elseb()
}
}
var x896: Int = x888
val x868 = x861 - 15
val x869 = x868 < 0
val x873 = {
def x873thenb(): scala.Tuple2[Int, Int] = {
val x870 = 15 - x861
val x871 = (0,x870)
x871
}
def x873elseb(): scala.Tuple2[Int, Int] = {
val x872 = (x868,0)
x872
}
if (x869) {
x873thenb()
} else { 
x873elseb()
}
}
val x874 = x873._1
val x875 = x873._2
val x933 = while ({val x897 = x896
val x898 = x897 < x895
x898}) {
val x900 = x896
val x901 = x845.getRow(x900)
var x902: Int = x874
val x930 = while ({val x903 = x902
val x904 = x903 < x881
x904}) {
val x906 = x896
val x910 = x902
val x907 = x889 + x906
val x908 = x907 - x888
val x909 = x908 * 30
val x911 = x875 + x910
val x912 = x911 - x874
val x913 = x909 + x912
var x914: Int = x913
val x915 = x867.binary_gradients
val x916 = x914
val x917 = x902
val x918 = x901(x917)
val x919 = x915(x916) = x918
val x920 = x902
val x921 = x901(x920)
val x922 = x921 > 0
val x927 = {
def x927thenb(): Unit = {
val x923 = x867.match_list
val x924 = x923.length
val x925 = x923.insert(x924, x916)
x925
}
if (x922) {
x927thenb()
}
}
val x928 = x902 += 1
()
}
val x931 = x896 += 1
()
}
val x934 = x867.match_list
val x935 = x934.length
val x936 = x935 < 0
val x939 = {
def x939thenb(): Unit = {
val x937 = println("dummy")
x937
}
if (x936) {
x939thenb()
}
}
val x1031 = x864 * x861
// a *thin* loop follows: x1077
var x941 = 0
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
var x1077: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x944 == 0) {x832}
else {
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
}
x941 = 1
while (x941 < x944) {  // begin fat loop x1077
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
val x942 = x1077
val x943 = x1048
val x1050 = x942.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1076 = { 
val x1074 = {
def x1074thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x943
}
def x1074elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1051 = x943.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x942
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1052 = x942.length
val x1053 = x943.length
val x1054 = x1052 + x1053
val x1055 = x942.isRow
val x1056 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1054,x1055)
var x1058 : Int = 0
val x1062 = while (x1058 < x1052) {
val x1059 = x942(x1058)
val x1060 = x1056(x1058) = x1059
x1060
x1058 = x1058 + 1
}
var x1064 : Int = 0
val x1069 = while (x1064 < x1053) {
val x1065 = x1064 + x1052
val x1066 = x943(x1064)
val x1067 = x1056(x1065) = x1066
x1067
x1064 = x1064 + 1
}
val x1070 = x1056// unsafe immutable
x1070
}
if (x1051) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
if (x1050) {
x1074thenb()
} else { 
x1074elseb()
}
}
x1074
}
x1077 = x1076
x941 += 1
} // end fat loop x1077
var x1106: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x860 == 0) {x832}
else {
val x865 = new generated.scala.IntVectorImpl(900,false)
val x866 = new generated.scala.IndexVectorSeqImpl(0)
val x867 = new generated.scala.BinarizedGradientTemplate(15,null,null,x841,x865,x866,null,null,null)
val x877 = x845.numCols
val x861 = x856.dcApply(x857)
val x876 = x861 + 15
val x878 = x876 > x877
val x881 = {
def x881thenb(): Int = {
val x879 = x845.numCols
x879
}
def x881elseb(): Int = {
x876
}
if (x878) {
x881thenb()
} else { 
x881elseb()
}
}
val x891 = x845.numRows
val x892 = x890 > x891
val x895 = {
def x895thenb(): Int = {
val x893 = x845.numRows
x893
}
def x895elseb(): Int = {
x890
}
if (x892) {
x895thenb()
} else { 
x895elseb()
}
}
var x896: Int = x888
val x868 = x861 - 15
val x869 = x868 < 0
val x873 = {
def x873thenb(): scala.Tuple2[Int, Int] = {
val x870 = 15 - x861
val x871 = (0,x870)
x871
}
def x873elseb(): scala.Tuple2[Int, Int] = {
val x872 = (x868,0)
x872
}
if (x869) {
x873thenb()
} else { 
x873elseb()
}
}
val x874 = x873._1
val x875 = x873._2
val x933 = while ({val x897 = x896
val x898 = x897 < x895
x898}) {
val x900 = x896
val x901 = x845.getRow(x900)
var x902: Int = x874
val x930 = while ({val x903 = x902
val x904 = x903 < x881
x904}) {
val x906 = x896
val x910 = x902
val x907 = x889 + x906
val x908 = x907 - x888
val x909 = x908 * 30
val x911 = x875 + x910
val x912 = x911 - x874
val x913 = x909 + x912
var x914: Int = x913
val x915 = x867.binary_gradients
val x916 = x914
val x917 = x902
val x918 = x901(x917)
val x919 = x915(x916) = x918
val x920 = x902
val x921 = x901(x920)
val x922 = x921 > 0
val x927 = {
def x927thenb(): Unit = {
val x923 = x867.match_list
val x924 = x923.length
val x925 = x923.insert(x924, x916)
x925
}
if (x922) {
x927thenb()
}
}
val x928 = x902 += 1
()
}
val x931 = x896 += 1
()
}
val x934 = x867.match_list
val x935 = x934.length
val x936 = x935 < 0
val x939 = {
def x939thenb(): Unit = {
val x937 = println("dummy")
x937
}
if (x936) {
x939thenb()
}
}
val x1031 = x864 * x861
// a *thin* loop follows: x1077
var x941 = 0
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
var x1077: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x944 == 0) {x832}
else {
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
}
x941 = 1
while (x941 < x944) {  // begin fat loop x1077
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
val x942 = x1077
val x943 = x1048
val x1050 = x942.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1076 = { 
val x1074 = {
def x1074thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x943
}
def x1074elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1051 = x943.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x942
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1052 = x942.length
val x1053 = x943.length
val x1054 = x1052 + x1053
val x1055 = x942.isRow
val x1056 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1054,x1055)
var x1058 : Int = 0
val x1062 = while (x1058 < x1052) {
val x1059 = x942(x1058)
val x1060 = x1056(x1058) = x1059
x1060
x1058 = x1058 + 1
}
var x1064 : Int = 0
val x1069 = while (x1064 < x1053) {
val x1065 = x1064 + x1052
val x1066 = x943(x1064)
val x1067 = x1056(x1065) = x1066
x1067
x1064 = x1064 + 1
}
val x1070 = x1056// unsafe immutable
x1070
}
if (x1051) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
if (x1050) {
x1074thenb()
} else { 
x1074elseb()
}
}
x1074
}
x1077 = x1076
x941 += 1
} // end fat loop x1077
x1077
}
}
x857 = 1
while (x857 < x860) {  // begin fat loop x1106
val x865 = new generated.scala.IntVectorImpl(900,false)
val x866 = new generated.scala.IndexVectorSeqImpl(0)
val x867 = new generated.scala.BinarizedGradientTemplate(15,null,null,x841,x865,x866,null,null,null)
val x877 = x845.numCols
val x861 = x856.dcApply(x857)
val x876 = x861 + 15
val x878 = x876 > x877
val x881 = {
def x881thenb(): Int = {
val x879 = x845.numCols
x879
}
def x881elseb(): Int = {
x876
}
if (x878) {
x881thenb()
} else { 
x881elseb()
}
}
val x891 = x845.numRows
val x892 = x890 > x891
val x895 = {
def x895thenb(): Int = {
val x893 = x845.numRows
x893
}
def x895elseb(): Int = {
x890
}
if (x892) {
x895thenb()
} else { 
x895elseb()
}
}
var x896: Int = x888
val x868 = x861 - 15
val x869 = x868 < 0
val x873 = {
def x873thenb(): scala.Tuple2[Int, Int] = {
val x870 = 15 - x861
val x871 = (0,x870)
x871
}
def x873elseb(): scala.Tuple2[Int, Int] = {
val x872 = (x868,0)
x872
}
if (x869) {
x873thenb()
} else { 
x873elseb()
}
}
val x874 = x873._1
val x875 = x873._2
val x933 = while ({val x897 = x896
val x898 = x897 < x895
x898}) {
val x900 = x896
val x901 = x845.getRow(x900)
var x902: Int = x874
val x930 = while ({val x903 = x902
val x904 = x903 < x881
x904}) {
val x906 = x896
val x910 = x902
val x907 = x889 + x906
val x908 = x907 - x888
val x909 = x908 * 30
val x911 = x875 + x910
val x912 = x911 - x874
val x913 = x909 + x912
var x914: Int = x913
val x915 = x867.binary_gradients
val x916 = x914
val x917 = x902
val x918 = x901(x917)
val x919 = x915(x916) = x918
val x920 = x902
val x921 = x901(x920)
val x922 = x921 > 0
val x927 = {
def x927thenb(): Unit = {
val x923 = x867.match_list
val x924 = x923.length
val x925 = x923.insert(x924, x916)
x925
}
if (x922) {
x927thenb()
}
}
val x928 = x902 += 1
()
}
val x931 = x896 += 1
()
}
val x934 = x867.match_list
val x935 = x934.length
val x936 = x935 < 0
val x939 = {
def x939thenb(): Unit = {
val x937 = println("dummy")
x937
}
if (x936) {
x939thenb()
}
}
val x1031 = x864 * x861
// a *thin* loop follows: x1077
var x941 = 0
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
var x1077: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x944 == 0) {x832}
else {
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
}
x941 = 1
while (x941 < x944) {  // begin fat loop x1077
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
val x942 = x1077
val x943 = x1048
val x1050 = x942.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1076 = { 
val x1074 = {
def x1074thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x943
}
def x1074elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1051 = x943.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x942
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1052 = x942.length
val x1053 = x943.length
val x1054 = x1052 + x1053
val x1055 = x942.isRow
val x1056 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1054,x1055)
var x1058 : Int = 0
val x1062 = while (x1058 < x1052) {
val x1059 = x942(x1058)
val x1060 = x1056(x1058) = x1059
x1060
x1058 = x1058 + 1
}
var x1064 : Int = 0
val x1069 = while (x1064 < x1053) {
val x1065 = x1064 + x1052
val x1066 = x943(x1064)
val x1067 = x1056(x1065) = x1066
x1067
x1064 = x1064 + 1
}
val x1070 = x1056// unsafe immutable
x1070
}
if (x1051) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
if (x1050) {
x1074thenb()
} else { 
x1074elseb()
}
}
x1074
}
x1077 = x1076
x941 += 1
} // end fat loop x1077
val x858 = x1106
val x859 = x1077
val x1079 = x858.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1105 = { 
val x1103 = {
def x1103thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x859
}
def x1103elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1080 = x859.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1101 = {
def x1101thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x858
}
def x1101elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1081 = x858.length
val x1082 = x859.length
val x1083 = x1081 + x1082
val x1084 = x858.isRow
val x1085 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1083,x1084)
var x1087 : Int = 0
val x1091 = while (x1087 < x1081) {
val x1088 = x858(x1087)
val x1089 = x1085(x1087) = x1088
x1089
x1087 = x1087 + 1
}
var x1093 : Int = 0
val x1098 = while (x1093 < x1082) {
val x1094 = x1093 + x1081
val x1095 = x859(x1093)
val x1096 = x1085(x1094) = x1095
x1096
x1093 = x1093 + 1
}
val x1099 = x1085// unsafe immutable
x1099
}
if (x1080) {
x1101thenb()
} else { 
x1101elseb()
}
}
x1101
}
if (x1079) {
x1103thenb()
} else { 
x1103elseb()
}
}
x1103
}
x1106 = x1105
x857 += 1
} // end fat loop x1106
val x850 = x1135
val x851 = x1106
val x1108 = x850.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1134 = { 
val x1132 = {
def x1132thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x851
}
def x1132elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1109 = x851.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1130 = {
def x1130thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x850
}
def x1130elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1110 = x850.length
val x1111 = x851.length
val x1112 = x1110 + x1111
val x1113 = x850.isRow
val x1114 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1112,x1113)
var x1116 : Int = 0
val x1120 = while (x1116 < x1110) {
val x1117 = x850(x1116)
val x1118 = x1114(x1116) = x1117
x1118
x1116 = x1116 + 1
}
var x1122 : Int = 0
val x1127 = while (x1122 < x1111) {
val x1123 = x1122 + x1110
val x1124 = x851(x1122)
val x1125 = x1114(x1123) = x1124
x1125
x1122 = x1122 + 1
}
val x1128 = x1114// unsafe immutable
x1128
}
if (x1109) {
x1130thenb()
} else { 
x1130elseb()
}
}
x1130
}
if (x1108) {
x1132thenb()
} else { 
x1132elseb()
}
}
x1132
}
x1135 = x1134
x849 += 1
} // end fat loop x1135
val x1136 = x1135.length
val x1137 = "Detections: "+x1136
val x1138 = println(x1137)
x1135
}
}
x828 = 1
while (x828 < x831) {  // begin fat loop x1167
val x833 = x225.dcApply(x828)
val x834 = x833._1
val x836 = "Name: "+x834
val x837 = println(x836)
val x835 = x833._2
val x838 = x835.length
val x839 = "Templates: "+x838
val x840 = println(x839)
val x841 = x714.fixedLevelIndex
val x842 = x714.pyramid
val x843 = x714.start_level
val x844 = x841 - x843
val x845 = x842(x844)
val x846 = x845.numRows
val x847 = x846 - 5
val x848 = new generated.scala.IndexVectorRangeImpl(5,x847)
val x852 = x848.length
val x940 = new generated.scala.IndexVectorRangeImpl(0,x838)
val x944 = x940.length
val x862 = x841
val x863 = Math.pow(2.0,x862)
val x864 = x863.asInstanceOf[Int]
var x849 = 0
val x854 = x845.numCols
val x855 = x854 - 5
val x856 = new generated.scala.IndexVectorRangeImpl(5,x855)
val x860 = x856.length
val x853 = x848.dcApply(x849)
val x890 = x853 + 15
val x882 = x853 - 15
val x883 = x882 < 0
val x887 = {
def x887thenb(): scala.Tuple2[Int, Int] = {
val x884 = 15 - x853
val x885 = (0,x884)
x885
}
def x887elseb(): scala.Tuple2[Int, Int] = {
val x886 = (x882,0)
x886
}
if (x883) {
x887thenb()
} else { 
x887elseb()
}
}
val x888 = x887._1
val x889 = x887._2
val x1036 = x864 * x853
var x857 = 0
val x865 = new generated.scala.IntVectorImpl(900,false)
val x866 = new generated.scala.IndexVectorSeqImpl(0)
val x867 = new generated.scala.BinarizedGradientTemplate(15,null,null,x841,x865,x866,null,null,null)
val x877 = x845.numCols
val x861 = x856.dcApply(x857)
val x876 = x861 + 15
val x878 = x876 > x877
val x881 = {
def x881thenb(): Int = {
val x879 = x845.numCols
x879
}
def x881elseb(): Int = {
x876
}
if (x878) {
x881thenb()
} else { 
x881elseb()
}
}
val x891 = x845.numRows
val x892 = x890 > x891
val x895 = {
def x895thenb(): Int = {
val x893 = x845.numRows
x893
}
def x895elseb(): Int = {
x890
}
if (x892) {
x895thenb()
} else { 
x895elseb()
}
}
var x896: Int = x888
val x868 = x861 - 15
val x869 = x868 < 0
val x873 = {
def x873thenb(): scala.Tuple2[Int, Int] = {
val x870 = 15 - x861
val x871 = (0,x870)
x871
}
def x873elseb(): scala.Tuple2[Int, Int] = {
val x872 = (x868,0)
x872
}
if (x869) {
x873thenb()
} else { 
x873elseb()
}
}
val x874 = x873._1
val x875 = x873._2
val x933 = while ({val x897 = x896
val x898 = x897 < x895
x898}) {
val x900 = x896
val x901 = x845.getRow(x900)
var x902: Int = x874
val x930 = while ({val x903 = x902
val x904 = x903 < x881
x904}) {
val x906 = x896
val x910 = x902
val x907 = x889 + x906
val x908 = x907 - x888
val x909 = x908 * 30
val x911 = x875 + x910
val x912 = x911 - x874
val x913 = x909 + x912
var x914: Int = x913
val x915 = x867.binary_gradients
val x916 = x914
val x917 = x902
val x918 = x901(x917)
val x919 = x915(x916) = x918
val x920 = x902
val x921 = x901(x920)
val x922 = x921 > 0
val x927 = {
def x927thenb(): Unit = {
val x923 = x867.match_list
val x924 = x923.length
val x925 = x923.insert(x924, x916)
x925
}
if (x922) {
x927thenb()
}
}
val x928 = x902 += 1
()
}
val x931 = x896 += 1
()
}
val x934 = x867.match_list
val x935 = x934.length
val x936 = x935 < 0
val x939 = {
def x939thenb(): Unit = {
val x937 = println("dummy")
x937
}
if (x936) {
x939thenb()
}
}
val x1031 = x864 * x861
// a *thin* loop follows: x1077
var x941 = 0
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
var x1077: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x944 == 0) {x832}
else {
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
}
x941 = 1
while (x941 < x944) {  // begin fat loop x1077
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
val x942 = x1077
val x943 = x1048
val x1050 = x942.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1076 = { 
val x1074 = {
def x1074thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x943
}
def x1074elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1051 = x943.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x942
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1052 = x942.length
val x1053 = x943.length
val x1054 = x1052 + x1053
val x1055 = x942.isRow
val x1056 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1054,x1055)
var x1058 : Int = 0
val x1062 = while (x1058 < x1052) {
val x1059 = x942(x1058)
val x1060 = x1056(x1058) = x1059
x1060
x1058 = x1058 + 1
}
var x1064 : Int = 0
val x1069 = while (x1064 < x1053) {
val x1065 = x1064 + x1052
val x1066 = x943(x1064)
val x1067 = x1056(x1065) = x1066
x1067
x1064 = x1064 + 1
}
val x1070 = x1056// unsafe immutable
x1070
}
if (x1051) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
if (x1050) {
x1074thenb()
} else { 
x1074elseb()
}
}
x1074
}
x1077 = x1076
x941 += 1
} // end fat loop x1077
var x1106: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x860 == 0) {x832}
else {
val x865 = new generated.scala.IntVectorImpl(900,false)
val x866 = new generated.scala.IndexVectorSeqImpl(0)
val x867 = new generated.scala.BinarizedGradientTemplate(15,null,null,x841,x865,x866,null,null,null)
val x877 = x845.numCols
val x861 = x856.dcApply(x857)
val x876 = x861 + 15
val x878 = x876 > x877
val x881 = {
def x881thenb(): Int = {
val x879 = x845.numCols
x879
}
def x881elseb(): Int = {
x876
}
if (x878) {
x881thenb()
} else { 
x881elseb()
}
}
val x891 = x845.numRows
val x892 = x890 > x891
val x895 = {
def x895thenb(): Int = {
val x893 = x845.numRows
x893
}
def x895elseb(): Int = {
x890
}
if (x892) {
x895thenb()
} else { 
x895elseb()
}
}
var x896: Int = x888
val x868 = x861 - 15
val x869 = x868 < 0
val x873 = {
def x873thenb(): scala.Tuple2[Int, Int] = {
val x870 = 15 - x861
val x871 = (0,x870)
x871
}
def x873elseb(): scala.Tuple2[Int, Int] = {
val x872 = (x868,0)
x872
}
if (x869) {
x873thenb()
} else { 
x873elseb()
}
}
val x874 = x873._1
val x875 = x873._2
val x933 = while ({val x897 = x896
val x898 = x897 < x895
x898}) {
val x900 = x896
val x901 = x845.getRow(x900)
var x902: Int = x874
val x930 = while ({val x903 = x902
val x904 = x903 < x881
x904}) {
val x906 = x896
val x910 = x902
val x907 = x889 + x906
val x908 = x907 - x888
val x909 = x908 * 30
val x911 = x875 + x910
val x912 = x911 - x874
val x913 = x909 + x912
var x914: Int = x913
val x915 = x867.binary_gradients
val x916 = x914
val x917 = x902
val x918 = x901(x917)
val x919 = x915(x916) = x918
val x920 = x902
val x921 = x901(x920)
val x922 = x921 > 0
val x927 = {
def x927thenb(): Unit = {
val x923 = x867.match_list
val x924 = x923.length
val x925 = x923.insert(x924, x916)
x925
}
if (x922) {
x927thenb()
}
}
val x928 = x902 += 1
()
}
val x931 = x896 += 1
()
}
val x934 = x867.match_list
val x935 = x934.length
val x936 = x935 < 0
val x939 = {
def x939thenb(): Unit = {
val x937 = println("dummy")
x937
}
if (x936) {
x939thenb()
}
}
val x1031 = x864 * x861
// a *thin* loop follows: x1077
var x941 = 0
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
var x1077: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x944 == 0) {x832}
else {
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
}
x941 = 1
while (x941 < x944) {  // begin fat loop x1077
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
val x942 = x1077
val x943 = x1048
val x1050 = x942.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1076 = { 
val x1074 = {
def x1074thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x943
}
def x1074elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1051 = x943.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x942
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1052 = x942.length
val x1053 = x943.length
val x1054 = x1052 + x1053
val x1055 = x942.isRow
val x1056 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1054,x1055)
var x1058 : Int = 0
val x1062 = while (x1058 < x1052) {
val x1059 = x942(x1058)
val x1060 = x1056(x1058) = x1059
x1060
x1058 = x1058 + 1
}
var x1064 : Int = 0
val x1069 = while (x1064 < x1053) {
val x1065 = x1064 + x1052
val x1066 = x943(x1064)
val x1067 = x1056(x1065) = x1066
x1067
x1064 = x1064 + 1
}
val x1070 = x1056// unsafe immutable
x1070
}
if (x1051) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
if (x1050) {
x1074thenb()
} else { 
x1074elseb()
}
}
x1074
}
x1077 = x1076
x941 += 1
} // end fat loop x1077
x1077
}
}
x857 = 1
while (x857 < x860) {  // begin fat loop x1106
val x865 = new generated.scala.IntVectorImpl(900,false)
val x866 = new generated.scala.IndexVectorSeqImpl(0)
val x867 = new generated.scala.BinarizedGradientTemplate(15,null,null,x841,x865,x866,null,null,null)
val x877 = x845.numCols
val x861 = x856.dcApply(x857)
val x876 = x861 + 15
val x878 = x876 > x877
val x881 = {
def x881thenb(): Int = {
val x879 = x845.numCols
x879
}
def x881elseb(): Int = {
x876
}
if (x878) {
x881thenb()
} else { 
x881elseb()
}
}
val x891 = x845.numRows
val x892 = x890 > x891
val x895 = {
def x895thenb(): Int = {
val x893 = x845.numRows
x893
}
def x895elseb(): Int = {
x890
}
if (x892) {
x895thenb()
} else { 
x895elseb()
}
}
var x896: Int = x888
val x868 = x861 - 15
val x869 = x868 < 0
val x873 = {
def x873thenb(): scala.Tuple2[Int, Int] = {
val x870 = 15 - x861
val x871 = (0,x870)
x871
}
def x873elseb(): scala.Tuple2[Int, Int] = {
val x872 = (x868,0)
x872
}
if (x869) {
x873thenb()
} else { 
x873elseb()
}
}
val x874 = x873._1
val x875 = x873._2
val x933 = while ({val x897 = x896
val x898 = x897 < x895
x898}) {
val x900 = x896
val x901 = x845.getRow(x900)
var x902: Int = x874
val x930 = while ({val x903 = x902
val x904 = x903 < x881
x904}) {
val x906 = x896
val x910 = x902
val x907 = x889 + x906
val x908 = x907 - x888
val x909 = x908 * 30
val x911 = x875 + x910
val x912 = x911 - x874
val x913 = x909 + x912
var x914: Int = x913
val x915 = x867.binary_gradients
val x916 = x914
val x917 = x902
val x918 = x901(x917)
val x919 = x915(x916) = x918
val x920 = x902
val x921 = x901(x920)
val x922 = x921 > 0
val x927 = {
def x927thenb(): Unit = {
val x923 = x867.match_list
val x924 = x923.length
val x925 = x923.insert(x924, x916)
x925
}
if (x922) {
x927thenb()
}
}
val x928 = x902 += 1
()
}
val x931 = x896 += 1
()
}
val x934 = x867.match_list
val x935 = x934.length
val x936 = x935 < 0
val x939 = {
def x939thenb(): Unit = {
val x937 = println("dummy")
x937
}
if (x936) {
x939thenb()
}
}
val x1031 = x864 * x861
// a *thin* loop follows: x1077
var x941 = 0
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
var x1077: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x944 == 0) {x832}
else {
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
}
x941 = 1
while (x941 < x944) {  // begin fat loop x1077
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
val x942 = x1077
val x943 = x1048
val x1050 = x942.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1076 = { 
val x1074 = {
def x1074thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x943
}
def x1074elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1051 = x943.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x942
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1052 = x942.length
val x1053 = x943.length
val x1054 = x1052 + x1053
val x1055 = x942.isRow
val x1056 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1054,x1055)
var x1058 : Int = 0
val x1062 = while (x1058 < x1052) {
val x1059 = x942(x1058)
val x1060 = x1056(x1058) = x1059
x1060
x1058 = x1058 + 1
}
var x1064 : Int = 0
val x1069 = while (x1064 < x1053) {
val x1065 = x1064 + x1052
val x1066 = x943(x1064)
val x1067 = x1056(x1065) = x1066
x1067
x1064 = x1064 + 1
}
val x1070 = x1056// unsafe immutable
x1070
}
if (x1051) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
if (x1050) {
x1074thenb()
} else { 
x1074elseb()
}
}
x1074
}
x1077 = x1076
x941 += 1
} // end fat loop x1077
val x858 = x1106
val x859 = x1077
val x1079 = x858.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1105 = { 
val x1103 = {
def x1103thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x859
}
def x1103elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1080 = x859.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1101 = {
def x1101thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x858
}
def x1101elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1081 = x858.length
val x1082 = x859.length
val x1083 = x1081 + x1082
val x1084 = x858.isRow
val x1085 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1083,x1084)
var x1087 : Int = 0
val x1091 = while (x1087 < x1081) {
val x1088 = x858(x1087)
val x1089 = x1085(x1087) = x1088
x1089
x1087 = x1087 + 1
}
var x1093 : Int = 0
val x1098 = while (x1093 < x1082) {
val x1094 = x1093 + x1081
val x1095 = x859(x1093)
val x1096 = x1085(x1094) = x1095
x1096
x1093 = x1093 + 1
}
val x1099 = x1085// unsafe immutable
x1099
}
if (x1080) {
x1101thenb()
} else { 
x1101elseb()
}
}
x1101
}
if (x1079) {
x1103thenb()
} else { 
x1103elseb()
}
}
x1103
}
x1106 = x1105
x857 += 1
} // end fat loop x1106
var x1135: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x852 == 0) {x832}
else {
val x854 = x845.numCols
val x855 = x854 - 5
val x856 = new generated.scala.IndexVectorRangeImpl(5,x855)
val x860 = x856.length
val x853 = x848.dcApply(x849)
val x890 = x853 + 15
val x882 = x853 - 15
val x883 = x882 < 0
val x887 = {
def x887thenb(): scala.Tuple2[Int, Int] = {
val x884 = 15 - x853
val x885 = (0,x884)
x885
}
def x887elseb(): scala.Tuple2[Int, Int] = {
val x886 = (x882,0)
x886
}
if (x883) {
x887thenb()
} else { 
x887elseb()
}
}
val x888 = x887._1
val x889 = x887._2
val x1036 = x864 * x853
var x857 = 0
val x865 = new generated.scala.IntVectorImpl(900,false)
val x866 = new generated.scala.IndexVectorSeqImpl(0)
val x867 = new generated.scala.BinarizedGradientTemplate(15,null,null,x841,x865,x866,null,null,null)
val x877 = x845.numCols
val x861 = x856.dcApply(x857)
val x876 = x861 + 15
val x878 = x876 > x877
val x881 = {
def x881thenb(): Int = {
val x879 = x845.numCols
x879
}
def x881elseb(): Int = {
x876
}
if (x878) {
x881thenb()
} else { 
x881elseb()
}
}
val x891 = x845.numRows
val x892 = x890 > x891
val x895 = {
def x895thenb(): Int = {
val x893 = x845.numRows
x893
}
def x895elseb(): Int = {
x890
}
if (x892) {
x895thenb()
} else { 
x895elseb()
}
}
var x896: Int = x888
val x868 = x861 - 15
val x869 = x868 < 0
val x873 = {
def x873thenb(): scala.Tuple2[Int, Int] = {
val x870 = 15 - x861
val x871 = (0,x870)
x871
}
def x873elseb(): scala.Tuple2[Int, Int] = {
val x872 = (x868,0)
x872
}
if (x869) {
x873thenb()
} else { 
x873elseb()
}
}
val x874 = x873._1
val x875 = x873._2
val x933 = while ({val x897 = x896
val x898 = x897 < x895
x898}) {
val x900 = x896
val x901 = x845.getRow(x900)
var x902: Int = x874
val x930 = while ({val x903 = x902
val x904 = x903 < x881
x904}) {
val x906 = x896
val x910 = x902
val x907 = x889 + x906
val x908 = x907 - x888
val x909 = x908 * 30
val x911 = x875 + x910
val x912 = x911 - x874
val x913 = x909 + x912
var x914: Int = x913
val x915 = x867.binary_gradients
val x916 = x914
val x917 = x902
val x918 = x901(x917)
val x919 = x915(x916) = x918
val x920 = x902
val x921 = x901(x920)
val x922 = x921 > 0
val x927 = {
def x927thenb(): Unit = {
val x923 = x867.match_list
val x924 = x923.length
val x925 = x923.insert(x924, x916)
x925
}
if (x922) {
x927thenb()
}
}
val x928 = x902 += 1
()
}
val x931 = x896 += 1
()
}
val x934 = x867.match_list
val x935 = x934.length
val x936 = x935 < 0
val x939 = {
def x939thenb(): Unit = {
val x937 = println("dummy")
x937
}
if (x936) {
x939thenb()
}
}
val x1031 = x864 * x861
// a *thin* loop follows: x1077
var x941 = 0
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
var x1077: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x944 == 0) {x832}
else {
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
}
x941 = 1
while (x941 < x944) {  // begin fat loop x1077
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
val x942 = x1077
val x943 = x1048
val x1050 = x942.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1076 = { 
val x1074 = {
def x1074thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x943
}
def x1074elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1051 = x943.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x942
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1052 = x942.length
val x1053 = x943.length
val x1054 = x1052 + x1053
val x1055 = x942.isRow
val x1056 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1054,x1055)
var x1058 : Int = 0
val x1062 = while (x1058 < x1052) {
val x1059 = x942(x1058)
val x1060 = x1056(x1058) = x1059
x1060
x1058 = x1058 + 1
}
var x1064 : Int = 0
val x1069 = while (x1064 < x1053) {
val x1065 = x1064 + x1052
val x1066 = x943(x1064)
val x1067 = x1056(x1065) = x1066
x1067
x1064 = x1064 + 1
}
val x1070 = x1056// unsafe immutable
x1070
}
if (x1051) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
if (x1050) {
x1074thenb()
} else { 
x1074elseb()
}
}
x1074
}
x1077 = x1076
x941 += 1
} // end fat loop x1077
var x1106: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x860 == 0) {x832}
else {
val x865 = new generated.scala.IntVectorImpl(900,false)
val x866 = new generated.scala.IndexVectorSeqImpl(0)
val x867 = new generated.scala.BinarizedGradientTemplate(15,null,null,x841,x865,x866,null,null,null)
val x877 = x845.numCols
val x861 = x856.dcApply(x857)
val x876 = x861 + 15
val x878 = x876 > x877
val x881 = {
def x881thenb(): Int = {
val x879 = x845.numCols
x879
}
def x881elseb(): Int = {
x876
}
if (x878) {
x881thenb()
} else { 
x881elseb()
}
}
val x891 = x845.numRows
val x892 = x890 > x891
val x895 = {
def x895thenb(): Int = {
val x893 = x845.numRows
x893
}
def x895elseb(): Int = {
x890
}
if (x892) {
x895thenb()
} else { 
x895elseb()
}
}
var x896: Int = x888
val x868 = x861 - 15
val x869 = x868 < 0
val x873 = {
def x873thenb(): scala.Tuple2[Int, Int] = {
val x870 = 15 - x861
val x871 = (0,x870)
x871
}
def x873elseb(): scala.Tuple2[Int, Int] = {
val x872 = (x868,0)
x872
}
if (x869) {
x873thenb()
} else { 
x873elseb()
}
}
val x874 = x873._1
val x875 = x873._2
val x933 = while ({val x897 = x896
val x898 = x897 < x895
x898}) {
val x900 = x896
val x901 = x845.getRow(x900)
var x902: Int = x874
val x930 = while ({val x903 = x902
val x904 = x903 < x881
x904}) {
val x906 = x896
val x910 = x902
val x907 = x889 + x906
val x908 = x907 - x888
val x909 = x908 * 30
val x911 = x875 + x910
val x912 = x911 - x874
val x913 = x909 + x912
var x914: Int = x913
val x915 = x867.binary_gradients
val x916 = x914
val x917 = x902
val x918 = x901(x917)
val x919 = x915(x916) = x918
val x920 = x902
val x921 = x901(x920)
val x922 = x921 > 0
val x927 = {
def x927thenb(): Unit = {
val x923 = x867.match_list
val x924 = x923.length
val x925 = x923.insert(x924, x916)
x925
}
if (x922) {
x927thenb()
}
}
val x928 = x902 += 1
()
}
val x931 = x896 += 1
()
}
val x934 = x867.match_list
val x935 = x934.length
val x936 = x935 < 0
val x939 = {
def x939thenb(): Unit = {
val x937 = println("dummy")
x937
}
if (x936) {
x939thenb()
}
}
val x1031 = x864 * x861
// a *thin* loop follows: x1077
var x941 = 0
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
var x1077: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x944 == 0) {x832}
else {
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
}
x941 = 1
while (x941 < x944) {  // begin fat loop x1077
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
val x942 = x1077
val x943 = x1048
val x1050 = x942.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1076 = { 
val x1074 = {
def x1074thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x943
}
def x1074elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1051 = x943.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x942
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1052 = x942.length
val x1053 = x943.length
val x1054 = x1052 + x1053
val x1055 = x942.isRow
val x1056 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1054,x1055)
var x1058 : Int = 0
val x1062 = while (x1058 < x1052) {
val x1059 = x942(x1058)
val x1060 = x1056(x1058) = x1059
x1060
x1058 = x1058 + 1
}
var x1064 : Int = 0
val x1069 = while (x1064 < x1053) {
val x1065 = x1064 + x1052
val x1066 = x943(x1064)
val x1067 = x1056(x1065) = x1066
x1067
x1064 = x1064 + 1
}
val x1070 = x1056// unsafe immutable
x1070
}
if (x1051) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
if (x1050) {
x1074thenb()
} else { 
x1074elseb()
}
}
x1074
}
x1077 = x1076
x941 += 1
} // end fat loop x1077
x1077
}
}
x857 = 1
while (x857 < x860) {  // begin fat loop x1106
val x865 = new generated.scala.IntVectorImpl(900,false)
val x866 = new generated.scala.IndexVectorSeqImpl(0)
val x867 = new generated.scala.BinarizedGradientTemplate(15,null,null,x841,x865,x866,null,null,null)
val x877 = x845.numCols
val x861 = x856.dcApply(x857)
val x876 = x861 + 15
val x878 = x876 > x877
val x881 = {
def x881thenb(): Int = {
val x879 = x845.numCols
x879
}
def x881elseb(): Int = {
x876
}
if (x878) {
x881thenb()
} else { 
x881elseb()
}
}
val x891 = x845.numRows
val x892 = x890 > x891
val x895 = {
def x895thenb(): Int = {
val x893 = x845.numRows
x893
}
def x895elseb(): Int = {
x890
}
if (x892) {
x895thenb()
} else { 
x895elseb()
}
}
var x896: Int = x888
val x868 = x861 - 15
val x869 = x868 < 0
val x873 = {
def x873thenb(): scala.Tuple2[Int, Int] = {
val x870 = 15 - x861
val x871 = (0,x870)
x871
}
def x873elseb(): scala.Tuple2[Int, Int] = {
val x872 = (x868,0)
x872
}
if (x869) {
x873thenb()
} else { 
x873elseb()
}
}
val x874 = x873._1
val x875 = x873._2
val x933 = while ({val x897 = x896
val x898 = x897 < x895
x898}) {
val x900 = x896
val x901 = x845.getRow(x900)
var x902: Int = x874
val x930 = while ({val x903 = x902
val x904 = x903 < x881
x904}) {
val x906 = x896
val x910 = x902
val x907 = x889 + x906
val x908 = x907 - x888
val x909 = x908 * 30
val x911 = x875 + x910
val x912 = x911 - x874
val x913 = x909 + x912
var x914: Int = x913
val x915 = x867.binary_gradients
val x916 = x914
val x917 = x902
val x918 = x901(x917)
val x919 = x915(x916) = x918
val x920 = x902
val x921 = x901(x920)
val x922 = x921 > 0
val x927 = {
def x927thenb(): Unit = {
val x923 = x867.match_list
val x924 = x923.length
val x925 = x923.insert(x924, x916)
x925
}
if (x922) {
x927thenb()
}
}
val x928 = x902 += 1
()
}
val x931 = x896 += 1
()
}
val x934 = x867.match_list
val x935 = x934.length
val x936 = x935 < 0
val x939 = {
def x939thenb(): Unit = {
val x937 = println("dummy")
x937
}
if (x936) {
x939thenb()
}
}
val x1031 = x864 * x861
// a *thin* loop follows: x1077
var x941 = 0
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
var x1077: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x944 == 0) {x832}
else {
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
}
x941 = 1
while (x941 < x944) {  // begin fat loop x1077
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
val x942 = x1077
val x943 = x1048
val x1050 = x942.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1076 = { 
val x1074 = {
def x1074thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x943
}
def x1074elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1051 = x943.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x942
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1052 = x942.length
val x1053 = x943.length
val x1054 = x1052 + x1053
val x1055 = x942.isRow
val x1056 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1054,x1055)
var x1058 : Int = 0
val x1062 = while (x1058 < x1052) {
val x1059 = x942(x1058)
val x1060 = x1056(x1058) = x1059
x1060
x1058 = x1058 + 1
}
var x1064 : Int = 0
val x1069 = while (x1064 < x1053) {
val x1065 = x1064 + x1052
val x1066 = x943(x1064)
val x1067 = x1056(x1065) = x1066
x1067
x1064 = x1064 + 1
}
val x1070 = x1056// unsafe immutable
x1070
}
if (x1051) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
if (x1050) {
x1074thenb()
} else { 
x1074elseb()
}
}
x1074
}
x1077 = x1076
x941 += 1
} // end fat loop x1077
val x858 = x1106
val x859 = x1077
val x1079 = x858.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1105 = { 
val x1103 = {
def x1103thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x859
}
def x1103elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1080 = x859.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1101 = {
def x1101thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x858
}
def x1101elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1081 = x858.length
val x1082 = x859.length
val x1083 = x1081 + x1082
val x1084 = x858.isRow
val x1085 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1083,x1084)
var x1087 : Int = 0
val x1091 = while (x1087 < x1081) {
val x1088 = x858(x1087)
val x1089 = x1085(x1087) = x1088
x1089
x1087 = x1087 + 1
}
var x1093 : Int = 0
val x1098 = while (x1093 < x1082) {
val x1094 = x1093 + x1081
val x1095 = x859(x1093)
val x1096 = x1085(x1094) = x1095
x1096
x1093 = x1093 + 1
}
val x1099 = x1085// unsafe immutable
x1099
}
if (x1080) {
x1101thenb()
} else { 
x1101elseb()
}
}
x1101
}
if (x1079) {
x1103thenb()
} else { 
x1103elseb()
}
}
x1103
}
x1106 = x1105
x857 += 1
} // end fat loop x1106
x1106
}
}
x849 = 1
while (x849 < x852) {  // begin fat loop x1135
val x854 = x845.numCols
val x855 = x854 - 5
val x856 = new generated.scala.IndexVectorRangeImpl(5,x855)
val x860 = x856.length
val x853 = x848.dcApply(x849)
val x890 = x853 + 15
val x882 = x853 - 15
val x883 = x882 < 0
val x887 = {
def x887thenb(): scala.Tuple2[Int, Int] = {
val x884 = 15 - x853
val x885 = (0,x884)
x885
}
def x887elseb(): scala.Tuple2[Int, Int] = {
val x886 = (x882,0)
x886
}
if (x883) {
x887thenb()
} else { 
x887elseb()
}
}
val x888 = x887._1
val x889 = x887._2
val x1036 = x864 * x853
var x857 = 0
val x865 = new generated.scala.IntVectorImpl(900,false)
val x866 = new generated.scala.IndexVectorSeqImpl(0)
val x867 = new generated.scala.BinarizedGradientTemplate(15,null,null,x841,x865,x866,null,null,null)
val x877 = x845.numCols
val x861 = x856.dcApply(x857)
val x876 = x861 + 15
val x878 = x876 > x877
val x881 = {
def x881thenb(): Int = {
val x879 = x845.numCols
x879
}
def x881elseb(): Int = {
x876
}
if (x878) {
x881thenb()
} else { 
x881elseb()
}
}
val x891 = x845.numRows
val x892 = x890 > x891
val x895 = {
def x895thenb(): Int = {
val x893 = x845.numRows
x893
}
def x895elseb(): Int = {
x890
}
if (x892) {
x895thenb()
} else { 
x895elseb()
}
}
var x896: Int = x888
val x868 = x861 - 15
val x869 = x868 < 0
val x873 = {
def x873thenb(): scala.Tuple2[Int, Int] = {
val x870 = 15 - x861
val x871 = (0,x870)
x871
}
def x873elseb(): scala.Tuple2[Int, Int] = {
val x872 = (x868,0)
x872
}
if (x869) {
x873thenb()
} else { 
x873elseb()
}
}
val x874 = x873._1
val x875 = x873._2
val x933 = while ({val x897 = x896
val x898 = x897 < x895
x898}) {
val x900 = x896
val x901 = x845.getRow(x900)
var x902: Int = x874
val x930 = while ({val x903 = x902
val x904 = x903 < x881
x904}) {
val x906 = x896
val x910 = x902
val x907 = x889 + x906
val x908 = x907 - x888
val x909 = x908 * 30
val x911 = x875 + x910
val x912 = x911 - x874
val x913 = x909 + x912
var x914: Int = x913
val x915 = x867.binary_gradients
val x916 = x914
val x917 = x902
val x918 = x901(x917)
val x919 = x915(x916) = x918
val x920 = x902
val x921 = x901(x920)
val x922 = x921 > 0
val x927 = {
def x927thenb(): Unit = {
val x923 = x867.match_list
val x924 = x923.length
val x925 = x923.insert(x924, x916)
x925
}
if (x922) {
x927thenb()
}
}
val x928 = x902 += 1
()
}
val x931 = x896 += 1
()
}
val x934 = x867.match_list
val x935 = x934.length
val x936 = x935 < 0
val x939 = {
def x939thenb(): Unit = {
val x937 = println("dummy")
x937
}
if (x936) {
x939thenb()
}
}
val x1031 = x864 * x861
// a *thin* loop follows: x1077
var x941 = 0
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
var x1077: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x944 == 0) {x832}
else {
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
}
x941 = 1
while (x941 < x944) {  // begin fat loop x1077
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
val x942 = x1077
val x943 = x1048
val x1050 = x942.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1076 = { 
val x1074 = {
def x1074thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x943
}
def x1074elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1051 = x943.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x942
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1052 = x942.length
val x1053 = x943.length
val x1054 = x1052 + x1053
val x1055 = x942.isRow
val x1056 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1054,x1055)
var x1058 : Int = 0
val x1062 = while (x1058 < x1052) {
val x1059 = x942(x1058)
val x1060 = x1056(x1058) = x1059
x1060
x1058 = x1058 + 1
}
var x1064 : Int = 0
val x1069 = while (x1064 < x1053) {
val x1065 = x1064 + x1052
val x1066 = x943(x1064)
val x1067 = x1056(x1065) = x1066
x1067
x1064 = x1064 + 1
}
val x1070 = x1056// unsafe immutable
x1070
}
if (x1051) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
if (x1050) {
x1074thenb()
} else { 
x1074elseb()
}
}
x1074
}
x1077 = x1076
x941 += 1
} // end fat loop x1077
var x1106: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x860 == 0) {x832}
else {
val x865 = new generated.scala.IntVectorImpl(900,false)
val x866 = new generated.scala.IndexVectorSeqImpl(0)
val x867 = new generated.scala.BinarizedGradientTemplate(15,null,null,x841,x865,x866,null,null,null)
val x877 = x845.numCols
val x861 = x856.dcApply(x857)
val x876 = x861 + 15
val x878 = x876 > x877
val x881 = {
def x881thenb(): Int = {
val x879 = x845.numCols
x879
}
def x881elseb(): Int = {
x876
}
if (x878) {
x881thenb()
} else { 
x881elseb()
}
}
val x891 = x845.numRows
val x892 = x890 > x891
val x895 = {
def x895thenb(): Int = {
val x893 = x845.numRows
x893
}
def x895elseb(): Int = {
x890
}
if (x892) {
x895thenb()
} else { 
x895elseb()
}
}
var x896: Int = x888
val x868 = x861 - 15
val x869 = x868 < 0
val x873 = {
def x873thenb(): scala.Tuple2[Int, Int] = {
val x870 = 15 - x861
val x871 = (0,x870)
x871
}
def x873elseb(): scala.Tuple2[Int, Int] = {
val x872 = (x868,0)
x872
}
if (x869) {
x873thenb()
} else { 
x873elseb()
}
}
val x874 = x873._1
val x875 = x873._2
val x933 = while ({val x897 = x896
val x898 = x897 < x895
x898}) {
val x900 = x896
val x901 = x845.getRow(x900)
var x902: Int = x874
val x930 = while ({val x903 = x902
val x904 = x903 < x881
x904}) {
val x906 = x896
val x910 = x902
val x907 = x889 + x906
val x908 = x907 - x888
val x909 = x908 * 30
val x911 = x875 + x910
val x912 = x911 - x874
val x913 = x909 + x912
var x914: Int = x913
val x915 = x867.binary_gradients
val x916 = x914
val x917 = x902
val x918 = x901(x917)
val x919 = x915(x916) = x918
val x920 = x902
val x921 = x901(x920)
val x922 = x921 > 0
val x927 = {
def x927thenb(): Unit = {
val x923 = x867.match_list
val x924 = x923.length
val x925 = x923.insert(x924, x916)
x925
}
if (x922) {
x927thenb()
}
}
val x928 = x902 += 1
()
}
val x931 = x896 += 1
()
}
val x934 = x867.match_list
val x935 = x934.length
val x936 = x935 < 0
val x939 = {
def x939thenb(): Unit = {
val x937 = println("dummy")
x937
}
if (x936) {
x939thenb()
}
}
val x1031 = x864 * x861
// a *thin* loop follows: x1077
var x941 = 0
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
var x1077: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x944 == 0) {x832}
else {
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
}
x941 = 1
while (x941 < x944) {  // begin fat loop x1077
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
val x942 = x1077
val x943 = x1048
val x1050 = x942.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1076 = { 
val x1074 = {
def x1074thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x943
}
def x1074elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1051 = x943.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x942
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1052 = x942.length
val x1053 = x943.length
val x1054 = x1052 + x1053
val x1055 = x942.isRow
val x1056 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1054,x1055)
var x1058 : Int = 0
val x1062 = while (x1058 < x1052) {
val x1059 = x942(x1058)
val x1060 = x1056(x1058) = x1059
x1060
x1058 = x1058 + 1
}
var x1064 : Int = 0
val x1069 = while (x1064 < x1053) {
val x1065 = x1064 + x1052
val x1066 = x943(x1064)
val x1067 = x1056(x1065) = x1066
x1067
x1064 = x1064 + 1
}
val x1070 = x1056// unsafe immutable
x1070
}
if (x1051) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
if (x1050) {
x1074thenb()
} else { 
x1074elseb()
}
}
x1074
}
x1077 = x1076
x941 += 1
} // end fat loop x1077
x1077
}
}
x857 = 1
while (x857 < x860) {  // begin fat loop x1106
val x865 = new generated.scala.IntVectorImpl(900,false)
val x866 = new generated.scala.IndexVectorSeqImpl(0)
val x867 = new generated.scala.BinarizedGradientTemplate(15,null,null,x841,x865,x866,null,null,null)
val x877 = x845.numCols
val x861 = x856.dcApply(x857)
val x876 = x861 + 15
val x878 = x876 > x877
val x881 = {
def x881thenb(): Int = {
val x879 = x845.numCols
x879
}
def x881elseb(): Int = {
x876
}
if (x878) {
x881thenb()
} else { 
x881elseb()
}
}
val x891 = x845.numRows
val x892 = x890 > x891
val x895 = {
def x895thenb(): Int = {
val x893 = x845.numRows
x893
}
def x895elseb(): Int = {
x890
}
if (x892) {
x895thenb()
} else { 
x895elseb()
}
}
var x896: Int = x888
val x868 = x861 - 15
val x869 = x868 < 0
val x873 = {
def x873thenb(): scala.Tuple2[Int, Int] = {
val x870 = 15 - x861
val x871 = (0,x870)
x871
}
def x873elseb(): scala.Tuple2[Int, Int] = {
val x872 = (x868,0)
x872
}
if (x869) {
x873thenb()
} else { 
x873elseb()
}
}
val x874 = x873._1
val x875 = x873._2
val x933 = while ({val x897 = x896
val x898 = x897 < x895
x898}) {
val x900 = x896
val x901 = x845.getRow(x900)
var x902: Int = x874
val x930 = while ({val x903 = x902
val x904 = x903 < x881
x904}) {
val x906 = x896
val x910 = x902
val x907 = x889 + x906
val x908 = x907 - x888
val x909 = x908 * 30
val x911 = x875 + x910
val x912 = x911 - x874
val x913 = x909 + x912
var x914: Int = x913
val x915 = x867.binary_gradients
val x916 = x914
val x917 = x902
val x918 = x901(x917)
val x919 = x915(x916) = x918
val x920 = x902
val x921 = x901(x920)
val x922 = x921 > 0
val x927 = {
def x927thenb(): Unit = {
val x923 = x867.match_list
val x924 = x923.length
val x925 = x923.insert(x924, x916)
x925
}
if (x922) {
x927thenb()
}
}
val x928 = x902 += 1
()
}
val x931 = x896 += 1
()
}
val x934 = x867.match_list
val x935 = x934.length
val x936 = x935 < 0
val x939 = {
def x939thenb(): Unit = {
val x937 = println("dummy")
x937
}
if (x936) {
x939thenb()
}
}
val x1031 = x864 * x861
// a *thin* loop follows: x1077
var x941 = 0
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
var x1077: generated.scala.Vector[generated.scala.BiGGDetection] = {
if (x944 == 0) {x832}
else {
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
}
x941 = 1
while (x941 < x944) {  // begin fat loop x1077
val x948 = x867.radius
val x945 = x940.dcApply(x941)
val x946 = x835(x945)
val x947 = x946.radius
val x949 = x947 != x948
val x973 = x946.binary_gradients
val x1028 = {
def x1028thenb(): Float = {
-1.0f
}
def x1028elseb(): Float = {
val x950 = x946.match_list
val x951 = x950.length
val x952 = x951.asInstanceOf[Float]
val x953 = x952==0.0
val x1026 = {
def x1026thenb(): Float = {
-1.0f
}
def x1026elseb(): Float = {
val x954 = x867.match_list
val x955 = x954.length
val x956 = x955.asInstanceOf[Float]
val x957 = x956 / x952
val x958 = x957 < 0.82f
val x1024 = {
def x1024thenb(): Float = {
x957
}
def x1024elseb(): Float = {
var x959: Float = 0.0f
val x960 = x952 * 0.18f
val x961 = x960 + 0.5f
val x962 = x961.asInstanceOf[Int]
var x963: Int = x962
var x964: Int = 0
var x965: Boolean = true
val x1015 = while ({val x966 = x964
val x968 = x965
val x967 = x966 < x951
val x969 = x967 && x968
x969}) {
val x971 = x964
val x974 = x964
val x978 = x867.binary_gradients
val x979 = x964
val x980 = x950(x979)
val x981 = x978(x980)
val x975 = x950(x974)
val x976 = x973(x975)
val x977 = x976==0
val x982 = x981==0
val x983 = x977 && x982
val x1012 = {
def x1012thenb(): Unit = {
val x984 = x959
val x985 = x984 + 1.0f
x959 = x985
()
}
def x1012elseb(): Unit = {
val x988 = x964
val x991 = x867.binary_gradients
val x992 = x964
val x993 = x950(x992)
val x994 = x991(x993)
val x989 = x950(x988)
val x990 = x973(x989)
val x995 = x990 & x994
val x996 = x995 > 0
val x1010 = {
def x1010thenb(): Unit = {
val x997 = x959
val x998 = x997 + 1.0f
x959 = x998
()
}
def x1010elseb(): Unit = {
val x1001 = x963
val x1002 = x1001 - 1
x963 = x1002
val x1004 = x963
val x1005 = x1004 <= 0
val x1008 = {
def x1008thenb(): Unit = {
x965 = false
()
}
if (x1005) {
x1008thenb()
}
}
x1008
}
if (x996) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
if (x983) {
x1012thenb()
} else { 
x1012elseb()
}
}
val x1013 = x964 += 1
()
}
val x1016 = x965
val x1017 = !x1016
val x1022 = {
def x1022thenb(): Float = {
0.819999f
}
def x1022elseb(): Float = {
val x1018 = x959
val x1019 = x1018 / x952
val x1020 = x1019.asInstanceOf[Float]
x1020
}
if (x1017) {
x1022thenb()
} else { 
x1022elseb()
}
}
x1022
}
if (x958) {
x1024thenb()
} else { 
x1024elseb()
}
}
x1024
}
if (x953) {
x1026thenb()
} else { 
x1026elseb()
}
}
x1026
}
if (x949) {
x1028thenb()
} else { 
x1028elseb()
}
}
val x1029 = x1028 > 0.82f
val x1048 = {
def x1048thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1030 = x946.rect
val x1032 = x1030.width
val x1033 = x1032 / 2
val x1034 = x1031 - x1033
val x1035 = x1034.asInstanceOf[Int]
val x1037 = x1030.height
val x1038 = x1037 / 2
val x1039 = x1036 - x1038
val x1040 = x1039.asInstanceOf[Int]
val x1041 = new generated.scala.Rect(x1035,x1040,x1032,x1037)
val x1042 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1043 = new generated.scala.BiGGDetection(x834,x1028,x1041,null,x945,x861,x853,x946,x867)
val x1044 = x1042(0) = x1043
x1042
}
def x1048elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1046
}
if (x1029) {
x1048thenb()
} else { 
x1048elseb()
}
}
val x942 = x1077
val x943 = x1048
val x1050 = x942.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1076 = { 
val x1074 = {
def x1074thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x943
}
def x1074elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1051 = x943.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x942
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1052 = x942.length
val x1053 = x943.length
val x1054 = x1052 + x1053
val x1055 = x942.isRow
val x1056 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1054,x1055)
var x1058 : Int = 0
val x1062 = while (x1058 < x1052) {
val x1059 = x942(x1058)
val x1060 = x1056(x1058) = x1059
x1060
x1058 = x1058 + 1
}
var x1064 : Int = 0
val x1069 = while (x1064 < x1053) {
val x1065 = x1064 + x1052
val x1066 = x943(x1064)
val x1067 = x1056(x1065) = x1066
x1067
x1064 = x1064 + 1
}
val x1070 = x1056// unsafe immutable
x1070
}
if (x1051) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
if (x1050) {
x1074thenb()
} else { 
x1074elseb()
}
}
x1074
}
x1077 = x1076
x941 += 1
} // end fat loop x1077
val x858 = x1106
val x859 = x1077
val x1079 = x858.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1105 = { 
val x1103 = {
def x1103thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x859
}
def x1103elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1080 = x859.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1101 = {
def x1101thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x858
}
def x1101elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1081 = x858.length
val x1082 = x859.length
val x1083 = x1081 + x1082
val x1084 = x858.isRow
val x1085 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1083,x1084)
var x1087 : Int = 0
val x1091 = while (x1087 < x1081) {
val x1088 = x858(x1087)
val x1089 = x1085(x1087) = x1088
x1089
x1087 = x1087 + 1
}
var x1093 : Int = 0
val x1098 = while (x1093 < x1082) {
val x1094 = x1093 + x1081
val x1095 = x859(x1093)
val x1096 = x1085(x1094) = x1095
x1096
x1093 = x1093 + 1
}
val x1099 = x1085// unsafe immutable
x1099
}
if (x1080) {
x1101thenb()
} else { 
x1101elseb()
}
}
x1101
}
if (x1079) {
x1103thenb()
} else { 
x1103elseb()
}
}
x1103
}
x1106 = x1105
x857 += 1
} // end fat loop x1106
val x850 = x1135
val x851 = x1106
val x1108 = x850.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1134 = { 
val x1132 = {
def x1132thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x851
}
def x1132elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1109 = x851.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1130 = {
def x1130thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x850
}
def x1130elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1110 = x850.length
val x1111 = x851.length
val x1112 = x1110 + x1111
val x1113 = x850.isRow
val x1114 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1112,x1113)
var x1116 : Int = 0
val x1120 = while (x1116 < x1110) {
val x1117 = x850(x1116)
val x1118 = x1114(x1116) = x1117
x1118
x1116 = x1116 + 1
}
var x1122 : Int = 0
val x1127 = while (x1122 < x1111) {
val x1123 = x1122 + x1110
val x1124 = x851(x1122)
val x1125 = x1114(x1123) = x1124
x1125
x1122 = x1122 + 1
}
val x1128 = x1114// unsafe immutable
x1128
}
if (x1109) {
x1130thenb()
} else { 
x1130elseb()
}
}
x1130
}
if (x1108) {
x1132thenb()
} else { 
x1132elseb()
}
}
x1132
}
x1135 = x1134
x849 += 1
} // end fat loop x1135
val x1136 = x1135.length
val x1137 = "Detections: "+x1136
val x1138 = println(x1137)
val x829 = x1167
val x830 = x1135
val x1140 = x829.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1166 = { 
val x1164 = {
def x1164thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x830
}
def x1164elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1141 = x830.isInstanceOf[generated.scala.EmptyVector[generated.scala.BiGGDetection]]
val x1162 = {
def x1162thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x829
}
def x1162elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1142 = x829.length
val x1143 = x830.length
val x1144 = x1142 + x1143
val x1145 = x829.isRow
val x1146 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1144,x1145)
var x1148 : Int = 0
val x1152 = while (x1148 < x1142) {
val x1149 = x829(x1148)
val x1150 = x1146(x1148) = x1149
x1150
x1148 = x1148 + 1
}
var x1154 : Int = 0
val x1159 = while (x1154 < x1143) {
val x1155 = x1154 + x1142
val x1156 = x830(x1154)
val x1157 = x1146(x1155) = x1156
x1157
x1154 = x1154 + 1
}
val x1160 = x1146// unsafe immutable
x1160
}
if (x1141) {
x1162thenb()
} else { 
x1162elseb()
}
}
x1162
}
if (x1140) {
x1164thenb()
} else { 
x1164elseb()
}
}
x1164
}
x1167 = x1166
x828 += 1
} // end fat loop x1167
val x1168 = x1167.length
var x1169: Int = x1168
val x1170 = x1169
val x1171 = "Detections before NMS: "+x1170
val x1172 = println(x1171)
var x1173: Int = 0
val x1287 = while ({val x1174 = x1173
val x1175 = x1169
val x1176 = x1175 - 1
val x1177 = x1174 < x1176
x1177}) {
val x1179 = x1173
val x1180 = x1179 + 1
var x1181: Int = x1180
var x1182: Boolean = false
val x1284 = while ({val x1183 = x1181
val x1184 = x1169
val x1186 = x1182
val x1185 = x1183 < x1184
val x1187 = x1186==false
val x1188 = x1185 && x1187
x1188}) {
val x1190 = x1173
val x1193 = x1181
val x1191 = x1167(x1190)
val x1192 = x1191.roi
val x1196 = x1192.x
val x1194 = x1167(x1193)
val x1195 = x1194.roi
val x1197 = x1195.x
val x1198 = x1195.width
val x1199 = x1197 + x1198
val x1200 = x1196 < x1199
val x1201 = x1192.width
val x1202 = x1196 + x1201
val x1203 = x1202 > x1197
val x1204 = x1200 && x1203
val x1205 = x1192.y
val x1206 = x1192.height
val x1207 = x1205 + x1206
val x1208 = x1195.y
val x1209 = x1207 > x1208
val x1210 = x1204 && x1209
val x1211 = x1195.height
val x1212 = x1208 + x1211
val x1213 = x1205 < x1212
val x1214 = x1210 && x1213
val x1235 = {
def x1235thenb(): Float = {
val x1221 = x1205 > x1208
val x1222 = {
def x1222thenb(): Int = {
x1205
}
def x1222elseb(): Int = {
x1208
}
if (x1221) {
x1222thenb()
} else { 
x1222elseb()
}
}
val x1226 = x1207 < x1212
val x1227 = {
def x1227thenb(): Int = {
x1207
}
def x1227elseb(): Int = {
x1212
}
if (x1226) {
x1227thenb()
} else { 
x1227elseb()
}
}
val x1228 = x1227 - x1222
val x1229 = x1228
val x1230 = 2.0f * x1229
val x1219 = x1196 > x1197
val x1220 = {
def x1220thenb(): Int = {
x1196
}
def x1220elseb(): Int = {
x1197
}
if (x1219) {
x1220thenb()
} else { 
x1220elseb()
}
}
val x1223 = x1202 < x1199
val x1224 = {
def x1224thenb(): Int = {
x1202
}
def x1224elseb(): Int = {
x1199
}
if (x1223) {
x1224thenb()
} else { 
x1224elseb()
}
}
val x1225 = x1224 - x1220
val x1231 = x1225
val x1232 = x1230 * x1231
val x1215 = x1211 * x1198
val x1216 = x1201 * x1206
val x1217 = x1215 + x1216
val x1218 = x1217
val x1233 = x1218 + 1.0E-6f
val x1234 = x1232 / x1233
x1234
}
def x1235elseb(): Float = {
0.0f
}
if (x1214) {
x1235thenb()
} else { 
x1235elseb()
}
}
val x1236 = x1235 > 0.6f
val x1281 = {
def x1281thenb(): Unit = {
val x1237 = x1173
val x1240 = x1181
val x1238 = x1167(x1237)
val x1239 = x1238.score
val x1241 = x1167(x1240)
val x1242 = x1241.score
val x1243 = x1239 >= x1242
val x1279 = {
def x1279thenb(): Unit = {
val x1244 = x1169
val x1247 = x1169
val x1249 = x1181
val x1248 = x1247 - 1
val x1250 = x1167(x1249)
val x1251 = x1167(x1248) = x1250
val x1252 = x1181
val x1245 = x1244 - 1
val x1246 = x1167(x1245)
val x1253 = x1167(x1252) = x1246
val x1254 = x1169
val x1255 = x1254 - 1
x1169 = x1255
val x1257 = x1181
val x1258 = x1257 - 1
x1181 = x1258
()
}
def x1279elseb(): Unit = {
val x1261 = x1169
val x1264 = x1169
val x1266 = x1173
val x1265 = x1264 - 1
val x1267 = x1167(x1266)
val x1268 = x1167(x1265) = x1267
val x1269 = x1173
val x1262 = x1261 - 1
val x1263 = x1167(x1262)
val x1270 = x1167(x1269) = x1263
val x1271 = x1169
val x1272 = x1271 - 1
x1169 = x1272
val x1274 = x1173
val x1275 = x1274 - 1
x1173 = x1275
x1182 = true
()
}
if (x1243) {
x1279thenb()
} else { 
x1279elseb()
}
}
x1279
}
if (x1236) {
x1281thenb()
}
}
val x1282 = x1181 += 1
()
}
val x1285 = x1173 += 1
()
}
val x1288 = x1169
val x1289 = x1288 - 0
val x1302 = "Total detections: "+x1289
val x1303 = println(x1302)
val x1304 = x228 += 1
()
}
val x1307 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
