/*****************************************
  Emitting Generated Code                  
*******************************************/
class gradientRunner extends ((Array[java.lang.String])=>(Unit)) {
def apply(x0:Array[java.lang.String]): Unit = {
val x1 = x0(0)
val x54 = { 
val x2 = new java.io.FileReader(x1)
val x3 = new java.io.BufferedReader(x2)
val x4 = x3.readLine()
var x5: java.lang.String = x4
val x6 = x5
val x7 = x6.trim()
x5 = x7
val x9 = x5
val x10 = x9.split("\\s+")
var x11: Array[java.lang.String] = x10
val x12 = x11
val x13 = x12.length
val x14 = new generated.scala.IntMatrixImpl(0,x13)
val x50 = while ({val x15 = x5
val x16 = x15 != null
x16}) {
val x18 = x11
val x19 = x18.length
val x20 = new generated.scala.IntVectorImpl(x19,true)
var x21: Int = 0
val x35 = while ({val x22 = x21
val x23 = x11
val x24 = x23.length
val x25 = x22 < x24
x25}) {
val x27 = x21
val x28 = x11
val x29 = x21
val x30 = x28(x29)
val x31 = java.lang.Integer.parseInt(x30)
val x32 = x20(x27) = x31
val x33 = x21 += 1
()
}
val x36 = x14.numRows
val x37 = x14.insertRow(x36,x20)
val x38 = x3.readLine()
x5 = x38
val x40 = x5
val x41 = x40 != null
val x48 = {
def x48thenb(): Unit = {
val x42 = x40.trim()
x5 = x42
val x44 = x5
val x45 = x44.split("\\s+")
x11 = x45
()
}
if (x41) {
x48thenb()
}
}
x48
}
val x51 = x3.close()
val x52 = new generated.scala.GrayscaleImageImpl(x14)
x52
}
val x55 = x0(1)
val x224 = { 
val x56 = new generated.scala.VectorImpl[java.lang.String](0,true)
val x57 = new java.io.File(x55)
val x58 = x57.getCanonicalFile()
val x59 = x58.listFiles()
val x65=x59.foreach{
x60 => 
val x62 = x56.length
val x61 = x60.getPath()
val x63 = x56.insert(x62, x61)
x63
}
def x222_block = {
val x218 = x56.length
val x219 = x56.isRow
val x220 = new generated.scala.VectorImpl[scala.Tuple2[java.lang.String, generated.scala.Vector[generated.scala.BinarizedGradientTemplate]]](x218,x219)
var mapIdx = 0
while (mapIdx < x56.size) { // begin map loop x222
val x66 = x56.dcApply(mapIdx)
x220.dcUpdate(mapIdx,  {
val x67 = "Loading model: "+x66
val x68 = println(x67)
val x69 = new generated.scala.VectorImpl[generated.scala.BinarizedGradientTemplate](0,true)
val x70 = new java.io.FileReader(x66)
val x71 = new java.io.BufferedReader(x70)
val x72 = x71.readLine()
val x73 = x72 != "bigg_object:"
val x76 = {
def x76thenb(): Nothing = {
val x74 = error("Illegal data format")
x74
}
if (x73) {
x76thenb()
}
}
val x77 = x71.readLine()
val x78 = x71.readLine()
val x79 = x78.trim()
val x80 = x79.split(" ")
val x81 = x80(0)
val x82 = x81 != "obj_name/obj_num/num_objs:"
val x85 = {
def x85thenb(): Nothing = {
val x83 = error("Illegal data format")
x83
}
if (x82) {
x85thenb()
}
}
var x90: Int = 0
val x88 = x80(3)
val x89 = java.lang.Integer.parseInt(x88)
val x215 = while ({val x91 = x90
val x92 = x91 < x89
x92}) {
val x94 = x71.readLine()
val x95 = x94.trim()
val x96 = x95 != "====OneBiGG====:"
val x99 = {
def x99thenb(): Nothing = {
val x97 = error("Illegal data format")
x97
}
if (x96) {
x99thenb()
}
}
val x100 = x71.readLine()
val x101 = x100.trim()
val x102 = x101.split(" ")
var x103: Array[java.lang.String] = x102
val x104 = x103
val x105 = x104(0)
val x106 = x105 != "view/radius/reduction:"
val x109 = {
def x109thenb(): Nothing = {
val x107 = error("Illegal data format")
x107
}
if (x106) {
x109thenb()
}
}
val x116 = x71.readLine()
val x117 = x116.trim()
val x118 = x117.split(" ")
x103 = x118
val x120 = x103
val x121 = x120(0)
val x122 = x121 != "Gradients:"
val x125 = {
def x125thenb(): Nothing = {
val x123 = error("Illegal data format")
x123
}
if (x122) {
x125thenb()
}
}
val x126 = x120(1)
val x127 = java.lang.Integer.parseInt(x126)
val x128 = new generated.scala.IntVectorImpl(x127,true)
val x129 = x71.readLine()
var x132: Int = 0
val x130 = x129.trim()
val x131 = x130.split(" ")
val x143 = while ({val x133 = x132
val x134 = x133 < x127
x134}) {
val x136 = x132
val x137 = x132
val x138 = x131(x137)
val x139 = java.lang.Integer.parseInt(x138)
val x140 = x128(x136) = x139
val x141 = x132 += 1
()
}
val x144 = x71.readLine()
val x145 = x144.trim()
val x146 = x145.split(" ")
x103 = x146
val x148 = x103
val x149 = x148(0)
val x150 = x149 != "Match_list:"
val x153 = {
def x153thenb(): Nothing = {
val x151 = error("Illegal data format")
x151
}
if (x150) {
x153thenb()
}
}
val x156 = new generated.scala.IndexVectorSeqImpl(0)
val x157 = x71.readLine()
x132 = 0
val x154 = x148(1)
val x155 = java.lang.Integer.parseInt(x154)
val x158 = x157.trim()
val x159 = x158.split(" ")
val x171 = while ({val x161 = x132
val x162 = x161 < x155
x162}) {
val x164 = x132
val x167 = x156.length
val x165 = x159(x164)
val x166 = java.lang.Integer.parseInt(x165)
val x168 = x156.insert(x167, x166)
val x169 = x132 += 1
()
}
val x172 = x71.readLine()
val x173 = x172.trim()
val x174 = x173.split(" ")
x103 = x174
val x176 = x103
val x177 = x176(0)
val x178 = x177 != "Occlusions:"
val x181 = {
def x181thenb(): Nothing = {
val x179 = error("Illegal data format")
x179
}
if (x178) {
x181thenb()
}
}
val x184 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](0,true)
val x185 = x71.readLine()
val x182 = x176(1)
val x183 = java.lang.Integer.parseInt(x182)
val x188 = x183 != 0
val x191 = {
def x191thenb(): Nothing = {
val x189 = error("Occlusions not supported.")
x189
}
if (x188) {
x191thenb()
}
}
val x192 = x71.readLine()
val x193 = x192.trim()
val x194 = x193 != "BoundingBox:"
val x197 = {
def x197thenb(): Nothing = {
val x195 = error("Illegal data format")
x195
}
if (x194) {
x197thenb()
}
}
val x198 = x71.readLine()
val x199 = x198.trim()
val x200 = x199.split(" ")
val x201 = x200(0)
val x202 = java.lang.Integer.parseInt(x201)
val x203 = x200(1)
val x204 = java.lang.Integer.parseInt(x203)
val x205 = x200(2)
val x206 = java.lang.Integer.parseInt(x205)
val x207 = x200(3)
val x208 = java.lang.Integer.parseInt(x207)
val x209 = new generated.scala.Rect(x202,x204,x206,x208)
val x112 = x104(2)
val x113 = java.lang.Integer.parseInt(x112)
val x210 = new generated.scala.BinarizedGradientTemplate(x113,x209,null,0,x128,x156,x184,null,null)
val x211 = x69.length
val x212 = x69.insert(x211, x210)
val x213 = x90 += 1
()
}
val x86 = x80(1)
val x216 = (x86,x69)
x216
})
mapIdx += 1
} // end map loop x222
x220
}
val x222 = x222_block
x222
}
val x225 = Seq()
val x226 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
var x227: Int = 0
val x266 = x54.numRows
val x267 = new generated.scala.IndexVectorRangeImpl(0,x266)
val x268 = x54.numCols
val x269 = new generated.scala.IndexVectorRangeImpl(0,x268)
val x270 = new generated.scala.IndexVector2Impl(x267,x269)
val x271 = x270.rowInd
val x272 = x271.length
val x276 = x270.colInd
val x337 = x276.length
val x338 = x276.isRow
val x525 = Math.Pi
val x578 = 2 / 2
val x1333 = while ({val x228 = x227
val x229 = x228 < 3
x229}) {
val x231 = new generated.scala.IntMatrixImpl(3,3)
val x232 = x231(0, 0) = -3
val x233 = x231(0, 1) = -10
val x234 = x231(0, 2) = -3
val x235 = x231(2, 0) = 3
val x236 = x231(2, 1) = 10
val x237 = x231(2, 2) = 3
val x259 = { 
val x238 = x231.numCols
val x239 = x231.numRows
val x240 = new generated.scala.IntMatrixImpl(x238,x239)
val x241 = x240.numRows
var x243 : Int = 0
val x257 = while (x243 < x241) {
val x244 = x240.numCols
var x246 : Int = 0
val x255 = while (x246 < x244) {
val x252 = { 
val x247 = x231.numCols
val x248 = x246 * x247
val x249 = x248 + x243
val x250 = x231.dcApply(x249)
x250
}
val x253 = x240(x243, x246) = x252
x253
x246 = x246 + 1
}
x255
x243 = x243 + 1
}
x240
}
val x260 = x259.numRows
val x262 = x260 - 1
val x263 = x262 / 2
val x279 = x266 - x263
val x261 = x259.numCols
val x264 = x261 - 1
val x265 = x264 / 2
val x284 = x268 - x265
def x342_block = {
val x273 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](x272,true)
var mapIdx = 0
while (mapIdx < x271.size) { // begin map loop x342
val x275 = x271.dcApply(mapIdx)
x273.dcUpdate(mapIdx,  {
val x278 = x275 >= x263
val x280 = x275 < x279
val x281 = x278 && x280
def x341_block = {
val x339 = new generated.scala.IntVectorImpl(x337,x338)
var mapIdx = 0
while (mapIdx < x276.size) { // begin map loop x341
val x277 = x276.dcApply(mapIdx)
x339.dcUpdate(mapIdx,  {
val x282 = x277 >= x265
val x283 = x281 && x282
val x285 = x277 < x284
val x286 = x283 && x285
val x336 = {
def x336thenb(): Int = {
val x287 = x275 - x263
val x288 = x275 + x263
val x289 = x288 + 1
val x293 = x289 - x287
val x290 = x277 - x265
val x291 = x277 + x265
val x292 = x291 + 1
val x294 = x292 - x290
val x322 = { 
val x295 = new generated.scala.IntMatrixImpl(x293,x294)
var x296: Int = x287
val x320 = while ({val x297 = x296
val x298 = x297 < x289
x298}) {
var x300: Int = x290
val x317 = while ({val x301 = x300
val x302 = x301 < x292
x302}) {
val x304 = x296
val x306 = x300
val x308 = x296
val x309 = x300
val x305 = x304 - x287
val x307 = x306 - x290
val x310 = x308 * x268
val x311 = x310 + x309
val x312 = x54.dcApply(x311)
val x313 = { 
x312
}
val x314 = x295(x305, x307) = x313
val x315 = x300 += 1
()
}
val x318 = x296 += 1
()
}
x295
}
val x323 = x322.numRows
val x324 = x322.numCols
def x330_block = {
val x325 = new generated.scala.IntMatrixImpl(x323,x324)
var zipIdx = 0
while (zipIdx < x322.size) { // begin zip loop x330
val x327 = x322.dcApply(zipIdx)
val x328 = x259.dcApply(zipIdx)
x325.dcUpdate(zipIdx,  {
val x329 = x327 * x328
x329
})
zipIdx += 1
} // end zip loop x330
x325
}
val x330 = x330_block
def x334_block = {
var x331 = x330.dcApply(0)
var reduceIdx = 1
while (reduceIdx < x330.size) { // begin reduce loop x334
val x332 = x330.dcApply(reduceIdx)
x331 = {
val x333 = x331 + x332
x333
}
reduceIdx += 1
} // end reduce loop x334
x331
}
val x334 = x334_block
x334
}
def x336elseb(): Int = {
val x335 = 0.asInstanceOf[Int]
x335
}
if (x286) {
x336thenb()
} else { 
x336elseb()
}
}
x336
})
mapIdx += 1
} // end map loop x341
x339
}
val x341 = x341_block
x341
})
mapIdx += 1
} // end map loop x342
x273
}
val x342 = x342_block
val x343 = x342.length
val x344 = x343==0
val x378 = { 
val x376 = {
def x376thenb(): generated.scala.Matrix[Int] = {
val x345 = new generated.scala.IntMatrixImpl(0,0)
x345
}
def x376elseb(): generated.scala.Matrix[Int] = {
val x347 = x342(0)
val x348 = x347.isRow
val x374 = {
def x374thenb(): generated.scala.Matrix[Int] = {
val x349 = x347.length
val x350 = new generated.scala.IntMatrixImpl(x343,x349)
var x352 : Int = 0
val x361 = while (x352 < x343) {
val x355 = x342(x352)
var x354 : Int = 0
val x359 = while (x354 < x349) {
val x356 = x355(x354)
val x357 = x350(x352, x354) = x356
x357
x354 = x354 + 1
}
x359
x352 = x352 + 1
}
x350
}
def x374elseb(): generated.scala.Matrix[Int] = {
val x349 = x347.length
val x363 = new generated.scala.IntMatrixImpl(x349,x343)
var x364 : Int = 0
val x372 = while (x364 < x343) {
val x366 = x342(x364)
var x365 : Int = 0
val x370 = while (x365 < x349) {
val x367 = x366(x365)
val x368 = x363(x365, x364) = x367
x368
x365 = x365 + 1
}
x370
x364 = x364 + 1
}
x363
}
if (x348) {
x374thenb()
} else { 
x374elseb()
}
}
x374
}
if (x344) {
x376thenb()
} else { 
x376elseb()
}
}
x376
}
val x379 = new generated.scala.IntImageImpl(x378)
val x380 = x231.numRows
val x381 = x231.numCols
val x382 = x380 - 1
val x383 = x382 / 2
val x391 = x266 - x383
val x384 = x381 - 1
val x385 = x384 / 2
val x396 = x268 - x385
def x453_block = {
val x386 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](x272,true)
var mapIdx = 0
while (mapIdx < x271.size) { // begin map loop x453
val x388 = x271.dcApply(mapIdx)
x386.dcUpdate(mapIdx,  {
val x390 = x388 >= x383
val x392 = x388 < x391
val x393 = x390 && x392
def x452_block = {
val x450 = new generated.scala.IntVectorImpl(x337,x338)
var mapIdx = 0
while (mapIdx < x276.size) { // begin map loop x452
val x389 = x276.dcApply(mapIdx)
x450.dcUpdate(mapIdx,  {
val x394 = x389 >= x385
val x395 = x393 && x394
val x397 = x389 < x396
val x398 = x395 && x397
val x448 = {
def x448thenb(): Int = {
val x399 = x388 - x383
val x400 = x388 + x383
val x401 = x400 + 1
val x405 = x401 - x399
val x402 = x389 - x385
val x403 = x389 + x385
val x404 = x403 + 1
val x406 = x404 - x402
val x434 = { 
val x407 = new generated.scala.IntMatrixImpl(x405,x406)
var x408: Int = x399
val x432 = while ({val x409 = x408
val x410 = x409 < x401
x410}) {
var x412: Int = x402
val x429 = while ({val x413 = x412
val x414 = x413 < x404
x414}) {
val x416 = x408
val x418 = x412
val x420 = x408
val x421 = x412
val x417 = x416 - x399
val x419 = x418 - x402
val x422 = x420 * x268
val x423 = x422 + x421
val x424 = x54.dcApply(x423)
val x425 = { 
x424
}
val x426 = x407(x417, x419) = x425
val x427 = x412 += 1
()
}
val x430 = x408 += 1
()
}
x407
}
val x435 = x434.numRows
val x436 = x434.numCols
def x442_block = {
val x437 = new generated.scala.IntMatrixImpl(x435,x436)
var zipIdx = 0
while (zipIdx < x434.size) { // begin zip loop x442
val x439 = x434.dcApply(zipIdx)
val x440 = x231.dcApply(zipIdx)
x437.dcUpdate(zipIdx,  {
val x441 = x439 * x440
x441
})
zipIdx += 1
} // end zip loop x442
x437
}
val x442 = x442_block
def x446_block = {
var x443 = x442.dcApply(0)
var reduceIdx = 1
while (reduceIdx < x442.size) { // begin reduce loop x446
val x444 = x442.dcApply(reduceIdx)
x443 = {
val x445 = x443 + x444
x445
}
reduceIdx += 1
} // end reduce loop x446
x443
}
val x446 = x446_block
x446
}
def x448elseb(): Int = {
val x335 = 0.asInstanceOf[Int]
x335
}
if (x398) {
x448thenb()
} else { 
x448elseb()
}
}
x448
})
mapIdx += 1
} // end map loop x452
x450
}
val x452 = x452_block
x452
})
mapIdx += 1
} // end map loop x453
x386
}
val x453 = x453_block
val x454 = x453.length
val x455 = x454==0
val x489 = { 
val x487 = {
def x487thenb(): generated.scala.Matrix[Int] = {
val x456 = new generated.scala.IntMatrixImpl(0,0)
x456
}
def x487elseb(): generated.scala.Matrix[Int] = {
val x458 = x453(0)
val x459 = x458.isRow
val x485 = {
def x485thenb(): generated.scala.Matrix[Int] = {
val x460 = x458.length
val x461 = new generated.scala.IntMatrixImpl(x454,x460)
var x463 : Int = 0
val x472 = while (x463 < x454) {
val x466 = x453(x463)
var x465 : Int = 0
val x470 = while (x465 < x460) {
val x467 = x466(x465)
val x468 = x461(x463, x465) = x467
x468
x465 = x465 + 1
}
x470
x463 = x463 + 1
}
x461
}
def x485elseb(): generated.scala.Matrix[Int] = {
val x460 = x458.length
val x474 = new generated.scala.IntMatrixImpl(x460,x454)
var x475 : Int = 0
val x483 = while (x475 < x454) {
val x477 = x453(x475)
var x476 : Int = 0
val x481 = while (x476 < x460) {
val x478 = x477(x476)
val x479 = x474(x476, x475) = x478
x479
x476 = x476 + 1
}
x481
x475 = x475 + 1
}
x474
}
if (x459) {
x485thenb()
} else { 
x485elseb()
}
}
x485
}
if (x455) {
x487thenb()
} else { 
x487elseb()
}
}
x487
}
val x490 = new generated.scala.IntImageImpl(x489)
val x493 = x379.numRows
val x494 = x379.numCols
def x497_block = {
val x495 = new generated.scala.FloatMatrixImpl(x493,x494)
var mapIdx = 0
while (mapIdx < x379.size) { // begin map loop x497
val x491 = x379.dcApply(mapIdx)
x495.dcUpdate(mapIdx,  {
val x492 = x491
x492
})
mapIdx += 1
} // end map loop x497
x495
}
val x497 = x497_block
val x500 = x490.numRows
val x501 = x490.numCols
def x504_block = {
val x502 = new generated.scala.FloatMatrixImpl(x500,x501)
var mapIdx = 0
while (mapIdx < x490.size) { // begin map loop x504
val x498 = x490.dcApply(mapIdx)
x502.dcUpdate(mapIdx,  {
val x499 = x498
x499
})
mapIdx += 1
} // end map loop x504
x502
}
val x504 = x504_block
val x505 = x497.numRows
val x506 = x497.numCols
def x528_block = {
val x517 = new generated.scala.FloatMatrixImpl(x505,x506)
var zipIdx = 0
while (zipIdx < x497.size) { // begin zip loop x528
val x519 = x497.dcApply(zipIdx)
val x520 = x504.dcApply(zipIdx)
x517.dcUpdate(zipIdx,  {
val x521 = x520
val x522 = x519
val x523 = Math.atan2(x521, x522)
val x524 = x523 * 180.0
val x526 = x524 / x525
val x527 = x526.asInstanceOf[Float]
x527
})
zipIdx += 1
} // end zip loop x528
x517
}
val x528 = x528_block
def x533_block = {
var mapIdx = 0
while (mapIdx < x528.size) { // begin map loop x533
val x529 = x528.dcApply(mapIdx)
x528.dcUpdate(mapIdx,  {
val x530 = x529 < 0.0f
val x532 = {
def x532thenb(): Float = {
val x531 = x529 + 360.0f
x531
}
def x532elseb(): Float = {
x529
}
if (x530) {
x532thenb()
} else { 
x532elseb()
}
}
x532
})
mapIdx += 1
} // end map loop x533
x528
}
val x533 = x533_block
def x534_block = {
val x507 = new generated.scala.FloatMatrixImpl(x505,x506)
var zipIdx = 0
while (zipIdx < x497.size) { // begin zip loop x534
val x509 = x497.dcApply(zipIdx)
val x510 = x504.dcApply(zipIdx)
x507.dcUpdate(zipIdx,  {
val x511 = x509 * x509
val x512 = x510 * x510
val x513 = x511 + x512
val x514 = x513
val x515 = Math.sqrt(x514)
val x516 = x515.asInstanceOf[Float]
x516
})
zipIdx += 1
} // end zip loop x534
x507
}
val x534 = x534_block
val x556 = x534.numRows
val x557 = x534.numCols
def x560_block = {
val x558 = new generated.scala.IntMatrixImpl(x556,x557)
var zipIdx = 0
while (zipIdx < x534.size) { // begin zip loop x560
val x536 = x534.dcApply(zipIdx)
val x537 = x533.dcApply(zipIdx)
x558.dcUpdate(zipIdx,  {
val x538 = x536 >= 200.0f
val x554 = {
def x554thenb(): Int = {
var x539: Float = x537
val x540 = x539
val x541 = x540 >= 180.0f
val x545 = {
def x545thenb(): Unit = {
val x542 = x540 - 180.0f
x539 = x542
()
}
if (x541) {
x545thenb()
}
}
val x546 = x539
val x547 = x546.asInstanceOf[Double]
val x548 = x547 / 22.5
val x549 = x548.asInstanceOf[Int]
val x550 = x549
val x551 = Math.pow(2.0,x550)
val x552 = x551.asInstanceOf[Int]
x552
}
def x554elseb(): Int = {
0
}
if (x538) {
x554thenb()
} else { 
x554elseb()
}
}
x554
})
zipIdx += 1
} // end zip loop x560
x558
}
val x560 = x560_block
val x561 = new generated.scala.GrayscaleImageImpl(x560)
val x562 = x561.getRow(0)
def x564_block = {
var mapIdx = 0
while (mapIdx < x562.size) { // begin map loop x564
val x563 = x562.dcApply(mapIdx)
x562.dcUpdate(mapIdx,  {
0
})
mapIdx += 1
} // end map loop x564
x562
}
val x564 = x564_block
val x565 = x561.numRows
val x566 = x565 - 1
val x567 = x561.getRow(x566)
def x569_block = {
var mapIdx = 0
while (mapIdx < x567.size) { // begin map loop x569
val x568 = x567.dcApply(mapIdx)
x567.dcUpdate(mapIdx,  {
0
})
mapIdx += 1
} // end map loop x569
x567
}
val x569 = x569_block
val x570 = x561.getCol(0)
def x572_block = {
var mapIdx = 0
while (mapIdx < x570.size) { // begin map loop x572
val x571 = x570.dcApply(mapIdx)
x570.dcUpdate(mapIdx,  {
0
})
mapIdx += 1
} // end map loop x572
x570
}
val x572 = x572_block
val x573 = x561.numCols
val x574 = x573 - 1
val x575 = x561.getCol(x574)
def x577_block = {
var mapIdx = 0
while (mapIdx < x575.size) { // begin map loop x577
val x576 = x575.dcApply(mapIdx)
x575.dcUpdate(mapIdx,  {
0
})
mapIdx += 1
} // end map loop x577
x575
}
val x577 = x577_block
val x579 = new generated.scala.IndexVectorRangeImpl(0,x565)
val x580 = new generated.scala.IndexVectorRangeImpl(0,x573)
val x581 = new generated.scala.IndexVector2Impl(x579,x580)
val x582 = x581.rowInd
val x583 = x582.length
val x587 = x581.colInd
val x590 = x565 - x578
val x595 = x573 - x578
val x696 = x587.length
val x697 = x587.isRow
def x701_block = {
val x584 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](x583,true)
var mapIdx = 0
while (mapIdx < x582.size) { // begin map loop x701
val x586 = x582.dcApply(mapIdx)
x584.dcUpdate(mapIdx,  {
val x589 = x586 >= x578
val x591 = x586 < x590
val x592 = x589 && x591
def x700_block = {
val x698 = new generated.scala.IntVectorImpl(x696,x697)
var mapIdx = 0
while (mapIdx < x587.size) { // begin map loop x700
val x588 = x587.dcApply(mapIdx)
x698.dcUpdate(mapIdx,  {
val x593 = x588 >= x578
val x594 = x592 && x593
val x596 = x588 < x595
val x597 = x594 && x596
val x694 = {
def x694thenb(): Int = {
val x634 = new generated.scala.IntVectorImpl(256,true)
var x635: Int = 0
val x598 = x586 - x578
val x599 = x586 + x578
val x600 = x599 + 1
val x604 = x600 - x598
val x601 = x588 - x578
val x602 = x588 + x578
val x603 = x602 + 1
val x605 = x603 - x601
val x633 = { 
val x606 = new generated.scala.IntMatrixImpl(x604,x605)
var x607: Int = x598
val x631 = while ({val x608 = x607
val x609 = x608 < x600
x609}) {
var x611: Int = x601
val x628 = while ({val x612 = x611
val x613 = x612 < x603
x613}) {
val x615 = x607
val x617 = x611
val x619 = x607
val x620 = x611
val x616 = x615 - x598
val x618 = x617 - x601
val x621 = x619 * x573
val x622 = x621 + x620
val x623 = x561.dcApply(x622)
val x624 = { 
x623
}
val x625 = x606(x616, x618) = x624
val x626 = x611 += 1
()
}
val x629 = x607 += 1
()
}
x606
}
val x637 = x633.numRows
val x642 = x633.numCols
val x665 = while ({val x636 = x635
val x638 = x636 < x637
x638}) {
var x640: Int = 0
val x662 = while ({val x641 = x640
val x643 = x641 < x642
x643}) {
val x645 = x635
val x646 = x640
val x651 = x635
val x652 = x640
val x653 = x651 * x642
val x654 = x653 + x652
val x655 = x633.dcApply(x654)
val x656 = { 
x655
}
val x657 = x634(x656)
val x647 = x645 * x642
val x648 = x647 + x646
val x649 = x633.dcApply(x648)
val x650 = { 
x649
}
val x658 = x657 + 1
val x659 = x634(x650) = x658
val x660 = x640 += 1
()
}
val x663 = x635 += 1
()
}
var x666: Int = 2
val x667 = x634(1)
var x668: Int = x667
var x669: Int = 1
val x687 = while ({val x670 = x666
val x671 = x634.length
val x672 = x670 < x671
x672}) {
val x674 = x666
val x675 = x634(x674)
val x676 = x668
val x677 = x675 > x676
val x684 = {
def x684thenb(): Unit = {
val x678 = x666
val x679 = x634(x678)
x668 = x679
val x681 = x666
x669 = x681
()
}
if (x677) {
x684thenb()
}
}
val x685 = x666 += 1
()
}
val x688 = x668
val x689 = x688 > 1
val x692 = {
def x692thenb(): Int = {
val x690 = x669
x690
}
def x692elseb(): Int = {
0
}
if (x689) {
x692thenb()
} else { 
x692elseb()
}
}
x692
}
def x694elseb(): Int = {
val x335 = 0.asInstanceOf[Int]
x335
}
if (x597) {
x694thenb()
} else { 
x694elseb()
}
}
x694
})
mapIdx += 1
} // end map loop x700
x698
}
val x700 = x700_block
x700
})
mapIdx += 1
} // end map loop x701
x584
}
val x701 = x701_block
val x702 = x701.length
val x703 = x702==0
val x737 = { 
val x735 = {
def x735thenb(): generated.scala.Matrix[Int] = {
val x704 = new generated.scala.IntMatrixImpl(0,0)
x704
}
def x735elseb(): generated.scala.Matrix[Int] = {
val x706 = x701(0)
val x707 = x706.isRow
val x733 = {
def x733thenb(): generated.scala.Matrix[Int] = {
val x708 = x706.length
val x709 = new generated.scala.IntMatrixImpl(x702,x708)
var x711 : Int = 0
val x720 = while (x711 < x702) {
val x714 = x701(x711)
var x713 : Int = 0
val x718 = while (x713 < x708) {
val x715 = x714(x713)
val x716 = x709(x711, x713) = x715
x716
x713 = x713 + 1
}
x718
x711 = x711 + 1
}
x709
}
def x733elseb(): generated.scala.Matrix[Int] = {
val x708 = x706.length
val x722 = new generated.scala.IntMatrixImpl(x708,x702)
var x723 : Int = 0
val x731 = while (x723 < x702) {
val x725 = x701(x723)
var x724 : Int = 0
val x729 = while (x724 < x708) {
val x726 = x725(x724)
val x727 = x722(x724, x723) = x726
x727
x724 = x724 + 1
}
x729
x723 = x723 + 1
}
x722
}
if (x707) {
x733thenb()
} else { 
x733elseb()
}
}
x733
}
if (x703) {
x735thenb()
} else { 
x735elseb()
}
}
x735
}
val x738 = new generated.scala.IntImageImpl(x737)
val x739 = new generated.scala.GrayscaleImageImpl(x738)
var x740: generated.scala.GrayscaleImage = x739
var x741: Int = 0
val x742 = new generated.scala.VectorImpl[generated.scala.GrayscaleImage](0,true)
val x743 = new generated.scala.BinarizedGradientPyramid(x742,3,1,3)
val x745 = x743.start_level
val x746 = x743.levels
val x747 = x745 + x746
val x752 = x743.pyramid
val x758 = x747 - 1
val x877 = while ({val x744 = x741
val x748 = x744 < x747
x748}) {
val x750 = x741
val x751 = x750 >= x745
val x757 = {
def x757thenb(): Unit = {
val x753 = x740
val x754 = x752.length
val x755 = x752.insert(x754, x753)
x755
}
if (x751) {
x757thenb()
}
}
val x759 = x741
val x760 = x759 != x758
val x874 = {
def x874thenb(): Unit = {
val x761 = x740
val x762 = x761.numRows
val x763 = x762 / 2
val x764 = new generated.scala.IndexVectorRangeImpl(0,x763)
val x765 = x761.numCols
val x766 = x765 / 2
val x767 = new generated.scala.IndexVectorRangeImpl(0,x766)
val x768 = new generated.scala.IndexVector2Impl(x764,x767)
val x769 = x768.rowInd
val x770 = x769.length
val x774 = x768.colInd
val x828 = x774.length
val x829 = x774.isRow
def x833_block = {
val x771 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](x770,true)
var mapIdx = 0
while (mapIdx < x769.size) { // begin map loop x833
val x773 = x769.dcApply(mapIdx)
x771.dcUpdate(mapIdx,  {
val x776 = 2 * x773
val x777 = x776 + 2
val x780 = x777 - x776
def x832_block = {
val x830 = new generated.scala.IntVectorImpl(x828,x829)
var mapIdx = 0
while (mapIdx < x774.size) { // begin map loop x832
val x775 = x774.dcApply(mapIdx)
x830.dcUpdate(mapIdx,  {
val x778 = 2 * x775
val x779 = x778 + 2
val x781 = x779 - x778
val x809 = { 
val x782 = new generated.scala.IntMatrixImpl(x780,x781)
var x783: Int = x776
val x807 = while ({val x784 = x783
val x785 = x784 < x777
x785}) {
var x787: Int = x778
val x804 = while ({val x788 = x787
val x789 = x788 < x779
x789}) {
val x791 = x783
val x793 = x787
val x795 = x783
val x796 = x787
val x792 = x791 - x776
val x794 = x793 - x778
val x797 = x795 * x765
val x798 = x797 + x796
val x799 = x761.dcApply(x798)
val x800 = { 
x799
}
val x801 = x782(x792, x794) = x800
val x802 = x787 += 1
()
}
val x805 = x783 += 1
()
}
x782
}
val x810 = x809.numCols
val x811 = 0 * x810
val x812 = x811 + 0
val x813 = x809.dcApply(x812)
val x814 = { 
x813
}
val x815 = 1 * x810
val x816 = x815 + 0
val x817 = x809.dcApply(x816)
val x818 = { 
x817
}
val x819 = x814 | x818
val x820 = x811 + 1
val x821 = x809.dcApply(x820)
val x822 = { 
x821
}
val x823 = x819 | x822
val x824 = x815 + 1
val x825 = x809.dcApply(x824)
val x826 = { 
x825
}
val x827 = x823 | x826
x827
})
mapIdx += 1
} // end map loop x832
x830
}
val x832 = x832_block
x832
})
mapIdx += 1
} // end map loop x833
x771
}
val x833 = x833_block
val x834 = x833.length
val x835 = x834==0
val x869 = { 
val x867 = {
def x867thenb(): generated.scala.Matrix[Int] = {
val x836 = new generated.scala.IntMatrixImpl(0,0)
x836
}
def x867elseb(): generated.scala.Matrix[Int] = {
val x838 = x833(0)
val x839 = x838.isRow
val x865 = {
def x865thenb(): generated.scala.Matrix[Int] = {
val x840 = x838.length
val x841 = new generated.scala.IntMatrixImpl(x834,x840)
var x843 : Int = 0
val x852 = while (x843 < x834) {
val x846 = x833(x843)
var x845 : Int = 0
val x850 = while (x845 < x840) {
val x847 = x846(x845)
val x848 = x841(x843, x845) = x847
x848
x845 = x845 + 1
}
x850
x843 = x843 + 1
}
x841
}
def x865elseb(): generated.scala.Matrix[Int] = {
val x840 = x838.length
val x854 = new generated.scala.IntMatrixImpl(x840,x834)
var x855 : Int = 0
val x863 = while (x855 < x834) {
val x857 = x833(x855)
var x856 : Int = 0
val x861 = while (x856 < x840) {
val x858 = x857(x856)
val x859 = x854(x856, x855) = x858
x859
x856 = x856 + 1
}
x861
x855 = x855 + 1
}
x854
}
if (x839) {
x865thenb()
} else { 
x865elseb()
}
}
x865
}
if (x835) {
x867thenb()
} else { 
x867elseb()
}
}
x867
}
val x870 = new generated.scala.IntImageImpl(x869)
val x871 = new generated.scala.GrayscaleImageImpl(x870)
x740 = x871
()
}
if (x760) {
x874thenb()
}
}
val x875 = x741 += 1
()
}
val x886 = x743.fixedLevelIndex
val x887 = x886 - x745
val x888 = x752(x887)
val x889 = x888.numRows
val x890 = x889 - 5
val x891 = new generated.scala.IndexVectorRangeImpl(5,x890)
val x893 = x888.numCols
val x894 = x893 - 5
val x895 = new generated.scala.IndexVectorRangeImpl(5,x894)
def x1194_block = {
val x878 = x224.dcApply(0)
var x1166 = {
val x879 = x878._1
val x881 = "Name: "+x879
val x882 = println(x881)
val x880 = x878._2
val x883 = x880.length
val x884 = "Templates: "+x883
val x885 = println(x884)
val x972 = new generated.scala.IndexVectorRangeImpl(0,x883)
def x1161_block = {
val x892 = x891.dcApply(0)
var x1133 = {
val x914 = x892 - 15
val x915 = x914 < 0
val x919 = {
def x919thenb(): scala.Tuple2[Int, Int] = {
val x916 = 15 - x892
val x917 = (0,x916)
x917
}
def x919elseb(): scala.Tuple2[Int, Int] = {
val x918 = (x914,0)
x918
}
if (x915) {
x919thenb()
} else { 
x919elseb()
}
}
val x920 = x919._1
val x922 = x892 + 15
val x923 = x922 > x889
val x924 = {
def x924thenb(): Int = {
x889
}
def x924elseb(): Int = {
x922
}
if (x923) {
x924thenb()
} else { 
x924elseb()
}
}
val x921 = x919._2
def x1132_block = {
val x896 = x895.dcApply(0)
var x1104 = {
val x900 = new generated.scala.IntVectorImpl(900,false)
val x901 = new generated.scala.IndexVectorSeqImpl(0)
val x902 = new generated.scala.BinarizedGradientTemplate(15,null,null,x886,x900,x901,null,null,null)
var x925: Int = x920
val x903 = x896 - 15
val x904 = x903 < 0
val x908 = {
def x908thenb(): scala.Tuple2[Int, Int] = {
val x905 = 15 - x896
val x906 = (0,x905)
x906
}
def x908elseb(): scala.Tuple2[Int, Int] = {
val x907 = (x903,0)
x907
}
if (x904) {
x908thenb()
} else { 
x908elseb()
}
}
val x909 = x908._1
val x911 = x896 + 15
val x912 = x911 > x893
val x913 = {
def x913thenb(): Int = {
x893
}
def x913elseb(): Int = {
x911
}
if (x912) {
x913thenb()
} else { 
x913elseb()
}
}
val x910 = x908._2
val x944 = x902.binary_gradients
val x957 = x902.match_list
val x958 = x957.length
val x967 = while ({val x926 = x925
val x927 = x926 < x924
x927}) {
val x929 = x925
var x931: Int = x909
val x947 = x929 * x893
val x964 = while ({val x932 = x931
val x933 = x932 < x913
x933}) {
val x935 = x925
val x939 = x931
val x936 = x921 + x935
val x937 = x936 - x920
val x938 = x937 * 30
val x940 = x910 + x939
val x941 = x940 - x909
val x942 = x938 + x941
var x943: Int = x942
val x945 = x943
val x946 = x931
val x948 = x947 + x946
val x949 = x888.dcApply(x948)
val x950 = { 
x949
}
val x951 = x944(x945) = x950
val x952 = x931
val x953 = x947 + x952
val x954 = x888.dcApply(x953)
val x955 = { 
x954
}
val x956 = x955 > 0
val x961 = {
def x961thenb(): Unit = {
val x959 = x957.insert(x958, x945)
x959
}
if (x956) {
x961thenb()
}
}
val x962 = x931 += 1
()
}
val x965 = x925 += 1
()
}
val x968 = x958 < 0
val x971 = {
def x971thenb(): Unit = {
val x969 = println("dummy")
x969
}
if (x968) {
x971thenb()
}
}
val x976 = x902.radius
def x1102_block = {
val x973 = x972.dcApply(0)
var x1074 = {
val x974 = x880(x973)
val x975 = x974.radius
val x977 = x975 != x976
val x1052 = {
def x1052thenb(): Float = {
-1.0f
}
def x1052elseb(): Float = {
val x978 = x974.match_list
val x979 = x978.length
val x980 = x979.asInstanceOf[Float]
val x981 = x980==0.0
val x1050 = {
def x1050thenb(): Float = {
-1.0f
}
def x1050elseb(): Float = {
val x982 = x958.asInstanceOf[Float]
val x983 = x982 / x980
val x984 = x983 < 0.82f
val x1048 = {
def x1048thenb(): Float = {
x983
}
def x1048elseb(): Float = {
var x985: Float = 0.0f
val x986 = x980 * 0.18f
val x987 = x986 + 0.5f
val x988 = x987.asInstanceOf[Int]
var x989: Int = x988
var x990: Int = 0
var x991: Boolean = true
val x999 = x974.binary_gradients
val x1039 = while ({val x992 = x990
val x994 = x991
val x993 = x992 < x979
val x995 = x993 && x994
x995}) {
val x997 = x990
val x1000 = x990
val x1004 = x990
val x1001 = x978(x1000)
val x1002 = x999(x1001)
val x1003 = x1002==0
val x1005 = x978(x1004)
val x1006 = x944(x1005)
val x1007 = x1006==0
val x1008 = x1003 && x1007
val x1036 = {
def x1036thenb(): Unit = {
val x1009 = x985
val x1010 = x1009 + 1.0f
x985 = x1010
()
}
def x1036elseb(): Unit = {
val x1013 = x990
val x1016 = x990
val x1014 = x978(x1013)
val x1015 = x999(x1014)
val x1017 = x978(x1016)
val x1018 = x944(x1017)
val x1019 = x1015 & x1018
val x1020 = x1019 > 0
val x1034 = {
def x1034thenb(): Unit = {
val x1021 = x985
val x1022 = x1021 + 1.0f
x985 = x1022
()
}
def x1034elseb(): Unit = {
val x1025 = x989
val x1026 = x1025 - 1
x989 = x1026
val x1028 = x989
val x1029 = x1028 <= 0
val x1032 = {
def x1032thenb(): Unit = {
x991 = false
()
}
if (x1029) {
x1032thenb()
}
}
x1032
}
if (x1020) {
x1034thenb()
} else { 
x1034elseb()
}
}
x1034
}
if (x1008) {
x1036thenb()
} else { 
x1036elseb()
}
}
val x1037 = x990 += 1
()
}
val x1040 = x991
val x1041 = !x1040
val x1046 = {
def x1046thenb(): Float = {
0.819999f
}
def x1046elseb(): Float = {
val x1042 = x985
val x1043 = x1042 / x980
val x1044 = x1043.asInstanceOf[Float]
x1044
}
if (x1041) {
x1046thenb()
} else { 
x1046elseb()
}
}
x1046
}
if (x984) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
if (x981) {
x1050thenb()
} else { 
x1050elseb()
}
}
x1050
}
if (x977) {
x1052thenb()
} else { 
x1052elseb()
}
}
val x1053 = x1052 > 0.82f
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1054 = x974.rect
val x1056 = x1054.width
val x897 = x886
val x898 = Math.pow(2.0,x897)
val x899 = x898.asInstanceOf[Int]
val x1055 = x899 * x896
val x1057 = x1056 / 2
val x1058 = x1055 - x1057
val x1059 = x1058.asInstanceOf[Int]
val x1061 = x1054.height
val x1060 = x899 * x892
val x1062 = x1061 / 2
val x1063 = x1060 - x1062
val x1064 = x1063.asInstanceOf[Int]
val x1065 = new generated.scala.Rect(x1059,x1064,x1056,x1061)
val x1066 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1067 = new generated.scala.BiGGDetection(x879,x1052,x1065,null,x973,x896,x892,x974,x902)
val x1068 = x1066(0) = x1067
x1066
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1070 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1070
}
if (x1053) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
var mapReduceIdx = 1
while (mapReduceIdx < x972.size) { // begin mapReduce loop x1102
val x973 = x972.dcApply(mapReduceIdx)
val x1075 = {
val x974 = x880(x973)
val x975 = x974.radius
val x977 = x975 != x976
val x1052 = {
def x1052thenb(): Float = {
-1.0f
}
def x1052elseb(): Float = {
val x978 = x974.match_list
val x979 = x978.length
val x980 = x979.asInstanceOf[Float]
val x981 = x980==0.0
val x1050 = {
def x1050thenb(): Float = {
-1.0f
}
def x1050elseb(): Float = {
val x982 = x958.asInstanceOf[Float]
val x983 = x982 / x980
val x984 = x983 < 0.82f
val x1048 = {
def x1048thenb(): Float = {
x983
}
def x1048elseb(): Float = {
var x985: Float = 0.0f
val x986 = x980 * 0.18f
val x987 = x986 + 0.5f
val x988 = x987.asInstanceOf[Int]
var x989: Int = x988
var x990: Int = 0
var x991: Boolean = true
val x999 = x974.binary_gradients
val x1039 = while ({val x992 = x990
val x994 = x991
val x993 = x992 < x979
val x995 = x993 && x994
x995}) {
val x997 = x990
val x1000 = x990
val x1004 = x990
val x1001 = x978(x1000)
val x1002 = x999(x1001)
val x1003 = x1002==0
val x1005 = x978(x1004)
val x1006 = x944(x1005)
val x1007 = x1006==0
val x1008 = x1003 && x1007
val x1036 = {
def x1036thenb(): Unit = {
val x1009 = x985
val x1010 = x1009 + 1.0f
x985 = x1010
()
}
def x1036elseb(): Unit = {
val x1013 = x990
val x1016 = x990
val x1014 = x978(x1013)
val x1015 = x999(x1014)
val x1017 = x978(x1016)
val x1018 = x944(x1017)
val x1019 = x1015 & x1018
val x1020 = x1019 > 0
val x1034 = {
def x1034thenb(): Unit = {
val x1021 = x985
val x1022 = x1021 + 1.0f
x985 = x1022
()
}
def x1034elseb(): Unit = {
val x1025 = x989
val x1026 = x1025 - 1
x989 = x1026
val x1028 = x989
val x1029 = x1028 <= 0
val x1032 = {
def x1032thenb(): Unit = {
x991 = false
()
}
if (x1029) {
x1032thenb()
}
}
x1032
}
if (x1020) {
x1034thenb()
} else { 
x1034elseb()
}
}
x1034
}
if (x1008) {
x1036thenb()
} else { 
x1036elseb()
}
}
val x1037 = x990 += 1
()
}
val x1040 = x991
val x1041 = !x1040
val x1046 = {
def x1046thenb(): Float = {
0.819999f
}
def x1046elseb(): Float = {
val x1042 = x985
val x1043 = x1042 / x980
val x1044 = x1043.asInstanceOf[Float]
x1044
}
if (x1041) {
x1046thenb()
} else { 
x1046elseb()
}
}
x1046
}
if (x984) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
if (x981) {
x1050thenb()
} else { 
x1050elseb()
}
}
x1050
}
if (x977) {
x1052thenb()
} else { 
x1052elseb()
}
}
val x1053 = x1052 > 0.82f
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1054 = x974.rect
val x1056 = x1054.width
val x897 = x886
val x898 = Math.pow(2.0,x897)
val x899 = x898.asInstanceOf[Int]
val x1055 = x899 * x896
val x1057 = x1056 / 2
val x1058 = x1055 - x1057
val x1059 = x1058.asInstanceOf[Int]
val x1061 = x1054.height
val x1060 = x899 * x892
val x1062 = x1061 / 2
val x1063 = x1060 - x1062
val x1064 = x1063.asInstanceOf[Int]
val x1065 = new generated.scala.Rect(x1059,x1064,x1056,x1061)
val x1066 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1067 = new generated.scala.BiGGDetection(x879,x1052,x1065,null,x973,x896,x892,x974,x902)
val x1068 = x1066(0) = x1067
x1066
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1070 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1070
}
if (x1053) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
x1074 = {
val x1076 = x1074.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1101 = { 
val x1099 = {
def x1099thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1075
}
def x1099elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1077 = x1075.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1097 = {
def x1097thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1074
}
def x1097elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1078 = x1074.length
val x1079 = x1075.length
val x1080 = x1078 + x1079
val x1081 = x1074.isRow
val x1082 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1080,x1081)
var x1084 : Int = 0
val x1088 = while (x1084 < x1078) {
val x1085 = x1074(x1084)
val x1086 = x1082(x1084) = x1085
x1086
x1084 = x1084 + 1
}
var x1090 : Int = 0
val x1095 = while (x1090 < x1079) {
val x1091 = x1090 + x1078
val x1092 = x1075(x1090)
val x1093 = x1082(x1091) = x1092
x1093
x1090 = x1090 + 1
}
x1082
}
if (x1077) {
x1097thenb()
} else { 
x1097elseb()
}
}
x1097
}
if (x1076) {
x1099thenb()
} else { 
x1099elseb()
}
}
x1099
}
x1101
}
mapReduceIdx += 1
} // end mapReduce loop x1102
x1074
}
val x1102 = x1102_block
x1102
}
var mapReduceIdx = 1
while (mapReduceIdx < x895.size) { // begin mapReduce loop x1132
val x896 = x895.dcApply(mapReduceIdx)
val x1105 = {
val x900 = new generated.scala.IntVectorImpl(900,false)
val x901 = new generated.scala.IndexVectorSeqImpl(0)
val x902 = new generated.scala.BinarizedGradientTemplate(15,null,null,x886,x900,x901,null,null,null)
var x925: Int = x920
val x903 = x896 - 15
val x904 = x903 < 0
val x908 = {
def x908thenb(): scala.Tuple2[Int, Int] = {
val x905 = 15 - x896
val x906 = (0,x905)
x906
}
def x908elseb(): scala.Tuple2[Int, Int] = {
val x907 = (x903,0)
x907
}
if (x904) {
x908thenb()
} else { 
x908elseb()
}
}
val x909 = x908._1
val x911 = x896 + 15
val x912 = x911 > x893
val x913 = {
def x913thenb(): Int = {
x893
}
def x913elseb(): Int = {
x911
}
if (x912) {
x913thenb()
} else { 
x913elseb()
}
}
val x910 = x908._2
val x944 = x902.binary_gradients
val x957 = x902.match_list
val x958 = x957.length
val x967 = while ({val x926 = x925
val x927 = x926 < x924
x927}) {
val x929 = x925
var x931: Int = x909
val x947 = x929 * x893
val x964 = while ({val x932 = x931
val x933 = x932 < x913
x933}) {
val x935 = x925
val x939 = x931
val x936 = x921 + x935
val x937 = x936 - x920
val x938 = x937 * 30
val x940 = x910 + x939
val x941 = x940 - x909
val x942 = x938 + x941
var x943: Int = x942
val x945 = x943
val x946 = x931
val x948 = x947 + x946
val x949 = x888.dcApply(x948)
val x950 = { 
x949
}
val x951 = x944(x945) = x950
val x952 = x931
val x953 = x947 + x952
val x954 = x888.dcApply(x953)
val x955 = { 
x954
}
val x956 = x955 > 0
val x961 = {
def x961thenb(): Unit = {
val x959 = x957.insert(x958, x945)
x959
}
if (x956) {
x961thenb()
}
}
val x962 = x931 += 1
()
}
val x965 = x925 += 1
()
}
val x968 = x958 < 0
val x971 = {
def x971thenb(): Unit = {
val x969 = println("dummy")
x969
}
if (x968) {
x971thenb()
}
}
val x976 = x902.radius
def x1102_block = {
val x973 = x972.dcApply(0)
var x1074 = {
val x974 = x880(x973)
val x975 = x974.radius
val x977 = x975 != x976
val x1052 = {
def x1052thenb(): Float = {
-1.0f
}
def x1052elseb(): Float = {
val x978 = x974.match_list
val x979 = x978.length
val x980 = x979.asInstanceOf[Float]
val x981 = x980==0.0
val x1050 = {
def x1050thenb(): Float = {
-1.0f
}
def x1050elseb(): Float = {
val x982 = x958.asInstanceOf[Float]
val x983 = x982 / x980
val x984 = x983 < 0.82f
val x1048 = {
def x1048thenb(): Float = {
x983
}
def x1048elseb(): Float = {
var x985: Float = 0.0f
val x986 = x980 * 0.18f
val x987 = x986 + 0.5f
val x988 = x987.asInstanceOf[Int]
var x989: Int = x988
var x990: Int = 0
var x991: Boolean = true
val x999 = x974.binary_gradients
val x1039 = while ({val x992 = x990
val x994 = x991
val x993 = x992 < x979
val x995 = x993 && x994
x995}) {
val x997 = x990
val x1000 = x990
val x1004 = x990
val x1001 = x978(x1000)
val x1002 = x999(x1001)
val x1003 = x1002==0
val x1005 = x978(x1004)
val x1006 = x944(x1005)
val x1007 = x1006==0
val x1008 = x1003 && x1007
val x1036 = {
def x1036thenb(): Unit = {
val x1009 = x985
val x1010 = x1009 + 1.0f
x985 = x1010
()
}
def x1036elseb(): Unit = {
val x1013 = x990
val x1016 = x990
val x1014 = x978(x1013)
val x1015 = x999(x1014)
val x1017 = x978(x1016)
val x1018 = x944(x1017)
val x1019 = x1015 & x1018
val x1020 = x1019 > 0
val x1034 = {
def x1034thenb(): Unit = {
val x1021 = x985
val x1022 = x1021 + 1.0f
x985 = x1022
()
}
def x1034elseb(): Unit = {
val x1025 = x989
val x1026 = x1025 - 1
x989 = x1026
val x1028 = x989
val x1029 = x1028 <= 0
val x1032 = {
def x1032thenb(): Unit = {
x991 = false
()
}
if (x1029) {
x1032thenb()
}
}
x1032
}
if (x1020) {
x1034thenb()
} else { 
x1034elseb()
}
}
x1034
}
if (x1008) {
x1036thenb()
} else { 
x1036elseb()
}
}
val x1037 = x990 += 1
()
}
val x1040 = x991
val x1041 = !x1040
val x1046 = {
def x1046thenb(): Float = {
0.819999f
}
def x1046elseb(): Float = {
val x1042 = x985
val x1043 = x1042 / x980
val x1044 = x1043.asInstanceOf[Float]
x1044
}
if (x1041) {
x1046thenb()
} else { 
x1046elseb()
}
}
x1046
}
if (x984) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
if (x981) {
x1050thenb()
} else { 
x1050elseb()
}
}
x1050
}
if (x977) {
x1052thenb()
} else { 
x1052elseb()
}
}
val x1053 = x1052 > 0.82f
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1054 = x974.rect
val x1056 = x1054.width
val x897 = x886
val x898 = Math.pow(2.0,x897)
val x899 = x898.asInstanceOf[Int]
val x1055 = x899 * x896
val x1057 = x1056 / 2
val x1058 = x1055 - x1057
val x1059 = x1058.asInstanceOf[Int]
val x1061 = x1054.height
val x1060 = x899 * x892
val x1062 = x1061 / 2
val x1063 = x1060 - x1062
val x1064 = x1063.asInstanceOf[Int]
val x1065 = new generated.scala.Rect(x1059,x1064,x1056,x1061)
val x1066 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1067 = new generated.scala.BiGGDetection(x879,x1052,x1065,null,x973,x896,x892,x974,x902)
val x1068 = x1066(0) = x1067
x1066
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1070 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1070
}
if (x1053) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
var mapReduceIdx = 1
while (mapReduceIdx < x972.size) { // begin mapReduce loop x1102
val x973 = x972.dcApply(mapReduceIdx)
val x1075 = {
val x974 = x880(x973)
val x975 = x974.radius
val x977 = x975 != x976
val x1052 = {
def x1052thenb(): Float = {
-1.0f
}
def x1052elseb(): Float = {
val x978 = x974.match_list
val x979 = x978.length
val x980 = x979.asInstanceOf[Float]
val x981 = x980==0.0
val x1050 = {
def x1050thenb(): Float = {
-1.0f
}
def x1050elseb(): Float = {
val x982 = x958.asInstanceOf[Float]
val x983 = x982 / x980
val x984 = x983 < 0.82f
val x1048 = {
def x1048thenb(): Float = {
x983
}
def x1048elseb(): Float = {
var x985: Float = 0.0f
val x986 = x980 * 0.18f
val x987 = x986 + 0.5f
val x988 = x987.asInstanceOf[Int]
var x989: Int = x988
var x990: Int = 0
var x991: Boolean = true
val x999 = x974.binary_gradients
val x1039 = while ({val x992 = x990
val x994 = x991
val x993 = x992 < x979
val x995 = x993 && x994
x995}) {
val x997 = x990
val x1000 = x990
val x1004 = x990
val x1001 = x978(x1000)
val x1002 = x999(x1001)
val x1003 = x1002==0
val x1005 = x978(x1004)
val x1006 = x944(x1005)
val x1007 = x1006==0
val x1008 = x1003 && x1007
val x1036 = {
def x1036thenb(): Unit = {
val x1009 = x985
val x1010 = x1009 + 1.0f
x985 = x1010
()
}
def x1036elseb(): Unit = {
val x1013 = x990
val x1016 = x990
val x1014 = x978(x1013)
val x1015 = x999(x1014)
val x1017 = x978(x1016)
val x1018 = x944(x1017)
val x1019 = x1015 & x1018
val x1020 = x1019 > 0
val x1034 = {
def x1034thenb(): Unit = {
val x1021 = x985
val x1022 = x1021 + 1.0f
x985 = x1022
()
}
def x1034elseb(): Unit = {
val x1025 = x989
val x1026 = x1025 - 1
x989 = x1026
val x1028 = x989
val x1029 = x1028 <= 0
val x1032 = {
def x1032thenb(): Unit = {
x991 = false
()
}
if (x1029) {
x1032thenb()
}
}
x1032
}
if (x1020) {
x1034thenb()
} else { 
x1034elseb()
}
}
x1034
}
if (x1008) {
x1036thenb()
} else { 
x1036elseb()
}
}
val x1037 = x990 += 1
()
}
val x1040 = x991
val x1041 = !x1040
val x1046 = {
def x1046thenb(): Float = {
0.819999f
}
def x1046elseb(): Float = {
val x1042 = x985
val x1043 = x1042 / x980
val x1044 = x1043.asInstanceOf[Float]
x1044
}
if (x1041) {
x1046thenb()
} else { 
x1046elseb()
}
}
x1046
}
if (x984) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
if (x981) {
x1050thenb()
} else { 
x1050elseb()
}
}
x1050
}
if (x977) {
x1052thenb()
} else { 
x1052elseb()
}
}
val x1053 = x1052 > 0.82f
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1054 = x974.rect
val x1056 = x1054.width
val x897 = x886
val x898 = Math.pow(2.0,x897)
val x899 = x898.asInstanceOf[Int]
val x1055 = x899 * x896
val x1057 = x1056 / 2
val x1058 = x1055 - x1057
val x1059 = x1058.asInstanceOf[Int]
val x1061 = x1054.height
val x1060 = x899 * x892
val x1062 = x1061 / 2
val x1063 = x1060 - x1062
val x1064 = x1063.asInstanceOf[Int]
val x1065 = new generated.scala.Rect(x1059,x1064,x1056,x1061)
val x1066 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1067 = new generated.scala.BiGGDetection(x879,x1052,x1065,null,x973,x896,x892,x974,x902)
val x1068 = x1066(0) = x1067
x1066
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1070 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1070
}
if (x1053) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
x1074 = {
val x1076 = x1074.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1101 = { 
val x1099 = {
def x1099thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1075
}
def x1099elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1077 = x1075.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1097 = {
def x1097thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1074
}
def x1097elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1078 = x1074.length
val x1079 = x1075.length
val x1080 = x1078 + x1079
val x1081 = x1074.isRow
val x1082 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1080,x1081)
var x1084 : Int = 0
val x1088 = while (x1084 < x1078) {
val x1085 = x1074(x1084)
val x1086 = x1082(x1084) = x1085
x1086
x1084 = x1084 + 1
}
var x1090 : Int = 0
val x1095 = while (x1090 < x1079) {
val x1091 = x1090 + x1078
val x1092 = x1075(x1090)
val x1093 = x1082(x1091) = x1092
x1093
x1090 = x1090 + 1
}
x1082
}
if (x1077) {
x1097thenb()
} else { 
x1097elseb()
}
}
x1097
}
if (x1076) {
x1099thenb()
} else { 
x1099elseb()
}
}
x1099
}
x1101
}
mapReduceIdx += 1
} // end mapReduce loop x1102
x1074
}
val x1102 = x1102_block
x1102
}
x1104 = {
val x1106 = x1104.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1131 = { 
val x1129 = {
def x1129thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1105
}
def x1129elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1107 = x1105.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1127 = {
def x1127thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1104
}
def x1127elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1108 = x1104.length
val x1109 = x1105.length
val x1110 = x1108 + x1109
val x1111 = x1104.isRow
val x1112 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1110,x1111)
var x1114 : Int = 0
val x1118 = while (x1114 < x1108) {
val x1115 = x1104(x1114)
val x1116 = x1112(x1114) = x1115
x1116
x1114 = x1114 + 1
}
var x1120 : Int = 0
val x1125 = while (x1120 < x1109) {
val x1121 = x1120 + x1108
val x1122 = x1105(x1120)
val x1123 = x1112(x1121) = x1122
x1123
x1120 = x1120 + 1
}
x1112
}
if (x1107) {
x1127thenb()
} else { 
x1127elseb()
}
}
x1127
}
if (x1106) {
x1129thenb()
} else { 
x1129elseb()
}
}
x1129
}
x1131
}
mapReduceIdx += 1
} // end mapReduce loop x1132
x1104
}
val x1132 = x1132_block
x1132
}
var mapReduceIdx = 1
while (mapReduceIdx < x891.size) { // begin mapReduce loop x1161
val x892 = x891.dcApply(mapReduceIdx)
val x1134 = {
val x914 = x892 - 15
val x915 = x914 < 0
val x919 = {
def x919thenb(): scala.Tuple2[Int, Int] = {
val x916 = 15 - x892
val x917 = (0,x916)
x917
}
def x919elseb(): scala.Tuple2[Int, Int] = {
val x918 = (x914,0)
x918
}
if (x915) {
x919thenb()
} else { 
x919elseb()
}
}
val x920 = x919._1
val x922 = x892 + 15
val x923 = x922 > x889
val x924 = {
def x924thenb(): Int = {
x889
}
def x924elseb(): Int = {
x922
}
if (x923) {
x924thenb()
} else { 
x924elseb()
}
}
val x921 = x919._2
def x1132_block = {
val x896 = x895.dcApply(0)
var x1104 = {
val x900 = new generated.scala.IntVectorImpl(900,false)
val x901 = new generated.scala.IndexVectorSeqImpl(0)
val x902 = new generated.scala.BinarizedGradientTemplate(15,null,null,x886,x900,x901,null,null,null)
var x925: Int = x920
val x903 = x896 - 15
val x904 = x903 < 0
val x908 = {
def x908thenb(): scala.Tuple2[Int, Int] = {
val x905 = 15 - x896
val x906 = (0,x905)
x906
}
def x908elseb(): scala.Tuple2[Int, Int] = {
val x907 = (x903,0)
x907
}
if (x904) {
x908thenb()
} else { 
x908elseb()
}
}
val x909 = x908._1
val x911 = x896 + 15
val x912 = x911 > x893
val x913 = {
def x913thenb(): Int = {
x893
}
def x913elseb(): Int = {
x911
}
if (x912) {
x913thenb()
} else { 
x913elseb()
}
}
val x910 = x908._2
val x944 = x902.binary_gradients
val x957 = x902.match_list
val x958 = x957.length
val x967 = while ({val x926 = x925
val x927 = x926 < x924
x927}) {
val x929 = x925
var x931: Int = x909
val x947 = x929 * x893
val x964 = while ({val x932 = x931
val x933 = x932 < x913
x933}) {
val x935 = x925
val x939 = x931
val x936 = x921 + x935
val x937 = x936 - x920
val x938 = x937 * 30
val x940 = x910 + x939
val x941 = x940 - x909
val x942 = x938 + x941
var x943: Int = x942
val x945 = x943
val x946 = x931
val x948 = x947 + x946
val x949 = x888.dcApply(x948)
val x950 = { 
x949
}
val x951 = x944(x945) = x950
val x952 = x931
val x953 = x947 + x952
val x954 = x888.dcApply(x953)
val x955 = { 
x954
}
val x956 = x955 > 0
val x961 = {
def x961thenb(): Unit = {
val x959 = x957.insert(x958, x945)
x959
}
if (x956) {
x961thenb()
}
}
val x962 = x931 += 1
()
}
val x965 = x925 += 1
()
}
val x968 = x958 < 0
val x971 = {
def x971thenb(): Unit = {
val x969 = println("dummy")
x969
}
if (x968) {
x971thenb()
}
}
val x976 = x902.radius
def x1102_block = {
val x973 = x972.dcApply(0)
var x1074 = {
val x974 = x880(x973)
val x975 = x974.radius
val x977 = x975 != x976
val x1052 = {
def x1052thenb(): Float = {
-1.0f
}
def x1052elseb(): Float = {
val x978 = x974.match_list
val x979 = x978.length
val x980 = x979.asInstanceOf[Float]
val x981 = x980==0.0
val x1050 = {
def x1050thenb(): Float = {
-1.0f
}
def x1050elseb(): Float = {
val x982 = x958.asInstanceOf[Float]
val x983 = x982 / x980
val x984 = x983 < 0.82f
val x1048 = {
def x1048thenb(): Float = {
x983
}
def x1048elseb(): Float = {
var x985: Float = 0.0f
val x986 = x980 * 0.18f
val x987 = x986 + 0.5f
val x988 = x987.asInstanceOf[Int]
var x989: Int = x988
var x990: Int = 0
var x991: Boolean = true
val x999 = x974.binary_gradients
val x1039 = while ({val x992 = x990
val x994 = x991
val x993 = x992 < x979
val x995 = x993 && x994
x995}) {
val x997 = x990
val x1000 = x990
val x1004 = x990
val x1001 = x978(x1000)
val x1002 = x999(x1001)
val x1003 = x1002==0
val x1005 = x978(x1004)
val x1006 = x944(x1005)
val x1007 = x1006==0
val x1008 = x1003 && x1007
val x1036 = {
def x1036thenb(): Unit = {
val x1009 = x985
val x1010 = x1009 + 1.0f
x985 = x1010
()
}
def x1036elseb(): Unit = {
val x1013 = x990
val x1016 = x990
val x1014 = x978(x1013)
val x1015 = x999(x1014)
val x1017 = x978(x1016)
val x1018 = x944(x1017)
val x1019 = x1015 & x1018
val x1020 = x1019 > 0
val x1034 = {
def x1034thenb(): Unit = {
val x1021 = x985
val x1022 = x1021 + 1.0f
x985 = x1022
()
}
def x1034elseb(): Unit = {
val x1025 = x989
val x1026 = x1025 - 1
x989 = x1026
val x1028 = x989
val x1029 = x1028 <= 0
val x1032 = {
def x1032thenb(): Unit = {
x991 = false
()
}
if (x1029) {
x1032thenb()
}
}
x1032
}
if (x1020) {
x1034thenb()
} else { 
x1034elseb()
}
}
x1034
}
if (x1008) {
x1036thenb()
} else { 
x1036elseb()
}
}
val x1037 = x990 += 1
()
}
val x1040 = x991
val x1041 = !x1040
val x1046 = {
def x1046thenb(): Float = {
0.819999f
}
def x1046elseb(): Float = {
val x1042 = x985
val x1043 = x1042 / x980
val x1044 = x1043.asInstanceOf[Float]
x1044
}
if (x1041) {
x1046thenb()
} else { 
x1046elseb()
}
}
x1046
}
if (x984) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
if (x981) {
x1050thenb()
} else { 
x1050elseb()
}
}
x1050
}
if (x977) {
x1052thenb()
} else { 
x1052elseb()
}
}
val x1053 = x1052 > 0.82f
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1054 = x974.rect
val x1056 = x1054.width
val x897 = x886
val x898 = Math.pow(2.0,x897)
val x899 = x898.asInstanceOf[Int]
val x1055 = x899 * x896
val x1057 = x1056 / 2
val x1058 = x1055 - x1057
val x1059 = x1058.asInstanceOf[Int]
val x1061 = x1054.height
val x1060 = x899 * x892
val x1062 = x1061 / 2
val x1063 = x1060 - x1062
val x1064 = x1063.asInstanceOf[Int]
val x1065 = new generated.scala.Rect(x1059,x1064,x1056,x1061)
val x1066 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1067 = new generated.scala.BiGGDetection(x879,x1052,x1065,null,x973,x896,x892,x974,x902)
val x1068 = x1066(0) = x1067
x1066
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1070 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1070
}
if (x1053) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
var mapReduceIdx = 1
while (mapReduceIdx < x972.size) { // begin mapReduce loop x1102
val x973 = x972.dcApply(mapReduceIdx)
val x1075 = {
val x974 = x880(x973)
val x975 = x974.radius
val x977 = x975 != x976
val x1052 = {
def x1052thenb(): Float = {
-1.0f
}
def x1052elseb(): Float = {
val x978 = x974.match_list
val x979 = x978.length
val x980 = x979.asInstanceOf[Float]
val x981 = x980==0.0
val x1050 = {
def x1050thenb(): Float = {
-1.0f
}
def x1050elseb(): Float = {
val x982 = x958.asInstanceOf[Float]
val x983 = x982 / x980
val x984 = x983 < 0.82f
val x1048 = {
def x1048thenb(): Float = {
x983
}
def x1048elseb(): Float = {
var x985: Float = 0.0f
val x986 = x980 * 0.18f
val x987 = x986 + 0.5f
val x988 = x987.asInstanceOf[Int]
var x989: Int = x988
var x990: Int = 0
var x991: Boolean = true
val x999 = x974.binary_gradients
val x1039 = while ({val x992 = x990
val x994 = x991
val x993 = x992 < x979
val x995 = x993 && x994
x995}) {
val x997 = x990
val x1000 = x990
val x1004 = x990
val x1001 = x978(x1000)
val x1002 = x999(x1001)
val x1003 = x1002==0
val x1005 = x978(x1004)
val x1006 = x944(x1005)
val x1007 = x1006==0
val x1008 = x1003 && x1007
val x1036 = {
def x1036thenb(): Unit = {
val x1009 = x985
val x1010 = x1009 + 1.0f
x985 = x1010
()
}
def x1036elseb(): Unit = {
val x1013 = x990
val x1016 = x990
val x1014 = x978(x1013)
val x1015 = x999(x1014)
val x1017 = x978(x1016)
val x1018 = x944(x1017)
val x1019 = x1015 & x1018
val x1020 = x1019 > 0
val x1034 = {
def x1034thenb(): Unit = {
val x1021 = x985
val x1022 = x1021 + 1.0f
x985 = x1022
()
}
def x1034elseb(): Unit = {
val x1025 = x989
val x1026 = x1025 - 1
x989 = x1026
val x1028 = x989
val x1029 = x1028 <= 0
val x1032 = {
def x1032thenb(): Unit = {
x991 = false
()
}
if (x1029) {
x1032thenb()
}
}
x1032
}
if (x1020) {
x1034thenb()
} else { 
x1034elseb()
}
}
x1034
}
if (x1008) {
x1036thenb()
} else { 
x1036elseb()
}
}
val x1037 = x990 += 1
()
}
val x1040 = x991
val x1041 = !x1040
val x1046 = {
def x1046thenb(): Float = {
0.819999f
}
def x1046elseb(): Float = {
val x1042 = x985
val x1043 = x1042 / x980
val x1044 = x1043.asInstanceOf[Float]
x1044
}
if (x1041) {
x1046thenb()
} else { 
x1046elseb()
}
}
x1046
}
if (x984) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
if (x981) {
x1050thenb()
} else { 
x1050elseb()
}
}
x1050
}
if (x977) {
x1052thenb()
} else { 
x1052elseb()
}
}
val x1053 = x1052 > 0.82f
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1054 = x974.rect
val x1056 = x1054.width
val x897 = x886
val x898 = Math.pow(2.0,x897)
val x899 = x898.asInstanceOf[Int]
val x1055 = x899 * x896
val x1057 = x1056 / 2
val x1058 = x1055 - x1057
val x1059 = x1058.asInstanceOf[Int]
val x1061 = x1054.height
val x1060 = x899 * x892
val x1062 = x1061 / 2
val x1063 = x1060 - x1062
val x1064 = x1063.asInstanceOf[Int]
val x1065 = new generated.scala.Rect(x1059,x1064,x1056,x1061)
val x1066 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1067 = new generated.scala.BiGGDetection(x879,x1052,x1065,null,x973,x896,x892,x974,x902)
val x1068 = x1066(0) = x1067
x1066
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1070 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1070
}
if (x1053) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
x1074 = {
val x1076 = x1074.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1101 = { 
val x1099 = {
def x1099thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1075
}
def x1099elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1077 = x1075.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1097 = {
def x1097thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1074
}
def x1097elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1078 = x1074.length
val x1079 = x1075.length
val x1080 = x1078 + x1079
val x1081 = x1074.isRow
val x1082 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1080,x1081)
var x1084 : Int = 0
val x1088 = while (x1084 < x1078) {
val x1085 = x1074(x1084)
val x1086 = x1082(x1084) = x1085
x1086
x1084 = x1084 + 1
}
var x1090 : Int = 0
val x1095 = while (x1090 < x1079) {
val x1091 = x1090 + x1078
val x1092 = x1075(x1090)
val x1093 = x1082(x1091) = x1092
x1093
x1090 = x1090 + 1
}
x1082
}
if (x1077) {
x1097thenb()
} else { 
x1097elseb()
}
}
x1097
}
if (x1076) {
x1099thenb()
} else { 
x1099elseb()
}
}
x1099
}
x1101
}
mapReduceIdx += 1
} // end mapReduce loop x1102
x1074
}
val x1102 = x1102_block
x1102
}
var mapReduceIdx = 1
while (mapReduceIdx < x895.size) { // begin mapReduce loop x1132
val x896 = x895.dcApply(mapReduceIdx)
val x1105 = {
val x900 = new generated.scala.IntVectorImpl(900,false)
val x901 = new generated.scala.IndexVectorSeqImpl(0)
val x902 = new generated.scala.BinarizedGradientTemplate(15,null,null,x886,x900,x901,null,null,null)
var x925: Int = x920
val x903 = x896 - 15
val x904 = x903 < 0
val x908 = {
def x908thenb(): scala.Tuple2[Int, Int] = {
val x905 = 15 - x896
val x906 = (0,x905)
x906
}
def x908elseb(): scala.Tuple2[Int, Int] = {
val x907 = (x903,0)
x907
}
if (x904) {
x908thenb()
} else { 
x908elseb()
}
}
val x909 = x908._1
val x911 = x896 + 15
val x912 = x911 > x893
val x913 = {
def x913thenb(): Int = {
x893
}
def x913elseb(): Int = {
x911
}
if (x912) {
x913thenb()
} else { 
x913elseb()
}
}
val x910 = x908._2
val x944 = x902.binary_gradients
val x957 = x902.match_list
val x958 = x957.length
val x967 = while ({val x926 = x925
val x927 = x926 < x924
x927}) {
val x929 = x925
var x931: Int = x909
val x947 = x929 * x893
val x964 = while ({val x932 = x931
val x933 = x932 < x913
x933}) {
val x935 = x925
val x939 = x931
val x936 = x921 + x935
val x937 = x936 - x920
val x938 = x937 * 30
val x940 = x910 + x939
val x941 = x940 - x909
val x942 = x938 + x941
var x943: Int = x942
val x945 = x943
val x946 = x931
val x948 = x947 + x946
val x949 = x888.dcApply(x948)
val x950 = { 
x949
}
val x951 = x944(x945) = x950
val x952 = x931
val x953 = x947 + x952
val x954 = x888.dcApply(x953)
val x955 = { 
x954
}
val x956 = x955 > 0
val x961 = {
def x961thenb(): Unit = {
val x959 = x957.insert(x958, x945)
x959
}
if (x956) {
x961thenb()
}
}
val x962 = x931 += 1
()
}
val x965 = x925 += 1
()
}
val x968 = x958 < 0
val x971 = {
def x971thenb(): Unit = {
val x969 = println("dummy")
x969
}
if (x968) {
x971thenb()
}
}
val x976 = x902.radius
def x1102_block = {
val x973 = x972.dcApply(0)
var x1074 = {
val x974 = x880(x973)
val x975 = x974.radius
val x977 = x975 != x976
val x1052 = {
def x1052thenb(): Float = {
-1.0f
}
def x1052elseb(): Float = {
val x978 = x974.match_list
val x979 = x978.length
val x980 = x979.asInstanceOf[Float]
val x981 = x980==0.0
val x1050 = {
def x1050thenb(): Float = {
-1.0f
}
def x1050elseb(): Float = {
val x982 = x958.asInstanceOf[Float]
val x983 = x982 / x980
val x984 = x983 < 0.82f
val x1048 = {
def x1048thenb(): Float = {
x983
}
def x1048elseb(): Float = {
var x985: Float = 0.0f
val x986 = x980 * 0.18f
val x987 = x986 + 0.5f
val x988 = x987.asInstanceOf[Int]
var x989: Int = x988
var x990: Int = 0
var x991: Boolean = true
val x999 = x974.binary_gradients
val x1039 = while ({val x992 = x990
val x994 = x991
val x993 = x992 < x979
val x995 = x993 && x994
x995}) {
val x997 = x990
val x1000 = x990
val x1004 = x990
val x1001 = x978(x1000)
val x1002 = x999(x1001)
val x1003 = x1002==0
val x1005 = x978(x1004)
val x1006 = x944(x1005)
val x1007 = x1006==0
val x1008 = x1003 && x1007
val x1036 = {
def x1036thenb(): Unit = {
val x1009 = x985
val x1010 = x1009 + 1.0f
x985 = x1010
()
}
def x1036elseb(): Unit = {
val x1013 = x990
val x1016 = x990
val x1014 = x978(x1013)
val x1015 = x999(x1014)
val x1017 = x978(x1016)
val x1018 = x944(x1017)
val x1019 = x1015 & x1018
val x1020 = x1019 > 0
val x1034 = {
def x1034thenb(): Unit = {
val x1021 = x985
val x1022 = x1021 + 1.0f
x985 = x1022
()
}
def x1034elseb(): Unit = {
val x1025 = x989
val x1026 = x1025 - 1
x989 = x1026
val x1028 = x989
val x1029 = x1028 <= 0
val x1032 = {
def x1032thenb(): Unit = {
x991 = false
()
}
if (x1029) {
x1032thenb()
}
}
x1032
}
if (x1020) {
x1034thenb()
} else { 
x1034elseb()
}
}
x1034
}
if (x1008) {
x1036thenb()
} else { 
x1036elseb()
}
}
val x1037 = x990 += 1
()
}
val x1040 = x991
val x1041 = !x1040
val x1046 = {
def x1046thenb(): Float = {
0.819999f
}
def x1046elseb(): Float = {
val x1042 = x985
val x1043 = x1042 / x980
val x1044 = x1043.asInstanceOf[Float]
x1044
}
if (x1041) {
x1046thenb()
} else { 
x1046elseb()
}
}
x1046
}
if (x984) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
if (x981) {
x1050thenb()
} else { 
x1050elseb()
}
}
x1050
}
if (x977) {
x1052thenb()
} else { 
x1052elseb()
}
}
val x1053 = x1052 > 0.82f
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1054 = x974.rect
val x1056 = x1054.width
val x897 = x886
val x898 = Math.pow(2.0,x897)
val x899 = x898.asInstanceOf[Int]
val x1055 = x899 * x896
val x1057 = x1056 / 2
val x1058 = x1055 - x1057
val x1059 = x1058.asInstanceOf[Int]
val x1061 = x1054.height
val x1060 = x899 * x892
val x1062 = x1061 / 2
val x1063 = x1060 - x1062
val x1064 = x1063.asInstanceOf[Int]
val x1065 = new generated.scala.Rect(x1059,x1064,x1056,x1061)
val x1066 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1067 = new generated.scala.BiGGDetection(x879,x1052,x1065,null,x973,x896,x892,x974,x902)
val x1068 = x1066(0) = x1067
x1066
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1070 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1070
}
if (x1053) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
var mapReduceIdx = 1
while (mapReduceIdx < x972.size) { // begin mapReduce loop x1102
val x973 = x972.dcApply(mapReduceIdx)
val x1075 = {
val x974 = x880(x973)
val x975 = x974.radius
val x977 = x975 != x976
val x1052 = {
def x1052thenb(): Float = {
-1.0f
}
def x1052elseb(): Float = {
val x978 = x974.match_list
val x979 = x978.length
val x980 = x979.asInstanceOf[Float]
val x981 = x980==0.0
val x1050 = {
def x1050thenb(): Float = {
-1.0f
}
def x1050elseb(): Float = {
val x982 = x958.asInstanceOf[Float]
val x983 = x982 / x980
val x984 = x983 < 0.82f
val x1048 = {
def x1048thenb(): Float = {
x983
}
def x1048elseb(): Float = {
var x985: Float = 0.0f
val x986 = x980 * 0.18f
val x987 = x986 + 0.5f
val x988 = x987.asInstanceOf[Int]
var x989: Int = x988
var x990: Int = 0
var x991: Boolean = true
val x999 = x974.binary_gradients
val x1039 = while ({val x992 = x990
val x994 = x991
val x993 = x992 < x979
val x995 = x993 && x994
x995}) {
val x997 = x990
val x1000 = x990
val x1004 = x990
val x1001 = x978(x1000)
val x1002 = x999(x1001)
val x1003 = x1002==0
val x1005 = x978(x1004)
val x1006 = x944(x1005)
val x1007 = x1006==0
val x1008 = x1003 && x1007
val x1036 = {
def x1036thenb(): Unit = {
val x1009 = x985
val x1010 = x1009 + 1.0f
x985 = x1010
()
}
def x1036elseb(): Unit = {
val x1013 = x990
val x1016 = x990
val x1014 = x978(x1013)
val x1015 = x999(x1014)
val x1017 = x978(x1016)
val x1018 = x944(x1017)
val x1019 = x1015 & x1018
val x1020 = x1019 > 0
val x1034 = {
def x1034thenb(): Unit = {
val x1021 = x985
val x1022 = x1021 + 1.0f
x985 = x1022
()
}
def x1034elseb(): Unit = {
val x1025 = x989
val x1026 = x1025 - 1
x989 = x1026
val x1028 = x989
val x1029 = x1028 <= 0
val x1032 = {
def x1032thenb(): Unit = {
x991 = false
()
}
if (x1029) {
x1032thenb()
}
}
x1032
}
if (x1020) {
x1034thenb()
} else { 
x1034elseb()
}
}
x1034
}
if (x1008) {
x1036thenb()
} else { 
x1036elseb()
}
}
val x1037 = x990 += 1
()
}
val x1040 = x991
val x1041 = !x1040
val x1046 = {
def x1046thenb(): Float = {
0.819999f
}
def x1046elseb(): Float = {
val x1042 = x985
val x1043 = x1042 / x980
val x1044 = x1043.asInstanceOf[Float]
x1044
}
if (x1041) {
x1046thenb()
} else { 
x1046elseb()
}
}
x1046
}
if (x984) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
if (x981) {
x1050thenb()
} else { 
x1050elseb()
}
}
x1050
}
if (x977) {
x1052thenb()
} else { 
x1052elseb()
}
}
val x1053 = x1052 > 0.82f
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1054 = x974.rect
val x1056 = x1054.width
val x897 = x886
val x898 = Math.pow(2.0,x897)
val x899 = x898.asInstanceOf[Int]
val x1055 = x899 * x896
val x1057 = x1056 / 2
val x1058 = x1055 - x1057
val x1059 = x1058.asInstanceOf[Int]
val x1061 = x1054.height
val x1060 = x899 * x892
val x1062 = x1061 / 2
val x1063 = x1060 - x1062
val x1064 = x1063.asInstanceOf[Int]
val x1065 = new generated.scala.Rect(x1059,x1064,x1056,x1061)
val x1066 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1067 = new generated.scala.BiGGDetection(x879,x1052,x1065,null,x973,x896,x892,x974,x902)
val x1068 = x1066(0) = x1067
x1066
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1070 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1070
}
if (x1053) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
x1074 = {
val x1076 = x1074.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1101 = { 
val x1099 = {
def x1099thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1075
}
def x1099elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1077 = x1075.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1097 = {
def x1097thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1074
}
def x1097elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1078 = x1074.length
val x1079 = x1075.length
val x1080 = x1078 + x1079
val x1081 = x1074.isRow
val x1082 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1080,x1081)
var x1084 : Int = 0
val x1088 = while (x1084 < x1078) {
val x1085 = x1074(x1084)
val x1086 = x1082(x1084) = x1085
x1086
x1084 = x1084 + 1
}
var x1090 : Int = 0
val x1095 = while (x1090 < x1079) {
val x1091 = x1090 + x1078
val x1092 = x1075(x1090)
val x1093 = x1082(x1091) = x1092
x1093
x1090 = x1090 + 1
}
x1082
}
if (x1077) {
x1097thenb()
} else { 
x1097elseb()
}
}
x1097
}
if (x1076) {
x1099thenb()
} else { 
x1099elseb()
}
}
x1099
}
x1101
}
mapReduceIdx += 1
} // end mapReduce loop x1102
x1074
}
val x1102 = x1102_block
x1102
}
x1104 = {
val x1106 = x1104.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1131 = { 
val x1129 = {
def x1129thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1105
}
def x1129elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1107 = x1105.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1127 = {
def x1127thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1104
}
def x1127elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1108 = x1104.length
val x1109 = x1105.length
val x1110 = x1108 + x1109
val x1111 = x1104.isRow
val x1112 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1110,x1111)
var x1114 : Int = 0
val x1118 = while (x1114 < x1108) {
val x1115 = x1104(x1114)
val x1116 = x1112(x1114) = x1115
x1116
x1114 = x1114 + 1
}
var x1120 : Int = 0
val x1125 = while (x1120 < x1109) {
val x1121 = x1120 + x1108
val x1122 = x1105(x1120)
val x1123 = x1112(x1121) = x1122
x1123
x1120 = x1120 + 1
}
x1112
}
if (x1107) {
x1127thenb()
} else { 
x1127elseb()
}
}
x1127
}
if (x1106) {
x1129thenb()
} else { 
x1129elseb()
}
}
x1129
}
x1131
}
mapReduceIdx += 1
} // end mapReduce loop x1132
x1104
}
val x1132 = x1132_block
x1132
}
x1133 = {
val x1135 = x1133.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1160 = { 
val x1158 = {
def x1158thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1134
}
def x1158elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1136 = x1134.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1156 = {
def x1156thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1133
}
def x1156elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1137 = x1133.length
val x1138 = x1134.length
val x1139 = x1137 + x1138
val x1140 = x1133.isRow
val x1141 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1139,x1140)
var x1143 : Int = 0
val x1147 = while (x1143 < x1137) {
val x1144 = x1133(x1143)
val x1145 = x1141(x1143) = x1144
x1145
x1143 = x1143 + 1
}
var x1149 : Int = 0
val x1154 = while (x1149 < x1138) {
val x1150 = x1149 + x1137
val x1151 = x1134(x1149)
val x1152 = x1141(x1150) = x1151
x1152
x1149 = x1149 + 1
}
x1141
}
if (x1136) {
x1156thenb()
} else { 
x1156elseb()
}
}
x1156
}
if (x1135) {
x1158thenb()
} else { 
x1158elseb()
}
}
x1158
}
x1160
}
mapReduceIdx += 1
} // end mapReduce loop x1161
x1133
}
val x1161 = x1161_block
val x1162 = x1161.length
val x1163 = "Detections: "+x1162
val x1164 = println(x1163)
x1161
}
var mapReduceIdx = 1
while (mapReduceIdx < x224.size) { // begin mapReduce loop x1194
val x878 = x224.dcApply(mapReduceIdx)
val x1167 = {
val x879 = x878._1
val x881 = "Name: "+x879
val x882 = println(x881)
val x880 = x878._2
val x883 = x880.length
val x884 = "Templates: "+x883
val x885 = println(x884)
val x972 = new generated.scala.IndexVectorRangeImpl(0,x883)
def x1161_block = {
val x892 = x891.dcApply(0)
var x1133 = {
val x914 = x892 - 15
val x915 = x914 < 0
val x919 = {
def x919thenb(): scala.Tuple2[Int, Int] = {
val x916 = 15 - x892
val x917 = (0,x916)
x917
}
def x919elseb(): scala.Tuple2[Int, Int] = {
val x918 = (x914,0)
x918
}
if (x915) {
x919thenb()
} else { 
x919elseb()
}
}
val x920 = x919._1
val x922 = x892 + 15
val x923 = x922 > x889
val x924 = {
def x924thenb(): Int = {
x889
}
def x924elseb(): Int = {
x922
}
if (x923) {
x924thenb()
} else { 
x924elseb()
}
}
val x921 = x919._2
def x1132_block = {
val x896 = x895.dcApply(0)
var x1104 = {
val x900 = new generated.scala.IntVectorImpl(900,false)
val x901 = new generated.scala.IndexVectorSeqImpl(0)
val x902 = new generated.scala.BinarizedGradientTemplate(15,null,null,x886,x900,x901,null,null,null)
var x925: Int = x920
val x903 = x896 - 15
val x904 = x903 < 0
val x908 = {
def x908thenb(): scala.Tuple2[Int, Int] = {
val x905 = 15 - x896
val x906 = (0,x905)
x906
}
def x908elseb(): scala.Tuple2[Int, Int] = {
val x907 = (x903,0)
x907
}
if (x904) {
x908thenb()
} else { 
x908elseb()
}
}
val x909 = x908._1
val x911 = x896 + 15
val x912 = x911 > x893
val x913 = {
def x913thenb(): Int = {
x893
}
def x913elseb(): Int = {
x911
}
if (x912) {
x913thenb()
} else { 
x913elseb()
}
}
val x910 = x908._2
val x944 = x902.binary_gradients
val x957 = x902.match_list
val x958 = x957.length
val x967 = while ({val x926 = x925
val x927 = x926 < x924
x927}) {
val x929 = x925
var x931: Int = x909
val x947 = x929 * x893
val x964 = while ({val x932 = x931
val x933 = x932 < x913
x933}) {
val x935 = x925
val x939 = x931
val x936 = x921 + x935
val x937 = x936 - x920
val x938 = x937 * 30
val x940 = x910 + x939
val x941 = x940 - x909
val x942 = x938 + x941
var x943: Int = x942
val x945 = x943
val x946 = x931
val x948 = x947 + x946
val x949 = x888.dcApply(x948)
val x950 = { 
x949
}
val x951 = x944(x945) = x950
val x952 = x931
val x953 = x947 + x952
val x954 = x888.dcApply(x953)
val x955 = { 
x954
}
val x956 = x955 > 0
val x961 = {
def x961thenb(): Unit = {
val x959 = x957.insert(x958, x945)
x959
}
if (x956) {
x961thenb()
}
}
val x962 = x931 += 1
()
}
val x965 = x925 += 1
()
}
val x968 = x958 < 0
val x971 = {
def x971thenb(): Unit = {
val x969 = println("dummy")
x969
}
if (x968) {
x971thenb()
}
}
val x976 = x902.radius
def x1102_block = {
val x973 = x972.dcApply(0)
var x1074 = {
val x974 = x880(x973)
val x975 = x974.radius
val x977 = x975 != x976
val x1052 = {
def x1052thenb(): Float = {
-1.0f
}
def x1052elseb(): Float = {
val x978 = x974.match_list
val x979 = x978.length
val x980 = x979.asInstanceOf[Float]
val x981 = x980==0.0
val x1050 = {
def x1050thenb(): Float = {
-1.0f
}
def x1050elseb(): Float = {
val x982 = x958.asInstanceOf[Float]
val x983 = x982 / x980
val x984 = x983 < 0.82f
val x1048 = {
def x1048thenb(): Float = {
x983
}
def x1048elseb(): Float = {
var x985: Float = 0.0f
val x986 = x980 * 0.18f
val x987 = x986 + 0.5f
val x988 = x987.asInstanceOf[Int]
var x989: Int = x988
var x990: Int = 0
var x991: Boolean = true
val x999 = x974.binary_gradients
val x1039 = while ({val x992 = x990
val x994 = x991
val x993 = x992 < x979
val x995 = x993 && x994
x995}) {
val x997 = x990
val x1000 = x990
val x1004 = x990
val x1001 = x978(x1000)
val x1002 = x999(x1001)
val x1003 = x1002==0
val x1005 = x978(x1004)
val x1006 = x944(x1005)
val x1007 = x1006==0
val x1008 = x1003 && x1007
val x1036 = {
def x1036thenb(): Unit = {
val x1009 = x985
val x1010 = x1009 + 1.0f
x985 = x1010
()
}
def x1036elseb(): Unit = {
val x1013 = x990
val x1016 = x990
val x1014 = x978(x1013)
val x1015 = x999(x1014)
val x1017 = x978(x1016)
val x1018 = x944(x1017)
val x1019 = x1015 & x1018
val x1020 = x1019 > 0
val x1034 = {
def x1034thenb(): Unit = {
val x1021 = x985
val x1022 = x1021 + 1.0f
x985 = x1022
()
}
def x1034elseb(): Unit = {
val x1025 = x989
val x1026 = x1025 - 1
x989 = x1026
val x1028 = x989
val x1029 = x1028 <= 0
val x1032 = {
def x1032thenb(): Unit = {
x991 = false
()
}
if (x1029) {
x1032thenb()
}
}
x1032
}
if (x1020) {
x1034thenb()
} else { 
x1034elseb()
}
}
x1034
}
if (x1008) {
x1036thenb()
} else { 
x1036elseb()
}
}
val x1037 = x990 += 1
()
}
val x1040 = x991
val x1041 = !x1040
val x1046 = {
def x1046thenb(): Float = {
0.819999f
}
def x1046elseb(): Float = {
val x1042 = x985
val x1043 = x1042 / x980
val x1044 = x1043.asInstanceOf[Float]
x1044
}
if (x1041) {
x1046thenb()
} else { 
x1046elseb()
}
}
x1046
}
if (x984) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
if (x981) {
x1050thenb()
} else { 
x1050elseb()
}
}
x1050
}
if (x977) {
x1052thenb()
} else { 
x1052elseb()
}
}
val x1053 = x1052 > 0.82f
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1054 = x974.rect
val x1056 = x1054.width
val x897 = x886
val x898 = Math.pow(2.0,x897)
val x899 = x898.asInstanceOf[Int]
val x1055 = x899 * x896
val x1057 = x1056 / 2
val x1058 = x1055 - x1057
val x1059 = x1058.asInstanceOf[Int]
val x1061 = x1054.height
val x1060 = x899 * x892
val x1062 = x1061 / 2
val x1063 = x1060 - x1062
val x1064 = x1063.asInstanceOf[Int]
val x1065 = new generated.scala.Rect(x1059,x1064,x1056,x1061)
val x1066 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1067 = new generated.scala.BiGGDetection(x879,x1052,x1065,null,x973,x896,x892,x974,x902)
val x1068 = x1066(0) = x1067
x1066
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1070 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1070
}
if (x1053) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
var mapReduceIdx = 1
while (mapReduceIdx < x972.size) { // begin mapReduce loop x1102
val x973 = x972.dcApply(mapReduceIdx)
val x1075 = {
val x974 = x880(x973)
val x975 = x974.radius
val x977 = x975 != x976
val x1052 = {
def x1052thenb(): Float = {
-1.0f
}
def x1052elseb(): Float = {
val x978 = x974.match_list
val x979 = x978.length
val x980 = x979.asInstanceOf[Float]
val x981 = x980==0.0
val x1050 = {
def x1050thenb(): Float = {
-1.0f
}
def x1050elseb(): Float = {
val x982 = x958.asInstanceOf[Float]
val x983 = x982 / x980
val x984 = x983 < 0.82f
val x1048 = {
def x1048thenb(): Float = {
x983
}
def x1048elseb(): Float = {
var x985: Float = 0.0f
val x986 = x980 * 0.18f
val x987 = x986 + 0.5f
val x988 = x987.asInstanceOf[Int]
var x989: Int = x988
var x990: Int = 0
var x991: Boolean = true
val x999 = x974.binary_gradients
val x1039 = while ({val x992 = x990
val x994 = x991
val x993 = x992 < x979
val x995 = x993 && x994
x995}) {
val x997 = x990
val x1000 = x990
val x1004 = x990
val x1001 = x978(x1000)
val x1002 = x999(x1001)
val x1003 = x1002==0
val x1005 = x978(x1004)
val x1006 = x944(x1005)
val x1007 = x1006==0
val x1008 = x1003 && x1007
val x1036 = {
def x1036thenb(): Unit = {
val x1009 = x985
val x1010 = x1009 + 1.0f
x985 = x1010
()
}
def x1036elseb(): Unit = {
val x1013 = x990
val x1016 = x990
val x1014 = x978(x1013)
val x1015 = x999(x1014)
val x1017 = x978(x1016)
val x1018 = x944(x1017)
val x1019 = x1015 & x1018
val x1020 = x1019 > 0
val x1034 = {
def x1034thenb(): Unit = {
val x1021 = x985
val x1022 = x1021 + 1.0f
x985 = x1022
()
}
def x1034elseb(): Unit = {
val x1025 = x989
val x1026 = x1025 - 1
x989 = x1026
val x1028 = x989
val x1029 = x1028 <= 0
val x1032 = {
def x1032thenb(): Unit = {
x991 = false
()
}
if (x1029) {
x1032thenb()
}
}
x1032
}
if (x1020) {
x1034thenb()
} else { 
x1034elseb()
}
}
x1034
}
if (x1008) {
x1036thenb()
} else { 
x1036elseb()
}
}
val x1037 = x990 += 1
()
}
val x1040 = x991
val x1041 = !x1040
val x1046 = {
def x1046thenb(): Float = {
0.819999f
}
def x1046elseb(): Float = {
val x1042 = x985
val x1043 = x1042 / x980
val x1044 = x1043.asInstanceOf[Float]
x1044
}
if (x1041) {
x1046thenb()
} else { 
x1046elseb()
}
}
x1046
}
if (x984) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
if (x981) {
x1050thenb()
} else { 
x1050elseb()
}
}
x1050
}
if (x977) {
x1052thenb()
} else { 
x1052elseb()
}
}
val x1053 = x1052 > 0.82f
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1054 = x974.rect
val x1056 = x1054.width
val x897 = x886
val x898 = Math.pow(2.0,x897)
val x899 = x898.asInstanceOf[Int]
val x1055 = x899 * x896
val x1057 = x1056 / 2
val x1058 = x1055 - x1057
val x1059 = x1058.asInstanceOf[Int]
val x1061 = x1054.height
val x1060 = x899 * x892
val x1062 = x1061 / 2
val x1063 = x1060 - x1062
val x1064 = x1063.asInstanceOf[Int]
val x1065 = new generated.scala.Rect(x1059,x1064,x1056,x1061)
val x1066 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1067 = new generated.scala.BiGGDetection(x879,x1052,x1065,null,x973,x896,x892,x974,x902)
val x1068 = x1066(0) = x1067
x1066
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1070 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1070
}
if (x1053) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
x1074 = {
val x1076 = x1074.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1101 = { 
val x1099 = {
def x1099thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1075
}
def x1099elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1077 = x1075.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1097 = {
def x1097thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1074
}
def x1097elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1078 = x1074.length
val x1079 = x1075.length
val x1080 = x1078 + x1079
val x1081 = x1074.isRow
val x1082 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1080,x1081)
var x1084 : Int = 0
val x1088 = while (x1084 < x1078) {
val x1085 = x1074(x1084)
val x1086 = x1082(x1084) = x1085
x1086
x1084 = x1084 + 1
}
var x1090 : Int = 0
val x1095 = while (x1090 < x1079) {
val x1091 = x1090 + x1078
val x1092 = x1075(x1090)
val x1093 = x1082(x1091) = x1092
x1093
x1090 = x1090 + 1
}
x1082
}
if (x1077) {
x1097thenb()
} else { 
x1097elseb()
}
}
x1097
}
if (x1076) {
x1099thenb()
} else { 
x1099elseb()
}
}
x1099
}
x1101
}
mapReduceIdx += 1
} // end mapReduce loop x1102
x1074
}
val x1102 = x1102_block
x1102
}
var mapReduceIdx = 1
while (mapReduceIdx < x895.size) { // begin mapReduce loop x1132
val x896 = x895.dcApply(mapReduceIdx)
val x1105 = {
val x900 = new generated.scala.IntVectorImpl(900,false)
val x901 = new generated.scala.IndexVectorSeqImpl(0)
val x902 = new generated.scala.BinarizedGradientTemplate(15,null,null,x886,x900,x901,null,null,null)
var x925: Int = x920
val x903 = x896 - 15
val x904 = x903 < 0
val x908 = {
def x908thenb(): scala.Tuple2[Int, Int] = {
val x905 = 15 - x896
val x906 = (0,x905)
x906
}
def x908elseb(): scala.Tuple2[Int, Int] = {
val x907 = (x903,0)
x907
}
if (x904) {
x908thenb()
} else { 
x908elseb()
}
}
val x909 = x908._1
val x911 = x896 + 15
val x912 = x911 > x893
val x913 = {
def x913thenb(): Int = {
x893
}
def x913elseb(): Int = {
x911
}
if (x912) {
x913thenb()
} else { 
x913elseb()
}
}
val x910 = x908._2
val x944 = x902.binary_gradients
val x957 = x902.match_list
val x958 = x957.length
val x967 = while ({val x926 = x925
val x927 = x926 < x924
x927}) {
val x929 = x925
var x931: Int = x909
val x947 = x929 * x893
val x964 = while ({val x932 = x931
val x933 = x932 < x913
x933}) {
val x935 = x925
val x939 = x931
val x936 = x921 + x935
val x937 = x936 - x920
val x938 = x937 * 30
val x940 = x910 + x939
val x941 = x940 - x909
val x942 = x938 + x941
var x943: Int = x942
val x945 = x943
val x946 = x931
val x948 = x947 + x946
val x949 = x888.dcApply(x948)
val x950 = { 
x949
}
val x951 = x944(x945) = x950
val x952 = x931
val x953 = x947 + x952
val x954 = x888.dcApply(x953)
val x955 = { 
x954
}
val x956 = x955 > 0
val x961 = {
def x961thenb(): Unit = {
val x959 = x957.insert(x958, x945)
x959
}
if (x956) {
x961thenb()
}
}
val x962 = x931 += 1
()
}
val x965 = x925 += 1
()
}
val x968 = x958 < 0
val x971 = {
def x971thenb(): Unit = {
val x969 = println("dummy")
x969
}
if (x968) {
x971thenb()
}
}
val x976 = x902.radius
def x1102_block = {
val x973 = x972.dcApply(0)
var x1074 = {
val x974 = x880(x973)
val x975 = x974.radius
val x977 = x975 != x976
val x1052 = {
def x1052thenb(): Float = {
-1.0f
}
def x1052elseb(): Float = {
val x978 = x974.match_list
val x979 = x978.length
val x980 = x979.asInstanceOf[Float]
val x981 = x980==0.0
val x1050 = {
def x1050thenb(): Float = {
-1.0f
}
def x1050elseb(): Float = {
val x982 = x958.asInstanceOf[Float]
val x983 = x982 / x980
val x984 = x983 < 0.82f
val x1048 = {
def x1048thenb(): Float = {
x983
}
def x1048elseb(): Float = {
var x985: Float = 0.0f
val x986 = x980 * 0.18f
val x987 = x986 + 0.5f
val x988 = x987.asInstanceOf[Int]
var x989: Int = x988
var x990: Int = 0
var x991: Boolean = true
val x999 = x974.binary_gradients
val x1039 = while ({val x992 = x990
val x994 = x991
val x993 = x992 < x979
val x995 = x993 && x994
x995}) {
val x997 = x990
val x1000 = x990
val x1004 = x990
val x1001 = x978(x1000)
val x1002 = x999(x1001)
val x1003 = x1002==0
val x1005 = x978(x1004)
val x1006 = x944(x1005)
val x1007 = x1006==0
val x1008 = x1003 && x1007
val x1036 = {
def x1036thenb(): Unit = {
val x1009 = x985
val x1010 = x1009 + 1.0f
x985 = x1010
()
}
def x1036elseb(): Unit = {
val x1013 = x990
val x1016 = x990
val x1014 = x978(x1013)
val x1015 = x999(x1014)
val x1017 = x978(x1016)
val x1018 = x944(x1017)
val x1019 = x1015 & x1018
val x1020 = x1019 > 0
val x1034 = {
def x1034thenb(): Unit = {
val x1021 = x985
val x1022 = x1021 + 1.0f
x985 = x1022
()
}
def x1034elseb(): Unit = {
val x1025 = x989
val x1026 = x1025 - 1
x989 = x1026
val x1028 = x989
val x1029 = x1028 <= 0
val x1032 = {
def x1032thenb(): Unit = {
x991 = false
()
}
if (x1029) {
x1032thenb()
}
}
x1032
}
if (x1020) {
x1034thenb()
} else { 
x1034elseb()
}
}
x1034
}
if (x1008) {
x1036thenb()
} else { 
x1036elseb()
}
}
val x1037 = x990 += 1
()
}
val x1040 = x991
val x1041 = !x1040
val x1046 = {
def x1046thenb(): Float = {
0.819999f
}
def x1046elseb(): Float = {
val x1042 = x985
val x1043 = x1042 / x980
val x1044 = x1043.asInstanceOf[Float]
x1044
}
if (x1041) {
x1046thenb()
} else { 
x1046elseb()
}
}
x1046
}
if (x984) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
if (x981) {
x1050thenb()
} else { 
x1050elseb()
}
}
x1050
}
if (x977) {
x1052thenb()
} else { 
x1052elseb()
}
}
val x1053 = x1052 > 0.82f
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1054 = x974.rect
val x1056 = x1054.width
val x897 = x886
val x898 = Math.pow(2.0,x897)
val x899 = x898.asInstanceOf[Int]
val x1055 = x899 * x896
val x1057 = x1056 / 2
val x1058 = x1055 - x1057
val x1059 = x1058.asInstanceOf[Int]
val x1061 = x1054.height
val x1060 = x899 * x892
val x1062 = x1061 / 2
val x1063 = x1060 - x1062
val x1064 = x1063.asInstanceOf[Int]
val x1065 = new generated.scala.Rect(x1059,x1064,x1056,x1061)
val x1066 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1067 = new generated.scala.BiGGDetection(x879,x1052,x1065,null,x973,x896,x892,x974,x902)
val x1068 = x1066(0) = x1067
x1066
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1070 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1070
}
if (x1053) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
var mapReduceIdx = 1
while (mapReduceIdx < x972.size) { // begin mapReduce loop x1102
val x973 = x972.dcApply(mapReduceIdx)
val x1075 = {
val x974 = x880(x973)
val x975 = x974.radius
val x977 = x975 != x976
val x1052 = {
def x1052thenb(): Float = {
-1.0f
}
def x1052elseb(): Float = {
val x978 = x974.match_list
val x979 = x978.length
val x980 = x979.asInstanceOf[Float]
val x981 = x980==0.0
val x1050 = {
def x1050thenb(): Float = {
-1.0f
}
def x1050elseb(): Float = {
val x982 = x958.asInstanceOf[Float]
val x983 = x982 / x980
val x984 = x983 < 0.82f
val x1048 = {
def x1048thenb(): Float = {
x983
}
def x1048elseb(): Float = {
var x985: Float = 0.0f
val x986 = x980 * 0.18f
val x987 = x986 + 0.5f
val x988 = x987.asInstanceOf[Int]
var x989: Int = x988
var x990: Int = 0
var x991: Boolean = true
val x999 = x974.binary_gradients
val x1039 = while ({val x992 = x990
val x994 = x991
val x993 = x992 < x979
val x995 = x993 && x994
x995}) {
val x997 = x990
val x1000 = x990
val x1004 = x990
val x1001 = x978(x1000)
val x1002 = x999(x1001)
val x1003 = x1002==0
val x1005 = x978(x1004)
val x1006 = x944(x1005)
val x1007 = x1006==0
val x1008 = x1003 && x1007
val x1036 = {
def x1036thenb(): Unit = {
val x1009 = x985
val x1010 = x1009 + 1.0f
x985 = x1010
()
}
def x1036elseb(): Unit = {
val x1013 = x990
val x1016 = x990
val x1014 = x978(x1013)
val x1015 = x999(x1014)
val x1017 = x978(x1016)
val x1018 = x944(x1017)
val x1019 = x1015 & x1018
val x1020 = x1019 > 0
val x1034 = {
def x1034thenb(): Unit = {
val x1021 = x985
val x1022 = x1021 + 1.0f
x985 = x1022
()
}
def x1034elseb(): Unit = {
val x1025 = x989
val x1026 = x1025 - 1
x989 = x1026
val x1028 = x989
val x1029 = x1028 <= 0
val x1032 = {
def x1032thenb(): Unit = {
x991 = false
()
}
if (x1029) {
x1032thenb()
}
}
x1032
}
if (x1020) {
x1034thenb()
} else { 
x1034elseb()
}
}
x1034
}
if (x1008) {
x1036thenb()
} else { 
x1036elseb()
}
}
val x1037 = x990 += 1
()
}
val x1040 = x991
val x1041 = !x1040
val x1046 = {
def x1046thenb(): Float = {
0.819999f
}
def x1046elseb(): Float = {
val x1042 = x985
val x1043 = x1042 / x980
val x1044 = x1043.asInstanceOf[Float]
x1044
}
if (x1041) {
x1046thenb()
} else { 
x1046elseb()
}
}
x1046
}
if (x984) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
if (x981) {
x1050thenb()
} else { 
x1050elseb()
}
}
x1050
}
if (x977) {
x1052thenb()
} else { 
x1052elseb()
}
}
val x1053 = x1052 > 0.82f
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1054 = x974.rect
val x1056 = x1054.width
val x897 = x886
val x898 = Math.pow(2.0,x897)
val x899 = x898.asInstanceOf[Int]
val x1055 = x899 * x896
val x1057 = x1056 / 2
val x1058 = x1055 - x1057
val x1059 = x1058.asInstanceOf[Int]
val x1061 = x1054.height
val x1060 = x899 * x892
val x1062 = x1061 / 2
val x1063 = x1060 - x1062
val x1064 = x1063.asInstanceOf[Int]
val x1065 = new generated.scala.Rect(x1059,x1064,x1056,x1061)
val x1066 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1067 = new generated.scala.BiGGDetection(x879,x1052,x1065,null,x973,x896,x892,x974,x902)
val x1068 = x1066(0) = x1067
x1066
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1070 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1070
}
if (x1053) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
x1074 = {
val x1076 = x1074.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1101 = { 
val x1099 = {
def x1099thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1075
}
def x1099elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1077 = x1075.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1097 = {
def x1097thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1074
}
def x1097elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1078 = x1074.length
val x1079 = x1075.length
val x1080 = x1078 + x1079
val x1081 = x1074.isRow
val x1082 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1080,x1081)
var x1084 : Int = 0
val x1088 = while (x1084 < x1078) {
val x1085 = x1074(x1084)
val x1086 = x1082(x1084) = x1085
x1086
x1084 = x1084 + 1
}
var x1090 : Int = 0
val x1095 = while (x1090 < x1079) {
val x1091 = x1090 + x1078
val x1092 = x1075(x1090)
val x1093 = x1082(x1091) = x1092
x1093
x1090 = x1090 + 1
}
x1082
}
if (x1077) {
x1097thenb()
} else { 
x1097elseb()
}
}
x1097
}
if (x1076) {
x1099thenb()
} else { 
x1099elseb()
}
}
x1099
}
x1101
}
mapReduceIdx += 1
} // end mapReduce loop x1102
x1074
}
val x1102 = x1102_block
x1102
}
x1104 = {
val x1106 = x1104.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1131 = { 
val x1129 = {
def x1129thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1105
}
def x1129elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1107 = x1105.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1127 = {
def x1127thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1104
}
def x1127elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1108 = x1104.length
val x1109 = x1105.length
val x1110 = x1108 + x1109
val x1111 = x1104.isRow
val x1112 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1110,x1111)
var x1114 : Int = 0
val x1118 = while (x1114 < x1108) {
val x1115 = x1104(x1114)
val x1116 = x1112(x1114) = x1115
x1116
x1114 = x1114 + 1
}
var x1120 : Int = 0
val x1125 = while (x1120 < x1109) {
val x1121 = x1120 + x1108
val x1122 = x1105(x1120)
val x1123 = x1112(x1121) = x1122
x1123
x1120 = x1120 + 1
}
x1112
}
if (x1107) {
x1127thenb()
} else { 
x1127elseb()
}
}
x1127
}
if (x1106) {
x1129thenb()
} else { 
x1129elseb()
}
}
x1129
}
x1131
}
mapReduceIdx += 1
} // end mapReduce loop x1132
x1104
}
val x1132 = x1132_block
x1132
}
var mapReduceIdx = 1
while (mapReduceIdx < x891.size) { // begin mapReduce loop x1161
val x892 = x891.dcApply(mapReduceIdx)
val x1134 = {
val x914 = x892 - 15
val x915 = x914 < 0
val x919 = {
def x919thenb(): scala.Tuple2[Int, Int] = {
val x916 = 15 - x892
val x917 = (0,x916)
x917
}
def x919elseb(): scala.Tuple2[Int, Int] = {
val x918 = (x914,0)
x918
}
if (x915) {
x919thenb()
} else { 
x919elseb()
}
}
val x920 = x919._1
val x922 = x892 + 15
val x923 = x922 > x889
val x924 = {
def x924thenb(): Int = {
x889
}
def x924elseb(): Int = {
x922
}
if (x923) {
x924thenb()
} else { 
x924elseb()
}
}
val x921 = x919._2
def x1132_block = {
val x896 = x895.dcApply(0)
var x1104 = {
val x900 = new generated.scala.IntVectorImpl(900,false)
val x901 = new generated.scala.IndexVectorSeqImpl(0)
val x902 = new generated.scala.BinarizedGradientTemplate(15,null,null,x886,x900,x901,null,null,null)
var x925: Int = x920
val x903 = x896 - 15
val x904 = x903 < 0
val x908 = {
def x908thenb(): scala.Tuple2[Int, Int] = {
val x905 = 15 - x896
val x906 = (0,x905)
x906
}
def x908elseb(): scala.Tuple2[Int, Int] = {
val x907 = (x903,0)
x907
}
if (x904) {
x908thenb()
} else { 
x908elseb()
}
}
val x909 = x908._1
val x911 = x896 + 15
val x912 = x911 > x893
val x913 = {
def x913thenb(): Int = {
x893
}
def x913elseb(): Int = {
x911
}
if (x912) {
x913thenb()
} else { 
x913elseb()
}
}
val x910 = x908._2
val x944 = x902.binary_gradients
val x957 = x902.match_list
val x958 = x957.length
val x967 = while ({val x926 = x925
val x927 = x926 < x924
x927}) {
val x929 = x925
var x931: Int = x909
val x947 = x929 * x893
val x964 = while ({val x932 = x931
val x933 = x932 < x913
x933}) {
val x935 = x925
val x939 = x931
val x936 = x921 + x935
val x937 = x936 - x920
val x938 = x937 * 30
val x940 = x910 + x939
val x941 = x940 - x909
val x942 = x938 + x941
var x943: Int = x942
val x945 = x943
val x946 = x931
val x948 = x947 + x946
val x949 = x888.dcApply(x948)
val x950 = { 
x949
}
val x951 = x944(x945) = x950
val x952 = x931
val x953 = x947 + x952
val x954 = x888.dcApply(x953)
val x955 = { 
x954
}
val x956 = x955 > 0
val x961 = {
def x961thenb(): Unit = {
val x959 = x957.insert(x958, x945)
x959
}
if (x956) {
x961thenb()
}
}
val x962 = x931 += 1
()
}
val x965 = x925 += 1
()
}
val x968 = x958 < 0
val x971 = {
def x971thenb(): Unit = {
val x969 = println("dummy")
x969
}
if (x968) {
x971thenb()
}
}
val x976 = x902.radius
def x1102_block = {
val x973 = x972.dcApply(0)
var x1074 = {
val x974 = x880(x973)
val x975 = x974.radius
val x977 = x975 != x976
val x1052 = {
def x1052thenb(): Float = {
-1.0f
}
def x1052elseb(): Float = {
val x978 = x974.match_list
val x979 = x978.length
val x980 = x979.asInstanceOf[Float]
val x981 = x980==0.0
val x1050 = {
def x1050thenb(): Float = {
-1.0f
}
def x1050elseb(): Float = {
val x982 = x958.asInstanceOf[Float]
val x983 = x982 / x980
val x984 = x983 < 0.82f
val x1048 = {
def x1048thenb(): Float = {
x983
}
def x1048elseb(): Float = {
var x985: Float = 0.0f
val x986 = x980 * 0.18f
val x987 = x986 + 0.5f
val x988 = x987.asInstanceOf[Int]
var x989: Int = x988
var x990: Int = 0
var x991: Boolean = true
val x999 = x974.binary_gradients
val x1039 = while ({val x992 = x990
val x994 = x991
val x993 = x992 < x979
val x995 = x993 && x994
x995}) {
val x997 = x990
val x1000 = x990
val x1004 = x990
val x1001 = x978(x1000)
val x1002 = x999(x1001)
val x1003 = x1002==0
val x1005 = x978(x1004)
val x1006 = x944(x1005)
val x1007 = x1006==0
val x1008 = x1003 && x1007
val x1036 = {
def x1036thenb(): Unit = {
val x1009 = x985
val x1010 = x1009 + 1.0f
x985 = x1010
()
}
def x1036elseb(): Unit = {
val x1013 = x990
val x1016 = x990
val x1014 = x978(x1013)
val x1015 = x999(x1014)
val x1017 = x978(x1016)
val x1018 = x944(x1017)
val x1019 = x1015 & x1018
val x1020 = x1019 > 0
val x1034 = {
def x1034thenb(): Unit = {
val x1021 = x985
val x1022 = x1021 + 1.0f
x985 = x1022
()
}
def x1034elseb(): Unit = {
val x1025 = x989
val x1026 = x1025 - 1
x989 = x1026
val x1028 = x989
val x1029 = x1028 <= 0
val x1032 = {
def x1032thenb(): Unit = {
x991 = false
()
}
if (x1029) {
x1032thenb()
}
}
x1032
}
if (x1020) {
x1034thenb()
} else { 
x1034elseb()
}
}
x1034
}
if (x1008) {
x1036thenb()
} else { 
x1036elseb()
}
}
val x1037 = x990 += 1
()
}
val x1040 = x991
val x1041 = !x1040
val x1046 = {
def x1046thenb(): Float = {
0.819999f
}
def x1046elseb(): Float = {
val x1042 = x985
val x1043 = x1042 / x980
val x1044 = x1043.asInstanceOf[Float]
x1044
}
if (x1041) {
x1046thenb()
} else { 
x1046elseb()
}
}
x1046
}
if (x984) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
if (x981) {
x1050thenb()
} else { 
x1050elseb()
}
}
x1050
}
if (x977) {
x1052thenb()
} else { 
x1052elseb()
}
}
val x1053 = x1052 > 0.82f
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1054 = x974.rect
val x1056 = x1054.width
val x897 = x886
val x898 = Math.pow(2.0,x897)
val x899 = x898.asInstanceOf[Int]
val x1055 = x899 * x896
val x1057 = x1056 / 2
val x1058 = x1055 - x1057
val x1059 = x1058.asInstanceOf[Int]
val x1061 = x1054.height
val x1060 = x899 * x892
val x1062 = x1061 / 2
val x1063 = x1060 - x1062
val x1064 = x1063.asInstanceOf[Int]
val x1065 = new generated.scala.Rect(x1059,x1064,x1056,x1061)
val x1066 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1067 = new generated.scala.BiGGDetection(x879,x1052,x1065,null,x973,x896,x892,x974,x902)
val x1068 = x1066(0) = x1067
x1066
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1070 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1070
}
if (x1053) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
var mapReduceIdx = 1
while (mapReduceIdx < x972.size) { // begin mapReduce loop x1102
val x973 = x972.dcApply(mapReduceIdx)
val x1075 = {
val x974 = x880(x973)
val x975 = x974.radius
val x977 = x975 != x976
val x1052 = {
def x1052thenb(): Float = {
-1.0f
}
def x1052elseb(): Float = {
val x978 = x974.match_list
val x979 = x978.length
val x980 = x979.asInstanceOf[Float]
val x981 = x980==0.0
val x1050 = {
def x1050thenb(): Float = {
-1.0f
}
def x1050elseb(): Float = {
val x982 = x958.asInstanceOf[Float]
val x983 = x982 / x980
val x984 = x983 < 0.82f
val x1048 = {
def x1048thenb(): Float = {
x983
}
def x1048elseb(): Float = {
var x985: Float = 0.0f
val x986 = x980 * 0.18f
val x987 = x986 + 0.5f
val x988 = x987.asInstanceOf[Int]
var x989: Int = x988
var x990: Int = 0
var x991: Boolean = true
val x999 = x974.binary_gradients
val x1039 = while ({val x992 = x990
val x994 = x991
val x993 = x992 < x979
val x995 = x993 && x994
x995}) {
val x997 = x990
val x1000 = x990
val x1004 = x990
val x1001 = x978(x1000)
val x1002 = x999(x1001)
val x1003 = x1002==0
val x1005 = x978(x1004)
val x1006 = x944(x1005)
val x1007 = x1006==0
val x1008 = x1003 && x1007
val x1036 = {
def x1036thenb(): Unit = {
val x1009 = x985
val x1010 = x1009 + 1.0f
x985 = x1010
()
}
def x1036elseb(): Unit = {
val x1013 = x990
val x1016 = x990
val x1014 = x978(x1013)
val x1015 = x999(x1014)
val x1017 = x978(x1016)
val x1018 = x944(x1017)
val x1019 = x1015 & x1018
val x1020 = x1019 > 0
val x1034 = {
def x1034thenb(): Unit = {
val x1021 = x985
val x1022 = x1021 + 1.0f
x985 = x1022
()
}
def x1034elseb(): Unit = {
val x1025 = x989
val x1026 = x1025 - 1
x989 = x1026
val x1028 = x989
val x1029 = x1028 <= 0
val x1032 = {
def x1032thenb(): Unit = {
x991 = false
()
}
if (x1029) {
x1032thenb()
}
}
x1032
}
if (x1020) {
x1034thenb()
} else { 
x1034elseb()
}
}
x1034
}
if (x1008) {
x1036thenb()
} else { 
x1036elseb()
}
}
val x1037 = x990 += 1
()
}
val x1040 = x991
val x1041 = !x1040
val x1046 = {
def x1046thenb(): Float = {
0.819999f
}
def x1046elseb(): Float = {
val x1042 = x985
val x1043 = x1042 / x980
val x1044 = x1043.asInstanceOf[Float]
x1044
}
if (x1041) {
x1046thenb()
} else { 
x1046elseb()
}
}
x1046
}
if (x984) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
if (x981) {
x1050thenb()
} else { 
x1050elseb()
}
}
x1050
}
if (x977) {
x1052thenb()
} else { 
x1052elseb()
}
}
val x1053 = x1052 > 0.82f
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1054 = x974.rect
val x1056 = x1054.width
val x897 = x886
val x898 = Math.pow(2.0,x897)
val x899 = x898.asInstanceOf[Int]
val x1055 = x899 * x896
val x1057 = x1056 / 2
val x1058 = x1055 - x1057
val x1059 = x1058.asInstanceOf[Int]
val x1061 = x1054.height
val x1060 = x899 * x892
val x1062 = x1061 / 2
val x1063 = x1060 - x1062
val x1064 = x1063.asInstanceOf[Int]
val x1065 = new generated.scala.Rect(x1059,x1064,x1056,x1061)
val x1066 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1067 = new generated.scala.BiGGDetection(x879,x1052,x1065,null,x973,x896,x892,x974,x902)
val x1068 = x1066(0) = x1067
x1066
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1070 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1070
}
if (x1053) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
x1074 = {
val x1076 = x1074.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1101 = { 
val x1099 = {
def x1099thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1075
}
def x1099elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1077 = x1075.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1097 = {
def x1097thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1074
}
def x1097elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1078 = x1074.length
val x1079 = x1075.length
val x1080 = x1078 + x1079
val x1081 = x1074.isRow
val x1082 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1080,x1081)
var x1084 : Int = 0
val x1088 = while (x1084 < x1078) {
val x1085 = x1074(x1084)
val x1086 = x1082(x1084) = x1085
x1086
x1084 = x1084 + 1
}
var x1090 : Int = 0
val x1095 = while (x1090 < x1079) {
val x1091 = x1090 + x1078
val x1092 = x1075(x1090)
val x1093 = x1082(x1091) = x1092
x1093
x1090 = x1090 + 1
}
x1082
}
if (x1077) {
x1097thenb()
} else { 
x1097elseb()
}
}
x1097
}
if (x1076) {
x1099thenb()
} else { 
x1099elseb()
}
}
x1099
}
x1101
}
mapReduceIdx += 1
} // end mapReduce loop x1102
x1074
}
val x1102 = x1102_block
x1102
}
var mapReduceIdx = 1
while (mapReduceIdx < x895.size) { // begin mapReduce loop x1132
val x896 = x895.dcApply(mapReduceIdx)
val x1105 = {
val x900 = new generated.scala.IntVectorImpl(900,false)
val x901 = new generated.scala.IndexVectorSeqImpl(0)
val x902 = new generated.scala.BinarizedGradientTemplate(15,null,null,x886,x900,x901,null,null,null)
var x925: Int = x920
val x903 = x896 - 15
val x904 = x903 < 0
val x908 = {
def x908thenb(): scala.Tuple2[Int, Int] = {
val x905 = 15 - x896
val x906 = (0,x905)
x906
}
def x908elseb(): scala.Tuple2[Int, Int] = {
val x907 = (x903,0)
x907
}
if (x904) {
x908thenb()
} else { 
x908elseb()
}
}
val x909 = x908._1
val x911 = x896 + 15
val x912 = x911 > x893
val x913 = {
def x913thenb(): Int = {
x893
}
def x913elseb(): Int = {
x911
}
if (x912) {
x913thenb()
} else { 
x913elseb()
}
}
val x910 = x908._2
val x944 = x902.binary_gradients
val x957 = x902.match_list
val x958 = x957.length
val x967 = while ({val x926 = x925
val x927 = x926 < x924
x927}) {
val x929 = x925
var x931: Int = x909
val x947 = x929 * x893
val x964 = while ({val x932 = x931
val x933 = x932 < x913
x933}) {
val x935 = x925
val x939 = x931
val x936 = x921 + x935
val x937 = x936 - x920
val x938 = x937 * 30
val x940 = x910 + x939
val x941 = x940 - x909
val x942 = x938 + x941
var x943: Int = x942
val x945 = x943
val x946 = x931
val x948 = x947 + x946
val x949 = x888.dcApply(x948)
val x950 = { 
x949
}
val x951 = x944(x945) = x950
val x952 = x931
val x953 = x947 + x952
val x954 = x888.dcApply(x953)
val x955 = { 
x954
}
val x956 = x955 > 0
val x961 = {
def x961thenb(): Unit = {
val x959 = x957.insert(x958, x945)
x959
}
if (x956) {
x961thenb()
}
}
val x962 = x931 += 1
()
}
val x965 = x925 += 1
()
}
val x968 = x958 < 0
val x971 = {
def x971thenb(): Unit = {
val x969 = println("dummy")
x969
}
if (x968) {
x971thenb()
}
}
val x976 = x902.radius
def x1102_block = {
val x973 = x972.dcApply(0)
var x1074 = {
val x974 = x880(x973)
val x975 = x974.radius
val x977 = x975 != x976
val x1052 = {
def x1052thenb(): Float = {
-1.0f
}
def x1052elseb(): Float = {
val x978 = x974.match_list
val x979 = x978.length
val x980 = x979.asInstanceOf[Float]
val x981 = x980==0.0
val x1050 = {
def x1050thenb(): Float = {
-1.0f
}
def x1050elseb(): Float = {
val x982 = x958.asInstanceOf[Float]
val x983 = x982 / x980
val x984 = x983 < 0.82f
val x1048 = {
def x1048thenb(): Float = {
x983
}
def x1048elseb(): Float = {
var x985: Float = 0.0f
val x986 = x980 * 0.18f
val x987 = x986 + 0.5f
val x988 = x987.asInstanceOf[Int]
var x989: Int = x988
var x990: Int = 0
var x991: Boolean = true
val x999 = x974.binary_gradients
val x1039 = while ({val x992 = x990
val x994 = x991
val x993 = x992 < x979
val x995 = x993 && x994
x995}) {
val x997 = x990
val x1000 = x990
val x1004 = x990
val x1001 = x978(x1000)
val x1002 = x999(x1001)
val x1003 = x1002==0
val x1005 = x978(x1004)
val x1006 = x944(x1005)
val x1007 = x1006==0
val x1008 = x1003 && x1007
val x1036 = {
def x1036thenb(): Unit = {
val x1009 = x985
val x1010 = x1009 + 1.0f
x985 = x1010
()
}
def x1036elseb(): Unit = {
val x1013 = x990
val x1016 = x990
val x1014 = x978(x1013)
val x1015 = x999(x1014)
val x1017 = x978(x1016)
val x1018 = x944(x1017)
val x1019 = x1015 & x1018
val x1020 = x1019 > 0
val x1034 = {
def x1034thenb(): Unit = {
val x1021 = x985
val x1022 = x1021 + 1.0f
x985 = x1022
()
}
def x1034elseb(): Unit = {
val x1025 = x989
val x1026 = x1025 - 1
x989 = x1026
val x1028 = x989
val x1029 = x1028 <= 0
val x1032 = {
def x1032thenb(): Unit = {
x991 = false
()
}
if (x1029) {
x1032thenb()
}
}
x1032
}
if (x1020) {
x1034thenb()
} else { 
x1034elseb()
}
}
x1034
}
if (x1008) {
x1036thenb()
} else { 
x1036elseb()
}
}
val x1037 = x990 += 1
()
}
val x1040 = x991
val x1041 = !x1040
val x1046 = {
def x1046thenb(): Float = {
0.819999f
}
def x1046elseb(): Float = {
val x1042 = x985
val x1043 = x1042 / x980
val x1044 = x1043.asInstanceOf[Float]
x1044
}
if (x1041) {
x1046thenb()
} else { 
x1046elseb()
}
}
x1046
}
if (x984) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
if (x981) {
x1050thenb()
} else { 
x1050elseb()
}
}
x1050
}
if (x977) {
x1052thenb()
} else { 
x1052elseb()
}
}
val x1053 = x1052 > 0.82f
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1054 = x974.rect
val x1056 = x1054.width
val x897 = x886
val x898 = Math.pow(2.0,x897)
val x899 = x898.asInstanceOf[Int]
val x1055 = x899 * x896
val x1057 = x1056 / 2
val x1058 = x1055 - x1057
val x1059 = x1058.asInstanceOf[Int]
val x1061 = x1054.height
val x1060 = x899 * x892
val x1062 = x1061 / 2
val x1063 = x1060 - x1062
val x1064 = x1063.asInstanceOf[Int]
val x1065 = new generated.scala.Rect(x1059,x1064,x1056,x1061)
val x1066 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1067 = new generated.scala.BiGGDetection(x879,x1052,x1065,null,x973,x896,x892,x974,x902)
val x1068 = x1066(0) = x1067
x1066
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1070 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1070
}
if (x1053) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
var mapReduceIdx = 1
while (mapReduceIdx < x972.size) { // begin mapReduce loop x1102
val x973 = x972.dcApply(mapReduceIdx)
val x1075 = {
val x974 = x880(x973)
val x975 = x974.radius
val x977 = x975 != x976
val x1052 = {
def x1052thenb(): Float = {
-1.0f
}
def x1052elseb(): Float = {
val x978 = x974.match_list
val x979 = x978.length
val x980 = x979.asInstanceOf[Float]
val x981 = x980==0.0
val x1050 = {
def x1050thenb(): Float = {
-1.0f
}
def x1050elseb(): Float = {
val x982 = x958.asInstanceOf[Float]
val x983 = x982 / x980
val x984 = x983 < 0.82f
val x1048 = {
def x1048thenb(): Float = {
x983
}
def x1048elseb(): Float = {
var x985: Float = 0.0f
val x986 = x980 * 0.18f
val x987 = x986 + 0.5f
val x988 = x987.asInstanceOf[Int]
var x989: Int = x988
var x990: Int = 0
var x991: Boolean = true
val x999 = x974.binary_gradients
val x1039 = while ({val x992 = x990
val x994 = x991
val x993 = x992 < x979
val x995 = x993 && x994
x995}) {
val x997 = x990
val x1000 = x990
val x1004 = x990
val x1001 = x978(x1000)
val x1002 = x999(x1001)
val x1003 = x1002==0
val x1005 = x978(x1004)
val x1006 = x944(x1005)
val x1007 = x1006==0
val x1008 = x1003 && x1007
val x1036 = {
def x1036thenb(): Unit = {
val x1009 = x985
val x1010 = x1009 + 1.0f
x985 = x1010
()
}
def x1036elseb(): Unit = {
val x1013 = x990
val x1016 = x990
val x1014 = x978(x1013)
val x1015 = x999(x1014)
val x1017 = x978(x1016)
val x1018 = x944(x1017)
val x1019 = x1015 & x1018
val x1020 = x1019 > 0
val x1034 = {
def x1034thenb(): Unit = {
val x1021 = x985
val x1022 = x1021 + 1.0f
x985 = x1022
()
}
def x1034elseb(): Unit = {
val x1025 = x989
val x1026 = x1025 - 1
x989 = x1026
val x1028 = x989
val x1029 = x1028 <= 0
val x1032 = {
def x1032thenb(): Unit = {
x991 = false
()
}
if (x1029) {
x1032thenb()
}
}
x1032
}
if (x1020) {
x1034thenb()
} else { 
x1034elseb()
}
}
x1034
}
if (x1008) {
x1036thenb()
} else { 
x1036elseb()
}
}
val x1037 = x990 += 1
()
}
val x1040 = x991
val x1041 = !x1040
val x1046 = {
def x1046thenb(): Float = {
0.819999f
}
def x1046elseb(): Float = {
val x1042 = x985
val x1043 = x1042 / x980
val x1044 = x1043.asInstanceOf[Float]
x1044
}
if (x1041) {
x1046thenb()
} else { 
x1046elseb()
}
}
x1046
}
if (x984) {
x1048thenb()
} else { 
x1048elseb()
}
}
x1048
}
if (x981) {
x1050thenb()
} else { 
x1050elseb()
}
}
x1050
}
if (x977) {
x1052thenb()
} else { 
x1052elseb()
}
}
val x1053 = x1052 > 0.82f
val x1072 = {
def x1072thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1054 = x974.rect
val x1056 = x1054.width
val x897 = x886
val x898 = Math.pow(2.0,x897)
val x899 = x898.asInstanceOf[Int]
val x1055 = x899 * x896
val x1057 = x1056 / 2
val x1058 = x1055 - x1057
val x1059 = x1058.asInstanceOf[Int]
val x1061 = x1054.height
val x1060 = x899 * x892
val x1062 = x1061 / 2
val x1063 = x1060 - x1062
val x1064 = x1063.asInstanceOf[Int]
val x1065 = new generated.scala.Rect(x1059,x1064,x1056,x1061)
val x1066 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1067 = new generated.scala.BiGGDetection(x879,x1052,x1065,null,x973,x896,x892,x974,x902)
val x1068 = x1066(0) = x1067
x1066
}
def x1072elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1070 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1070
}
if (x1053) {
x1072thenb()
} else { 
x1072elseb()
}
}
x1072
}
x1074 = {
val x1076 = x1074.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1101 = { 
val x1099 = {
def x1099thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1075
}
def x1099elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1077 = x1075.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1097 = {
def x1097thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1074
}
def x1097elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1078 = x1074.length
val x1079 = x1075.length
val x1080 = x1078 + x1079
val x1081 = x1074.isRow
val x1082 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1080,x1081)
var x1084 : Int = 0
val x1088 = while (x1084 < x1078) {
val x1085 = x1074(x1084)
val x1086 = x1082(x1084) = x1085
x1086
x1084 = x1084 + 1
}
var x1090 : Int = 0
val x1095 = while (x1090 < x1079) {
val x1091 = x1090 + x1078
val x1092 = x1075(x1090)
val x1093 = x1082(x1091) = x1092
x1093
x1090 = x1090 + 1
}
x1082
}
if (x1077) {
x1097thenb()
} else { 
x1097elseb()
}
}
x1097
}
if (x1076) {
x1099thenb()
} else { 
x1099elseb()
}
}
x1099
}
x1101
}
mapReduceIdx += 1
} // end mapReduce loop x1102
x1074
}
val x1102 = x1102_block
x1102
}
x1104 = {
val x1106 = x1104.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1131 = { 
val x1129 = {
def x1129thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1105
}
def x1129elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1107 = x1105.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1127 = {
def x1127thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1104
}
def x1127elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1108 = x1104.length
val x1109 = x1105.length
val x1110 = x1108 + x1109
val x1111 = x1104.isRow
val x1112 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1110,x1111)
var x1114 : Int = 0
val x1118 = while (x1114 < x1108) {
val x1115 = x1104(x1114)
val x1116 = x1112(x1114) = x1115
x1116
x1114 = x1114 + 1
}
var x1120 : Int = 0
val x1125 = while (x1120 < x1109) {
val x1121 = x1120 + x1108
val x1122 = x1105(x1120)
val x1123 = x1112(x1121) = x1122
x1123
x1120 = x1120 + 1
}
x1112
}
if (x1107) {
x1127thenb()
} else { 
x1127elseb()
}
}
x1127
}
if (x1106) {
x1129thenb()
} else { 
x1129elseb()
}
}
x1129
}
x1131
}
mapReduceIdx += 1
} // end mapReduce loop x1132
x1104
}
val x1132 = x1132_block
x1132
}
x1133 = {
val x1135 = x1133.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1160 = { 
val x1158 = {
def x1158thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1134
}
def x1158elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1136 = x1134.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1156 = {
def x1156thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1133
}
def x1156elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1137 = x1133.length
val x1138 = x1134.length
val x1139 = x1137 + x1138
val x1140 = x1133.isRow
val x1141 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1139,x1140)
var x1143 : Int = 0
val x1147 = while (x1143 < x1137) {
val x1144 = x1133(x1143)
val x1145 = x1141(x1143) = x1144
x1145
x1143 = x1143 + 1
}
var x1149 : Int = 0
val x1154 = while (x1149 < x1138) {
val x1150 = x1149 + x1137
val x1151 = x1134(x1149)
val x1152 = x1141(x1150) = x1151
x1152
x1149 = x1149 + 1
}
x1141
}
if (x1136) {
x1156thenb()
} else { 
x1156elseb()
}
}
x1156
}
if (x1135) {
x1158thenb()
} else { 
x1158elseb()
}
}
x1158
}
x1160
}
mapReduceIdx += 1
} // end mapReduce loop x1161
x1133
}
val x1161 = x1161_block
val x1162 = x1161.length
val x1163 = "Detections: "+x1162
val x1164 = println(x1163)
x1161
}
x1166 = {
val x1168 = x1166.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1193 = { 
val x1191 = {
def x1191thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1167
}
def x1191elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1169 = x1167.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1189 = {
def x1189thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1166
}
def x1189elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1170 = x1166.length
val x1171 = x1167.length
val x1172 = x1170 + x1171
val x1173 = x1166.isRow
val x1174 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1172,x1173)
var x1176 : Int = 0
val x1180 = while (x1176 < x1170) {
val x1177 = x1166(x1176)
val x1178 = x1174(x1176) = x1177
x1178
x1176 = x1176 + 1
}
var x1182 : Int = 0
val x1187 = while (x1182 < x1171) {
val x1183 = x1182 + x1170
val x1184 = x1167(x1182)
val x1185 = x1174(x1183) = x1184
x1185
x1182 = x1182 + 1
}
x1174
}
if (x1169) {
x1189thenb()
} else { 
x1189elseb()
}
}
x1189
}
if (x1168) {
x1191thenb()
} else { 
x1191elseb()
}
}
x1191
}
x1193
}
mapReduceIdx += 1
} // end mapReduce loop x1194
x1166
}
val x1194 = x1194_block
val x1195 = x1194.length
var x1196: Int = x1195
val x1197 = x1196
val x1198 = "Detections before NMS: "+x1197
val x1199 = println(x1198)
var x1200: Int = 0
val x1314 = while ({val x1201 = x1200
val x1202 = x1196
val x1203 = x1202 - 1
val x1204 = x1201 < x1203
x1204}) {
val x1206 = x1200
val x1207 = x1206 + 1
var x1208: Int = x1207
var x1209: Boolean = false
val x1311 = while ({val x1210 = x1208
val x1211 = x1196
val x1213 = x1209
val x1212 = x1210 < x1211
val x1214 = x1213==false
val x1215 = x1212 && x1214
x1215}) {
val x1217 = x1200
val x1220 = x1208
val x1218 = x1194(x1217)
val x1219 = x1218.roi
val x1223 = x1219.x
val x1221 = x1194(x1220)
val x1222 = x1221.roi
val x1224 = x1222.x
val x1225 = x1222.width
val x1226 = x1224 + x1225
val x1227 = x1223 < x1226
val x1228 = x1219.width
val x1229 = x1223 + x1228
val x1230 = x1229 > x1224
val x1231 = x1227 && x1230
val x1232 = x1219.y
val x1233 = x1219.height
val x1234 = x1232 + x1233
val x1235 = x1222.y
val x1236 = x1234 > x1235
val x1237 = x1231 && x1236
val x1238 = x1222.height
val x1239 = x1235 + x1238
val x1240 = x1232 < x1239
val x1241 = x1237 && x1240
val x1262 = {
def x1262thenb(): Float = {
val x1248 = x1232 > x1235
val x1249 = {
def x1249thenb(): Int = {
x1232
}
def x1249elseb(): Int = {
x1235
}
if (x1248) {
x1249thenb()
} else { 
x1249elseb()
}
}
val x1253 = x1234 < x1239
val x1254 = {
def x1254thenb(): Int = {
x1234
}
def x1254elseb(): Int = {
x1239
}
if (x1253) {
x1254thenb()
} else { 
x1254elseb()
}
}
val x1255 = x1254 - x1249
val x1256 = x1255
val x1257 = 2.0f * x1256
val x1246 = x1223 > x1224
val x1247 = {
def x1247thenb(): Int = {
x1223
}
def x1247elseb(): Int = {
x1224
}
if (x1246) {
x1247thenb()
} else { 
x1247elseb()
}
}
val x1250 = x1229 < x1226
val x1251 = {
def x1251thenb(): Int = {
x1229
}
def x1251elseb(): Int = {
x1226
}
if (x1250) {
x1251thenb()
} else { 
x1251elseb()
}
}
val x1252 = x1251 - x1247
val x1258 = x1252
val x1259 = x1257 * x1258
val x1242 = x1238 * x1225
val x1243 = x1228 * x1233
val x1244 = x1242 + x1243
val x1245 = x1244
val x1260 = x1245 + 1.0E-6f
val x1261 = x1259 / x1260
x1261
}
def x1262elseb(): Float = {
0.0f
}
if (x1241) {
x1262thenb()
} else { 
x1262elseb()
}
}
val x1263 = x1262 > 0.6f
val x1308 = {
def x1308thenb(): Unit = {
val x1264 = x1200
val x1267 = x1208
val x1265 = x1194(x1264)
val x1266 = x1265.score
val x1268 = x1194(x1267)
val x1269 = x1268.score
val x1270 = x1266 >= x1269
val x1306 = {
def x1306thenb(): Unit = {
val x1271 = x1196
val x1274 = x1196
val x1276 = x1208
val x1275 = x1274 - 1
val x1277 = x1194(x1276)
val x1278 = x1194(x1275) = x1277
val x1279 = x1208
val x1272 = x1271 - 1
val x1273 = x1194(x1272)
val x1280 = x1194(x1279) = x1273
val x1281 = x1196
val x1282 = x1281 - 1
x1196 = x1282
val x1284 = x1208
val x1285 = x1284 - 1
x1208 = x1285
()
}
def x1306elseb(): Unit = {
val x1288 = x1196
val x1291 = x1196
val x1293 = x1200
val x1292 = x1291 - 1
val x1294 = x1194(x1293)
val x1295 = x1194(x1292) = x1294
val x1296 = x1200
val x1289 = x1288 - 1
val x1290 = x1194(x1289)
val x1297 = x1194(x1296) = x1290
val x1298 = x1196
val x1299 = x1298 - 1
x1196 = x1299
val x1301 = x1200
val x1302 = x1301 - 1
x1200 = x1302
x1209 = true
()
}
if (x1270) {
x1306thenb()
} else { 
x1306elseb()
}
}
x1306
}
if (x1263) {
x1308thenb()
}
}
val x1309 = x1208 += 1
()
}
val x1312 = x1200 += 1
()
}
val x1315 = x1196
val x1316 = x1315 - 0
val x1317 = x1194.isRow
val x1327 = { 
val x1318 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1316,x1317)
var x1320 : Int = 0
val x1325 = while (x1320 < x1315) {
val x1321 = x1320 - 0
val x1322 = x1194(x1320)
val x1323 = x1318(x1321) = x1322
x1323
x1320 = x1320 + 1
}
x1318
}
val x1328 = x1327.length
val x1329 = "Total detections: "+x1328
val x1330 = println(x1329)
val x1331 = x227 += 1
()
}
val x1334 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
