/*****************************************
  Emitting Generated Code                  
*******************************************/
class LBPDenoiseRunner extends ((Array[java.lang.String])=>(Unit)) {
def apply(x0:Array[java.lang.String]): Unit = {
val x1 = x0.length
val x2 = x1 < 1
val x7 = {
def x7thenb(): Nothing = {
val x3 = println("Usage: LBPDenoise <rows> <cols>")
val x4 = println("Example: LBPDenoise 100 100")
val x5 = exit(-1)
x5
}
if (x2) {
x7thenb()
}
}
var x8: Int = 100
var x9: Int = 100
var x10: java.lang.String = "laplace"
val x11 = new generated.scala.DoubleMatrixImpl(5,5)
val x12 = x11.cloneL
val x13 = x0(0)
val x14 = java.lang.Integer.parseInt(x13)
val x15 = x0(1)
val x16 = java.lang.Integer.parseInt(x15)
val x17 = new generated.scala.DoubleMatrixImpl(x14,x16)
val x18 = x17.numRows
val x21 = x17.numCols
var x27: Int = 0
var x28: Int = 0
val x24 = Math.min(x18, x21)
val x25 = x24.asInstanceOf[Double]
val x26 = x25 / 2.0
val x19 = x18.asInstanceOf[Double]
val x20 = x19 / 2.0
val x22 = x21.asInstanceOf[Double]
val x23 = x22 / 2.0
val x60 = 4
val x77 = while ({val x29 = x27
val x30 = x17.numRows
val x31 = x29 < x30
x31}) {
x28 = 0
val x74 = while ({val x34 = x28
val x35 = x17.numCols
val x36 = x34 < x35
x36}) {
val x38 = x27
val x41 = x27
val x45 = x28
val x48 = x28
val x54 = x27
val x55 = x17.numRows
val x56 = x55 / 2
val x57 = x54 < x56
val x71 = {
def x71thenb(): Unit = {
val x63 = x27
val x64 = x28
val x39 = x38.asInstanceOf[Double]
val x40 = x39 - x20
val x42 = x41.asInstanceOf[Double]
val x43 = x42 - x20
val x44 = x40 * x43
val x46 = x45.asInstanceOf[Double]
val x47 = x46 - x23
val x49 = x48.asInstanceOf[Double]
val x50 = x49 - x23
val x51 = x47 * x50
val x52 = x44 + x51
val x53 = Math.sqrt(x52)
val x58 = x53 / x26
val x59 = Math.min(1.0, x58)
val x61 = x59 * x60
val x62 = Math.floor(x61)
val x65 = x17(x63, x64) = x62
x65
}
def x71elseb(): Unit = {
val x67 = x27
val x68 = x28
val x69 = x17(x67, x68) = 0.0
x69
}
if (x57) {
x71thenb()
} else { 
x71elseb()
}
}
val x72 = x28 += 1
()
}
val x75 = x27 += 1
()
}
val x710 = List()
val x117 = { 
val x78 = new java.io.FileWriter("src.pgm")
val x79 = new java.io.BufferedWriter(x78)
val x80 = x79.write("P2\n")
val x81 = x17.numCols
val x82 = java.lang.String.valueOf(x81)
val x83 = x79.write(x82)
val x84 = x79.write(" ")
val x85 = x17.numRows
val x86 = java.lang.String.valueOf(x85)
val x87 = x86+"\n"
val x88 = x79.write(x87)
val x89 = x79.write("255\n")
val x93 = x17.numRows
val x94 = x17.numCols
val x104 = x17.numRows
val x105 = x17.numCols
val x113 = x17.numRows
val x95 = x93 * x94
var x90 = 0
val x96 = x17.dcApply(x90)
var x100: Double = {
if (x95 == 0) {1.7976931348623157E308}
else {
val x96 = x17.dcApply(x90)
x96
}
}
x90 = 1
while (x90 < x95) {  // begin fat loop x100
val x96 = x17.dcApply(x90)
val x91 = x100
val x92 = x96
val x98 = x91 < x92
val x99 = {
def x99thenb(): Double = {
x91
}
def x99elseb(): Double = {
x92
}
if (x98) {
x99thenb()
} else { 
x99elseb()
}
}
x100 = x99
x90 += 1
} // end fat loop x100
val x106 = x104 * x105
var x101 = 0
val x107 = x17.dcApply(x101)
var x111: Double = {
if (x106 == 0) {-1.7976931348623157E308}
else {
val x107 = x17.dcApply(x101)
x107
}
}
x101 = 1
while (x101 < x106) {  // begin fat loop x111
val x107 = x17.dcApply(x101)
val x102 = x111
val x103 = x107
val x109 = x102 > x103
val x110 = {
def x110thenb(): Double = {
x102
}
def x110elseb(): Double = {
x103
}
if (x109) {
x110thenb()
} else { 
x110elseb()
}
}
x111 = x110
x101 += 1
} // end fat loop x111
val x1033 = x100 != x111
val x1036 = x111 - x100
// a *thin* loop follows: x114
var x112 = 0
var x114: Unit = {
val x1025 = x17.getRow(x112)
val x1028 = x1025.length
// a *thin* loop follows: x1029
var x1026 = 0
var x1029: Unit = {
val x1032 = x1025.dcApply(x1026)
val x1044 = {
def x1044thenb(): Unit = {
val x1034 = x1032 - x100
val x1035 = 255.0 * x1034
val x1037 = x1035 / x1036
val x1038 = x1037.asInstanceOf[Int]
val x1039 = x1038+""
val x1040 = x79.write(x1039)
x1040
}
def x1044elseb(): Unit = {
val x1042 = x79.write("0")
x1042
}
if (x1033) {
x1044thenb()
} else { 
x1044elseb()
}
}
val x1045 = x79.write("\t")
x1045
}
x1026 = 1
while (x1026 < x1028) {  // begin fat loop x1029
x1029 = {
val x1032 = x1025.dcApply(x1026)
val x1044 = {
def x1044thenb(): Unit = {
val x1034 = x1032 - x100
val x1035 = 255.0 * x1034
val x1037 = x1035 / x1036
val x1038 = x1037.asInstanceOf[Int]
val x1039 = x1038+""
val x1040 = x79.write(x1039)
x1040
}
def x1044elseb(): Unit = {
val x1042 = x79.write("0")
x1042
}
if (x1033) {
x1044thenb()
} else { 
x1044elseb()
}
}
val x1045 = x79.write("\t")
x1045
}
x1026 += 1
} // end fat loop x1029
val x1030 = x79.write("\n")
x1030
}
x112 = 1
while (x112 < x113) {  // begin fat loop x114
x114 = {
val x1025 = x17.getRow(x112)
val x1028 = x1025.length
// a *thin* loop follows: x1029
var x1026 = 0
var x1029: Unit = {
val x1032 = x1025.dcApply(x1026)
val x1044 = {
def x1044thenb(): Unit = {
val x1034 = x1032 - x100
val x1035 = 255.0 * x1034
val x1037 = x1035 / x1036
val x1038 = x1037.asInstanceOf[Int]
val x1039 = x1038+""
val x1040 = x79.write(x1039)
x1040
}
def x1044elseb(): Unit = {
val x1042 = x79.write("0")
x1042
}
if (x1033) {
x1044thenb()
} else { 
x1044elseb()
}
}
val x1045 = x79.write("\t")
x1045
}
x1026 = 1
while (x1026 < x1028) {  // begin fat loop x1029
x1029 = {
val x1032 = x1025.dcApply(x1026)
val x1044 = {
def x1044thenb(): Unit = {
val x1034 = x1032 - x100
val x1035 = 255.0 * x1034
val x1037 = x1035 / x1036
val x1038 = x1037.asInstanceOf[Int]
val x1039 = x1038+""
val x1040 = x79.write(x1039)
x1040
}
def x1044elseb(): Unit = {
val x1042 = x79.write("0")
x1042
}
if (x1033) {
x1044thenb()
} else { 
x1044elseb()
}
}
val x1045 = x79.write("\t")
x1045
}
x1026 += 1
} // end fat loop x1029
val x1030 = x79.write("\n")
x1030
}
x112 += 1
} // end fat loop x114
val x115 = x79.close()
x115
}
val x120 = x17.numRows
val x121 = x17.numCols
val x122 = x120 * x121
val x118 = 2
// a *thin* loop follows: x128
var x119 = 0
val x123 = x17.dcApply(x119)
val x124 = generated.scala.Global.randRef.nextGaussian()
val x125 = x124 * x118
val x126 = x123 + x125
val x128 = {
x17
}
x128.dcUpdate(x119, x126)
x119 = 1
while (x119 < x122) {  // begin fat loop x128
val x123 = x17.dcApply(x119)
val x124 = generated.scala.Global.randRef.nextGaussian()
val x125 = x124 * x118
val x126 = x123 + x125
x128.dcUpdate(x119, x126)
x119 += 1
} // end fat loop x128
val x167 = x17.numRows
x8 = x167
val x169 = x17.numCols
x9 = x169
val x171 = x17.cloneL
val x172 = new generated.scala.UndirectedGraphImpl[generated.scala.MessageVertex, generated.scala.MessageEdge]()
val x173 = x171.numRows
val x174 = x171.numCols
val x175 = new generated.scala.MatrixImpl[generated.scala.MessageVertex](x173,x174)
var x176: Int = 0
var x177: Int = 0
val x278 = while ({val x178 = x176
val x179 = x171.numRows
val x180 = x178 < x179
x180}) {
x177 = 0
val x275 = while ({val x183 = x177
val x184 = x171.numCols
val x185 = x183 < x184
x185}) {
val x187 = x176
val x188 = x177
val x189 = x171.numCols
val x195 = { 
val x192 = new generated.scala.DoubleVectorImpl(5,true)
x192
}
val x196 = x176
val x197 = x177
val x203 = { 
val x198 = x171.numCols
val x199 = x196 * x198
val x200 = x199 + x197
val x201 = x171.dcApply(x200)
x201
}
var x204: Int = 0
val x221 = while ({val x205 = x204
val x206 = x205 < 5
x206}) {
val x208 = x204
val x209 = x204
val x212 = x204
val x210 = x209
val x211 = x203 - x210
val x213 = x212
val x214 = x203 - x213
val x215 = x211 * x214
val x216 = x215 / 8.0
val x217 = 0.0 - x216
val x218 = x195(x208) = x217
val x219 = x204 += 1
()
}
// a *thin* loop follows: x229
var x222 = 0
val x226 = x195.dcApply(x222)
val x227 = Math.exp(x226)
val x229 = {
val x223 = x195.isRow
val x224 = new generated.scala.DoubleVectorImpl(5,x223)
x224
}
x229.dcUpdate(x222, x227)
x222 = 1
while (x222 < 5) {  // begin fat loop x229
val x226 = x195.dcApply(x222)
val x227 = Math.exp(x226)
x229.dcUpdate(x222, x227)
x222 += 1
} // end fat loop x229
var x230 = 0
val x233 = x229.dcApply(x230)
var x236: Double = {
if (5 == 0) {0.0}
else {
val x233 = x229.dcApply(x230)
x233
}
}
x230 = 1
while (x230 < 5) {  // begin fat loop x236
val x233 = x229.dcApply(x230)
val x231 = x236
val x232 = x233
val x235 = x231 + x232
x236 = x235
x230 += 1
} // end fat loop x236
val x237 = Math.log(x236)
// a *thin* loop follows: x242
var x238 = 0
val x239 = x195.dcApply(x238)
val x240 = x239 - x237
val x242 = {
x195
}
x242.dcUpdate(x238, x240)
x238 = 1
while (x238 < 5) {  // begin fat loop x242
val x239 = x195.dcApply(x238)
val x240 = x239 - x237
x242.dcUpdate(x238, x240)
x238 += 1
} // end fat loop x242
val x245 = { 
val x192 = new generated.scala.DoubleVectorImpl(5,true)
x192
}
// a *thin* loop follows: x253
var x246 = 0
val x250 = x245.dcApply(x246)
val x251 = Math.exp(x250)
val x253 = {
val x247 = x245.isRow
val x248 = new generated.scala.DoubleVectorImpl(5,x247)
x248
}
x253.dcUpdate(x246, x251)
x246 = 1
while (x246 < 5) {  // begin fat loop x253
val x250 = x245.dcApply(x246)
val x251 = Math.exp(x250)
x253.dcUpdate(x246, x251)
x246 += 1
} // end fat loop x253
var x254 = 0
val x257 = x253.dcApply(x254)
var x260: Double = {
if (5 == 0) {0.0}
else {
val x257 = x253.dcApply(x254)
x257
}
}
x254 = 1
while (x254 < 5) {  // begin fat loop x260
val x257 = x253.dcApply(x254)
val x255 = x260
val x256 = x257
val x259 = x255 + x256
x260 = x259
x254 += 1
} // end fat loop x260
val x261 = Math.log(x260)
// a *thin* loop follows: x266
var x262 = 0
val x263 = x245.dcApply(x262)
val x264 = x263 - x261
val x266 = {
x245
}
x266.dcUpdate(x262, x264)
x262 = 1
while (x262 < 5) {  // begin fat loop x266
val x263 = x245.dcApply(x262)
val x264 = x263 - x261
x266.dcUpdate(x262, x264)
x262 += 1
} // end fat loop x266
val x190 = x187 * x189
val x191 = x190 + x188
val x267 = new generated.scala.DenoiseVertexDataImpl(x191,x266,x195)
val x268 = new generated.scala.MessageVertexImpl(x172,x267)
val x269 = x176
val x270 = x177
val x271 = x175(x269, x270) = x268
val x272 = x172.addVertex(x268)
val x273 = x177 += 1
()
}
val x276 = x176 += 1
()
}
val x281 = { 
val x192 = new generated.scala.DoubleVectorImpl(5,true)
x192
}
// a *thin* loop follows: x289
var x282 = 0
val x286 = x281.dcApply(x282)
val x287 = Math.exp(x286)
val x289 = {
val x283 = x281.isRow
val x284 = new generated.scala.DoubleVectorImpl(5,x283)
x284
}
x289.dcUpdate(x282, x287)
x282 = 1
while (x282 < 5) {  // begin fat loop x289
val x286 = x281.dcApply(x282)
val x287 = Math.exp(x286)
x289.dcUpdate(x282, x287)
x282 += 1
} // end fat loop x289
var x290 = 0
val x293 = x289.dcApply(x290)
var x296: Double = {
if (5 == 0) {0.0}
else {
val x293 = x289.dcApply(x290)
x293
}
}
x290 = 1
while (x290 < 5) {  // begin fat loop x296
val x293 = x289.dcApply(x290)
val x291 = x296
val x292 = x293
val x295 = x291 + x292
x296 = x295
x290 += 1
} // end fat loop x296
val x297 = Math.log(x296)
// a *thin* loop follows: x302
var x298 = 0
val x299 = x281.dcApply(x298)
val x300 = x299 - x297
val x302 = {
x281
}
x302.dcUpdate(x298, x300)
x298 = 1
while (x298 < 5) {  // begin fat loop x302
val x299 = x281.dcApply(x298)
val x300 = x299 - x297
x302.dcUpdate(x298, x300)
x298 += 1
} // end fat loop x302
val x305 = { 
val x192 = new generated.scala.DoubleVectorImpl(5,true)
x192
}
// a *thin* loop follows: x313
var x306 = 0
val x310 = x305.dcApply(x306)
val x311 = Math.exp(x310)
val x313 = {
val x307 = x305.isRow
val x308 = new generated.scala.DoubleVectorImpl(5,x307)
x308
}
x313.dcUpdate(x306, x311)
x306 = 1
while (x306 < 5) {  // begin fat loop x313
val x310 = x305.dcApply(x306)
val x311 = Math.exp(x310)
x313.dcUpdate(x306, x311)
x306 += 1
} // end fat loop x313
var x314 = 0
val x317 = x313.dcApply(x314)
var x320: Double = {
if (5 == 0) {0.0}
else {
val x317 = x313.dcApply(x314)
x317
}
}
x314 = 1
while (x314 < 5) {  // begin fat loop x320
val x317 = x313.dcApply(x314)
val x315 = x320
val x316 = x317
val x319 = x315 + x316
x320 = x319
x314 += 1
} // end fat loop x320
val x321 = Math.log(x320)
// a *thin* loop follows: x326
var x322 = 0
val x323 = x305.dcApply(x322)
val x324 = x323 - x321
val x326 = {
x305
}
x326.dcUpdate(x322, x324)
x322 = 1
while (x322 < 5) {  // begin fat loop x326
val x323 = x305.dcApply(x322)
val x324 = x323 - x321
x326.dcUpdate(x322, x324)
x322 += 1
} // end fat loop x326
val x327 = new generated.scala.DenoiseEdgeDataImpl(x302,x326)
x176 = 0
val x592 = x10
val x593 = x592=="laplace"
val x594 = 10
val x640 = 0.0 - x594
val x657 = {
def x657thenb(): Unit = {
var x595: Int = 0
var x596: Int = 0
val x621 = while ({val x597 = x595
val x598 = x12.numRows
val x599 = x597 < x598
x599}) {
x596 = 0
val x618 = while ({val x602 = x596
val x603 = x12.numCols
val x604 = x602 < x603
x604}) {
val x606 = x595
val x607 = x596
val x608 = x595
val x609 = x596
val x610 = x608 - x609
val x611 = Math.abs(x610)
val x612 = x611
val x613 = x594 * x612
val x614 = 0.0 - x613
val x615 = x12(x606, x607) = x614
val x616 = x596 += 1
()
}
val x619 = x595 += 1
()
}
()
}
def x657elseb(): Unit = {
val x623 = x592=="square"
val x655 = {
def x655thenb(): Unit = {
var x624: Int = 0
var x625: Int = 0
val x653 = while ({val x626 = x624
val x627 = x12.numRows
val x628 = x626 < x627
x628}) {
x625 = 0
val x650 = while ({val x631 = x625
val x632 = x12.numCols
val x633 = x631 < x632
x633}) {
val x635 = x624
val x636 = x625
val x637 = x635 != x636
val x647 = {
def x647thenb(): Unit = {
val x638 = x624
val x639 = x625
val x641 = x12(x638, x639) = x640
x641
}
def x647elseb(): Unit = {
val x643 = x624
val x644 = x625
val x645 = x12(x643, x644) = 0.0
x645
}
if (x637) {
x647thenb()
} else { 
x647elseb()
}
}
val x648 = x625 += 1
()
}
val x651 = x624 += 1
()
}
()
}
if (x623) {
x655thenb()
}
}
x655
}
if (x593) {
x657thenb()
} else { 
x657elseb()
}
}
var x680: Int = 1
val x682 = Seq()
val x686 = collection.mutable.HashSet[generated.scala.MessageVertex]()
val x809 = scala.Double.MinValue
val x810 = Math.log(x809)
val x1021 = x680
val x1022 = "Update functions ran: "+x1021
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
