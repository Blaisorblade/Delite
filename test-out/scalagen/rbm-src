/*****************************************
  Emitting Generated Code                  
*******************************************/
class RBMRunner extends ((Array[java.lang.String])=>(Unit)) {
def apply(x0:Array[java.lang.String]): Unit = {
val x1 = { generated.scala.Global.randRef.setSeed(generated.scala.Global.INITIAL_SEED);   generated.scala.Global.intRandRef.setSeed(generated.scala.Global.INITIAL_SEED); }
val x2 = x0.length
val x3 = x2 < 3
val x7 = {
def x7thenb(): Nothing = {
val x4 = println("Usage: RBM <MNIST data file> <numHiddenUnits> <numcases>")
val x5 = exit(-1)
x5
}
if (x3) {
x7thenb()
}
}
val x8 = x0(1)
val x9 = java.lang.Integer.parseInt(x8)
val x10 = "Using "+x9
val x11 = x10+" hidden units."
val x12 = println(x11)
val x13 = println("Reading MNIST dataset")
val x16 = x0(0)
val x63 = { 
val x17 = new java.io.FileReader(x16)
val x18 = new java.io.BufferedReader(x17)
val x19 = x18.readLine()
var x20: java.lang.String = x19
val x21 = x20
val x22 = x21.trim()
x20 = x22
val x24 = x20
val x25 = x24.split("\\s+")
var x26: Array[java.lang.String] = x25
val x27 = x26
val x28 = x27.length
val x29 = new generated.scala.DoubleMatrixImpl(0,x28)
val x59 = while ({val x30 = x20
val x31 = x30 != null
x31}) {
val x33 = x26
val x34 = x33.length
val x35 = new generated.scala.DoubleVectorImpl(x34,true)
var x37 : Int = 0
val x43 = while (x37 < x34) {
val x38 = x26
val x39 = x38(x37)
val x40 = java.lang.Double.parseDouble(x39)
val x41 = x35(x37) = x40
x41
x37 = x37 + 1
}
val x44 = x35// unsafe immutable
val x45 = x29.numRows
val x46 = x29.insertRow(x45,x44)
val x47 = x18.readLine()
x20 = x47
val x49 = x20
val x50 = x49 != null
val x51 = x49.trim()
val x57 = {
def x57thenb(): Unit = {
x20 = x51
val x53 = x20
val x54 = x53.split("\\s+")
x26 = x54
()
}
if (x50) {
x57thenb()
}
}
x57
}
val x60 = x18.close()
val x61 = x29// unsafe immutable
x61
}
val x66 = x63.numRows
val x67 = x63.numCols
def x70_block = {
val x68 = new generated.scala.FloatMatrixImpl(x66,x67)
var mapIdx = 0
while (mapIdx < x63.size) { // begin map loop x70
val x64 = x63.dcApply(mapIdx)
x68.dcUpdate(mapIdx,  {
val x65 = x64.floatValue()
x65
})
mapIdx += 1
} // end map loop x70
x68
}
val x70 = x70_block
val x71 = x70.numCols
val x81 = { 
val x74 = new generated.scala.FloatMatrixImpl(x71,x9)
def x79_block = {
var mapIdx = 0
while (mapIdx < x74.size) { // begin map loop x79
val x75 = x74.dcApply(mapIdx)
x74.dcUpdate(mapIdx,  {
val x76 = generated.scala.Global.randRef.nextGaussian()
val x77 = x76.floatValue()
x77
})
mapIdx += 1
} // end map loop x79
x74
}
val x79 = x79_block
x79
}
val x82 = x81.numRows
val x83 = x81.numCols
def x88_block = {
val x84 = new generated.scala.FloatMatrixImpl(x82,x83)
var mapIdx = 0
while (mapIdx < x81.size) { // begin map loop x88
val x86 = x81.dcApply(mapIdx)
x84.dcUpdate(mapIdx,  {
val x87 = x86 * 0.1f
x87
})
mapIdx += 1
} // end map loop x88
x84
}
val x88 = x88_block
val x89 = x88.cloneL
val x93 = { 
val x90 = new generated.scala.FloatVectorImpl(x9,true)
x90
}
val x97 = { 
val x94 = new generated.scala.FloatVectorImpl(x71,true)
x94
}
val x100 = { 
val x98 = new generated.scala.FloatMatrixImpl(x71,x9)
x98
}
var x101: generated.scala.Matrix[Float] = x100
val x92 = { 
val x90 = new generated.scala.FloatVectorImpl(x9,true)
x90
}
var x104: generated.scala.Vector[Float] = x92
val x96 = { 
val x94 = new generated.scala.FloatVectorImpl(x71,true)
x94
}
var x107: generated.scala.Vector[Float] = x96
val x108 = Seq()
val x109 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
var x110: Int = 0
val x111 = x110
val x112 = x111 < 10
val x14 = x0(2)
val x15 = java.lang.Integer.parseInt(x14)
val x72 = x70.numRows
val x73 = x72 / x15
val x215 = List()
val x423 = { 
val x416 = new generated.scala.FloatMatrixImpl(x15,x9)
def x421_block = {
var mapIdx = 0
while (mapIdx < x416.size) { // begin map loop x421
val x417 = x416.dcApply(mapIdx)
x416.dcUpdate(mapIdx,  {
val x418 = generated.scala.Global.randRef.nextFloat()
val x419 = x418.asInstanceOf[Float]
x419
})
mapIdx += 1
} // end map loop x421
x416
}
val x421 = x421_block
x421
}
val x896 = x111 > 5
val x897 = {
def x897thenb(): Float = {
0.9f
}
def x897elseb(): Float = {
0.5f
}
if (x896) {
x897thenb()
} else { 
x897elseb()
}
}
val x914 = x15
val x971 = 0.1f / x914
val x1036 = "--> Epoch "+x111
val x1043 = while ({x112}) {
var x113: Float = 0.0f
var x114: Int = 0
val x115 = x114
val x116 = x115 < x73
val x117 = x115 * x15
val x118 = x115 + 1
val x119 = x118 * x15
val x120 = x119 - x117
val x142 = { 
val x121 = new generated.scala.FloatMatrixImpl(x120,x71)
var x122: Int = x117
val x123 = x122
val x124 = x123 < x119
val x128 = x123 - x117
val x129 = x123 * x71
val x139 = while ({x124}) {
var x125: Int = 0
val x126 = x125
val x127 = x126 < x71
val x130 = x129 + x126
val x131 = x70.dcApply(x130)
val x132 = { 
x131
}
val x136 = while ({x127}) {
val x133 = x121(x128, x126) = x132
val x134 = x125 += 1
()
}
val x137 = x122 += 1
()
}
val x140 = x121// unsafe immutable
x140
}
val x166 = x142.numRows
val x169 = new generated.scala.IndexVectorRangeImpl(0,x166)
val x177 = x142.numCols
val x312 = { 
val x294 = new generated.scala.FloatMatrixImpl(x177,x166)
val x295 = x294.numRows
var x297 : Int = 0
val x309 = while (x297 < x295) {
val x298 = x294.numCols
var x300 : Int = 0
val x307 = while (x300 < x298) {
val x301 = x300 * x177
val x302 = x301 + x297
val x303 = x142.dcApply(x302)
val x304 = { 
x303
}
val x305 = x294(x297, x300) = x304
x305
x300 = x300 + 1
}
x307
x297 = x297 + 1
}
val x310 = x294// unsafe immutable
x310
}
val x334 = x312.numRows
val x336 = new generated.scala.IndexVectorRangeImpl(0,x334)
val x344 = x312.numCols
val x399 = new generated.scala.IndexVectorRangeImpl(0,x177)
val x415 = { 
val x398 = new generated.scala.FloatVectorImpl(x177,true)
val x412 = {
var forIdx = 0
while (forIdx < x399.size) { // begin foreach loop x412
val x400 = x399.dcApply(forIdx)
val x401 = x142.getCol(x400)
val x402 = x401.length
var x408: Float = 0
var x403 = 0
while (x403 < x402) {  // begin fat loop x408
val x406 = x401(x403)
val x404 = x408
val x405 = x406
val x407 = x404 + x405
x408 = x407
x403 += 1
} // end fat loop x408
val x409 = x398(x400) = x408
x409
forIdx += 1
} // end foreach loop x412
}
val x413 = x398// unsafe immutable
x413
}
val x962 = x415.length
val x963 = x415.isRow
val x1035 = while ({x116}) {
val x219 = { 
val x165 = { 
val x143 = x89.numCols
val x144 = x89.numRows
val x145 = new generated.scala.FloatMatrixImpl(x143,x144)
val x146 = x145.numRows
var x148 : Int = 0
val x162 = while (x148 < x146) {
val x149 = x145.numCols
var x151 : Int = 0
val x160 = while (x151 < x149) {
val x157 = { 
val x152 = x89.numCols
val x153 = x151 * x152
val x154 = x153 + x148
val x155 = x89.dcApply(x154)
x155
}
val x158 = x145(x148, x151) = x157
x158
x151 = x151 + 1
}
x160
x148 = x148 + 1
}
val x163 = x145// unsafe immutable
x163
}
val x167 = x89.numCols
val x168 = new generated.scala.FloatMatrixImpl(x166,x167)
val x216 = {
var forIdx = 0
while (forIdx < x169.size) { // begin foreach loop x216
val x170 = x169.dcApply(forIdx)
var x171: Int = 0
val x172 = x171
val x178 = x170 * x177
val x179 = x178 + 0
val x180 = x142.dcApply(x179)
val x181 = { 
x180
}
val x212 = while ({val x173 = x168.numCols
val x174 = x172 < x173
x174}) {
var x176: Int = 1
val x187 = { 
val x182 = x165.numCols
val x183 = x172 * x182
val x184 = x183 + 0
val x185 = x165.dcApply(x184)
x185
}
val x188 = x181 * x187
var x189: Float = x188
val x190 = x176
val x194 = x178 + x190
val x195 = x142.dcApply(x194)
val x196 = { 
x195
}
val x207 = while ({val x191 = x165.numCols
val x192 = x190 < x191
x192}) {
val x202 = { 
val x197 = x165.numCols
val x198 = x172 * x197
val x199 = x198 + x190
val x200 = x165.dcApply(x199)
x200
}
val x203 = x196 * x202
val x204 = x189 += x203
val x205 = x176 += 1
()
}
val x208 = x189
val x209 = x168(x170, x172) = x208
val x210 = x171 += 1
()
}
()
forIdx += 1
} // end foreach loop x216
}
val x217 = x168// unsafe immutable
x217
}
val x265 = { 
val x220 = x93.isRow
val x263 = {
def x263thenb(): generated.scala.Matrix[Float] = {
val x221 = x93.length
val x222 = 1 * x221
val x223 = new generated.scala.FloatMatrixImpl(x15,x222)
val x224 = new generated.scala.IndexVectorRangeImpl(0,x222)
val x238 = {
var forIdx = 0
while (forIdx < x224.size) { // begin foreach loop x238
val x225 = x224.dcApply(forIdx)
val x226 = x93.length
var x228: Int = 0
val x229 = x228
val x230 = x229 < x15
val x227 = x225 % x226
val x235 = while ({x230}) {
val x231 = x93(x227)
val x232 = x223(x229, x225) = x231
val x233 = x228 += 1
()
}
()
forIdx += 1
} // end foreach loop x238
}
val x239 = x223// unsafe immutable
x239
}
def x263elseb(): generated.scala.Matrix[Float] = {
val x241 = x93.length
val x242 = x15 * x241
val x243 = new generated.scala.FloatMatrixImpl(x242,1)
val x244 = x93.length
val x245 = x15 * x244
val x246 = new generated.scala.IndexVectorRangeImpl(0,x245)
val x260 = {
var forIdx = 0
while (forIdx < x246.size) { // begin foreach loop x260
val x247 = x246.dcApply(forIdx)
val x248 = x93.length
var x250: Int = 0
val x251 = x250
val x252 = x251 < 1
val x249 = x247 % x248
val x257 = while ({x252}) {
val x253 = x93(x249)
val x254 = x243(x247, x251) = x253
val x255 = x250 += 1
()
}
()
forIdx += 1
} // end foreach loop x260
}
val x261 = x243// unsafe immutable
x261
}
if (x220) {
x263thenb()
} else { 
x263elseb()
}
}
x263
}
val x453 = { 
val x431 = x89.numCols
val x432 = x89.numRows
val x433 = new generated.scala.FloatMatrixImpl(x431,x432)
val x434 = x433.numRows
var x436 : Int = 0
val x450 = while (x436 < x434) {
val x437 = x433.numCols
var x439 : Int = 0
val x448 = while (x439 < x437) {
val x445 = { 
val x440 = x89.numCols
val x441 = x439 * x440
val x442 = x441 + x436
val x443 = x89.dcApply(x442)
x443
}
val x446 = x433(x436, x439) = x445
x446
x439 = x439 + 1
}
x448
x436 = x436 + 1
}
val x451 = x433// unsafe immutable
x451
}
val x266 = x219.numRows
val x267 = x219.numCols
def x273_block = {
val x268 = new generated.scala.FloatMatrixImpl(x266,x267)
var zipIdx = 0
while (zipIdx < x219.size) { // begin zip loop x273
val x270 = x219.dcApply(zipIdx)
val x271 = x265.dcApply(zipIdx)
x268.dcUpdate(zipIdx,  {
val x272 = x270 + x271
x272
})
zipIdx += 1
} // end zip loop x273
x268
}
val x273 = x273_block
val x281 = x273.numRows
val x282 = x273.numCols
def x285_block = {
val x283 = new generated.scala.FloatMatrixImpl(x281,x282)
var mapIdx = 0
while (mapIdx < x273.size) { // begin map loop x285
val x274 = x273.dcApply(mapIdx)
x283.dcUpdate(mapIdx,  {
val x275 = x274
val x276 = x275 * -1.0
val x277 = Math.exp(x276)
val x278 = 1.0 + x277
val x279 = 1.0 / x278
val x280 = x279.asInstanceOf[Float]
x280
})
mapIdx += 1
} // end map loop x285
x283
}
val x285 = x285_block
val x293 = { 
x285
}
val x313 = x293.numCols
val x314 = x293.numRows
def x430_block = {
val x428 = new generated.scala.FloatMatrixImpl(x314,x313)
var zipIdx = 0
while (zipIdx < x293.size) { // begin zip loop x430
val x424 = x293.dcApply(zipIdx)
val x425 = x423.dcApply(zipIdx)
x428.dcUpdate(zipIdx,  {
val x426 = x424 > x425
val x427 = {
def x427thenb(): Float = {
1.0f
}
def x427elseb(): Float = {
0.0f
}
if (x426) {
x427thenb()
} else { 
x427elseb()
}
}
x427
})
zipIdx += 1
} // end zip loop x430
x428
}
val x430 = x430_block
val x477 = x430.numRows
val x480 = new generated.scala.IndexVectorRangeImpl(0,x477)
val x488 = x430.numCols
val x529 = { 
val x476 = { 
val x454 = x453.numCols
val x455 = x453.numRows
val x456 = new generated.scala.FloatMatrixImpl(x454,x455)
val x457 = x456.numRows
var x459 : Int = 0
val x473 = while (x459 < x457) {
val x460 = x456.numCols
var x462 : Int = 0
val x471 = while (x462 < x460) {
val x468 = { 
val x463 = x453.numCols
val x464 = x462 * x463
val x465 = x464 + x459
val x466 = x453.dcApply(x465)
x466
}
val x469 = x456(x459, x462) = x468
x469
x462 = x462 + 1
}
x471
x459 = x459 + 1
}
val x474 = x456// unsafe immutable
x474
}
val x478 = x453.numCols
val x479 = new generated.scala.FloatMatrixImpl(x477,x478)
val x526 = {
var forIdx = 0
while (forIdx < x480.size) { // begin foreach loop x526
val x481 = x480.dcApply(forIdx)
var x482: Int = 0
val x483 = x482
val x489 = x481 * x488
val x490 = x489 + 0
val x491 = x430.dcApply(x490)
val x492 = { 
x491
}
val x523 = while ({val x484 = x479.numCols
val x485 = x483 < x484
x485}) {
var x487: Int = 1
val x498 = { 
val x493 = x476.numCols
val x494 = x483 * x493
val x495 = x494 + 0
val x496 = x476.dcApply(x495)
x496
}
val x499 = x492 * x498
var x500: Float = x499
val x501 = x487
val x505 = x489 + x501
val x506 = x430.dcApply(x505)
val x507 = { 
x506
}
val x518 = while ({val x502 = x476.numCols
val x503 = x501 < x502
x503}) {
val x513 = { 
val x508 = x476.numCols
val x509 = x483 * x508
val x510 = x509 + x501
val x511 = x476.dcApply(x510)
x511
}
val x514 = x507 * x513
val x515 = x500 += x514
val x516 = x487 += 1
()
}
val x519 = x500
val x520 = x479(x481, x483) = x519
val x521 = x482 += 1
()
}
()
forIdx += 1
} // end foreach loop x526
}
val x527 = x479// unsafe immutable
x527
}
val x575 = { 
val x530 = x97.isRow
val x573 = {
def x573thenb(): generated.scala.Matrix[Float] = {
val x531 = x97.length
val x532 = 1 * x531
val x533 = new generated.scala.FloatMatrixImpl(x15,x532)
val x534 = new generated.scala.IndexVectorRangeImpl(0,x532)
val x548 = {
var forIdx = 0
while (forIdx < x534.size) { // begin foreach loop x548
val x535 = x534.dcApply(forIdx)
val x536 = x97.length
var x538: Int = 0
val x539 = x538
val x540 = x539 < x15
val x537 = x535 % x536
val x545 = while ({x540}) {
val x541 = x97(x537)
val x542 = x533(x539, x535) = x541
val x543 = x538 += 1
()
}
()
forIdx += 1
} // end foreach loop x548
}
val x549 = x533// unsafe immutable
x549
}
def x573elseb(): generated.scala.Matrix[Float] = {
val x551 = x97.length
val x552 = x15 * x551
val x553 = new generated.scala.FloatMatrixImpl(x552,1)
val x554 = x97.length
val x555 = x15 * x554
val x556 = new generated.scala.IndexVectorRangeImpl(0,x555)
val x570 = {
var forIdx = 0
while (forIdx < x556.size) { // begin foreach loop x570
val x557 = x556.dcApply(forIdx)
val x558 = x97.length
var x560: Int = 0
val x561 = x560
val x562 = x561 < 1
val x559 = x557 % x558
val x567 = while ({x562}) {
val x563 = x97(x559)
val x564 = x553(x557, x561) = x563
val x565 = x560 += 1
()
}
()
forIdx += 1
} // end foreach loop x570
}
val x571 = x553// unsafe immutable
x571
}
if (x530) {
x573thenb()
} else { 
x573elseb()
}
}
x573
}
val x576 = x529.numRows
val x577 = x529.numCols
def x583_block = {
val x578 = new generated.scala.FloatMatrixImpl(x576,x577)
var zipIdx = 0
while (zipIdx < x529.size) { // begin zip loop x583
val x580 = x529.dcApply(zipIdx)
val x581 = x575.dcApply(zipIdx)
x578.dcUpdate(zipIdx,  {
val x582 = x580 + x581
x582
})
zipIdx += 1
} // end zip loop x583
x578
}
val x583 = x583_block
val x591 = x583.numRows
val x592 = x583.numCols
def x595_block = {
val x593 = new generated.scala.FloatMatrixImpl(x591,x592)
var mapIdx = 0
while (mapIdx < x583.size) { // begin map loop x595
val x584 = x583.dcApply(mapIdx)
x593.dcUpdate(mapIdx,  {
val x585 = x584
val x586 = x585 * -1.0
val x587 = Math.exp(x586)
val x588 = 1.0 + x587
val x589 = 1.0 / x588
val x590 = x589.asInstanceOf[Float]
x590
})
mapIdx += 1
} // end map loop x595
x593
}
val x595 = x595_block
val x603 = { 
x595
}
val x627 = x603.numRows
val x630 = new generated.scala.IndexVectorRangeImpl(0,x627)
val x638 = x603.numCols
val x679 = { 
val x626 = { 
val x604 = x89.numCols
val x605 = x89.numRows
val x606 = new generated.scala.FloatMatrixImpl(x604,x605)
val x607 = x606.numRows
var x609 : Int = 0
val x623 = while (x609 < x607) {
val x610 = x606.numCols
var x612 : Int = 0
val x621 = while (x612 < x610) {
val x618 = { 
val x613 = x89.numCols
val x614 = x612 * x613
val x615 = x614 + x609
val x616 = x89.dcApply(x615)
x616
}
val x619 = x606(x609, x612) = x618
x619
x612 = x612 + 1
}
x621
x609 = x609 + 1
}
val x624 = x606// unsafe immutable
x624
}
val x628 = x89.numCols
val x629 = new generated.scala.FloatMatrixImpl(x627,x628)
val x676 = {
var forIdx = 0
while (forIdx < x630.size) { // begin foreach loop x676
val x631 = x630.dcApply(forIdx)
var x632: Int = 0
val x633 = x632
val x639 = x631 * x638
val x640 = x639 + 0
val x641 = x603.dcApply(x640)
val x642 = { 
x641
}
val x673 = while ({val x634 = x629.numCols
val x635 = x633 < x634
x635}) {
var x637: Int = 1
val x648 = { 
val x643 = x626.numCols
val x644 = x633 * x643
val x645 = x644 + 0
val x646 = x626.dcApply(x645)
x646
}
val x649 = x642 * x648
var x650: Float = x649
val x651 = x637
val x655 = x639 + x651
val x656 = x603.dcApply(x655)
val x657 = { 
x656
}
val x668 = while ({val x652 = x626.numCols
val x653 = x651 < x652
x653}) {
val x663 = { 
val x658 = x626.numCols
val x659 = x633 * x658
val x660 = x659 + x651
val x661 = x626.dcApply(x660)
x661
}
val x664 = x657 * x663
val x665 = x650 += x664
val x666 = x637 += 1
()
}
val x669 = x650
val x670 = x629(x631, x633) = x669
val x671 = x632 += 1
()
}
()
forIdx += 1
} // end foreach loop x676
}
val x677 = x629// unsafe immutable
x677
}
def x882_block = {
val x877 = new generated.scala.FloatMatrixImpl(x166,x177)
var zipIdx = 0
while (zipIdx < x142.size) { // begin zip loop x882
val x879 = x142.dcApply(zipIdx)
val x880 = x603.dcApply(zipIdx)
x877.dcUpdate(zipIdx,  {
val x881 = x879 - x880
x881
})
zipIdx += 1
} // end zip loop x882
x877
}
val x882 = x882_block
val x883 = x882.numRows
val x884 = x882.numCols
def x890_block = {
val x885 = new generated.scala.FloatMatrixImpl(x883,x884)
var zipIdx = 0
while (zipIdx < x882.size) { // begin zip loop x890
val x887 = x882.dcApply(zipIdx)
val x888 = x882.dcApply(zipIdx)
x885.dcUpdate(zipIdx,  {
val x889 = x887 * x888
x889
})
zipIdx += 1
} // end zip loop x890
x885
}
val x890 = x890_block
def x894_block = {
var x891 = x890.dcApply(0)
var reduceIdx = 1
while (reduceIdx < x890.size) { // begin reduce loop x894
val x892 = x890.dcApply(reduceIdx)
x891 = {
val x893 = x891 + x892
x893
}
reduceIdx += 1
} // end reduce loop x894
x891
}
val x894 = x894_block
val x895 = x113 += x894
val x898 = x101
def x928_block = {
val x922 = x89.numRows
val x923 = x89.numCols
val x924 = new generated.scala.FloatMatrixImpl(x922,x923)
var mapIdx = 0
while (mapIdx < x89.size) { // begin map loop x928
val x926 = x89.dcApply(mapIdx)
x924.dcUpdate(mapIdx,  {
val x927 = x926 * 2.0E-4f
x927
})
mapIdx += 1
} // end map loop x928
x924
}
val x928 = x928_block
val x899 = x898.numRows
val x900 = x898.numCols
def x905_block = {
val x901 = new generated.scala.FloatMatrixImpl(x899,x900)
var mapIdx = 0
while (mapIdx < x898.size) { // begin map loop x905
val x903 = x898.dcApply(mapIdx)
x901.dcUpdate(mapIdx,  {
val x904 = x903 * x897
x904
})
mapIdx += 1
} // end map loop x905
x901
}
val x905 = x905_block
val x333 = { 
val x315 = new generated.scala.FloatMatrixImpl(x313,x314)
val x316 = x315.numRows
var x318 : Int = 0
val x330 = while (x318 < x316) {
val x319 = x315.numCols
var x321 : Int = 0
val x328 = while (x321 < x319) {
val x322 = x321 * x313
val x323 = x322 + x318
val x324 = x293.dcApply(x323)
val x325 = { 
x324
}
val x326 = x315(x318, x321) = x325
x326
x321 = x321 + 1
}
x328
x318 = x318 + 1
}
val x331 = x315// unsafe immutable
x331
}
val x349 = x333.numCols
val x379 = { 
val x335 = new generated.scala.FloatMatrixImpl(x334,x313)
val x376 = {
var forIdx = 0
while (forIdx < x336.size) { // begin foreach loop x376
val x337 = x336.dcApply(forIdx)
var x338: Int = 0
val x339 = x338
val x345 = x337 * x344
val x346 = x345 + 0
val x347 = x312.dcApply(x346)
val x348 = { 
x347
}
val x350 = x339 * x349
val x351 = x350 + 0
val x352 = x333.dcApply(x351)
val x353 = { 
x352
}
val x354 = x348 * x353
val x373 = while ({val x340 = x335.numCols
val x341 = x339 < x340
x341}) {
var x343: Int = 1
var x355: Float = x354
val x356 = x343
val x357 = x356 < x349
val x358 = x345 + x356
val x359 = x312.dcApply(x358)
val x360 = { 
x359
}
val x361 = x350 + x356
val x362 = x333.dcApply(x361)
val x363 = { 
x362
}
val x364 = x360 * x363
val x368 = while ({x357}) {
val x365 = x355 += x364
val x366 = x343 += 1
()
}
val x369 = x355
val x370 = x335(x337, x339) = x369
val x371 = x338 += 1
()
}
()
forIdx += 1
} // end foreach loop x376
}
val x377 = x335// unsafe immutable
x377
}
val x727 = x679.numRows
val x728 = x679.numCols
def x734_block = {
val x729 = new generated.scala.FloatMatrixImpl(x727,x728)
var zipIdx = 0
while (zipIdx < x679.size) { // begin zip loop x734
val x731 = x679.dcApply(zipIdx)
val x732 = x265.dcApply(zipIdx)
x729.dcUpdate(zipIdx,  {
val x733 = x731 + x732
x733
})
zipIdx += 1
} // end zip loop x734
x729
}
val x734 = x734_block
val x742 = x734.numRows
val x743 = x734.numCols
def x746_block = {
val x744 = new generated.scala.FloatMatrixImpl(x742,x743)
var mapIdx = 0
while (mapIdx < x734.size) { // begin map loop x746
val x735 = x734.dcApply(mapIdx)
x744.dcUpdate(mapIdx,  {
val x736 = x735
val x737 = x736 * -1.0
val x738 = Math.exp(x737)
val x739 = 1.0 + x738
val x740 = 1.0 / x739
val x741 = x740.asInstanceOf[Float]
x741
})
mapIdx += 1
} // end map loop x746
x744
}
val x746 = x746_block
val x754 = { 
x746
}
val x773 = { 
val x755 = new generated.scala.FloatMatrixImpl(x638,x627)
val x756 = x755.numRows
var x758 : Int = 0
val x770 = while (x758 < x756) {
val x759 = x755.numCols
var x761 : Int = 0
val x768 = while (x761 < x759) {
val x762 = x761 * x638
val x763 = x762 + x758
val x764 = x603.dcApply(x763)
val x765 = { 
x764
}
val x766 = x755(x758, x761) = x765
x766
x761 = x761 + 1
}
x768
x758 = x758 + 1
}
val x771 = x755// unsafe immutable
x771
}
val x774 = x754.numCols
val x795 = x773.numRows
val x797 = new generated.scala.IndexVectorRangeImpl(0,x795)
val x805 = x773.numCols
val x775 = x754.numRows
val x794 = { 
val x776 = new generated.scala.FloatMatrixImpl(x774,x775)
val x777 = x776.numRows
var x779 : Int = 0
val x791 = while (x779 < x777) {
val x780 = x776.numCols
var x782 : Int = 0
val x789 = while (x782 < x780) {
val x783 = x782 * x774
val x784 = x783 + x779
val x785 = x754.dcApply(x784)
val x786 = { 
x785
}
val x787 = x776(x779, x782) = x786
x787
x782 = x782 + 1
}
x789
x779 = x779 + 1
}
val x792 = x776// unsafe immutable
x792
}
val x810 = x794.numCols
val x840 = { 
val x796 = new generated.scala.FloatMatrixImpl(x795,x774)
val x837 = {
var forIdx = 0
while (forIdx < x797.size) { // begin foreach loop x837
val x798 = x797.dcApply(forIdx)
var x799: Int = 0
val x800 = x799
val x806 = x798 * x805
val x807 = x806 + 0
val x808 = x773.dcApply(x807)
val x809 = { 
x808
}
val x811 = x800 * x810
val x812 = x811 + 0
val x813 = x794.dcApply(x812)
val x814 = { 
x813
}
val x815 = x809 * x814
val x834 = while ({val x801 = x796.numCols
val x802 = x800 < x801
x802}) {
var x804: Int = 1
var x816: Float = x815
val x817 = x804
val x818 = x817 < x810
val x819 = x806 + x817
val x820 = x773.dcApply(x819)
val x821 = { 
x820
}
val x822 = x811 + x817
val x823 = x794.dcApply(x822)
val x824 = { 
x823
}
val x825 = x821 * x824
val x829 = while ({x818}) {
val x826 = x816 += x825
val x827 = x804 += 1
()
}
val x830 = x816
val x831 = x796(x798, x800) = x830
val x832 = x799 += 1
()
}
()
forIdx += 1
} // end foreach loop x837
}
val x838 = x796// unsafe immutable
x838
}
val x906 = x379.numRows
val x907 = x379.numCols
def x913_block = {
val x908 = new generated.scala.FloatMatrixImpl(x906,x907)
var zipIdx = 0
while (zipIdx < x379.size) { // begin zip loop x913
val x910 = x379.dcApply(zipIdx)
val x911 = x840.dcApply(zipIdx)
x908.dcUpdate(zipIdx,  {
val x912 = x910 - x911
x912
})
zipIdx += 1
} // end zip loop x913
x908
}
val x913 = x913_block
val x915 = x913.numRows
val x916 = x913.numCols
def x921_block = {
val x917 = new generated.scala.FloatMatrixImpl(x915,x916)
var mapIdx = 0
while (mapIdx < x913.size) { // begin map loop x921
val x919 = x913.dcApply(mapIdx)
x917.dcUpdate(mapIdx,  {
val x920 = x919 / x914
x920
})
mapIdx += 1
} // end map loop x921
x917
}
val x921 = x921_block
val x929 = x921.numRows
val x930 = x921.numCols
def x936_block = {
val x931 = new generated.scala.FloatMatrixImpl(x929,x930)
var zipIdx = 0
while (zipIdx < x921.size) { // begin zip loop x936
val x933 = x921.dcApply(zipIdx)
val x934 = x928.dcApply(zipIdx)
x931.dcUpdate(zipIdx,  {
val x935 = x933 - x934
x935
})
zipIdx += 1
} // end zip loop x936
x931
}
val x936 = x936_block
val x937 = x936.numRows
val x938 = x936.numCols
def x943_block = {
val x939 = new generated.scala.FloatMatrixImpl(x937,x938)
var mapIdx = 0
while (mapIdx < x936.size) { // begin map loop x943
val x941 = x936.dcApply(mapIdx)
x939.dcUpdate(mapIdx,  {
val x942 = x941 * 0.1f
x942
})
mapIdx += 1
} // end map loop x943
x939
}
val x943 = x943_block
val x944 = x905.numRows
val x945 = x905.numCols
def x951_block = {
val x946 = new generated.scala.FloatMatrixImpl(x944,x945)
var zipIdx = 0
while (zipIdx < x905.size) { // begin zip loop x951
val x948 = x905.dcApply(zipIdx)
val x949 = x943.dcApply(zipIdx)
x946.dcUpdate(zipIdx,  {
val x950 = x948 + x949
x950
})
zipIdx += 1
} // end zip loop x951
x946
}
val x951 = x951_block
x101 = x951
val x953 = x107
val x954 = x953.length
val x955 = x953.isRow
val x961 = {
val x957 = new generated.scala.FloatVectorImpl(x954,x955)
x957
}
var x956 = 0
while (x956 < x954) {  // begin fat loop x961
val x959 = x953(x956)
val x960 = x959 * x897
x961.dcUpdate(x956, x960)
x956 += 1
} // end fat loop x961
val x860 = new generated.scala.IndexVectorRangeImpl(0,x638)
val x876 = { 
val x859 = new generated.scala.FloatVectorImpl(x638,true)
val x873 = {
var forIdx = 0
while (forIdx < x860.size) { // begin foreach loop x873
val x861 = x860.dcApply(forIdx)
val x862 = x603.getCol(x861)
val x863 = x862.length
var x869: Float = 0
var x864 = 0
while (x864 < x863) {  // begin fat loop x869
val x867 = x862(x864)
val x865 = x869
val x866 = x867
val x868 = x865 + x866
x869 = x868
x864 += 1
} // end fat loop x869
val x870 = x859(x861) = x869
x870
forIdx += 1
} // end foreach loop x873
}
val x874 = x859// unsafe immutable
x874
}
val x970 = {
val x965 = new generated.scala.FloatVectorImpl(x962,x963)
x965
}
var x964 = 0
while (x964 < x962) {  // begin fat loop x970
val x967 = x415(x964)
val x968 = x876(x964)
val x969 = x967 - x968
x970.dcUpdate(x964, x969)
x964 += 1
} // end fat loop x970
val x977 = {
val x973 = new generated.scala.FloatVectorImpl(x962,x963)
x973
}
var x972 = 0
while (x972 < x962) {  // begin fat loop x977
val x975 = x970(x972)
val x976 = x975 * x971
x977.dcUpdate(x972, x976)
x972 += 1
} // end fat loop x977
val x984 = {
val x979 = new generated.scala.FloatVectorImpl(x954,x955)
x979
}
var x978 = 0
while (x978 < x954) {  // begin fat loop x984
val x981 = x961(x978)
val x982 = x977(x978)
val x983 = x981 + x982
x984.dcUpdate(x978, x983)
x978 += 1
} // end fat loop x984
x107 = x984
val x986 = x104
val x987 = x986.length
val x988 = x986.isRow
val x994 = {
val x990 = new generated.scala.FloatVectorImpl(x987,x988)
x990
}
var x989 = 0
while (x989 < x987) {  // begin fat loop x994
val x992 = x986(x989)
val x993 = x992 * x897
x994.dcUpdate(x989, x993)
x989 += 1
} // end fat loop x994
val x381 = new generated.scala.IndexVectorRangeImpl(0,x313)
val x397 = { 
val x380 = new generated.scala.FloatVectorImpl(x313,true)
val x394 = {
var forIdx = 0
while (forIdx < x381.size) { // begin foreach loop x394
val x382 = x381.dcApply(forIdx)
val x383 = x293.getCol(x382)
val x384 = x383.length
var x390: Float = 0
var x385 = 0
while (x385 < x384) {  // begin fat loop x390
val x388 = x383(x385)
val x386 = x390
val x387 = x388
val x389 = x386 + x387
x390 = x389
x385 += 1
} // end fat loop x390
val x391 = x380(x382) = x390
x391
forIdx += 1
} // end foreach loop x394
}
val x395 = x380// unsafe immutable
x395
}
val x995 = x397.length
val x996 = x397.isRow
val x842 = new generated.scala.IndexVectorRangeImpl(0,x774)
val x858 = { 
val x841 = new generated.scala.FloatVectorImpl(x774,true)
val x855 = {
var forIdx = 0
while (forIdx < x842.size) { // begin foreach loop x855
val x843 = x842.dcApply(forIdx)
val x844 = x754.getCol(x843)
val x845 = x844.length
var x851: Float = 0
var x846 = 0
while (x846 < x845) {  // begin fat loop x851
val x849 = x844(x846)
val x847 = x851
val x848 = x849
val x850 = x847 + x848
x851 = x850
x846 += 1
} // end fat loop x851
val x852 = x841(x843) = x851
x852
forIdx += 1
} // end foreach loop x855
}
val x856 = x841// unsafe immutable
x856
}
val x1003 = {
val x998 = new generated.scala.FloatVectorImpl(x995,x996)
x998
}
var x997 = 0
while (x997 < x995) {  // begin fat loop x1003
val x1000 = x397(x997)
val x1001 = x858(x997)
val x1002 = x1000 - x1001
x1003.dcUpdate(x997, x1002)
x997 += 1
} // end fat loop x1003
val x1009 = {
val x1005 = new generated.scala.FloatVectorImpl(x995,x996)
x1005
}
var x1004 = 0
while (x1004 < x995) {  // begin fat loop x1009
val x1007 = x1003(x1004)
val x1008 = x1007 * x971
x1009.dcUpdate(x1004, x1008)
x1004 += 1
} // end fat loop x1009
val x1016 = {
val x1011 = new generated.scala.FloatVectorImpl(x987,x988)
x1011
}
var x1010 = 0
while (x1010 < x987) {  // begin fat loop x1016
val x1013 = x994(x1010)
val x1014 = x1009(x1010)
val x1015 = x1013 + x1014
x1016.dcUpdate(x1010, x1015)
x1010 += 1
} // end fat loop x1016
x104 = x1016
val x1018 = x101
def x1022_block = {
var zipIdx = 0
while (zipIdx < x89.size) { // begin zip loop x1022
val x1019 = x89.dcApply(zipIdx)
val x1020 = x1018.dcApply(zipIdx)
x89.dcUpdate(zipIdx,  {
val x1021 = x1019 + x1020
x1021
})
zipIdx += 1
} // end zip loop x1022
x89
}
val x1022 = x1022_block
val x1023 = x107
def x1027_block = {
var zipIdx = 0
while (zipIdx < x97.size) { // begin zip loop x1027
val x1024 = x97.dcApply(zipIdx)
val x1025 = x1023.dcApply(zipIdx)
x97.dcUpdate(zipIdx,  {
val x1026 = x1024 + x1025
x1026
})
zipIdx += 1
} // end zip loop x1027
x97
}
val x1027 = x1027_block
val x1028 = x104
def x1032_block = {
var zipIdx = 0
while (zipIdx < x93.size) { // begin zip loop x1032
val x1029 = x93.dcApply(zipIdx)
val x1030 = x1028.dcApply(zipIdx)
x93.dcUpdate(zipIdx,  {
val x1031 = x1029 + x1030
x1031
})
zipIdx += 1
} // end zip loop x1032
x93
}
val x1032 = x1032_block
val x1033 = x114 += 1
()
}
val x1037 = println(x1036)
val x1038 = x113
val x1039 = " error = "+x1038
val x1040 = println(x1039)
val x1041 = x110 += 1
()
}
val x1044 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
