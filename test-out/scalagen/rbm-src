/*****************************************
  Emitting Generated Code                  
*******************************************/
class RBMRunner extends ((Array[java.lang.String])=>(Unit)) {
def apply(x0:Array[java.lang.String]): Unit = {
val x1 = { generated.scala.Global.randRef.setSeed(generated.scala.Global.INITIAL_SEED);   generated.scala.Global.intRandRef.setSeed(generated.scala.Global.INITIAL_SEED); }
val x2 = x0.length
val x3 = x2 < 3
val x7 = {
def x7thenb(): Nothing = {
val x4 = println("Usage: RBM <MNIST data file> <numHiddenUnits> <numcases>")
val x5 = exit(-1)
x5
}
def x7elseb(): Unit = {
()
}
if (x3) {
x7thenb()
} else {
x7elseb()
}
}
val x8 = x0(1)
val x9 = java.lang.Integer.parseInt(x8)
val x10 = "Using "+x9
val x11 = x10+" hidden units."
val x12 = println(x11)
val x13 = println("Reading MNIST dataset")
val x16 = x0(0)
val x61 = { 
val x17 = new java.io.FileReader(x16)
val x18 = new java.io.BufferedReader(x17)
val x19 = x18.readLine()
var x20: java.lang.String = x19
val x21 = x20
val x22 = x21.trim()
x20 = x22
val x24 = x20
val x25 = x24.split("\\s+")
var x26: Array[java.lang.String] = x25
val x27 = x26
val x28 = x27.length
val x29 = new generated.scala.DoubleMatrixImpl(0,x28)
val x58 = while ({val x30 = x20
val x31 = x30 != null
x31}) {
val x33 = x26
val x34 = x33.length
val x35 = new generated.scala.DoubleVectorImpl(x34,true)
var x37 : Int = 0
val x43 = while (x37 < x34) {
val x38 = x26
val x39 = x38(x37)
val x40 = java.lang.Double.parseDouble(x39)
val x41 = x35(x37) = x40
x41
x37 = x37 + 1
}
val x44 = x29.numRows
val x45 = x29.insertRow(x44,x35)
val x46 = x18.readLine()
x20 = x46
val x48 = x20
val x49 = x48 != null
val x56 = {
def x56thenb(): Unit = {
val x50 = x48.trim()
x20 = x50
val x52 = x20
val x53 = x52.split("\\s+")
x26 = x53
()
}
def x56elseb(): Unit = {
()
}
if (x49) {
x56thenb()
} else {
x56elseb()
}
}
x56
}
val x59 = x18.close()
x29
}
val x64 = x61.numRows
val x65 = x61.numCols
def x68_block = {
val x66 = new generated.scala.FloatMatrixImpl(x64,x65)
var mapIdx = 0
while (mapIdx < x61.size) { // begin map loop x68
val x62 = x61.dcApply(mapIdx)
x66.dcUpdate(mapIdx,  {
val x63 = x62.floatValue()
x63
})
mapIdx += 1
} // end map loop x68
x66
}
val x68 = x68_block
val x69 = x68.numCols
val x79 = { 
val x72 = new generated.scala.FloatMatrixImpl(x69,x9)
def x77_block = {
var mapIdx = 0
while (mapIdx < x72.size) { // begin map loop x77
val x73 = x72.dcApply(mapIdx)
x72.dcUpdate(mapIdx,  {
val x74 = generated.scala.Global.randRef.nextGaussian()
val x75 = x74.floatValue()
x75
})
mapIdx += 1
} // end map loop x77
x72
}
val x77 = x77_block
x77
}
def x82_block = {
var mapIdx = 0
while (mapIdx < x79.size) { // begin map loop x82
val x80 = x79.dcApply(mapIdx)
x79.dcUpdate(mapIdx,  {
val x81 = x80 * 0.1f
x81
})
mapIdx += 1
} // end map loop x82
x79
}
val x82 = x82_block
val x85 = { 
val x83 = new generated.scala.FloatVectorImpl(x9,true)
x83
}
val x88 = { 
val x86 = new generated.scala.FloatVectorImpl(x69,true)
x86
}
val x91 = { 
val x89 = new generated.scala.FloatMatrixImpl(x69,x9)
x89
}
val x94 = { 
val x92 = new generated.scala.FloatVectorImpl(x9,true)
x92
}
val x97 = { 
val x95 = new generated.scala.FloatVectorImpl(x69,true)
x95
}
val x98 = Seq()
val x99 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
var x100: Int = 0
val x14 = x0(2)
val x15 = java.lang.Integer.parseInt(x14)
val x70 = x68.numRows
val x71 = x70 / x15
val x214 = List()
val x417 = { 
val x410 = new generated.scala.FloatMatrixImpl(x15,x9)
def x415_block = {
var mapIdx = 0
while (mapIdx < x410.size) { // begin map loop x415
val x411 = x410.dcApply(mapIdx)
x410.dcUpdate(mapIdx,  {
val x412 = generated.scala.Global.randRef.nextFloat()
val x413 = x412.asInstanceOf[Float]
x413
})
mapIdx += 1
} // end map loop x415
x410
}
val x415 = x415_block
x415
}
val x888 = x15
val x934 = 0.1f / x888
val x990 = while ({val x101 = x100
val x102 = x101 < 10
x102}) {
var x104: Float = 0.0f
var x105: Int = 0
val x981 = while ({val x106 = x105
val x107 = x106 < x71
x107}) {
val x109 = x105
val x111 = x105
val x110 = x109 * x15
val x112 = x111 + 1
val x113 = x112 * x15
val x114 = x113 - x110
val x141 = { 
val x115 = new generated.scala.FloatMatrixImpl(x114,x69)
var x116: Int = x110
val x139 = while ({val x117 = x116
val x118 = x117 < x113
x118}) {
var x120: Int = 0
val x136 = while ({val x121 = x120
val x122 = x121 < x69
x122}) {
val x124 = x116
val x126 = x120
val x127 = x116
val x128 = x120
val x125 = x124 - x110
val x129 = x127 * x69
val x130 = x129 + x128
val x131 = x68.dcApply(x130)
val x132 = { 
x131
}
val x133 = x115(x125, x126) = x132
val x134 = x120 += 1
()
}
val x137 = x116 += 1
()
}
x115
}
val x164 = x141.numRows
val x167 = new generated.scala.IndexVectorRangeImpl(0,x164)
val x175 = x141.numCols
val x217 = { 
val x163 = { 
val x142 = x79.numCols
val x143 = x79.numRows
val x144 = new generated.scala.FloatMatrixImpl(x142,x143)
val x145 = x144.numRows
var x147 : Int = 0
val x161 = while (x147 < x145) {
val x148 = x144.numCols
var x150 : Int = 0
val x159 = while (x150 < x148) {
val x156 = { 
val x151 = x79.numCols
val x152 = x150 * x151
val x153 = x152 + x147
val x154 = x79.dcApply(x153)
x154
}
val x157 = x144(x147, x150) = x156
x157
x150 = x150 + 1
}
x159
x147 = x147 + 1
}
x144
}
val x165 = x79.numCols
val x166 = new generated.scala.FloatMatrixImpl(x164,x165)
val x181 = x163.numCols
def x215_block = {
var forIdx = 0
while (forIdx < x167.size) { // begin foreach loop x215
val x168 = x167.dcApply(forIdx)
var x169: Int = 0
val x176 = x168 * x175
val x177 = x176 + 0
val x178 = x141.dcApply(x177)
val x179 = { 
x178
}
val x211 = while ({val x170 = x169
val x171 = x166.numCols
val x172 = x170 < x171
x172}) {
var x174: Int = 1
val x180 = x169
val x182 = x180 * x181
val x183 = x182 + 0
val x184 = x163.dcApply(x183)
val x185 = { 
x184
}
val x186 = x179 * x185
var x187: Float = x186
val x205 = while ({val x188 = x174
val x189 = x188 < x181
x189}) {
val x191 = x174
val x195 = x169
val x196 = x174
val x192 = x176 + x191
val x193 = x141.dcApply(x192)
val x194 = { 
x193
}
val x197 = x195 * x181
val x198 = x197 + x196
val x199 = x163.dcApply(x198)
val x200 = { 
x199
}
val x201 = x194 * x200
val x202 = x187 += x201
val x203 = x174 += 1
()
}
val x206 = x169
val x207 = x187
val x208 = x166(x168, x206) = x207
val x209 = x169 += 1
()
}
()
forIdx += 1
} // end foreach loop x215
}
val x215 = x215_block
x166
}
val x265 = { 
val x218 = x85.isRow
val x263 = {
def x263thenb(): generated.scala.Matrix[Float] = {
val x219 = x85.length
val x220 = 1 * x219
val x221 = new generated.scala.FloatMatrixImpl(x15,x220)
val x222 = new generated.scala.IndexVectorRangeImpl(0,x220)
def x238_block = {
var forIdx = 0
while (forIdx < x222.size) { // begin foreach loop x238
val x223 = x222.dcApply(forIdx)
val x224 = x85.length
var x226: Int = 0
val x225 = x223 % x224
val x235 = while ({val x227 = x226
val x228 = x227 < x15
x228}) {
val x230 = x226
val x231 = x85(x225)
val x232 = x221(x230, x223) = x231
val x233 = x226 += 1
()
}
()
forIdx += 1
} // end foreach loop x238
}
val x238 = x238_block
x221
}
def x263elseb(): generated.scala.Matrix[Float] = {
val x240 = x85.length
val x241 = x15 * x240
val x242 = new generated.scala.FloatMatrixImpl(x241,1)
val x243 = x85.length
val x244 = x15 * x243
val x245 = new generated.scala.IndexVectorRangeImpl(0,x244)
def x261_block = {
var forIdx = 0
while (forIdx < x245.size) { // begin foreach loop x261
val x246 = x245.dcApply(forIdx)
val x247 = x85.length
var x249: Int = 0
val x248 = x246 % x247
val x258 = while ({val x250 = x249
val x251 = x250 < 1
x251}) {
val x253 = x249
val x254 = x85(x248)
val x255 = x242(x246, x253) = x254
val x256 = x249 += 1
()
}
()
forIdx += 1
} // end foreach loop x261
}
val x261 = x261_block
x242
}
if (x218) {
x263thenb()
} else {
x263elseb()
}
}
x263
}
val x446 = { 
val x425 = x79.numCols
val x426 = x79.numRows
val x427 = new generated.scala.FloatMatrixImpl(x425,x426)
val x428 = x427.numRows
var x430 : Int = 0
val x444 = while (x430 < x428) {
val x431 = x427.numCols
var x433 : Int = 0
val x442 = while (x433 < x431) {
val x439 = { 
val x434 = x79.numCols
val x435 = x433 * x434
val x436 = x435 + x430
val x437 = x79.dcApply(x436)
x437
}
val x440 = x427(x430, x433) = x439
x440
x433 = x433 + 1
}
x442
x430 = x430 + 1
}
x427
}
val x566 = { 
val x519 = x88.isRow
val x564 = {
def x564thenb(): generated.scala.Matrix[Float] = {
val x520 = x88.length
val x521 = 1 * x520
val x522 = new generated.scala.FloatMatrixImpl(x15,x521)
val x523 = new generated.scala.IndexVectorRangeImpl(0,x521)
def x539_block = {
var forIdx = 0
while (forIdx < x523.size) { // begin foreach loop x539
val x524 = x523.dcApply(forIdx)
val x525 = x88.length
var x527: Int = 0
val x526 = x524 % x525
val x536 = while ({val x528 = x527
val x529 = x528 < x15
x529}) {
val x531 = x527
val x532 = x88(x526)
val x533 = x522(x531, x524) = x532
val x534 = x527 += 1
()
}
()
forIdx += 1
} // end foreach loop x539
}
val x539 = x539_block
x522
}
def x564elseb(): generated.scala.Matrix[Float] = {
val x541 = x88.length
val x542 = x15 * x541
val x543 = new generated.scala.FloatMatrixImpl(x542,1)
val x544 = x88.length
val x545 = x15 * x544
val x546 = new generated.scala.IndexVectorRangeImpl(0,x545)
def x562_block = {
var forIdx = 0
while (forIdx < x546.size) { // begin foreach loop x562
val x547 = x546.dcApply(forIdx)
val x548 = x88.length
var x550: Int = 0
val x549 = x547 % x548
val x559 = while ({val x551 = x550
val x552 = x551 < 1
x552}) {
val x554 = x550
val x555 = x88(x549)
val x556 = x543(x547, x554) = x555
val x557 = x550 += 1
()
}
()
forIdx += 1
} // end foreach loop x562
}
val x562 = x562_block
x543
}
if (x519) {
x564thenb()
} else {
x564elseb()
}
}
x564
}
val x447 = x446.numCols
val x266 = x217.numRows
val x267 = x217.numCols
def x273_block = {
val x268 = new generated.scala.FloatMatrixImpl(x266,x267)
var zipIdx = 0
while (zipIdx < x217.size) { // begin zip loop x273
val x270 = x217.dcApply(zipIdx)
val x271 = x265.dcApply(zipIdx)
x268.dcUpdate(zipIdx,  {
val x272 = x270 + x271
x272
})
zipIdx += 1
} // end zip loop x273
x268
}
val x273 = x273_block
val x274 = x273.numRows
val x275 = x273.numCols
def x285_block = {
val x276 = new generated.scala.FloatMatrixImpl(x274,x275)
var mapIdx = 0
while (mapIdx < x273.size) { // begin map loop x285
val x278 = x273.dcApply(mapIdx)
x276.dcUpdate(mapIdx,  {
val x279 = x278
val x280 = x279 * -1.0
val x281 = Math.exp(x280)
val x282 = 1.0 + x281
val x283 = 1.0 / x282
val x284 = x283.asInstanceOf[Float]
x284
})
mapIdx += 1
} // end map loop x285
x276
}
val x285 = x285_block
val x304 = x285.numCols
val x305 = x285.numRows
def x424_block = {
val x422 = new generated.scala.FloatMatrixImpl(x305,x304)
var zipIdx = 0
while (zipIdx < x285.size) { // begin zip loop x424
val x418 = x285.dcApply(zipIdx)
val x419 = x417.dcApply(zipIdx)
x422.dcUpdate(zipIdx,  {
val x420 = x418 > x419
val x421 = {
def x421thenb(): Float = {
1.0f
}
def x421elseb(): Float = {
0.0f
}
if (x420) {
x421thenb()
} else {
x421elseb()
}
}
x421
})
zipIdx += 1
} // end zip loop x424
x422
}
val x424 = x424_block
val x467 = x424.numRows
val x469 = new generated.scala.IndexVectorRangeImpl(0,x467)
val x477 = x424.numCols
val x448 = x446.numRows
val x466 = { 
val x449 = new generated.scala.FloatMatrixImpl(x447,x448)
val x450 = x449.numRows
var x452 : Int = 0
val x464 = while (x452 < x450) {
val x453 = x449.numCols
var x455 : Int = 0
val x462 = while (x455 < x453) {
val x456 = x455 * x447
val x457 = x456 + x452
val x458 = x446.dcApply(x457)
val x459 = { 
x458
}
val x460 = x449(x452, x455) = x459
x460
x455 = x455 + 1
}
x462
x452 = x452 + 1
}
x449
}
val x483 = x466.numCols
val x518 = { 
val x468 = new generated.scala.FloatMatrixImpl(x467,x447)
def x516_block = {
var forIdx = 0
while (forIdx < x469.size) { // begin foreach loop x516
val x470 = x469.dcApply(forIdx)
var x471: Int = 0
val x478 = x470 * x477
val x479 = x478 + 0
val x480 = x424.dcApply(x479)
val x481 = { 
x480
}
val x513 = while ({val x472 = x471
val x473 = x468.numCols
val x474 = x472 < x473
x474}) {
var x476: Int = 1
val x482 = x471
val x484 = x482 * x483
val x485 = x484 + 0
val x486 = x466.dcApply(x485)
val x487 = { 
x486
}
val x488 = x481 * x487
var x489: Float = x488
val x507 = while ({val x490 = x476
val x491 = x490 < x483
x491}) {
val x493 = x476
val x497 = x471
val x498 = x476
val x494 = x478 + x493
val x495 = x424.dcApply(x494)
val x496 = { 
x495
}
val x499 = x497 * x483
val x500 = x499 + x498
val x501 = x466.dcApply(x500)
val x502 = { 
x501
}
val x503 = x496 * x502
val x504 = x489 += x503
val x505 = x476 += 1
()
}
val x508 = x471
val x509 = x489
val x510 = x468(x470, x508) = x509
val x511 = x471 += 1
()
}
()
forIdx += 1
} // end foreach loop x516
}
val x516 = x516_block
x468
}
val x567 = x518.numRows
val x568 = x518.numCols
def x574_block = {
val x569 = new generated.scala.FloatMatrixImpl(x567,x568)
var zipIdx = 0
while (zipIdx < x518.size) { // begin zip loop x574
val x571 = x518.dcApply(zipIdx)
val x572 = x566.dcApply(zipIdx)
x569.dcUpdate(zipIdx,  {
val x573 = x571 + x572
x573
})
zipIdx += 1
} // end zip loop x574
x569
}
val x574 = x574_block
val x575 = x574.numRows
val x576 = x574.numCols
def x586_block = {
val x577 = new generated.scala.FloatMatrixImpl(x575,x576)
var mapIdx = 0
while (mapIdx < x574.size) { // begin map loop x586
val x579 = x574.dcApply(mapIdx)
x577.dcUpdate(mapIdx,  {
val x580 = x579
val x581 = x580 * -1.0
val x582 = Math.exp(x581)
val x583 = 1.0 + x582
val x584 = 1.0 / x583
val x585 = x584.asInstanceOf[Float]
x585
})
mapIdx += 1
} // end map loop x586
x577
}
val x586 = x586_block
val x609 = x586.numRows
val x612 = new generated.scala.IndexVectorRangeImpl(0,x609)
val x620 = x586.numCols
val x661 = { 
val x608 = { 
val x587 = x79.numCols
val x588 = x79.numRows
val x589 = new generated.scala.FloatMatrixImpl(x587,x588)
val x590 = x589.numRows
var x592 : Int = 0
val x606 = while (x592 < x590) {
val x593 = x589.numCols
var x595 : Int = 0
val x604 = while (x595 < x593) {
val x601 = { 
val x596 = x79.numCols
val x597 = x595 * x596
val x598 = x597 + x592
val x599 = x79.dcApply(x598)
x599
}
val x602 = x589(x592, x595) = x601
x602
x595 = x595 + 1
}
x604
x592 = x592 + 1
}
x589
}
val x610 = x79.numCols
val x611 = new generated.scala.FloatMatrixImpl(x609,x610)
val x626 = x608.numCols
def x659_block = {
var forIdx = 0
while (forIdx < x612.size) { // begin foreach loop x659
val x613 = x612.dcApply(forIdx)
var x614: Int = 0
val x621 = x613 * x620
val x622 = x621 + 0
val x623 = x586.dcApply(x622)
val x624 = { 
x623
}
val x656 = while ({val x615 = x614
val x616 = x611.numCols
val x617 = x615 < x616
x617}) {
var x619: Int = 1
val x625 = x614
val x627 = x625 * x626
val x628 = x627 + 0
val x629 = x608.dcApply(x628)
val x630 = { 
x629
}
val x631 = x624 * x630
var x632: Float = x631
val x650 = while ({val x633 = x619
val x634 = x633 < x626
x634}) {
val x636 = x619
val x640 = x614
val x641 = x619
val x637 = x621 + x636
val x638 = x586.dcApply(x637)
val x639 = { 
x638
}
val x642 = x640 * x626
val x643 = x642 + x641
val x644 = x608.dcApply(x643)
val x645 = { 
x644
}
val x646 = x639 * x645
val x647 = x632 += x646
val x648 = x619 += 1
()
}
val x651 = x614
val x652 = x632
val x653 = x611(x613, x651) = x652
val x654 = x614 += 1
()
}
()
forIdx += 1
} // end foreach loop x659
}
val x659 = x659_block
x611
}
def x860_block = {
val x855 = new generated.scala.FloatMatrixImpl(x164,x175)
var zipIdx = 0
while (zipIdx < x141.size) { // begin zip loop x860
val x857 = x141.dcApply(zipIdx)
val x858 = x586.dcApply(zipIdx)
x855.dcUpdate(zipIdx,  {
val x859 = x857 - x858
x859
})
zipIdx += 1
} // end zip loop x860
x855
}
val x860 = x860_block
val x861 = x860.numRows
val x862 = x860.numCols
def x868_block = {
val x863 = new generated.scala.FloatMatrixImpl(x861,x862)
var zipIdx = 0
while (zipIdx < x860.size) { // begin zip loop x868
val x865 = x860.dcApply(zipIdx)
val x866 = x860.dcApply(zipIdx)
x863.dcUpdate(zipIdx,  {
val x867 = x865 * x866
x867
})
zipIdx += 1
} // end zip loop x868
x863
}
val x868 = x868_block
def x872_block = {
var x869 = x868.dcApply(0)
var reduceIdx = 1
while (reduceIdx < x868.size) { // begin reduce loop x872
val x870 = x868.dcApply(reduceIdx)
x869 = {
val x871 = x869 + x870
x871
}
reduceIdx += 1
} // end reduce loop x872
x869
}
val x872 = x872_block
val x873 = x104 += x872
val x874 = x100
val x875 = x874 > 5
val x876 = {
def x876thenb(): Float = {
0.9f
}
def x876elseb(): Float = {
0.5f
}
if (x875) {
x876thenb()
} else {
x876elseb()
}
}
def x879_block = {
var mapIdx = 0
while (mapIdx < x91.size) { // begin map loop x879
val x877 = x91.dcApply(mapIdx)
x91.dcUpdate(mapIdx,  {
val x878 = x877 * x876
x878
})
mapIdx += 1
} // end map loop x879
x91
}
val x879 = x879_block
def x902_block = {
val x896 = x79.numRows
val x897 = x79.numCols
val x898 = new generated.scala.FloatMatrixImpl(x896,x897)
var mapIdx = 0
while (mapIdx < x79.size) { // begin map loop x902
val x900 = x79.dcApply(mapIdx)
x898.dcUpdate(mapIdx,  {
val x901 = x900 * 2.0E-4f
x901
})
mapIdx += 1
} // end map loop x902
x898
}
val x902 = x902_block
val x303 = { 
val x286 = new generated.scala.FloatMatrixImpl(x175,x164)
val x287 = x286.numRows
var x289 : Int = 0
val x301 = while (x289 < x287) {
val x290 = x286.numCols
var x292 : Int = 0
val x299 = while (x292 < x290) {
val x293 = x292 * x175
val x294 = x293 + x289
val x295 = x141.dcApply(x294)
val x296 = { 
x295
}
val x297 = x286(x289, x292) = x296
x297
x292 = x292 + 1
}
x299
x289 = x289 + 1
}
x286
}
val x324 = x303.numRows
val x326 = new generated.scala.IndexVectorRangeImpl(0,x324)
val x334 = x303.numCols
val x323 = { 
val x306 = new generated.scala.FloatMatrixImpl(x304,x305)
val x307 = x306.numRows
var x309 : Int = 0
val x321 = while (x309 < x307) {
val x310 = x306.numCols
var x312 : Int = 0
val x319 = while (x312 < x310) {
val x313 = x312 * x304
val x314 = x313 + x309
val x315 = x285.dcApply(x314)
val x316 = { 
x315
}
val x317 = x306(x309, x312) = x316
x317
x312 = x312 + 1
}
x319
x309 = x309 + 1
}
x306
}
val x340 = x323.numCols
val x375 = { 
val x325 = new generated.scala.FloatMatrixImpl(x324,x304)
def x373_block = {
var forIdx = 0
while (forIdx < x326.size) { // begin foreach loop x373
val x327 = x326.dcApply(forIdx)
var x328: Int = 0
val x335 = x327 * x334
val x336 = x335 + 0
val x337 = x303.dcApply(x336)
val x338 = { 
x337
}
val x370 = while ({val x329 = x328
val x330 = x325.numCols
val x331 = x329 < x330
x331}) {
var x333: Int = 1
val x339 = x328
val x341 = x339 * x340
val x342 = x341 + 0
val x343 = x323.dcApply(x342)
val x344 = { 
x343
}
val x345 = x338 * x344
var x346: Float = x345
val x364 = while ({val x347 = x333
val x348 = x347 < x340
x348}) {
val x350 = x333
val x354 = x328
val x355 = x333
val x351 = x335 + x350
val x352 = x303.dcApply(x351)
val x353 = { 
x352
}
val x356 = x354 * x340
val x357 = x356 + x355
val x358 = x323.dcApply(x357)
val x359 = { 
x358
}
val x360 = x353 * x359
val x361 = x346 += x360
val x362 = x333 += 1
()
}
val x365 = x328
val x366 = x346
val x367 = x325(x327, x365) = x366
val x368 = x328 += 1
()
}
()
forIdx += 1
} // end foreach loop x373
}
val x373 = x373_block
x325
}
val x711 = x661.numRows
val x712 = x661.numCols
def x718_block = {
val x713 = new generated.scala.FloatMatrixImpl(x711,x712)
var zipIdx = 0
while (zipIdx < x661.size) { // begin zip loop x718
val x715 = x661.dcApply(zipIdx)
val x716 = x265.dcApply(zipIdx)
x713.dcUpdate(zipIdx,  {
val x717 = x715 + x716
x717
})
zipIdx += 1
} // end zip loop x718
x713
}
val x718 = x718_block
val x719 = x718.numRows
val x720 = x718.numCols
def x730_block = {
val x721 = new generated.scala.FloatMatrixImpl(x719,x720)
var mapIdx = 0
while (mapIdx < x718.size) { // begin map loop x730
val x723 = x718.dcApply(mapIdx)
x721.dcUpdate(mapIdx,  {
val x724 = x723
val x725 = x724 * -1.0
val x726 = Math.exp(x725)
val x727 = 1.0 + x726
val x728 = 1.0 / x727
val x729 = x728.asInstanceOf[Float]
x729
})
mapIdx += 1
} // end map loop x730
x721
}
val x730 = x730_block
val x749 = x730.numCols
val x748 = { 
val x731 = new generated.scala.FloatMatrixImpl(x620,x609)
val x732 = x731.numRows
var x734 : Int = 0
val x746 = while (x734 < x732) {
val x735 = x731.numCols
var x737 : Int = 0
val x744 = while (x737 < x735) {
val x738 = x737 * x620
val x739 = x738 + x734
val x740 = x586.dcApply(x739)
val x741 = { 
x740
}
val x742 = x731(x734, x737) = x741
x742
x737 = x737 + 1
}
x744
x734 = x734 + 1
}
x731
}
val x769 = x748.numRows
val x771 = new generated.scala.IndexVectorRangeImpl(0,x769)
val x779 = x748.numCols
val x750 = x730.numRows
val x768 = { 
val x751 = new generated.scala.FloatMatrixImpl(x749,x750)
val x752 = x751.numRows
var x754 : Int = 0
val x766 = while (x754 < x752) {
val x755 = x751.numCols
var x757 : Int = 0
val x764 = while (x757 < x755) {
val x758 = x757 * x749
val x759 = x758 + x754
val x760 = x730.dcApply(x759)
val x761 = { 
x760
}
val x762 = x751(x754, x757) = x761
x762
x757 = x757 + 1
}
x764
x754 = x754 + 1
}
x751
}
val x785 = x768.numCols
val x820 = { 
val x770 = new generated.scala.FloatMatrixImpl(x769,x749)
def x818_block = {
var forIdx = 0
while (forIdx < x771.size) { // begin foreach loop x818
val x772 = x771.dcApply(forIdx)
var x773: Int = 0
val x780 = x772 * x779
val x781 = x780 + 0
val x782 = x748.dcApply(x781)
val x783 = { 
x782
}
val x815 = while ({val x774 = x773
val x775 = x770.numCols
val x776 = x774 < x775
x776}) {
var x778: Int = 1
val x784 = x773
val x786 = x784 * x785
val x787 = x786 + 0
val x788 = x768.dcApply(x787)
val x789 = { 
x788
}
val x790 = x783 * x789
var x791: Float = x790
val x809 = while ({val x792 = x778
val x793 = x792 < x785
x793}) {
val x795 = x778
val x799 = x773
val x800 = x778
val x796 = x780 + x795
val x797 = x748.dcApply(x796)
val x798 = { 
x797
}
val x801 = x799 * x785
val x802 = x801 + x800
val x803 = x768.dcApply(x802)
val x804 = { 
x803
}
val x805 = x798 * x804
val x806 = x791 += x805
val x807 = x778 += 1
()
}
val x810 = x773
val x811 = x791
val x812 = x770(x772, x810) = x811
val x813 = x773 += 1
()
}
()
forIdx += 1
} // end foreach loop x818
}
val x818 = x818_block
x770
}
val x880 = x375.numRows
val x881 = x375.numCols
def x887_block = {
val x882 = new generated.scala.FloatMatrixImpl(x880,x881)
var zipIdx = 0
while (zipIdx < x375.size) { // begin zip loop x887
val x884 = x375.dcApply(zipIdx)
val x885 = x820.dcApply(zipIdx)
x882.dcUpdate(zipIdx,  {
val x886 = x884 - x885
x886
})
zipIdx += 1
} // end zip loop x887
x882
}
val x887 = x887_block
val x889 = x887.numRows
val x890 = x887.numCols
def x895_block = {
val x891 = new generated.scala.FloatMatrixImpl(x889,x890)
var mapIdx = 0
while (mapIdx < x887.size) { // begin map loop x895
val x893 = x887.dcApply(mapIdx)
x891.dcUpdate(mapIdx,  {
val x894 = x893 / x888
x894
})
mapIdx += 1
} // end map loop x895
x891
}
val x895 = x895_block
val x903 = x895.numRows
val x904 = x895.numCols
def x910_block = {
val x905 = new generated.scala.FloatMatrixImpl(x903,x904)
var zipIdx = 0
while (zipIdx < x895.size) { // begin zip loop x910
val x907 = x895.dcApply(zipIdx)
val x908 = x902.dcApply(zipIdx)
x905.dcUpdate(zipIdx,  {
val x909 = x907 - x908
x909
})
zipIdx += 1
} // end zip loop x910
x905
}
val x910 = x910_block
val x911 = x910.numRows
val x912 = x910.numCols
def x917_block = {
val x913 = new generated.scala.FloatMatrixImpl(x911,x912)
var mapIdx = 0
while (mapIdx < x910.size) { // begin map loop x917
val x915 = x910.dcApply(mapIdx)
x913.dcUpdate(mapIdx,  {
val x916 = x915 * 0.1f
x916
})
mapIdx += 1
} // end map loop x917
x913
}
val x917 = x917_block
def x921_block = {
var zipIdx = 0
while (zipIdx < x91.size) { // begin zip loop x921
val x918 = x91.dcApply(zipIdx)
val x919 = x917.dcApply(zipIdx)
x91.dcUpdate(zipIdx,  {
val x920 = x918 + x919
x920
})
zipIdx += 1
} // end zip loop x921
x91
}
val x921 = x921_block
def x924_block = {
var mapIdx = 0
while (mapIdx < x97.size) { // begin map loop x924
val x922 = x97.dcApply(mapIdx)
x97.dcUpdate(mapIdx,  {
val x923 = x922 * x876
x923
})
mapIdx += 1
} // end map loop x924
x97
}
val x924 = x924_block
val x394 = new generated.scala.IndexVectorRangeImpl(0,x175)
val x409 = { 
val x393 = new generated.scala.FloatVectorImpl(x175,true)
def x407_block = {
var forIdx = 0
while (forIdx < x394.size) { // begin foreach loop x407
val x395 = x394.dcApply(forIdx)
val x396 = x141.getCol(x395)
val x397 = x396.length
var x403: Float = 0
var x398 = 0
while (x398 < x397) {  // begin fat loop x403
val x401 = x396(x398)
val x399 = x403
val x400 = x401
val x402 = x399 + x400
x403 = x402
x398 += 1
} // end fat loop x403
val x404 = x393(x395) = x403
x404
forIdx += 1
} // end foreach loop x407
}
val x407 = x407_block
x393
}
val x925 = x409.length
val x926 = x409.isRow
val x839 = new generated.scala.IndexVectorRangeImpl(0,x620)
val x854 = { 
val x838 = new generated.scala.FloatVectorImpl(x620,true)
def x852_block = {
var forIdx = 0
while (forIdx < x839.size) { // begin foreach loop x852
val x840 = x839.dcApply(forIdx)
val x841 = x586.getCol(x840)
val x842 = x841.length
var x848: Float = 0
var x843 = 0
while (x843 < x842) {  // begin fat loop x848
val x846 = x841(x843)
val x844 = x848
val x845 = x846
val x847 = x844 + x845
x848 = x847
x843 += 1
} // end fat loop x848
val x849 = x838(x840) = x848
x849
forIdx += 1
} // end foreach loop x852
}
val x852 = x852_block
x838
}
val x933 = {
val x928 = new generated.scala.FloatVectorImpl(x925,x926)
x928
}
var x927 = 0
while (x927 < x925) {  // begin fat loop x933
val x930 = x409(x927)
val x931 = x854(x927)
val x932 = x930 - x931
x933.dcUpdate(x927, x932)
x927 += 1
} // end fat loop x933
val x940 = {
val x936 = new generated.scala.FloatVectorImpl(x925,x926)
x936
}
var x935 = 0
while (x935 < x925) {  // begin fat loop x940
val x938 = x933(x935)
val x939 = x938 * x934
x940.dcUpdate(x935, x939)
x935 += 1
} // end fat loop x940
def x944_block = {
var zipIdx = 0
while (zipIdx < x97.size) { // begin zip loop x944
val x941 = x97.dcApply(zipIdx)
val x942 = x940.dcApply(zipIdx)
x97.dcUpdate(zipIdx,  {
val x943 = x941 + x942
x943
})
zipIdx += 1
} // end zip loop x944
x97
}
val x944 = x944_block
def x947_block = {
var mapIdx = 0
while (mapIdx < x94.size) { // begin map loop x947
val x945 = x94.dcApply(mapIdx)
x94.dcUpdate(mapIdx,  {
val x946 = x945 * x876
x946
})
mapIdx += 1
} // end map loop x947
x94
}
val x947 = x947_block
val x377 = new generated.scala.IndexVectorRangeImpl(0,x304)
val x392 = { 
val x376 = new generated.scala.FloatVectorImpl(x304,true)
def x390_block = {
var forIdx = 0
while (forIdx < x377.size) { // begin foreach loop x390
val x378 = x377.dcApply(forIdx)
val x379 = x285.getCol(x378)
val x380 = x379.length
var x386: Float = 0
var x381 = 0
while (x381 < x380) {  // begin fat loop x386
val x384 = x379(x381)
val x382 = x386
val x383 = x384
val x385 = x382 + x383
x386 = x385
x381 += 1
} // end fat loop x386
val x387 = x376(x378) = x386
x387
forIdx += 1
} // end foreach loop x390
}
val x390 = x390_block
x376
}
val x948 = x392.length
val x949 = x392.isRow
val x822 = new generated.scala.IndexVectorRangeImpl(0,x749)
val x837 = { 
val x821 = new generated.scala.FloatVectorImpl(x749,true)
def x835_block = {
var forIdx = 0
while (forIdx < x822.size) { // begin foreach loop x835
val x823 = x822.dcApply(forIdx)
val x824 = x730.getCol(x823)
val x825 = x824.length
var x831: Float = 0
var x826 = 0
while (x826 < x825) {  // begin fat loop x831
val x829 = x824(x826)
val x827 = x831
val x828 = x829
val x830 = x827 + x828
x831 = x830
x826 += 1
} // end fat loop x831
val x832 = x821(x823) = x831
x832
forIdx += 1
} // end foreach loop x835
}
val x835 = x835_block
x821
}
val x956 = {
val x951 = new generated.scala.FloatVectorImpl(x948,x949)
x951
}
var x950 = 0
while (x950 < x948) {  // begin fat loop x956
val x953 = x392(x950)
val x954 = x837(x950)
val x955 = x953 - x954
x956.dcUpdate(x950, x955)
x950 += 1
} // end fat loop x956
val x962 = {
val x958 = new generated.scala.FloatVectorImpl(x948,x949)
x958
}
var x957 = 0
while (x957 < x948) {  // begin fat loop x962
val x960 = x956(x957)
val x961 = x960 * x934
x962.dcUpdate(x957, x961)
x957 += 1
} // end fat loop x962
def x966_block = {
var zipIdx = 0
while (zipIdx < x94.size) { // begin zip loop x966
val x963 = x94.dcApply(zipIdx)
val x964 = x962.dcApply(zipIdx)
x94.dcUpdate(zipIdx,  {
val x965 = x963 + x964
x965
})
zipIdx += 1
} // end zip loop x966
x94
}
val x966 = x966_block
def x970_block = {
var zipIdx = 0
while (zipIdx < x79.size) { // begin zip loop x970
val x967 = x79.dcApply(zipIdx)
val x968 = x91.dcApply(zipIdx)
x79.dcUpdate(zipIdx,  {
val x969 = x967 + x968
x969
})
zipIdx += 1
} // end zip loop x970
x79
}
val x970 = x970_block
def x974_block = {
var zipIdx = 0
while (zipIdx < x88.size) { // begin zip loop x974
val x971 = x88.dcApply(zipIdx)
val x972 = x97.dcApply(zipIdx)
x88.dcUpdate(zipIdx,  {
val x973 = x971 + x972
x973
})
zipIdx += 1
} // end zip loop x974
x88
}
val x974 = x974_block
def x978_block = {
var zipIdx = 0
while (zipIdx < x85.size) { // begin zip loop x978
val x975 = x85.dcApply(zipIdx)
val x976 = x94.dcApply(zipIdx)
x85.dcUpdate(zipIdx,  {
val x977 = x975 + x976
x977
})
zipIdx += 1
} // end zip loop x978
x85
}
val x978 = x978_block
val x979 = x105 += 1
()
}
val x982 = x100
val x983 = "--> Epoch "+x982
val x984 = println(x983)
val x985 = x104
val x986 = " error = "+x985
val x987 = println(x986)
val x988 = x100 += 1
()
}
val x991 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
