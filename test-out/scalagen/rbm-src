/*****************************************
  Emitting Generated Code                  
*******************************************/
class Application extends ((Array[java.lang.String])=>(Unit)) {
def apply(x0:Array[java.lang.String]): Unit = {
val x1 = { generated.scala.Global.randRef.setSeed(generated.scala.Global.INITIAL_SEED);   generated.scala.Global.intRandRef.setSeed(generated.scala.Global.INITIAL_SEED); }
val x2 = x0.length
val x3 = x2 < 3
val x7 = {
def x7thenb(): Nothing = {
val x4 = println("Usage: RBM <MNIST data file> <numHiddenUnits> <numcases>")
val x5 = exit(-1)
x5
}
def x7elseb(): Unit = {
()
}
if (x3) {
x7thenb()
} else {
x7elseb()
}
}
val x8 = x0(1)
val x9 = java.lang.Integer.parseInt(x8)
val x10 = "Using "+x9
val x11 = x10+" hidden units."
val x12 = println(x11)
val x13 = println("Reading MNIST dataset")
val x16 = x0(0)
def x61_block = { 
val x17 = new java.io.FileReader(x16)
val x18 = new java.io.BufferedReader(x17)
val x19 = x18.readLine()
var x20 = x19
val x21 = x20
val x22 = x21.trim()
x20 = x22
val x24 = x20
val x25 = x24.split("\\s+")
var x26 = x25
val x27 = x26
val x28 = x27.length
val x29 = new generated.scala.DoubleMatrixImpl(0,x28)
val x58 = while ({val x30 = x20
val x31 = x30 != null
x31}) {
val x33 = x26
val x34 = x33.length
val x35 = new generated.scala.DoubleVectorImpl(x34,true)
var x37 : Int = 0
val x43 = while (x37 < x34) {
val x38 = x26
val x39 = x38(x37)
val x40 = java.lang.Double.parseDouble(x39)
val x41 = x35(x37) = x40
x41
x37 = x37 + 1
}
val x44 = x29.numRows
val x45 = x29.insertRow(x44,x35)
val x46 = x18.readLine()
x20 = x46
val x48 = x20
val x49 = x48 != null
val x56 = {
def x56thenb(): Unit = {
val x50 = x48.trim()
x20 = x50
val x52 = x20
val x53 = x52.split("\\s+")
x26 = x53
()
}
def x56elseb(): Unit = {
()
}
if (x49) {
x56thenb()
} else {
x56elseb()
}
}
x56
}
val x59 = x18.close()
x29
}
val x61 = x61_block
val x64 = x61.numRows
val x65 = x61.numCols
def x68_block = {
val x66 = new generated.scala.FloatMatrixImpl(x64,x65)
var mapIdx = 0
while (mapIdx < x61.size) {
val x62 = x61.dcApply(mapIdx)
x66.dcUpdate(mapIdx,  {
val x63 = x62.floatValue()
x63
})
mapIdx += 1
} // end while
x66
}
val x68 = x68_block
val x69 = x68.numCols
def x79_block = { 
val x72 = new generated.scala.FloatMatrixImpl(x69,x9)
def x77_block = {
var mapIdx = 0
while (mapIdx < x72.size) {
val x73 = x72.dcApply(mapIdx)
x72.dcUpdate(mapIdx,  {
val x74 = generated.scala.Global.randRef.nextGaussian()
val x75 = x74.floatValue()
x75
})
mapIdx += 1
} // end while
x72
}
val x77 = x77_block
x77
}
val x79 = x79_block
val x80 = x79.numRows
val x81 = x79.numCols
def x86_block = {
val x82 = new generated.scala.FloatMatrixImpl(x80,x81)
var mapIdx = 0
while (mapIdx < x79.size) {
val x84 = x79.dcApply(mapIdx)
x82.dcUpdate(mapIdx,  {
val x85 = x84 * 0.1f
x85
})
mapIdx += 1
} // end while
x82
}
val x86 = x86_block
var x87 = x86
def x90_block = { 
val x88 = new generated.scala.FloatVectorImpl(x9,true)
x88
}
val x90 = x90_block
var x91 = x90
def x94_block = { 
val x92 = new generated.scala.FloatVectorImpl(x69,true)
x92
}
val x94 = x94_block
var x95 = x94
def x98_block = { 
val x96 = new generated.scala.FloatMatrixImpl(x69,x9)
x96
}
val x98 = x98_block
var x99 = x98
var x102 = x90
var x105 = x94
val x106 = println("tic:" + (System.nanoTime / 1000000L))
var x107 = 0
val x14 = x0(2)
val x15 = java.lang.Integer.parseInt(x14)
val x70 = x68.numRows
val x71 = x70 / x15
val x271 = x270
val x272 = x271 * -1.0
val x543 = x542
val x544 = x543 * -1.0
val x674 = x673
val x675 = x674 * -1.0
val x828 = x15
val x886 = 0.1f / x828
val x976 = while ({val x108 = x107
val x109 = x108 < 10
x109}) {
var x111 = 0.0f
var x112 = 0
val x967 = while ({val x113 = x112
val x114 = x113 < x71
x114}) {
val x116 = x112
val x118 = x112
val x146 = x87
val x205 = x91
val x273 = Math.exp(x272)
val x402 = x87
val x477 = x95
val x545 = Math.exp(x544)
val x550 = x87
val x608 = x91
val x676 = Math.exp(x675)
val x117 = x116 * x15
val x119 = x118 + 1
val x120 = x119 * x15
val x121 = x120 - x117
def x145_block = { 
val x122 = new generated.scala.FloatMatrixImpl(x121,x69)
var x123 = x117
val x143 = while ({val x124 = x123
val x125 = x124 < x120
x125}) {
var x127 = 0
val x140 = while ({val x128 = x127
val x129 = x128 < x69
x129}) {
val x131 = x123
val x133 = x127
val x134 = x123
val x135 = x127
val x132 = x131 - x117
val x136 = x68(x134, x135)
val x137 = x122(x132, x133) = x136
val x138 = x127 += 1
()
}
val x141 = x123 += 1
()
}
x122
}
val x145 = x145_block
val x147 = x146.numCols
val x164 = x145.numRows
val x166 = new generated.scala.IndexVectorRangeImpl(0,x164)
val x148 = x146.numRows
def x163_block = { 
val x149 = new generated.scala.FloatMatrixImpl(x147,x148)
val x150 = x149.numRows
var x152 : Int = 0
val x161 = while (x152 < x150) {
val x153 = x149.numCols
var x155 : Int = 0
val x159 = while (x155 < x153) {
val x156 = x146(x155, x152)
val x157 = x149(x152, x155) = x156
x157
x155 = x155 + 1
}
x159
x152 = x152 + 1
}
x149
}
val x163 = x163_block
val x180 = x163.numCols
def x204_block = { 
val x165 = new generated.scala.FloatMatrixImpl(x164,x147)
def x202_block = {
var forIdx = 0
while (forIdx < x166.size) {
val x167 = x166.dcApply(forIdx)
var x168 = 0
val x174 = x145(x167, 0)
val x198 = while ({val x169 = x168
val x170 = x165.numCols
val x171 = x169 < x170
x171}) {
var x173 = 1
val x175 = x168
val x176 = x163(x175, 0)
val x177 = x174 * x176
var x178 = x177
val x192 = while ({val x179 = x173
val x181 = x179 < x180
x181}) {
val x183 = x173
val x185 = x168
val x186 = x173
val x184 = x145(x167, x183)
val x187 = x163(x185, x186)
val x188 = x184 * x187
val x189 = x178 += x188
val x190 = x173 += 1
()
}
val x193 = x168
val x194 = x178
val x195 = x165(x167, x193) = x194
val x196 = x168 += 1
()
}
()
forIdx += 1
} // end while
}
val x202 = x202_block
x165
}
val x204 = x204_block
val x206 = x205.isRow
def x248_block = { 
val x246 = {
def x246thenb(): generated.scala.Matrix[Float] = {
val x207 = x205.length
val x208 = 1 * x207
val x209 = new generated.scala.FloatMatrixImpl(x15,x208)
val x210 = new generated.scala.IndexVectorRangeImpl(0,x208)
def x225_block = {
var forIdx = 0
while (forIdx < x210.size) {
val x211 = x210.dcApply(forIdx)
var x213 = 0
val x212 = x211 % x207
val x218 = x205(x212)
val x222 = while ({val x214 = x213
val x215 = x214 < x15
x215}) {
val x217 = x213
val x219 = x209(x217, x211) = x218
val x220 = x213 += 1
()
}
()
forIdx += 1
} // end while
}
val x225 = x225_block
x209
}
def x246elseb(): generated.scala.Matrix[Float] = {
val x207 = x205.length
val x227 = x15 * x207
val x228 = new generated.scala.FloatMatrixImpl(x227,1)
val x229 = new generated.scala.IndexVectorRangeImpl(0,x227)
def x244_block = {
var forIdx = 0
while (forIdx < x229.size) {
val x230 = x229.dcApply(forIdx)
var x232 = 0
val x231 = x230 % x207
val x237 = x205(x231)
val x241 = while ({val x233 = x232
val x234 = x233 < 1
x234}) {
val x236 = x232
val x238 = x228(x230, x236) = x237
val x239 = x232 += 1
()
}
()
forIdx += 1
} // end while
}
val x244 = x244_block
x228
}
if (x206) {
x246thenb()
} else {
x246elseb()
}
}
x246
}
val x248 = x248_block
val x249 = x204.numRows
val x250 = x204.numCols
def x256_block = {
val x251 = new generated.scala.FloatMatrixImpl(x249,x250)
var zipIdx = 0
while (zipIdx < x204.size) {
val x253 = x204.dcApply(zipIdx)
val x254 = x248.dcApply(zipIdx)
x251.dcUpdate(zipIdx,  {
val x255 = x253 + x254
x255
})
zipIdx += 1
} // end while
x251
}
val x256 = x256_block
val x265 = x256.numRows
val x266 = x256.numCols
def x269_block = {
val x267 = new generated.scala.FloatMatrixImpl(x265,x266)
var mapIdx = 0
while (mapIdx < x256.size) {
val x257 = x256.dcApply(mapIdx)
x267.dcUpdate(mapIdx,  {
val x258 = x257
val x259 = x258 * -1.0
val x260 = Math.exp(x259)
val x261 = 1.0 + x260
val x262 = 1.0 / x261
val x263 = x262.asInstanceOf[Float]
x263
})
mapIdx += 1
} // end while
x267
}
val x269 = x269_block
def x277_block = { 
x269
}
val x277 = x277_block
def x394_block = { 
val x387 = new generated.scala.FloatMatrixImpl(x15,x9)
def x392_block = {
var mapIdx = 0
while (mapIdx < x387.size) {
val x388 = x387.dcApply(mapIdx)
x387.dcUpdate(mapIdx,  {
val x389 = generated.scala.Global.randRef.nextFloat()
val x390 = x389.asInstanceOf[Float]
x390
})
mapIdx += 1
} // end while
x387
}
val x392 = x392_block
x392
}
val x394 = x394_block
val x294 = x277.numCols
val x295 = x277.numRows
def x401_block = {
val x399 = new generated.scala.FloatMatrixImpl(x295,x294)
var zipIdx = 0
while (zipIdx < x277.size) {
val x395 = x277.dcApply(zipIdx)
val x396 = x394.dcApply(zipIdx)
x399.dcUpdate(zipIdx,  {
val x397 = x395 > x396
val x398 = {
def x398thenb(): Float = {
1.0f
}
def x398elseb(): Float = {
0.0f
}
if (x397) {
x398thenb()
} else {
x398elseb()
}
}
x398
})
zipIdx += 1
} // end while
x399
}
val x401 = x401_block
val x403 = x402.numCols
val x404 = x402.numRows
def x419_block = { 
val x405 = new generated.scala.FloatMatrixImpl(x403,x404)
val x406 = x405.numRows
var x408 : Int = 0
val x417 = while (x408 < x406) {
val x409 = x405.numCols
var x411 : Int = 0
val x415 = while (x411 < x409) {
val x412 = x402(x411, x408)
val x413 = x405(x408, x411) = x412
x413
x411 = x411 + 1
}
x415
x408 = x408 + 1
}
x405
}
val x419 = x419_block
val x420 = x419.numCols
val x437 = x401.numRows
val x439 = new generated.scala.IndexVectorRangeImpl(0,x437)
val x421 = x419.numRows
def x436_block = { 
val x422 = new generated.scala.FloatMatrixImpl(x420,x421)
val x423 = x422.numRows
var x425 : Int = 0
val x434 = while (x425 < x423) {
val x426 = x422.numCols
var x428 : Int = 0
val x432 = while (x428 < x426) {
val x429 = x419(x428, x425)
val x430 = x422(x425, x428) = x429
x430
x428 = x428 + 1
}
x432
x425 = x425 + 1
}
x422
}
val x436 = x436_block
val x453 = x436.numCols
def x476_block = { 
val x438 = new generated.scala.FloatMatrixImpl(x437,x420)
def x474_block = {
var forIdx = 0
while (forIdx < x439.size) {
val x440 = x439.dcApply(forIdx)
var x441 = 0
val x447 = x401(x440, 0)
val x471 = while ({val x442 = x441
val x443 = x438.numCols
val x444 = x442 < x443
x444}) {
var x446 = 1
val x448 = x441
val x449 = x436(x448, 0)
val x450 = x447 * x449
var x451 = x450
val x465 = while ({val x452 = x446
val x454 = x452 < x453
x454}) {
val x456 = x446
val x458 = x441
val x459 = x446
val x457 = x401(x440, x456)
val x460 = x436(x458, x459)
val x461 = x457 * x460
val x462 = x451 += x461
val x463 = x446 += 1
()
}
val x466 = x441
val x467 = x451
val x468 = x438(x440, x466) = x467
val x469 = x441 += 1
()
}
()
forIdx += 1
} // end while
}
val x474 = x474_block
x438
}
val x476 = x476_block
val x478 = x477.isRow
def x520_block = { 
val x518 = {
def x518thenb(): generated.scala.Matrix[Float] = {
val x479 = x477.length
val x480 = 1 * x479
val x481 = new generated.scala.FloatMatrixImpl(x15,x480)
val x482 = new generated.scala.IndexVectorRangeImpl(0,x480)
def x497_block = {
var forIdx = 0
while (forIdx < x482.size) {
val x483 = x482.dcApply(forIdx)
var x485 = 0
val x484 = x483 % x479
val x490 = x477(x484)
val x494 = while ({val x486 = x485
val x487 = x486 < x15
x487}) {
val x489 = x485
val x491 = x481(x489, x483) = x490
val x492 = x485 += 1
()
}
()
forIdx += 1
} // end while
}
val x497 = x497_block
x481
}
def x518elseb(): generated.scala.Matrix[Float] = {
val x479 = x477.length
val x499 = x15 * x479
val x500 = new generated.scala.FloatMatrixImpl(x499,1)
val x501 = new generated.scala.IndexVectorRangeImpl(0,x499)
def x516_block = {
var forIdx = 0
while (forIdx < x501.size) {
val x502 = x501.dcApply(forIdx)
var x504 = 0
val x503 = x502 % x479
val x509 = x477(x503)
val x513 = while ({val x505 = x504
val x506 = x505 < 1
x506}) {
val x508 = x504
val x510 = x500(x502, x508) = x509
val x511 = x504 += 1
()
}
()
forIdx += 1
} // end while
}
val x516 = x516_block
x500
}
if (x478) {
x518thenb()
} else {
x518elseb()
}
}
x518
}
val x520 = x520_block
val x521 = x476.numRows
val x522 = x476.numCols
def x528_block = {
val x523 = new generated.scala.FloatMatrixImpl(x521,x522)
var zipIdx = 0
while (zipIdx < x476.size) {
val x525 = x476.dcApply(zipIdx)
val x526 = x520.dcApply(zipIdx)
x523.dcUpdate(zipIdx,  {
val x527 = x525 + x526
x527
})
zipIdx += 1
} // end while
x523
}
val x528 = x528_block
val x537 = x528.numRows
val x538 = x528.numCols
def x541_block = {
val x539 = new generated.scala.FloatMatrixImpl(x537,x538)
var mapIdx = 0
while (mapIdx < x528.size) {
val x529 = x528.dcApply(mapIdx)
x539.dcUpdate(mapIdx,  {
val x530 = x529
val x531 = x530 * -1.0
val x532 = Math.exp(x531)
val x533 = 1.0 + x532
val x534 = 1.0 / x533
val x535 = x534.asInstanceOf[Float]
x535
})
mapIdx += 1
} // end while
x539
}
val x541 = x541_block
def x549_block = { 
x541
}
val x549 = x549_block
val x278 = x145.numCols
def x795_block = {
val x790 = new generated.scala.FloatMatrixImpl(x164,x278)
var zipIdx = 0
while (zipIdx < x145.size) {
val x792 = x145.dcApply(zipIdx)
val x793 = x549.dcApply(zipIdx)
x790.dcUpdate(zipIdx,  {
val x794 = x792 - x793
x794
})
zipIdx += 1
} // end while
x790
}
val x795 = x795_block
val x796 = x795.numRows
val x797 = x795.numCols
def x803_block = {
val x798 = new generated.scala.FloatMatrixImpl(x796,x797)
var zipIdx = 0
while (zipIdx < x795.size) {
val x800 = x795.dcApply(zipIdx)
val x801 = x795.dcApply(zipIdx)
x798.dcUpdate(zipIdx,  {
val x802 = x800 * x801
x802
})
zipIdx += 1
} // end while
x798
}
val x803 = x803_block
def x807_block = {
var x804 = x803.dcApply(0)
var reduceIdx = 1
while (reduceIdx < x803.size) {
val x805 = x803.dcApply(reduceIdx)
x804 = {
val x806 = x804 + x805
x806
}
reduceIdx += 1
} // end while
x804
}
val x807 = x807_block
val x808 = x111 += x807
val x809 = x107
val x812 = x99
val x836 = x87
val x813 = x812.numRows
val x814 = x812.numCols
val x810 = x809 > 5
val x811 = {
def x811thenb(): Float = {
0.9f
}
def x811elseb(): Float = {
0.5f
}
if (x810) {
x811thenb()
} else {
x811elseb()
}
}
def x819_block = {
val x815 = new generated.scala.FloatMatrixImpl(x813,x814)
var mapIdx = 0
while (mapIdx < x812.size) {
val x817 = x812.dcApply(mapIdx)
x815.dcUpdate(mapIdx,  {
val x818 = x817 * x811
x818
})
mapIdx += 1
} // end while
x815
}
val x819 = x819_block
def x293_block = { 
val x279 = new generated.scala.FloatMatrixImpl(x278,x164)
val x280 = x279.numRows
var x282 : Int = 0
val x291 = while (x282 < x280) {
val x283 = x279.numCols
var x285 : Int = 0
val x289 = while (x285 < x283) {
val x286 = x145(x285, x282)
val x287 = x279(x282, x285) = x286
x287
x285 = x285 + 1
}
x289
x282 = x282 + 1
}
x279
}
val x293 = x293_block
val x311 = x293.numRows
val x313 = new generated.scala.IndexVectorRangeImpl(0,x311)
def x310_block = { 
val x296 = new generated.scala.FloatMatrixImpl(x294,x295)
val x297 = x296.numRows
var x299 : Int = 0
val x308 = while (x299 < x297) {
val x300 = x296.numCols
var x302 : Int = 0
val x306 = while (x302 < x300) {
val x303 = x277(x302, x299)
val x304 = x296(x299, x302) = x303
x304
x302 = x302 + 1
}
x306
x299 = x299 + 1
}
x296
}
val x310 = x310_block
val x327 = x310.numCols
def x350_block = { 
val x312 = new generated.scala.FloatMatrixImpl(x311,x294)
def x348_block = {
var forIdx = 0
while (forIdx < x313.size) {
val x314 = x313.dcApply(forIdx)
var x315 = 0
val x321 = x293(x314, 0)
val x345 = while ({val x316 = x315
val x317 = x312.numCols
val x318 = x316 < x317
x318}) {
var x320 = 1
val x322 = x315
val x323 = x310(x322, 0)
val x324 = x321 * x323
var x325 = x324
val x339 = while ({val x326 = x320
val x328 = x326 < x327
x328}) {
val x330 = x320
val x332 = x315
val x333 = x320
val x331 = x293(x314, x330)
val x334 = x310(x332, x333)
val x335 = x331 * x334
val x336 = x325 += x335
val x337 = x320 += 1
()
}
val x340 = x315
val x341 = x325
val x342 = x312(x314, x340) = x341
val x343 = x315 += 1
()
}
()
forIdx += 1
} // end while
}
val x348 = x348_block
x312
}
val x350 = x350_block
val x551 = x550.numCols
val x568 = x549.numRows
val x570 = new generated.scala.IndexVectorRangeImpl(0,x568)
val x552 = x550.numRows
def x567_block = { 
val x553 = new generated.scala.FloatMatrixImpl(x551,x552)
val x554 = x553.numRows
var x556 : Int = 0
val x565 = while (x556 < x554) {
val x557 = x553.numCols
var x559 : Int = 0
val x563 = while (x559 < x557) {
val x560 = x550(x559, x556)
val x561 = x553(x556, x559) = x560
x561
x559 = x559 + 1
}
x563
x556 = x556 + 1
}
x553
}
val x567 = x567_block
val x584 = x567.numCols
def x607_block = { 
val x569 = new generated.scala.FloatMatrixImpl(x568,x551)
def x605_block = {
var forIdx = 0
while (forIdx < x570.size) {
val x571 = x570.dcApply(forIdx)
var x572 = 0
val x578 = x549(x571, 0)
val x602 = while ({val x573 = x572
val x574 = x569.numCols
val x575 = x573 < x574
x575}) {
var x577 = 1
val x579 = x572
val x580 = x567(x579, 0)
val x581 = x578 * x580
var x582 = x581
val x596 = while ({val x583 = x577
val x585 = x583 < x584
x585}) {
val x587 = x577
val x589 = x572
val x590 = x577
val x588 = x549(x571, x587)
val x591 = x567(x589, x590)
val x592 = x588 * x591
val x593 = x582 += x592
val x594 = x577 += 1
()
}
val x597 = x572
val x598 = x582
val x599 = x569(x571, x597) = x598
val x600 = x572 += 1
()
}
()
forIdx += 1
} // end while
}
val x605 = x605_block
x569
}
val x607 = x607_block
val x609 = x608.isRow
def x651_block = { 
val x649 = {
def x649thenb(): generated.scala.Matrix[Float] = {
val x610 = x608.length
val x611 = 1 * x610
val x612 = new generated.scala.FloatMatrixImpl(x15,x611)
val x613 = new generated.scala.IndexVectorRangeImpl(0,x611)
def x628_block = {
var forIdx = 0
while (forIdx < x613.size) {
val x614 = x613.dcApply(forIdx)
var x616 = 0
val x615 = x614 % x610
val x621 = x608(x615)
val x625 = while ({val x617 = x616
val x618 = x617 < x15
x618}) {
val x620 = x616
val x622 = x612(x620, x614) = x621
val x623 = x616 += 1
()
}
()
forIdx += 1
} // end while
}
val x628 = x628_block
x612
}
def x649elseb(): generated.scala.Matrix[Float] = {
val x610 = x608.length
val x630 = x15 * x610
val x631 = new generated.scala.FloatMatrixImpl(x630,1)
val x632 = new generated.scala.IndexVectorRangeImpl(0,x630)
def x647_block = {
var forIdx = 0
while (forIdx < x632.size) {
val x633 = x632.dcApply(forIdx)
var x635 = 0
val x634 = x633 % x610
val x640 = x608(x634)
val x644 = while ({val x636 = x635
val x637 = x636 < 1
x637}) {
val x639 = x635
val x641 = x631(x633, x639) = x640
val x642 = x635 += 1
()
}
()
forIdx += 1
} // end while
}
val x647 = x647_block
x631
}
if (x609) {
x649thenb()
} else {
x649elseb()
}
}
x649
}
val x651 = x651_block
val x652 = x607.numRows
val x653 = x607.numCols
def x659_block = {
val x654 = new generated.scala.FloatMatrixImpl(x652,x653)
var zipIdx = 0
while (zipIdx < x607.size) {
val x656 = x607.dcApply(zipIdx)
val x657 = x651.dcApply(zipIdx)
x654.dcUpdate(zipIdx,  {
val x658 = x656 + x657
x658
})
zipIdx += 1
} // end while
x654
}
val x659 = x659_block
val x668 = x659.numRows
val x669 = x659.numCols
def x672_block = {
val x670 = new generated.scala.FloatMatrixImpl(x668,x669)
var mapIdx = 0
while (mapIdx < x659.size) {
val x660 = x659.dcApply(mapIdx)
x670.dcUpdate(mapIdx,  {
val x661 = x660
val x662 = x661 * -1.0
val x663 = Math.exp(x662)
val x664 = 1.0 + x663
val x665 = 1.0 / x664
val x666 = x665.asInstanceOf[Float]
x666
})
mapIdx += 1
} // end while
x670
}
val x672 = x672_block
def x680_block = { 
x672
}
val x680 = x680_block
val x681 = x549.numCols
def x696_block = { 
val x682 = new generated.scala.FloatMatrixImpl(x681,x568)
val x683 = x682.numRows
var x685 : Int = 0
val x694 = while (x685 < x683) {
val x686 = x682.numCols
var x688 : Int = 0
val x692 = while (x688 < x686) {
val x689 = x549(x688, x685)
val x690 = x682(x685, x688) = x689
x690
x688 = x688 + 1
}
x692
x685 = x685 + 1
}
x682
}
val x696 = x696_block
val x697 = x680.numCols
val x714 = x696.numRows
val x716 = new generated.scala.IndexVectorRangeImpl(0,x714)
val x698 = x680.numRows
def x713_block = { 
val x699 = new generated.scala.FloatMatrixImpl(x697,x698)
val x700 = x699.numRows
var x702 : Int = 0
val x711 = while (x702 < x700) {
val x703 = x699.numCols
var x705 : Int = 0
val x709 = while (x705 < x703) {
val x706 = x680(x705, x702)
val x707 = x699(x702, x705) = x706
x707
x705 = x705 + 1
}
x709
x702 = x702 + 1
}
x699
}
val x713 = x713_block
val x730 = x713.numCols
def x753_block = { 
val x715 = new generated.scala.FloatMatrixImpl(x714,x697)
def x751_block = {
var forIdx = 0
while (forIdx < x716.size) {
val x717 = x716.dcApply(forIdx)
var x718 = 0
val x724 = x696(x717, 0)
val x748 = while ({val x719 = x718
val x720 = x715.numCols
val x721 = x719 < x720
x721}) {
var x723 = 1
val x725 = x718
val x726 = x713(x725, 0)
val x727 = x724 * x726
var x728 = x727
val x742 = while ({val x729 = x723
val x731 = x729 < x730
x731}) {
val x733 = x723
val x735 = x718
val x736 = x723
val x734 = x696(x717, x733)
val x737 = x713(x735, x736)
val x738 = x734 * x737
val x739 = x728 += x738
val x740 = x723 += 1
()
}
val x743 = x718
val x744 = x728
val x745 = x715(x717, x743) = x744
val x746 = x718 += 1
()
}
()
forIdx += 1
} // end while
}
val x751 = x751_block
x715
}
val x753 = x753_block
val x820 = x350.numRows
val x821 = x350.numCols
def x827_block = {
val x822 = new generated.scala.FloatMatrixImpl(x820,x821)
var zipIdx = 0
while (zipIdx < x350.size) {
val x824 = x350.dcApply(zipIdx)
val x825 = x753.dcApply(zipIdx)
x822.dcUpdate(zipIdx,  {
val x826 = x824 - x825
x826
})
zipIdx += 1
} // end while
x822
}
val x827 = x827_block
val x829 = x827.numRows
val x830 = x827.numCols
def x835_block = {
val x831 = new generated.scala.FloatMatrixImpl(x829,x830)
var mapIdx = 0
while (mapIdx < x827.size) {
val x833 = x827.dcApply(mapIdx)
x831.dcUpdate(mapIdx,  {
val x834 = x833 / x828
x834
})
mapIdx += 1
} // end while
x831
}
val x835 = x835_block
val x837 = x836.numRows
val x838 = x836.numCols
def x843_block = {
val x839 = new generated.scala.FloatMatrixImpl(x837,x838)
var mapIdx = 0
while (mapIdx < x836.size) {
val x841 = x836.dcApply(mapIdx)
x839.dcUpdate(mapIdx,  {
val x842 = x841 * 2.0E-4f
x842
})
mapIdx += 1
} // end while
x839
}
val x843 = x843_block
val x844 = x835.numRows
val x845 = x835.numCols
def x851_block = {
val x846 = new generated.scala.FloatMatrixImpl(x844,x845)
var zipIdx = 0
while (zipIdx < x835.size) {
val x848 = x835.dcApply(zipIdx)
val x849 = x843.dcApply(zipIdx)
x846.dcUpdate(zipIdx,  {
val x850 = x848 - x849
x850
})
zipIdx += 1
} // end while
x846
}
val x851 = x851_block
val x852 = x851.numRows
val x853 = x851.numCols
def x858_block = {
val x854 = new generated.scala.FloatMatrixImpl(x852,x853)
var mapIdx = 0
while (mapIdx < x851.size) {
val x856 = x851.dcApply(mapIdx)
x854.dcUpdate(mapIdx,  {
val x857 = x856 * 0.1f
x857
})
mapIdx += 1
} // end while
x854
}
val x858 = x858_block
val x859 = x819.numRows
val x860 = x819.numCols
def x866_block = {
val x861 = new generated.scala.FloatMatrixImpl(x859,x860)
var zipIdx = 0
while (zipIdx < x819.size) {
val x863 = x819.dcApply(zipIdx)
val x864 = x858.dcApply(zipIdx)
x861.dcUpdate(zipIdx,  {
val x865 = x863 + x864
x865
})
zipIdx += 1
} // end while
x861
}
val x866 = x866_block
x99 = x866
val x868 = x105
val x869 = x868.length
val x870 = x868.isRow
val x876 = {
val x872 = new generated.scala.FloatVectorImpl(x869,x870)
x872
}
var x871 = 0
while (x871 < x869) {  // begin fat loop x876
val x874 = x868(x871)
val x875 = x874 * x811
x876.dcUpdate(x871, x875)
x871 += 1
} // end fat loop x876
val x370 = new generated.scala.IndexVectorRangeImpl(0,x278)
def x386_block = { 
val x369 = new generated.scala.FloatVectorImpl(x278,true)
def x384_block = {
var forIdx = 0
while (forIdx < x370.size) {
val x371 = x370.dcApply(forIdx)
val x372 = x145.vview(x371,x278,x164,false)
def x373_block = { 
x372
}
val x373 = x373_block
val x374 = x373.length
var x380: Float = 0
var x375 = 0
while (x375 < x374) {  // begin fat loop x380
val x378 = x373(x375)
val x376 = x380
val x377 = x378
val x379 = x376 + x377
x380 = x379
x375 += 1
} // end fat loop x380
val x381 = x369(x371) = x380
x381
forIdx += 1
} // end while
}
val x384 = x384_block
x369
}
val x386 = x386_block
val x877 = x386.length
val x878 = x386.isRow
val x773 = new generated.scala.IndexVectorRangeImpl(0,x681)
def x789_block = { 
val x772 = new generated.scala.FloatVectorImpl(x681,true)
def x787_block = {
var forIdx = 0
while (forIdx < x773.size) {
val x774 = x773.dcApply(forIdx)
val x775 = x549.vview(x774,x681,x568,false)
def x776_block = { 
x775
}
val x776 = x776_block
val x777 = x776.length
var x783: Float = 0
var x778 = 0
while (x778 < x777) {  // begin fat loop x783
val x781 = x776(x778)
val x779 = x783
val x780 = x781
val x782 = x779 + x780
x783 = x782
x778 += 1
} // end fat loop x783
val x784 = x772(x774) = x783
x784
forIdx += 1
} // end while
}
val x787 = x787_block
x772
}
val x789 = x789_block
val x885 = {
val x880 = new generated.scala.FloatVectorImpl(x877,x878)
x880
}
var x879 = 0
while (x879 < x877) {  // begin fat loop x885
val x882 = x386(x879)
val x883 = x789(x879)
val x884 = x882 - x883
x885.dcUpdate(x879, x884)
x879 += 1
} // end fat loop x885
val x892 = {
val x888 = new generated.scala.FloatVectorImpl(x877,x878)
x888
}
var x887 = 0
while (x887 < x877) {  // begin fat loop x892
val x890 = x885(x887)
val x891 = x890 * x886
x892.dcUpdate(x887, x891)
x887 += 1
} // end fat loop x892
val x899 = {
val x894 = new generated.scala.FloatVectorImpl(x869,x870)
x894
}
var x893 = 0
while (x893 < x869) {  // begin fat loop x899
val x896 = x876(x893)
val x897 = x892(x893)
val x898 = x896 + x897
x899.dcUpdate(x893, x898)
x893 += 1
} // end fat loop x899
x105 = x899
val x901 = x102
val x902 = x901.length
val x903 = x901.isRow
val x909 = {
val x905 = new generated.scala.FloatVectorImpl(x902,x903)
x905
}
var x904 = 0
while (x904 < x902) {  // begin fat loop x909
val x907 = x901(x904)
val x908 = x907 * x811
x909.dcUpdate(x904, x908)
x904 += 1
} // end fat loop x909
val x352 = new generated.scala.IndexVectorRangeImpl(0,x294)
def x368_block = { 
val x351 = new generated.scala.FloatVectorImpl(x294,true)
def x366_block = {
var forIdx = 0
while (forIdx < x352.size) {
val x353 = x352.dcApply(forIdx)
val x354 = x277.vview(x353,x294,x295,false)
def x355_block = { 
x354
}
val x355 = x355_block
val x356 = x355.length
var x362: Float = 0
var x357 = 0
while (x357 < x356) {  // begin fat loop x362
val x360 = x355(x357)
val x358 = x362
val x359 = x360
val x361 = x358 + x359
x362 = x361
x357 += 1
} // end fat loop x362
val x363 = x351(x353) = x362
x363
forIdx += 1
} // end while
}
val x366 = x366_block
x351
}
val x368 = x368_block
val x910 = x368.length
val x911 = x368.isRow
val x755 = new generated.scala.IndexVectorRangeImpl(0,x697)
def x771_block = { 
val x754 = new generated.scala.FloatVectorImpl(x697,true)
def x769_block = {
var forIdx = 0
while (forIdx < x755.size) {
val x756 = x755.dcApply(forIdx)
val x757 = x680.vview(x756,x697,x698,false)
def x758_block = { 
x757
}
val x758 = x758_block
val x759 = x758.length
var x765: Float = 0
var x760 = 0
while (x760 < x759) {  // begin fat loop x765
val x763 = x758(x760)
val x761 = x765
val x762 = x763
val x764 = x761 + x762
x765 = x764
x760 += 1
} // end fat loop x765
val x766 = x754(x756) = x765
x766
forIdx += 1
} // end while
}
val x769 = x769_block
x754
}
val x771 = x771_block
val x918 = {
val x913 = new generated.scala.FloatVectorImpl(x910,x911)
x913
}
var x912 = 0
while (x912 < x910) {  // begin fat loop x918
val x915 = x368(x912)
val x916 = x771(x912)
val x917 = x915 - x916
x918.dcUpdate(x912, x917)
x912 += 1
} // end fat loop x918
val x924 = {
val x920 = new generated.scala.FloatVectorImpl(x910,x911)
x920
}
var x919 = 0
while (x919 < x910) {  // begin fat loop x924
val x922 = x918(x919)
val x923 = x922 * x886
x924.dcUpdate(x919, x923)
x919 += 1
} // end fat loop x924
val x931 = {
val x926 = new generated.scala.FloatVectorImpl(x902,x903)
x926
}
var x925 = 0
while (x925 < x902) {  // begin fat loop x931
val x928 = x909(x925)
val x929 = x924(x925)
val x930 = x928 + x929
x931.dcUpdate(x925, x930)
x925 += 1
} // end fat loop x931
x102 = x931
val x933 = x99
def x939_block = {
val x934 = new generated.scala.FloatMatrixImpl(x837,x838)
var zipIdx = 0
while (zipIdx < x836.size) {
val x936 = x836.dcApply(zipIdx)
val x937 = x933.dcApply(zipIdx)
x934.dcUpdate(zipIdx,  {
val x938 = x936 + x937
x938
})
zipIdx += 1
} // end while
x934
}
val x939 = x939_block
x87 = x939
val x941 = x95
val x942 = x105
val x943 = x941.length
val x944 = x941.isRow
val x951 = {
val x946 = new generated.scala.FloatVectorImpl(x943,x944)
x946
}
var x945 = 0
while (x945 < x943) {  // begin fat loop x951
val x948 = x941(x945)
val x949 = x942(x945)
val x950 = x948 + x949
x951.dcUpdate(x945, x950)
x945 += 1
} // end fat loop x951
x95 = x951
val x953 = x91
val x954 = x102
val x955 = x953.length
val x956 = x953.isRow
val x963 = {
val x958 = new generated.scala.FloatVectorImpl(x955,x956)
x958
}
var x957 = 0
while (x957 < x955) {  // begin fat loop x963
val x960 = x953(x957)
val x961 = x954(x957)
val x962 = x960 + x961
x963.dcUpdate(x957, x962)
x957 += 1
} // end fat loop x963
x91 = x963
val x965 = x112 += 1
()
}
val x968 = x107
val x969 = "--> Epoch "+x968
val x970 = println(x969)
val x971 = x111
val x972 = " error = "+x971
val x973 = println(x972)
val x974 = x107 += 1
()
}
val x977 = println("toc:" + (System.nanoTime / 1000000L))
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
