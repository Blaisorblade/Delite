/*****************************************
  Emitting Generated Code                  
*******************************************/
class RBM extends ((Array[java.lang.String])=>(Unit)) {
def apply(x0:Array[java.lang.String]): Unit = {
val x1 = { generated.scala.Global.randRef.setSeed(generated.scala.Global.INITIAL_SEED);   generated.scala.Global.intRandRef.setSeed(generated.scala.Global.INITIAL_SEED); }
val x2 = x0.length
val x3 = x2 < 3
val x7 = {
def x7thenb(): Nothing = {
val x4 = println("Usage: RBM <MNIST data file> <numHiddenUnits> <numcases>")
val x5 = exit(-1)
x5
}
def x7elseb(): Unit = {
()
}
if (x3) {
x7thenb()
} else {
x7elseb()
}
}
val x8 = x0(1)
val x9 = java.lang.Integer.parseInt(x8)
val x10 = "Using "+x9
val x11 = x10+" hidden units."
val x12 = println(x11)
val x13 = println("Reading MNIST dataset")
val x16 = x0(0)
def x61_block = { 
val x17 = new java.io.FileReader(x16)
val x18 = new java.io.BufferedReader(x17)
val x19 = x18.readLine()
var x20 = x19
val x21 = x20
val x22 = x21.trim()
x20 = x22
val x24 = x20
val x25 = x24.split("\\s+")
var x26 = x25
val x27 = x26
val x28 = x27.length
val x29 = new generated.scala.DoubleMatrixImpl(0,x28)
val x58 = while ({val x30 = x20
val x31 = x30 != null
x31}) {
val x33 = x26
val x34 = x33.length
val x35 = new generated.scala.DoubleVectorImpl(x34,true)
var x37 : Int = 0
val x43 = while (x37 < x34) {
val x38 = x26
val x39 = x38(x37)
val x40 = java.lang.Double.parseDouble(x39)
val x41 = x35(x37) = x40
x41
x37 = x37 + 1
}
val x44 = x29.numRows
val x45 = x29.insertRow(x44,x35)
val x46 = x18.readLine()
x20 = x46
val x48 = x20
val x49 = x48 != null
val x56 = {
def x56thenb(): Unit = {
val x50 = x48.trim()
x20 = x50
val x52 = x20
val x53 = x52.split("\\s+")
x26 = x53
()
}
def x56elseb(): Unit = {
()
}
if (x49) {
x56thenb()
} else {
x56elseb()
}
}
x56
}
val x59 = x18.close()
x29
}
val x61 = x61_block
val x64 = x61.numRows
val x65 = x61.numCols
def x68_block = {
val x66 = new generated.scala.FloatMatrixImpl(x64,x65)
var mapIdx = 0
while (mapIdx < x61.size) {
val x62 = x61.dcApply(mapIdx)
x66.dcUpdate(mapIdx,  {
val x63 = x62.floatValue()
x63
})
mapIdx += 1
} // end while
x66
}
val x68 = x68_block
val x69 = x68.numCols
def x79_block = { 
val x72 = new generated.scala.FloatMatrixImpl(x69,x9)
def x77_block = {
var mapIdx = 0
while (mapIdx < x72.size) {
val x73 = x72.dcApply(mapIdx)
x72.dcUpdate(mapIdx,  {
val x74 = generated.scala.Global.randRef.nextGaussian()
val x75 = x74.floatValue()
x75
})
mapIdx += 1
} // end while
x72
}
val x77 = x77_block
x77
}
val x79 = x79_block
val x80 = x79.numRows
val x81 = x79.numCols
def x86_block = {
val x82 = new generated.scala.FloatMatrixImpl(x80,x81)
var mapIdx = 0
while (mapIdx < x79.size) {
val x84 = x79.dcApply(mapIdx)
x82.dcUpdate(mapIdx,  {
val x85 = x84 * 0.1f
x85
})
mapIdx += 1
} // end while
x82
}
val x86 = x86_block
var x87 = x86
def x90_block = { 
val x88 = new generated.scala.FloatVectorImpl(x9,true)
x88
}
val x90 = x90_block
var x91 = x90
def x94_block = { 
val x92 = new generated.scala.FloatVectorImpl(x69,true)
x92
}
val x94 = x94_block
var x95 = x94
def x98_block = { 
val x96 = new generated.scala.FloatMatrixImpl(x69,x9)
x96
}
val x98 = x98_block
var x99 = x98
var x102 = x90
var x105 = x94
val x106 = println("tic:" + (System.nanoTime / 1000000L))
var x107 = 0
val x14 = x0(2)
val x15 = java.lang.Integer.parseInt(x14)
val x70 = x68.numRows
val x71 = x70 / x15
val x801 = x15
val x859 = 0.1f / x801
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
