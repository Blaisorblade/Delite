/*****************************************
  Emitting Generated Code                  
*******************************************/
class gradientRunner extends ((Array[java.lang.String])=>(Unit)) {
def apply(x0:Array[java.lang.String]): Unit = {
val x1 = x0(0)
val x54 = { 
val x2 = new java.io.FileReader(x1)
val x3 = new java.io.BufferedReader(x2)
val x4 = x3.readLine()
var x5: java.lang.String = x4
val x6 = x5
val x7 = x6.trim()
x5 = x7
val x9 = x5
val x10 = x9.split("\\s+")
var x11: Array[java.lang.String] = x10
val x12 = x11
val x13 = x12.length
val x14 = new generated.scala.IntMatrixImpl(0,x13)
val x49 = while ({val x15 = x5
val x16 = x15 != null
x16}) {
val x18 = x11
val x19 = x18.length
val x20 = new generated.scala.IntVectorImpl(x19,true)
var x21: Int = 0
val x22 = x21
val x33 = while ({val x23 = x11
val x24 = x23.length
val x25 = x22 < x24
x25}) {
val x27 = x11
val x28 = x27(x22)
val x29 = java.lang.Integer.parseInt(x28)
val x30 = x20(x22) = x29
val x31 = x21 += 1
()
}
val x34 = x20// unsafe immutable
val x35 = x14.numRows
val x36 = x14.insertRow(x35,x34)
val x37 = x3.readLine()
x5 = x37
val x39 = x5
val x40 = x39 != null
val x41 = x39.trim()
val x47 = {
def x47thenb(): Unit = {
x5 = x41
val x43 = x5
val x44 = x43.split("\\s+")
x11 = x44
()
}
if (x40) {
x47thenb()
}
}
x47
}
val x50 = x3.close()
val x51 = x14// unsafe immutable
val x52 = new generated.scala.GrayscaleImageImpl(x51)
x52
}
val x55 = x0(1)
val x61 = x60.getPath()
val x222 = { 
val x56 = new generated.scala.VectorImpl[java.lang.String](0,true)
val x57 = new java.io.File(x55)
val x58 = x57.getCanonicalFile()
val x59 = x58.listFiles()
val x62 = x56.length
val x63 = x56.insert(x62, x61)
val x65=x59.foreach{
x60 => 
x63
}
def x220_block = {
val x216 = x56.length
val x217 = x56.isRow
val x218 = new generated.scala.VectorImpl[scala.Tuple2[java.lang.String, generated.scala.Vector[generated.scala.BinarizedGradientTemplate]]](x216,x217)
var mapIdx = 0
while (mapIdx < x56.size) { // begin map loop x220
val x66 = x56.dcApply(mapIdx)
x218.dcUpdate(mapIdx,  {
val x67 = "Loading model: "+x66
val x68 = println(x67)
val x69 = new generated.scala.VectorImpl[generated.scala.BinarizedGradientTemplate](0,true)
val x70 = new java.io.FileReader(x66)
val x71 = new java.io.BufferedReader(x70)
val x72 = x71.readLine()
val x73 = x72 != "bigg_object:"
val x76 = {
def x76thenb(): Nothing = {
val x74 = error("Illegal data format")
x74
}
if (x73) {
x76thenb()
}
}
val x77 = x71.readLine()
val x78 = x71.readLine()
val x79 = x78.trim()
val x80 = x79.split(" ")
val x81 = x80(0)
val x82 = x81 != "obj_name/obj_num/num_objs:"
val x85 = {
def x85thenb(): Nothing = {
val x83 = error("Illegal data format")
x83
}
if (x82) {
x85thenb()
}
}
var x90: Int = 0
val x88 = x80(3)
val x89 = java.lang.Integer.parseInt(x88)
val x91 = x90
val x92 = x91 < x89
val x212 = while ({x92}) {
val x93 = x71.readLine()
val x94 = x93.trim()
val x95 = x94 != "====OneBiGG====:"
val x98 = {
def x98thenb(): Nothing = {
val x96 = error("Illegal data format")
x96
}
if (x95) {
x98thenb()
}
}
val x99 = x71.readLine()
val x100 = x99.trim()
val x101 = x100.split(" ")
var x102: Array[java.lang.String] = x101
val x103 = x102
val x104 = x103(0)
val x105 = x104 != "view/radius/reduction:"
val x108 = {
def x108thenb(): Nothing = {
val x106 = error("Illegal data format")
x106
}
if (x105) {
x108thenb()
}
}
val x109 = x102
val x116 = x71.readLine()
val x117 = x116.trim()
val x118 = x117.split(" ")
x102 = x118
val x120 = x102
val x121 = x120(0)
val x122 = x121 != "Gradients:"
val x125 = {
def x125thenb(): Nothing = {
val x123 = error("Illegal data format")
x123
}
if (x122) {
x125thenb()
}
}
val x126 = x102
val x127 = x126(1)
val x128 = java.lang.Integer.parseInt(x127)
val x129 = new generated.scala.IntVectorImpl(x128,true)
val x130 = x71.readLine()
var x133: Int = 0
val x134 = x133
val x135 = x134 < x128
val x131 = x130.trim()
val x132 = x131.split(" ")
val x136 = x132(x134)
val x137 = java.lang.Integer.parseInt(x136)
val x141 = while ({x135}) {
val x138 = x129(x134) = x137
val x139 = x133 += 1
()
}
val x142 = x71.readLine()
val x143 = x142.trim()
val x144 = x143.split(" ")
x102 = x144
val x146 = x102
val x147 = x146(0)
val x148 = x147 != "Match_list:"
val x151 = {
def x151thenb(): Nothing = {
val x149 = error("Illegal data format")
x149
}
if (x148) {
x151thenb()
}
}
val x152 = x102
val x155 = new generated.scala.IndexVectorSeqImpl(0)
val x156 = x71.readLine()
x133 = 0
val x153 = x152(1)
val x154 = java.lang.Integer.parseInt(x153)
val x160 = x134 < x154
val x157 = x156.trim()
val x158 = x157.split(" ")
val x161 = x158(x134)
val x162 = java.lang.Integer.parseInt(x161)
val x167 = while ({x160}) {
val x163 = x155.length
val x164 = x155.insert(x163, x162)
val x165 = x133 += 1
()
}
val x168 = x71.readLine()
val x169 = x168.trim()
val x170 = x169.split(" ")
x102 = x170
val x172 = x102
val x173 = x172(0)
val x174 = x173 != "Occlusions:"
val x177 = {
def x177thenb(): Nothing = {
val x175 = error("Illegal data format")
x175
}
if (x174) {
x177thenb()
}
}
val x178 = x102
val x181 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](0,true)
val x182 = x71.readLine()
val x179 = x178(1)
val x180 = java.lang.Integer.parseInt(x179)
val x185 = x180 != 0
val x188 = {
def x188thenb(): Nothing = {
val x186 = error("Occlusions not supported.")
x186
}
if (x185) {
x188thenb()
}
}
val x189 = x71.readLine()
val x190 = x189.trim()
val x191 = x190 != "BoundingBox:"
val x194 = {
def x194thenb(): Nothing = {
val x192 = error("Illegal data format")
x192
}
if (x191) {
x194thenb()
}
}
val x195 = x71.readLine()
val x196 = x195.trim()
val x197 = x196.split(" ")
val x198 = x197(0)
val x199 = java.lang.Integer.parseInt(x198)
val x200 = x197(1)
val x201 = java.lang.Integer.parseInt(x200)
val x202 = x197(2)
val x203 = java.lang.Integer.parseInt(x202)
val x204 = x197(3)
val x205 = java.lang.Integer.parseInt(x204)
val x206 = new generated.scala.Rect(x199,x201,x203,x205)
val x112 = x109(2)
val x113 = java.lang.Integer.parseInt(x112)
val x207 = new generated.scala.BinarizedGradientTemplate(x113,x206,null,0,x129,x155,x181,null,null)
val x208 = x69.length
val x209 = x69.insert(x208, x207)
val x210 = x90 += 1
()
}
val x213 = x69// unsafe immutable
val x86 = x80(1)
val x214 = (x86,x213)
x214
})
mapIdx += 1
} // end map loop x220
x218
}
val x220 = x220_block
x220
}
val x223 = Seq()
val x224 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
var x225: Int = 0
val x226 = x225
val x227 = x226 < 3
val x264 = x54.numRows
val x265 = new generated.scala.IndexVectorRangeImpl(0,x264)
val x266 = x54.numCols
val x267 = new generated.scala.IndexVectorRangeImpl(0,x266)
val x268 = new generated.scala.IndexVector2Impl(x265,x267)
val x269 = x268.rowInd
val x270 = x269.length
val x274 = x268.colInd
val x329 = 0.asInstanceOf[Int]
val x332 = x274.length
val x333 = x274.isRow
val x521 = Math.Pi
val x573 = 2 / 2
val x1265 = while ({x227}) {
val x228 = new generated.scala.IntMatrixImpl(3,3)
val x229 = x228(0, 0) = -3
val x230 = x228(0, 1) = -10
val x231 = x228(0, 2) = -3
val x232 = x228(2, 0) = 3
val x233 = x228(2, 1) = 10
val x234 = x228(2, 2) = 3
val x257 = { 
val x235 = x228.numCols
val x236 = x228.numRows
val x237 = new generated.scala.IntMatrixImpl(x235,x236)
val x238 = x237.numRows
var x240 : Int = 0
val x254 = while (x240 < x238) {
val x241 = x237.numCols
var x243 : Int = 0
val x252 = while (x243 < x241) {
val x249 = { 
val x244 = x228.numCols
val x245 = x243 * x244
val x246 = x245 + x240
val x247 = x228.dcApply(x246)
x247
}
val x250 = x237(x240, x243) = x249
x250
x243 = x243 + 1
}
x252
x240 = x240 + 1
}
val x255 = x237// unsafe immutable
x255
}
val x258 = x257.numRows
val x259 = x257.numCols
val x260 = x258 - 1
val x261 = x260 / 2
val x277 = x264 - x261
val x262 = x259 - 1
val x263 = x262 / 2
val x282 = x266 - x263
def x337_block = {
val x271 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](x270,true)
var mapIdx = 0
while (mapIdx < x269.size) { // begin map loop x337
val x273 = x269.dcApply(mapIdx)
x271.dcUpdate(mapIdx,  {
val x276 = x273 >= x261
val x278 = x273 < x277
val x279 = x276 && x278
val x285 = x273 - x261
val x286 = x273 + x261
val x287 = x286 + 1
val x291 = x287 - x285
def x336_block = {
val x334 = new generated.scala.IntVectorImpl(x332,x333)
var mapIdx = 0
while (mapIdx < x274.size) { // begin map loop x336
val x275 = x274.dcApply(mapIdx)
x334.dcUpdate(mapIdx,  {
val x280 = x275 >= x263
val x281 = x279 && x280
val x283 = x275 < x282
val x284 = x281 && x283
val x288 = x275 - x263
val x289 = x275 + x263
val x290 = x289 + 1
val x292 = x290 - x288
val x315 = { 
val x293 = new generated.scala.IntMatrixImpl(x291,x292)
var x294: Int = x285
val x295 = x294
val x296 = x295 < x287
val x300 = x295 - x285
val x302 = x295 * x266
val x312 = while ({x296}) {
var x297: Int = x288
val x298 = x297
val x299 = x298 < x290
val x301 = x298 - x288
val x303 = x302 + x298
val x304 = x54.dcApply(x303)
val x305 = { 
x304
}
val x309 = while ({x299}) {
val x306 = x293(x300, x301) = x305
val x307 = x297 += 1
()
}
val x310 = x294 += 1
()
}
val x313 = x293// unsafe immutable
x313
}
val x316 = x315.numRows
val x317 = x315.numCols
val x330 = {
def x330thenb(): Int = {
def x323_block = {
val x318 = new generated.scala.IntMatrixImpl(x316,x317)
var zipIdx = 0
while (zipIdx < x315.size) { // begin zip loop x323
val x320 = x315.dcApply(zipIdx)
val x321 = x257.dcApply(zipIdx)
x318.dcUpdate(zipIdx,  {
val x322 = x320 * x321
x322
})
zipIdx += 1
} // end zip loop x323
x318
}
val x323 = x323_block
def x327_block = {
var x324 = x323.dcApply(0)
var reduceIdx = 1
while (reduceIdx < x323.size) { // begin reduce loop x327
val x325 = x323.dcApply(reduceIdx)
x324 = {
val x326 = x324 + x325
x326
}
reduceIdx += 1
} // end reduce loop x327
x324
}
val x327 = x327_block
x327
}
def x330elseb(): Int = {
x329
}
if (x284) {
x330thenb()
} else { 
x330elseb()
}
}
x330
})
mapIdx += 1
} // end map loop x336
x334
}
val x336 = x336_block
x336
})
mapIdx += 1
} // end map loop x337
x271
}
val x337 = x337_block
val x338 = x337.length
val x339 = x338==0
val x343 = x337(0)
val x344 = x343.isRow
val x345 = x343.length
val x376 = { 
val x374 = {
def x374thenb(): generated.scala.Matrix[Int] = {
val x340 = new generated.scala.IntMatrixImpl(0,0)
val x341 = x340// unsafe immutable
x341
}
def x374elseb(): generated.scala.Matrix[Int] = {
val x372 = {
def x372thenb(): generated.scala.Matrix[Int] = {
val x346 = new generated.scala.IntMatrixImpl(x338,x345)
var x348 : Int = 0
val x357 = while (x348 < x338) {
val x351 = x337(x348)
var x350 : Int = 0
val x355 = while (x350 < x345) {
val x352 = x351(x350)
val x353 = x346(x348, x350) = x352
x353
x350 = x350 + 1
}
x355
x348 = x348 + 1
}
val x358 = x346// unsafe immutable
x358
}
def x372elseb(): generated.scala.Matrix[Int] = {
val x360 = new generated.scala.IntMatrixImpl(x345,x338)
var x361 : Int = 0
val x369 = while (x361 < x338) {
val x363 = x337(x361)
var x362 : Int = 0
val x367 = while (x362 < x345) {
val x364 = x363(x362)
val x365 = x360(x362, x361) = x364
x365
x362 = x362 + 1
}
x367
x361 = x361 + 1
}
val x370 = x360// unsafe immutable
x370
}
if (x344) {
x372thenb()
} else { 
x372elseb()
}
}
x372
}
if (x339) {
x374thenb()
} else { 
x374elseb()
}
}
x374
}
val x377 = new generated.scala.IntImageImpl(x376)
val x378 = x228.numRows
val x379 = x228.numCols
val x380 = x378 - 1
val x381 = x380 / 2
val x389 = x264 - x381
val x382 = x379 - 1
val x383 = x382 / 2
val x394 = x266 - x383
def x446_block = {
val x384 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](x270,true)
var mapIdx = 0
while (mapIdx < x269.size) { // begin map loop x446
val x386 = x269.dcApply(mapIdx)
x384.dcUpdate(mapIdx,  {
val x388 = x386 >= x381
val x390 = x386 < x389
val x391 = x388 && x390
val x397 = x386 - x381
val x398 = x386 + x381
val x399 = x398 + 1
val x403 = x399 - x397
def x445_block = {
val x443 = new generated.scala.IntVectorImpl(x332,x333)
var mapIdx = 0
while (mapIdx < x274.size) { // begin map loop x445
val x387 = x274.dcApply(mapIdx)
x443.dcUpdate(mapIdx,  {
val x392 = x387 >= x383
val x393 = x391 && x392
val x395 = x387 < x394
val x396 = x393 && x395
val x400 = x387 - x383
val x401 = x387 + x383
val x402 = x401 + 1
val x404 = x402 - x400
val x427 = { 
val x405 = new generated.scala.IntMatrixImpl(x403,x404)
var x406: Int = x397
val x407 = x406
val x408 = x407 < x399
val x412 = x407 - x397
val x414 = x407 * x266
val x424 = while ({x408}) {
var x409: Int = x400
val x410 = x409
val x411 = x410 < x402
val x413 = x410 - x400
val x415 = x414 + x410
val x416 = x54.dcApply(x415)
val x417 = { 
x416
}
val x421 = while ({x411}) {
val x418 = x405(x412, x413) = x417
val x419 = x409 += 1
()
}
val x422 = x406 += 1
()
}
val x425 = x405// unsafe immutable
x425
}
val x428 = x427.numRows
val x429 = x427.numCols
val x441 = {
def x441thenb(): Int = {
def x435_block = {
val x430 = new generated.scala.IntMatrixImpl(x428,x429)
var zipIdx = 0
while (zipIdx < x427.size) { // begin zip loop x435
val x432 = x427.dcApply(zipIdx)
val x433 = x228.dcApply(zipIdx)
x430.dcUpdate(zipIdx,  {
val x434 = x432 * x433
x434
})
zipIdx += 1
} // end zip loop x435
x430
}
val x435 = x435_block
def x439_block = {
var x436 = x435.dcApply(0)
var reduceIdx = 1
while (reduceIdx < x435.size) { // begin reduce loop x439
val x437 = x435.dcApply(reduceIdx)
x436 = {
val x438 = x436 + x437
x438
}
reduceIdx += 1
} // end reduce loop x439
x436
}
val x439 = x439_block
x439
}
def x441elseb(): Int = {
x329
}
if (x396) {
x441thenb()
} else { 
x441elseb()
}
}
x441
})
mapIdx += 1
} // end map loop x445
x443
}
val x445 = x445_block
x445
})
mapIdx += 1
} // end map loop x446
x384
}
val x446 = x446_block
val x447 = x446.length
val x448 = x447==0
val x452 = x446(0)
val x453 = x452.isRow
val x454 = x452.length
val x485 = { 
val x483 = {
def x483thenb(): generated.scala.Matrix[Int] = {
val x449 = new generated.scala.IntMatrixImpl(0,0)
val x450 = x449// unsafe immutable
x450
}
def x483elseb(): generated.scala.Matrix[Int] = {
val x481 = {
def x481thenb(): generated.scala.Matrix[Int] = {
val x455 = new generated.scala.IntMatrixImpl(x447,x454)
var x457 : Int = 0
val x466 = while (x457 < x447) {
val x460 = x446(x457)
var x459 : Int = 0
val x464 = while (x459 < x454) {
val x461 = x460(x459)
val x462 = x455(x457, x459) = x461
x462
x459 = x459 + 1
}
x464
x457 = x457 + 1
}
val x467 = x455// unsafe immutable
x467
}
def x481elseb(): generated.scala.Matrix[Int] = {
val x469 = new generated.scala.IntMatrixImpl(x454,x447)
var x470 : Int = 0
val x478 = while (x470 < x447) {
val x472 = x446(x470)
var x471 : Int = 0
val x476 = while (x471 < x454) {
val x473 = x472(x471)
val x474 = x469(x471, x470) = x473
x474
x471 = x471 + 1
}
x476
x470 = x470 + 1
}
val x479 = x469// unsafe immutable
x479
}
if (x453) {
x481thenb()
} else { 
x481elseb()
}
}
x481
}
if (x448) {
x483thenb()
} else { 
x483elseb()
}
}
x483
}
val x486 = new generated.scala.IntImageImpl(x485)
val x489 = x377.numRows
val x490 = x377.numCols
def x493_block = {
val x491 = new generated.scala.FloatMatrixImpl(x489,x490)
var mapIdx = 0
while (mapIdx < x377.size) { // begin map loop x493
val x487 = x377.dcApply(mapIdx)
x491.dcUpdate(mapIdx,  {
val x488 = x487
x488
})
mapIdx += 1
} // end map loop x493
x491
}
val x493 = x493_block
val x496 = x486.numRows
val x497 = x486.numCols
def x500_block = {
val x498 = new generated.scala.FloatMatrixImpl(x496,x497)
var mapIdx = 0
while (mapIdx < x486.size) { // begin map loop x500
val x494 = x486.dcApply(mapIdx)
x498.dcUpdate(mapIdx,  {
val x495 = x494
x495
})
mapIdx += 1
} // end map loop x500
x498
}
val x500 = x500_block
val x501 = x493.numRows
val x502 = x493.numCols
def x524_block = {
val x513 = new generated.scala.FloatMatrixImpl(x501,x502)
var zipIdx = 0
while (zipIdx < x493.size) { // begin zip loop x524
val x515 = x493.dcApply(zipIdx)
val x516 = x500.dcApply(zipIdx)
x513.dcUpdate(zipIdx,  {
val x517 = x516
val x518 = x515
val x519 = Math.atan2(x517, x518)
val x520 = x519 * 180.0
val x522 = x520 / x521
val x523 = x522.asInstanceOf[Float]
x523
})
zipIdx += 1
} // end zip loop x524
x513
}
val x524 = x524_block
def x529_block = {
var mapIdx = 0
while (mapIdx < x524.size) { // begin map loop x529
val x525 = x524.dcApply(mapIdx)
x524.dcUpdate(mapIdx,  {
val x526 = x525 < 0.0f
val x527 = x525 + 360.0f
val x528 = {
def x528thenb(): Float = {
x527
}
def x528elseb(): Float = {
x525
}
if (x526) {
x528thenb()
} else { 
x528elseb()
}
}
x528
})
mapIdx += 1
} // end map loop x529
x524
}
val x529 = x529_block
def x530_block = {
val x503 = new generated.scala.FloatMatrixImpl(x501,x502)
var zipIdx = 0
while (zipIdx < x493.size) { // begin zip loop x530
val x505 = x493.dcApply(zipIdx)
val x506 = x500.dcApply(zipIdx)
x503.dcUpdate(zipIdx,  {
val x507 = x505 * x505
val x508 = x506 * x506
val x509 = x507 + x508
val x510 = x509
val x511 = Math.sqrt(x510)
val x512 = x511.asInstanceOf[Float]
x512
})
zipIdx += 1
} // end zip loop x530
x503
}
val x530 = x530_block
val x551 = x530.numRows
val x552 = x530.numCols
def x555_block = {
val x553 = new generated.scala.IntMatrixImpl(x551,x552)
var zipIdx = 0
while (zipIdx < x530.size) { // begin zip loop x555
val x532 = x530.dcApply(zipIdx)
val x533 = x529.dcApply(zipIdx)
x553.dcUpdate(zipIdx,  {
val x534 = x532 >= 200.0f
val x549 = {
def x549thenb(): Int = {
var x535: Float = x533
val x536 = x535
val x537 = x536 >= 180.0f
val x538 = x536 - 180.0f
val x541 = {
def x541thenb(): Unit = {
x535 = x538
()
}
if (x537) {
x541thenb()
}
}
val x542 = x536.asInstanceOf[Double]
val x543 = x542 / 22.5
val x544 = x543.asInstanceOf[Int]
val x545 = x544
val x546 = Math.pow(2.0,x545)
val x547 = x546.asInstanceOf[Int]
x547
}
def x549elseb(): Int = {
0
}
if (x534) {
x549thenb()
} else { 
x549elseb()
}
}
x549
})
zipIdx += 1
} // end zip loop x555
x553
}
val x555 = x555_block
val x556 = new generated.scala.GrayscaleImageImpl(x555)
val x557 = x556.getRow(0)
def x559_block = {
var mapIdx = 0
while (mapIdx < x557.size) { // begin map loop x559
val x558 = x557.dcApply(mapIdx)
x557.dcUpdate(mapIdx,  {
0
})
mapIdx += 1
} // end map loop x559
x557
}
val x559 = x559_block
val x560 = x556.numRows
val x561 = x560 - 1
val x562 = x556.getRow(x561)
def x564_block = {
var mapIdx = 0
while (mapIdx < x562.size) { // begin map loop x564
val x563 = x562.dcApply(mapIdx)
x562.dcUpdate(mapIdx,  {
0
})
mapIdx += 1
} // end map loop x564
x562
}
val x564 = x564_block
val x565 = x556.getCol(0)
def x567_block = {
var mapIdx = 0
while (mapIdx < x565.size) { // begin map loop x567
val x566 = x565.dcApply(mapIdx)
x565.dcUpdate(mapIdx,  {
0
})
mapIdx += 1
} // end map loop x567
x565
}
val x567 = x567_block
val x568 = x556.numCols
val x569 = x568 - 1
val x570 = x556.getCol(x569)
def x572_block = {
var mapIdx = 0
while (mapIdx < x570.size) { // begin map loop x572
val x571 = x570.dcApply(mapIdx)
x570.dcUpdate(mapIdx,  {
0
})
mapIdx += 1
} // end map loop x572
x570
}
val x572 = x572_block
val x574 = new generated.scala.IndexVectorRangeImpl(0,x560)
val x575 = new generated.scala.IndexVectorRangeImpl(0,x568)
val x576 = new generated.scala.IndexVector2Impl(x574,x575)
val x577 = x576.rowInd
val x578 = x577.length
val x582 = x576.colInd
val x585 = x560 - x573
val x590 = x568 - x573
val x670 = x582.length
val x671 = x582.isRow
def x675_block = {
val x579 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](x578,true)
var mapIdx = 0
while (mapIdx < x577.size) { // begin map loop x675
val x581 = x577.dcApply(mapIdx)
x579.dcUpdate(mapIdx,  {
val x584 = x581 >= x573
val x586 = x581 < x585
val x587 = x584 && x586
val x593 = x581 - x573
val x594 = x581 + x573
val x595 = x594 + 1
val x599 = x595 - x593
def x674_block = {
val x672 = new generated.scala.IntVectorImpl(x670,x671)
var mapIdx = 0
while (mapIdx < x582.size) { // begin map loop x674
val x583 = x582.dcApply(mapIdx)
x672.dcUpdate(mapIdx,  {
val x588 = x583 >= x573
val x589 = x587 && x588
val x591 = x583 < x590
val x592 = x589 && x591
val x596 = x583 - x573
val x597 = x583 + x573
val x598 = x597 + 1
val x600 = x598 - x596
val x623 = { 
val x601 = new generated.scala.IntMatrixImpl(x599,x600)
var x602: Int = x593
val x603 = x602
val x604 = x603 < x595
val x608 = x603 - x593
val x610 = x603 * x568
val x620 = while ({x604}) {
var x605: Int = x596
val x606 = x605
val x607 = x606 < x598
val x609 = x606 - x596
val x611 = x610 + x606
val x612 = x556.dcApply(x611)
val x613 = { 
x612
}
val x617 = while ({x607}) {
val x614 = x601(x608, x609) = x613
val x615 = x605 += 1
()
}
val x618 = x602 += 1
()
}
val x621 = x601// unsafe immutable
x621
}
val x627 = x623.numRows
val x631 = x623.numCols
val x668 = {
def x668thenb(): Int = {
val x624 = new generated.scala.IntVectorImpl(256,true)
var x625: Int = 0
val x626 = x625
val x628 = x626 < x627
val x633 = x626 * x631
val x645 = while ({x628}) {
var x629: Int = 0
val x630 = x629
val x632 = x630 < x631
val x634 = x633 + x630
val x635 = x623.dcApply(x634)
val x636 = { 
x635
}
val x642 = while ({x632}) {
val x637 = x624(x636)
val x638 = x637 + 1
val x639 = x624(x636) = x638
val x640 = x629 += 1
()
}
val x643 = x625 += 1
()
}
var x646: Int = 2
val x647 = x624(1)
var x648: Int = x647
var x649: Int = 1
val x650 = x646
val x655 = x648
val x663 = while ({val x651 = x624.length
val x652 = x650 < x651
x652}) {
val x654 = x624(x650)
val x656 = x654 > x655
val x660 = {
def x660thenb(): Unit = {
x648 = x654
x649 = x650
()
}
if (x656) {
x660thenb()
}
}
val x661 = x646 += 1
()
}
val x664 = x655 > 1
val x665 = x649
val x666 = {
def x666thenb(): Int = {
x665
}
def x666elseb(): Int = {
0
}
if (x664) {
x666thenb()
} else { 
x666elseb()
}
}
x666
}
def x668elseb(): Int = {
x329
}
if (x592) {
x668thenb()
} else { 
x668elseb()
}
}
x668
})
mapIdx += 1
} // end map loop x674
x672
}
val x674 = x674_block
x674
})
mapIdx += 1
} // end map loop x675
x579
}
val x675 = x675_block
val x676 = x675.length
val x677 = x676==0
val x681 = x675(0)
val x682 = x681.isRow
val x683 = x681.length
val x714 = { 
val x712 = {
def x712thenb(): generated.scala.Matrix[Int] = {
val x678 = new generated.scala.IntMatrixImpl(0,0)
val x679 = x678// unsafe immutable
x679
}
def x712elseb(): generated.scala.Matrix[Int] = {
val x710 = {
def x710thenb(): generated.scala.Matrix[Int] = {
val x684 = new generated.scala.IntMatrixImpl(x676,x683)
var x686 : Int = 0
val x695 = while (x686 < x676) {
val x689 = x675(x686)
var x688 : Int = 0
val x693 = while (x688 < x683) {
val x690 = x689(x688)
val x691 = x684(x686, x688) = x690
x691
x688 = x688 + 1
}
x693
x686 = x686 + 1
}
val x696 = x684// unsafe immutable
x696
}
def x710elseb(): generated.scala.Matrix[Int] = {
val x698 = new generated.scala.IntMatrixImpl(x683,x676)
var x699 : Int = 0
val x707 = while (x699 < x676) {
val x701 = x675(x699)
var x700 : Int = 0
val x705 = while (x700 < x683) {
val x702 = x701(x700)
val x703 = x698(x700, x699) = x702
x703
x700 = x700 + 1
}
x705
x699 = x699 + 1
}
val x708 = x698// unsafe immutable
x708
}
if (x682) {
x710thenb()
} else { 
x710elseb()
}
}
x710
}
if (x677) {
x712thenb()
} else { 
x712elseb()
}
}
x712
}
val x715 = new generated.scala.IntImageImpl(x714)
val x716 = new generated.scala.GrayscaleImageImpl(x715)
var x717: generated.scala.GrayscaleImage = x716
var x718: Int = 0
val x719 = new generated.scala.VectorImpl[generated.scala.GrayscaleImage](0,true)
val x720 = new generated.scala.BinarizedGradientPyramid(x719,3,1,3)
val x721 = x718
val x854 = while ({val x722 = x720.start_level
val x723 = x720.levels
val x724 = x722 + x723
val x725 = x721 < x724
x725}) {
val x727 = x720.start_level
val x728 = x721 >= x727
val x734 = {
def x734thenb(): Unit = {
val x729 = x720.pyramid
val x730 = x717
val x731 = x729.length
val x732 = x729.insert(x731, x730)
x732
}
if (x728) {
x734thenb()
}
}
val x735 = x720.start_level
val x736 = x720.levels
val x737 = x735 + x736
val x738 = x737 - 1
val x739 = x721 != x738
val x851 = {
def x851thenb(): Unit = {
val x740 = x717
val x741 = x740.numRows
val x742 = x741 / 2
val x743 = new generated.scala.IndexVectorRangeImpl(0,x742)
val x744 = x740.numCols
val x745 = x744 / 2
val x746 = new generated.scala.IndexVectorRangeImpl(0,x745)
val x747 = new generated.scala.IndexVector2Impl(x743,x746)
val x748 = x747.rowInd
val x749 = x748.length
val x753 = x747.colInd
val x802 = x753.length
val x803 = x753.isRow
def x807_block = {
val x750 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](x749,true)
var mapIdx = 0
while (mapIdx < x748.size) { // begin map loop x807
val x752 = x748.dcApply(mapIdx)
x750.dcUpdate(mapIdx,  {
val x755 = 2 * x752
val x756 = x755 + 2
val x759 = x756 - x755
def x806_block = {
val x804 = new generated.scala.IntVectorImpl(x802,x803)
var mapIdx = 0
while (mapIdx < x753.size) { // begin map loop x806
val x754 = x753.dcApply(mapIdx)
x804.dcUpdate(mapIdx,  {
val x757 = 2 * x754
val x758 = x757 + 2
val x760 = x758 - x757
val x783 = { 
val x761 = new generated.scala.IntMatrixImpl(x759,x760)
var x762: Int = x755
val x763 = x762
val x764 = x763 < x756
val x768 = x763 - x755
val x770 = x763 * x744
val x780 = while ({x764}) {
var x765: Int = x757
val x766 = x765
val x767 = x766 < x758
val x769 = x766 - x757
val x771 = x770 + x766
val x772 = x740.dcApply(x771)
val x773 = { 
x772
}
val x777 = while ({x767}) {
val x774 = x761(x768, x769) = x773
val x775 = x765 += 1
()
}
val x778 = x762 += 1
()
}
val x781 = x761// unsafe immutable
x781
}
val x784 = x783.numCols
val x785 = 0 * x784
val x786 = x785 + 0
val x787 = x783.dcApply(x786)
val x788 = { 
x787
}
val x789 = 1 * x784
val x790 = x789 + 0
val x791 = x783.dcApply(x790)
val x792 = { 
x791
}
val x793 = x788 | x792
val x794 = x785 + 1
val x795 = x783.dcApply(x794)
val x796 = { 
x795
}
val x797 = x793 | x796
val x798 = x789 + 1
val x799 = x783.dcApply(x798)
val x800 = { 
x799
}
val x801 = x797 | x800
x801
})
mapIdx += 1
} // end map loop x806
x804
}
val x806 = x806_block
x806
})
mapIdx += 1
} // end map loop x807
x750
}
val x807 = x807_block
val x808 = x807.length
val x809 = x808==0
val x813 = x807(0)
val x814 = x813.isRow
val x815 = x813.length
val x846 = { 
val x844 = {
def x844thenb(): generated.scala.Matrix[Int] = {
val x810 = new generated.scala.IntMatrixImpl(0,0)
val x811 = x810// unsafe immutable
x811
}
def x844elseb(): generated.scala.Matrix[Int] = {
val x842 = {
def x842thenb(): generated.scala.Matrix[Int] = {
val x816 = new generated.scala.IntMatrixImpl(x808,x815)
var x818 : Int = 0
val x827 = while (x818 < x808) {
val x821 = x807(x818)
var x820 : Int = 0
val x825 = while (x820 < x815) {
val x822 = x821(x820)
val x823 = x816(x818, x820) = x822
x823
x820 = x820 + 1
}
x825
x818 = x818 + 1
}
val x828 = x816// unsafe immutable
x828
}
def x842elseb(): generated.scala.Matrix[Int] = {
val x830 = new generated.scala.IntMatrixImpl(x815,x808)
var x831 : Int = 0
val x839 = while (x831 < x808) {
val x833 = x807(x831)
var x832 : Int = 0
val x837 = while (x832 < x815) {
val x834 = x833(x832)
val x835 = x830(x832, x831) = x834
x835
x832 = x832 + 1
}
x837
x831 = x831 + 1
}
val x840 = x830// unsafe immutable
x840
}
if (x814) {
x842thenb()
} else { 
x842elseb()
}
}
x842
}
if (x809) {
x844thenb()
} else { 
x844elseb()
}
}
x844
}
val x847 = new generated.scala.IntImageImpl(x846)
val x848 = new generated.scala.GrayscaleImageImpl(x847)
x717 = x848
()
}
if (x739) {
x851thenb()
}
}
val x852 = x718 += 1
()
}
def x1156_block = {
val x855 = x222.dcApply(0)
var x1127 = {
val x856 = x855._1
val x858 = "Name: "+x856
val x859 = println(x858)
val x857 = x855._2
val x860 = x857.length
val x861 = "Templates: "+x860
val x862 = println(x861)
val x863 = x720.fixedLevelIndex
val x864 = x720.pyramid
val x865 = x720.start_level
val x866 = x863 - x865
val x867 = x864(x866)
val x868 = x867.numRows
val x869 = x868 - 5
val x870 = new generated.scala.IndexVectorRangeImpl(5,x869)
val x942 = new generated.scala.IndexVectorRangeImpl(0,x860)
val x876 = x863
val x877 = Math.pow(2.0,x876)
val x878 = x877.asInstanceOf[Int]
def x1122_block = {
val x871 = x870.dcApply(0)
var x1093 = {
val x872 = x867.numCols
val x873 = x872 - 5
val x874 = new generated.scala.IndexVectorRangeImpl(5,x873)
val x902 = x871 + 15
val x894 = x871 - 15
val x895 = x894 < 0
val x896 = 15 - x871
val x897 = (0,x896)
val x898 = (x894,0)
val x899 = {
def x899thenb(): scala.Tuple2[Int, Int] = {
x897
}
def x899elseb(): scala.Tuple2[Int, Int] = {
x898
}
if (x895) {
x899thenb()
} else { 
x899elseb()
}
}
val x900 = x899._1
val x901 = x899._2
val x1017 = x878 * x871
def x1091_block = {
val x875 = x874.dcApply(0)
var x1062 = {
val x879 = new generated.scala.IntVectorImpl(900,false)
val x880 = new generated.scala.IndexVectorSeqImpl(0)
val x881 = new generated.scala.BinarizedGradientTemplate(15,null,null,x863,x879,x880,null,null,null)
val x891 = x867.numCols
val x890 = x875 + 15
val x892 = x890 > x891
val x893 = {
def x893thenb(): Int = {
x891
}
def x893elseb(): Int = {
x890
}
if (x892) {
x893thenb()
} else { 
x893elseb()
}
}
val x903 = x867.numRows
val x904 = x902 > x903
val x905 = {
def x905thenb(): Int = {
x903
}
def x905elseb(): Int = {
x902
}
if (x904) {
x905thenb()
} else { 
x905elseb()
}
}
var x906: Int = x900
val x907 = x906
val x908 = x907 < x905
val x882 = x875 - 15
val x883 = x882 < 0
val x884 = 15 - x875
val x885 = (0,x884)
val x886 = (x882,0)
val x887 = {
def x887thenb(): scala.Tuple2[Int, Int] = {
x885
}
def x887elseb(): scala.Tuple2[Int, Int] = {
x886
}
if (x883) {
x887thenb()
} else { 
x887elseb()
}
}
val x888 = x887._1
val x913 = x901 + x907
val x914 = x913 - x900
val x915 = x914 * 30
val x889 = x887._2
val x935 = while ({x908}) {
val x909 = x867.getRow(x907)
var x910: Int = x888
val x911 = x910
val x912 = x911 < x893
val x916 = x889 + x911
val x917 = x916 - x888
val x918 = x915 + x917
val x932 = while ({x912}) {
var x919: Int = x918
val x920 = x881.binary_gradients
val x922 = x909(x911)
val x921 = x919
val x923 = x920(x921) = x922
val x924 = x922 > 0
val x929 = {
def x929thenb(): Unit = {
val x925 = x881.match_list
val x926 = x925.length
val x927 = x925.insert(x926, x921)
x927
}
if (x924) {
x929thenb()
}
}
val x930 = x910 += 1
()
}
val x933 = x906 += 1
()
}
val x936 = x881.match_list
val x937 = x936.length
val x938 = x937 < 0
val x941 = {
def x941thenb(): Unit = {
val x939 = println("dummy")
x939
}
if (x938) {
x941thenb()
}
}
val x1012 = x878 * x875
def x1060_block = {
val x943 = x942.dcApply(0)
var x1031 = {
val x946 = x881.radius
val x944 = x857(x943)
val x945 = x944.radius
val x947 = x945 != x946
val x948 = x944.match_list
val x949 = x948.length
val x950 = x949.asInstanceOf[Float]
val x951 = x950==0.0
val x958 = x950 * 0.18f
val x959 = x958 + 0.5f
val x960 = x959.asInstanceOf[Int]
val x969 = x944.binary_gradients
val x1009 = {
def x1009thenb(): Float = {
-1.0f
}
def x1009elseb(): Float = {
val x1007 = {
def x1007thenb(): Float = {
-1.0f
}
def x1007elseb(): Float = {
val x952 = x881.match_list
val x953 = x952.length
val x954 = x953.asInstanceOf[Float]
val x955 = x954 / x950
val x956 = x955 < 0.82f
val x1005 = {
def x1005thenb(): Float = {
x955
}
def x1005elseb(): Float = {
var x957: Float = 0.0f
var x961: Int = x960
var x962: Int = 0
var x963: Boolean = true
val x964 = x962
val x965 = x964 < x949
val x966 = x963
val x967 = x965 && x966
val x968 = x948(x964)
val x970 = x969(x968)
val x971 = x970==0
val x976 = x957
val x977 = x976 + 1.0f
val x986 = x961
val x987 = x986 - 1
val x989 = x986 <= 0
val x999 = while ({x967}) {
val x972 = x881.binary_gradients
val x973 = x972(x968)
val x974 = x973==0
val x975 = x971 && x974
val x996 = {
def x996thenb(): Unit = {
x957 = x977
()
}
def x996elseb(): Unit = {
val x980 = x881.binary_gradients
val x981 = x980(x968)
val x982 = x970 & x981
val x983 = x982 > 0
val x994 = {
def x994thenb(): Unit = {
x957 = x977
()
}
def x994elseb(): Unit = {
x961 = x987
val x992 = {
def x992thenb(): Unit = {
x963 = false
()
}
if (x989) {
x992thenb()
}
}
x992
}
if (x983) {
x994thenb()
} else { 
x994elseb()
}
}
x994
}
if (x975) {
x996thenb()
} else { 
x996elseb()
}
}
val x997 = x962 += 1
()
}
val x1000 = !x966
val x1001 = x976 / x950
val x1002 = x1001.asInstanceOf[Float]
val x1003 = {
def x1003thenb(): Float = {
0.819999f
}
def x1003elseb(): Float = {
x1002
}
if (x1000) {
x1003thenb()
} else { 
x1003elseb()
}
}
x1003
}
if (x956) {
x1005thenb()
} else { 
x1005elseb()
}
}
x1005
}
if (x951) {
x1007thenb()
} else { 
x1007elseb()
}
}
x1007
}
if (x947) {
x1009thenb()
} else { 
x1009elseb()
}
}
val x1010 = x1009 > 0.82f
val x1011 = x944.rect
val x1013 = x1011.width
val x1014 = x1013 / 2
val x1015 = x1012 - x1014
val x1016 = x1015.asInstanceOf[Int]
val x1018 = x1011.height
val x1019 = x1018 / 2
val x1020 = x1017 - x1019
val x1021 = x1020.asInstanceOf[Int]
val x1029 = {
def x1029thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1022 = new generated.scala.Rect(x1016,x1021,x1013,x1018)
val x1023 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1024 = new generated.scala.BiGGDetection(x856,x1009,x1022,null,x943,x875,x871,x944,x881)
val x1025 = x1023(0) = x1024
x1023
}
def x1029elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1027 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1027
}
if (x1010) {
x1029thenb()
} else { 
x1029elseb()
}
}
x1029
}
var mapReduceIdx = 1
while (mapReduceIdx < x942.size) { // begin mapReduce loop x1060
val x943 = x942.dcApply(mapReduceIdx)
val x1032 = {
val x946 = x881.radius
val x944 = x857(x943)
val x945 = x944.radius
val x947 = x945 != x946
val x948 = x944.match_list
val x949 = x948.length
val x950 = x949.asInstanceOf[Float]
val x951 = x950==0.0
val x958 = x950 * 0.18f
val x959 = x958 + 0.5f
val x960 = x959.asInstanceOf[Int]
val x969 = x944.binary_gradients
val x1009 = {
def x1009thenb(): Float = {
-1.0f
}
def x1009elseb(): Float = {
val x1007 = {
def x1007thenb(): Float = {
-1.0f
}
def x1007elseb(): Float = {
val x952 = x881.match_list
val x953 = x952.length
val x954 = x953.asInstanceOf[Float]
val x955 = x954 / x950
val x956 = x955 < 0.82f
val x1005 = {
def x1005thenb(): Float = {
x955
}
def x1005elseb(): Float = {
var x957: Float = 0.0f
var x961: Int = x960
var x962: Int = 0
var x963: Boolean = true
val x964 = x962
val x965 = x964 < x949
val x966 = x963
val x967 = x965 && x966
val x968 = x948(x964)
val x970 = x969(x968)
val x971 = x970==0
val x976 = x957
val x977 = x976 + 1.0f
val x986 = x961
val x987 = x986 - 1
val x989 = x986 <= 0
val x999 = while ({x967}) {
val x972 = x881.binary_gradients
val x973 = x972(x968)
val x974 = x973==0
val x975 = x971 && x974
val x996 = {
def x996thenb(): Unit = {
x957 = x977
()
}
def x996elseb(): Unit = {
val x980 = x881.binary_gradients
val x981 = x980(x968)
val x982 = x970 & x981
val x983 = x982 > 0
val x994 = {
def x994thenb(): Unit = {
x957 = x977
()
}
def x994elseb(): Unit = {
x961 = x987
val x992 = {
def x992thenb(): Unit = {
x963 = false
()
}
if (x989) {
x992thenb()
}
}
x992
}
if (x983) {
x994thenb()
} else { 
x994elseb()
}
}
x994
}
if (x975) {
x996thenb()
} else { 
x996elseb()
}
}
val x997 = x962 += 1
()
}
val x1000 = !x966
val x1001 = x976 / x950
val x1002 = x1001.asInstanceOf[Float]
val x1003 = {
def x1003thenb(): Float = {
0.819999f
}
def x1003elseb(): Float = {
x1002
}
if (x1000) {
x1003thenb()
} else { 
x1003elseb()
}
}
x1003
}
if (x956) {
x1005thenb()
} else { 
x1005elseb()
}
}
x1005
}
if (x951) {
x1007thenb()
} else { 
x1007elseb()
}
}
x1007
}
if (x947) {
x1009thenb()
} else { 
x1009elseb()
}
}
val x1010 = x1009 > 0.82f
val x1011 = x944.rect
val x1013 = x1011.width
val x1014 = x1013 / 2
val x1015 = x1012 - x1014
val x1016 = x1015.asInstanceOf[Int]
val x1018 = x1011.height
val x1019 = x1018 / 2
val x1020 = x1017 - x1019
val x1021 = x1020.asInstanceOf[Int]
val x1029 = {
def x1029thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1022 = new generated.scala.Rect(x1016,x1021,x1013,x1018)
val x1023 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1024 = new generated.scala.BiGGDetection(x856,x1009,x1022,null,x943,x875,x871,x944,x881)
val x1025 = x1023(0) = x1024
x1023
}
def x1029elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1027 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1027
}
if (x1010) {
x1029thenb()
} else { 
x1029elseb()
}
}
x1029
}
x1031 = {
val x1033 = x1031.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1034 = x1032.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1035 = x1031.length
val x1036 = x1032.length
val x1037 = x1035 + x1036
val x1038 = x1031.isRow
val x1059 = { 
val x1057 = {
def x1057thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1032
}
def x1057elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1055 = {
def x1055thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1031
}
def x1055elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1039 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1037,x1038)
var x1041 : Int = 0
val x1045 = while (x1041 < x1035) {
val x1042 = x1031(x1041)
val x1043 = x1039(x1041) = x1042
x1043
x1041 = x1041 + 1
}
var x1047 : Int = 0
val x1052 = while (x1047 < x1036) {
val x1048 = x1047 + x1035
val x1049 = x1032(x1047)
val x1050 = x1039(x1048) = x1049
x1050
x1047 = x1047 + 1
}
val x1053 = x1039// unsafe immutable
x1053
}
if (x1034) {
x1055thenb()
} else { 
x1055elseb()
}
}
x1055
}
if (x1033) {
x1057thenb()
} else { 
x1057elseb()
}
}
x1057
}
x1059
}
mapReduceIdx += 1
} // end mapReduce loop x1060
x1031
}
val x1060 = x1060_block
x1060
}
var mapReduceIdx = 1
while (mapReduceIdx < x874.size) { // begin mapReduce loop x1091
val x875 = x874.dcApply(mapReduceIdx)
val x1063 = {
val x879 = new generated.scala.IntVectorImpl(900,false)
val x880 = new generated.scala.IndexVectorSeqImpl(0)
val x881 = new generated.scala.BinarizedGradientTemplate(15,null,null,x863,x879,x880,null,null,null)
val x891 = x867.numCols
val x890 = x875 + 15
val x892 = x890 > x891
val x893 = {
def x893thenb(): Int = {
x891
}
def x893elseb(): Int = {
x890
}
if (x892) {
x893thenb()
} else { 
x893elseb()
}
}
val x903 = x867.numRows
val x904 = x902 > x903
val x905 = {
def x905thenb(): Int = {
x903
}
def x905elseb(): Int = {
x902
}
if (x904) {
x905thenb()
} else { 
x905elseb()
}
}
var x906: Int = x900
val x907 = x906
val x908 = x907 < x905
val x882 = x875 - 15
val x883 = x882 < 0
val x884 = 15 - x875
val x885 = (0,x884)
val x886 = (x882,0)
val x887 = {
def x887thenb(): scala.Tuple2[Int, Int] = {
x885
}
def x887elseb(): scala.Tuple2[Int, Int] = {
x886
}
if (x883) {
x887thenb()
} else { 
x887elseb()
}
}
val x888 = x887._1
val x913 = x901 + x907
val x914 = x913 - x900
val x915 = x914 * 30
val x889 = x887._2
val x935 = while ({x908}) {
val x909 = x867.getRow(x907)
var x910: Int = x888
val x911 = x910
val x912 = x911 < x893
val x916 = x889 + x911
val x917 = x916 - x888
val x918 = x915 + x917
val x932 = while ({x912}) {
var x919: Int = x918
val x920 = x881.binary_gradients
val x922 = x909(x911)
val x921 = x919
val x923 = x920(x921) = x922
val x924 = x922 > 0
val x929 = {
def x929thenb(): Unit = {
val x925 = x881.match_list
val x926 = x925.length
val x927 = x925.insert(x926, x921)
x927
}
if (x924) {
x929thenb()
}
}
val x930 = x910 += 1
()
}
val x933 = x906 += 1
()
}
val x936 = x881.match_list
val x937 = x936.length
val x938 = x937 < 0
val x941 = {
def x941thenb(): Unit = {
val x939 = println("dummy")
x939
}
if (x938) {
x941thenb()
}
}
val x1012 = x878 * x875
def x1060_block = {
val x943 = x942.dcApply(0)
var x1031 = {
val x946 = x881.radius
val x944 = x857(x943)
val x945 = x944.radius
val x947 = x945 != x946
val x948 = x944.match_list
val x949 = x948.length
val x950 = x949.asInstanceOf[Float]
val x951 = x950==0.0
val x958 = x950 * 0.18f
val x959 = x958 + 0.5f
val x960 = x959.asInstanceOf[Int]
val x969 = x944.binary_gradients
val x1009 = {
def x1009thenb(): Float = {
-1.0f
}
def x1009elseb(): Float = {
val x1007 = {
def x1007thenb(): Float = {
-1.0f
}
def x1007elseb(): Float = {
val x952 = x881.match_list
val x953 = x952.length
val x954 = x953.asInstanceOf[Float]
val x955 = x954 / x950
val x956 = x955 < 0.82f
val x1005 = {
def x1005thenb(): Float = {
x955
}
def x1005elseb(): Float = {
var x957: Float = 0.0f
var x961: Int = x960
var x962: Int = 0
var x963: Boolean = true
val x964 = x962
val x965 = x964 < x949
val x966 = x963
val x967 = x965 && x966
val x968 = x948(x964)
val x970 = x969(x968)
val x971 = x970==0
val x976 = x957
val x977 = x976 + 1.0f
val x986 = x961
val x987 = x986 - 1
val x989 = x986 <= 0
val x999 = while ({x967}) {
val x972 = x881.binary_gradients
val x973 = x972(x968)
val x974 = x973==0
val x975 = x971 && x974
val x996 = {
def x996thenb(): Unit = {
x957 = x977
()
}
def x996elseb(): Unit = {
val x980 = x881.binary_gradients
val x981 = x980(x968)
val x982 = x970 & x981
val x983 = x982 > 0
val x994 = {
def x994thenb(): Unit = {
x957 = x977
()
}
def x994elseb(): Unit = {
x961 = x987
val x992 = {
def x992thenb(): Unit = {
x963 = false
()
}
if (x989) {
x992thenb()
}
}
x992
}
if (x983) {
x994thenb()
} else { 
x994elseb()
}
}
x994
}
if (x975) {
x996thenb()
} else { 
x996elseb()
}
}
val x997 = x962 += 1
()
}
val x1000 = !x966
val x1001 = x976 / x950
val x1002 = x1001.asInstanceOf[Float]
val x1003 = {
def x1003thenb(): Float = {
0.819999f
}
def x1003elseb(): Float = {
x1002
}
if (x1000) {
x1003thenb()
} else { 
x1003elseb()
}
}
x1003
}
if (x956) {
x1005thenb()
} else { 
x1005elseb()
}
}
x1005
}
if (x951) {
x1007thenb()
} else { 
x1007elseb()
}
}
x1007
}
if (x947) {
x1009thenb()
} else { 
x1009elseb()
}
}
val x1010 = x1009 > 0.82f
val x1011 = x944.rect
val x1013 = x1011.width
val x1014 = x1013 / 2
val x1015 = x1012 - x1014
val x1016 = x1015.asInstanceOf[Int]
val x1018 = x1011.height
val x1019 = x1018 / 2
val x1020 = x1017 - x1019
val x1021 = x1020.asInstanceOf[Int]
val x1029 = {
def x1029thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1022 = new generated.scala.Rect(x1016,x1021,x1013,x1018)
val x1023 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1024 = new generated.scala.BiGGDetection(x856,x1009,x1022,null,x943,x875,x871,x944,x881)
val x1025 = x1023(0) = x1024
x1023
}
def x1029elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1027 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1027
}
if (x1010) {
x1029thenb()
} else { 
x1029elseb()
}
}
x1029
}
var mapReduceIdx = 1
while (mapReduceIdx < x942.size) { // begin mapReduce loop x1060
val x943 = x942.dcApply(mapReduceIdx)
val x1032 = {
val x946 = x881.radius
val x944 = x857(x943)
val x945 = x944.radius
val x947 = x945 != x946
val x948 = x944.match_list
val x949 = x948.length
val x950 = x949.asInstanceOf[Float]
val x951 = x950==0.0
val x958 = x950 * 0.18f
val x959 = x958 + 0.5f
val x960 = x959.asInstanceOf[Int]
val x969 = x944.binary_gradients
val x1009 = {
def x1009thenb(): Float = {
-1.0f
}
def x1009elseb(): Float = {
val x1007 = {
def x1007thenb(): Float = {
-1.0f
}
def x1007elseb(): Float = {
val x952 = x881.match_list
val x953 = x952.length
val x954 = x953.asInstanceOf[Float]
val x955 = x954 / x950
val x956 = x955 < 0.82f
val x1005 = {
def x1005thenb(): Float = {
x955
}
def x1005elseb(): Float = {
var x957: Float = 0.0f
var x961: Int = x960
var x962: Int = 0
var x963: Boolean = true
val x964 = x962
val x965 = x964 < x949
val x966 = x963
val x967 = x965 && x966
val x968 = x948(x964)
val x970 = x969(x968)
val x971 = x970==0
val x976 = x957
val x977 = x976 + 1.0f
val x986 = x961
val x987 = x986 - 1
val x989 = x986 <= 0
val x999 = while ({x967}) {
val x972 = x881.binary_gradients
val x973 = x972(x968)
val x974 = x973==0
val x975 = x971 && x974
val x996 = {
def x996thenb(): Unit = {
x957 = x977
()
}
def x996elseb(): Unit = {
val x980 = x881.binary_gradients
val x981 = x980(x968)
val x982 = x970 & x981
val x983 = x982 > 0
val x994 = {
def x994thenb(): Unit = {
x957 = x977
()
}
def x994elseb(): Unit = {
x961 = x987
val x992 = {
def x992thenb(): Unit = {
x963 = false
()
}
if (x989) {
x992thenb()
}
}
x992
}
if (x983) {
x994thenb()
} else { 
x994elseb()
}
}
x994
}
if (x975) {
x996thenb()
} else { 
x996elseb()
}
}
val x997 = x962 += 1
()
}
val x1000 = !x966
val x1001 = x976 / x950
val x1002 = x1001.asInstanceOf[Float]
val x1003 = {
def x1003thenb(): Float = {
0.819999f
}
def x1003elseb(): Float = {
x1002
}
if (x1000) {
x1003thenb()
} else { 
x1003elseb()
}
}
x1003
}
if (x956) {
x1005thenb()
} else { 
x1005elseb()
}
}
x1005
}
if (x951) {
x1007thenb()
} else { 
x1007elseb()
}
}
x1007
}
if (x947) {
x1009thenb()
} else { 
x1009elseb()
}
}
val x1010 = x1009 > 0.82f
val x1011 = x944.rect
val x1013 = x1011.width
val x1014 = x1013 / 2
val x1015 = x1012 - x1014
val x1016 = x1015.asInstanceOf[Int]
val x1018 = x1011.height
val x1019 = x1018 / 2
val x1020 = x1017 - x1019
val x1021 = x1020.asInstanceOf[Int]
val x1029 = {
def x1029thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1022 = new generated.scala.Rect(x1016,x1021,x1013,x1018)
val x1023 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1024 = new generated.scala.BiGGDetection(x856,x1009,x1022,null,x943,x875,x871,x944,x881)
val x1025 = x1023(0) = x1024
x1023
}
def x1029elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1027 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1027
}
if (x1010) {
x1029thenb()
} else { 
x1029elseb()
}
}
x1029
}
x1031 = {
val x1033 = x1031.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1034 = x1032.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1035 = x1031.length
val x1036 = x1032.length
val x1037 = x1035 + x1036
val x1038 = x1031.isRow
val x1059 = { 
val x1057 = {
def x1057thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1032
}
def x1057elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1055 = {
def x1055thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1031
}
def x1055elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1039 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1037,x1038)
var x1041 : Int = 0
val x1045 = while (x1041 < x1035) {
val x1042 = x1031(x1041)
val x1043 = x1039(x1041) = x1042
x1043
x1041 = x1041 + 1
}
var x1047 : Int = 0
val x1052 = while (x1047 < x1036) {
val x1048 = x1047 + x1035
val x1049 = x1032(x1047)
val x1050 = x1039(x1048) = x1049
x1050
x1047 = x1047 + 1
}
val x1053 = x1039// unsafe immutable
x1053
}
if (x1034) {
x1055thenb()
} else { 
x1055elseb()
}
}
x1055
}
if (x1033) {
x1057thenb()
} else { 
x1057elseb()
}
}
x1057
}
x1059
}
mapReduceIdx += 1
} // end mapReduce loop x1060
x1031
}
val x1060 = x1060_block
x1060
}
x1062 = {
val x1064 = x1062.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1065 = x1063.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1066 = x1062.length
val x1067 = x1063.length
val x1068 = x1066 + x1067
val x1069 = x1062.isRow
val x1090 = { 
val x1088 = {
def x1088thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1063
}
def x1088elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1086 = {
def x1086thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1062
}
def x1086elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1070 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1068,x1069)
var x1072 : Int = 0
val x1076 = while (x1072 < x1066) {
val x1073 = x1062(x1072)
val x1074 = x1070(x1072) = x1073
x1074
x1072 = x1072 + 1
}
var x1078 : Int = 0
val x1083 = while (x1078 < x1067) {
val x1079 = x1078 + x1066
val x1080 = x1063(x1078)
val x1081 = x1070(x1079) = x1080
x1081
x1078 = x1078 + 1
}
val x1084 = x1070// unsafe immutable
x1084
}
if (x1065) {
x1086thenb()
} else { 
x1086elseb()
}
}
x1086
}
if (x1064) {
x1088thenb()
} else { 
x1088elseb()
}
}
x1088
}
x1090
}
mapReduceIdx += 1
} // end mapReduce loop x1091
x1062
}
val x1091 = x1091_block
x1091
}
var mapReduceIdx = 1
while (mapReduceIdx < x870.size) { // begin mapReduce loop x1122
val x871 = x870.dcApply(mapReduceIdx)
val x1094 = {
val x872 = x867.numCols
val x873 = x872 - 5
val x874 = new generated.scala.IndexVectorRangeImpl(5,x873)
val x902 = x871 + 15
val x894 = x871 - 15
val x895 = x894 < 0
val x896 = 15 - x871
val x897 = (0,x896)
val x898 = (x894,0)
val x899 = {
def x899thenb(): scala.Tuple2[Int, Int] = {
x897
}
def x899elseb(): scala.Tuple2[Int, Int] = {
x898
}
if (x895) {
x899thenb()
} else { 
x899elseb()
}
}
val x900 = x899._1
val x901 = x899._2
val x1017 = x878 * x871
def x1091_block = {
val x875 = x874.dcApply(0)
var x1062 = {
val x879 = new generated.scala.IntVectorImpl(900,false)
val x880 = new generated.scala.IndexVectorSeqImpl(0)
val x881 = new generated.scala.BinarizedGradientTemplate(15,null,null,x863,x879,x880,null,null,null)
val x891 = x867.numCols
val x890 = x875 + 15
val x892 = x890 > x891
val x893 = {
def x893thenb(): Int = {
x891
}
def x893elseb(): Int = {
x890
}
if (x892) {
x893thenb()
} else { 
x893elseb()
}
}
val x903 = x867.numRows
val x904 = x902 > x903
val x905 = {
def x905thenb(): Int = {
x903
}
def x905elseb(): Int = {
x902
}
if (x904) {
x905thenb()
} else { 
x905elseb()
}
}
var x906: Int = x900
val x907 = x906
val x908 = x907 < x905
val x882 = x875 - 15
val x883 = x882 < 0
val x884 = 15 - x875
val x885 = (0,x884)
val x886 = (x882,0)
val x887 = {
def x887thenb(): scala.Tuple2[Int, Int] = {
x885
}
def x887elseb(): scala.Tuple2[Int, Int] = {
x886
}
if (x883) {
x887thenb()
} else { 
x887elseb()
}
}
val x888 = x887._1
val x913 = x901 + x907
val x914 = x913 - x900
val x915 = x914 * 30
val x889 = x887._2
val x935 = while ({x908}) {
val x909 = x867.getRow(x907)
var x910: Int = x888
val x911 = x910
val x912 = x911 < x893
val x916 = x889 + x911
val x917 = x916 - x888
val x918 = x915 + x917
val x932 = while ({x912}) {
var x919: Int = x918
val x920 = x881.binary_gradients
val x922 = x909(x911)
val x921 = x919
val x923 = x920(x921) = x922
val x924 = x922 > 0
val x929 = {
def x929thenb(): Unit = {
val x925 = x881.match_list
val x926 = x925.length
val x927 = x925.insert(x926, x921)
x927
}
if (x924) {
x929thenb()
}
}
val x930 = x910 += 1
()
}
val x933 = x906 += 1
()
}
val x936 = x881.match_list
val x937 = x936.length
val x938 = x937 < 0
val x941 = {
def x941thenb(): Unit = {
val x939 = println("dummy")
x939
}
if (x938) {
x941thenb()
}
}
val x1012 = x878 * x875
def x1060_block = {
val x943 = x942.dcApply(0)
var x1031 = {
val x946 = x881.radius
val x944 = x857(x943)
val x945 = x944.radius
val x947 = x945 != x946
val x948 = x944.match_list
val x949 = x948.length
val x950 = x949.asInstanceOf[Float]
val x951 = x950==0.0
val x958 = x950 * 0.18f
val x959 = x958 + 0.5f
val x960 = x959.asInstanceOf[Int]
val x969 = x944.binary_gradients
val x1009 = {
def x1009thenb(): Float = {
-1.0f
}
def x1009elseb(): Float = {
val x1007 = {
def x1007thenb(): Float = {
-1.0f
}
def x1007elseb(): Float = {
val x952 = x881.match_list
val x953 = x952.length
val x954 = x953.asInstanceOf[Float]
val x955 = x954 / x950
val x956 = x955 < 0.82f
val x1005 = {
def x1005thenb(): Float = {
x955
}
def x1005elseb(): Float = {
var x957: Float = 0.0f
var x961: Int = x960
var x962: Int = 0
var x963: Boolean = true
val x964 = x962
val x965 = x964 < x949
val x966 = x963
val x967 = x965 && x966
val x968 = x948(x964)
val x970 = x969(x968)
val x971 = x970==0
val x976 = x957
val x977 = x976 + 1.0f
val x986 = x961
val x987 = x986 - 1
val x989 = x986 <= 0
val x999 = while ({x967}) {
val x972 = x881.binary_gradients
val x973 = x972(x968)
val x974 = x973==0
val x975 = x971 && x974
val x996 = {
def x996thenb(): Unit = {
x957 = x977
()
}
def x996elseb(): Unit = {
val x980 = x881.binary_gradients
val x981 = x980(x968)
val x982 = x970 & x981
val x983 = x982 > 0
val x994 = {
def x994thenb(): Unit = {
x957 = x977
()
}
def x994elseb(): Unit = {
x961 = x987
val x992 = {
def x992thenb(): Unit = {
x963 = false
()
}
if (x989) {
x992thenb()
}
}
x992
}
if (x983) {
x994thenb()
} else { 
x994elseb()
}
}
x994
}
if (x975) {
x996thenb()
} else { 
x996elseb()
}
}
val x997 = x962 += 1
()
}
val x1000 = !x966
val x1001 = x976 / x950
val x1002 = x1001.asInstanceOf[Float]
val x1003 = {
def x1003thenb(): Float = {
0.819999f
}
def x1003elseb(): Float = {
x1002
}
if (x1000) {
x1003thenb()
} else { 
x1003elseb()
}
}
x1003
}
if (x956) {
x1005thenb()
} else { 
x1005elseb()
}
}
x1005
}
if (x951) {
x1007thenb()
} else { 
x1007elseb()
}
}
x1007
}
if (x947) {
x1009thenb()
} else { 
x1009elseb()
}
}
val x1010 = x1009 > 0.82f
val x1011 = x944.rect
val x1013 = x1011.width
val x1014 = x1013 / 2
val x1015 = x1012 - x1014
val x1016 = x1015.asInstanceOf[Int]
val x1018 = x1011.height
val x1019 = x1018 / 2
val x1020 = x1017 - x1019
val x1021 = x1020.asInstanceOf[Int]
val x1029 = {
def x1029thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1022 = new generated.scala.Rect(x1016,x1021,x1013,x1018)
val x1023 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1024 = new generated.scala.BiGGDetection(x856,x1009,x1022,null,x943,x875,x871,x944,x881)
val x1025 = x1023(0) = x1024
x1023
}
def x1029elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1027 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1027
}
if (x1010) {
x1029thenb()
} else { 
x1029elseb()
}
}
x1029
}
var mapReduceIdx = 1
while (mapReduceIdx < x942.size) { // begin mapReduce loop x1060
val x943 = x942.dcApply(mapReduceIdx)
val x1032 = {
val x946 = x881.radius
val x944 = x857(x943)
val x945 = x944.radius
val x947 = x945 != x946
val x948 = x944.match_list
val x949 = x948.length
val x950 = x949.asInstanceOf[Float]
val x951 = x950==0.0
val x958 = x950 * 0.18f
val x959 = x958 + 0.5f
val x960 = x959.asInstanceOf[Int]
val x969 = x944.binary_gradients
val x1009 = {
def x1009thenb(): Float = {
-1.0f
}
def x1009elseb(): Float = {
val x1007 = {
def x1007thenb(): Float = {
-1.0f
}
def x1007elseb(): Float = {
val x952 = x881.match_list
val x953 = x952.length
val x954 = x953.asInstanceOf[Float]
val x955 = x954 / x950
val x956 = x955 < 0.82f
val x1005 = {
def x1005thenb(): Float = {
x955
}
def x1005elseb(): Float = {
var x957: Float = 0.0f
var x961: Int = x960
var x962: Int = 0
var x963: Boolean = true
val x964 = x962
val x965 = x964 < x949
val x966 = x963
val x967 = x965 && x966
val x968 = x948(x964)
val x970 = x969(x968)
val x971 = x970==0
val x976 = x957
val x977 = x976 + 1.0f
val x986 = x961
val x987 = x986 - 1
val x989 = x986 <= 0
val x999 = while ({x967}) {
val x972 = x881.binary_gradients
val x973 = x972(x968)
val x974 = x973==0
val x975 = x971 && x974
val x996 = {
def x996thenb(): Unit = {
x957 = x977
()
}
def x996elseb(): Unit = {
val x980 = x881.binary_gradients
val x981 = x980(x968)
val x982 = x970 & x981
val x983 = x982 > 0
val x994 = {
def x994thenb(): Unit = {
x957 = x977
()
}
def x994elseb(): Unit = {
x961 = x987
val x992 = {
def x992thenb(): Unit = {
x963 = false
()
}
if (x989) {
x992thenb()
}
}
x992
}
if (x983) {
x994thenb()
} else { 
x994elseb()
}
}
x994
}
if (x975) {
x996thenb()
} else { 
x996elseb()
}
}
val x997 = x962 += 1
()
}
val x1000 = !x966
val x1001 = x976 / x950
val x1002 = x1001.asInstanceOf[Float]
val x1003 = {
def x1003thenb(): Float = {
0.819999f
}
def x1003elseb(): Float = {
x1002
}
if (x1000) {
x1003thenb()
} else { 
x1003elseb()
}
}
x1003
}
if (x956) {
x1005thenb()
} else { 
x1005elseb()
}
}
x1005
}
if (x951) {
x1007thenb()
} else { 
x1007elseb()
}
}
x1007
}
if (x947) {
x1009thenb()
} else { 
x1009elseb()
}
}
val x1010 = x1009 > 0.82f
val x1011 = x944.rect
val x1013 = x1011.width
val x1014 = x1013 / 2
val x1015 = x1012 - x1014
val x1016 = x1015.asInstanceOf[Int]
val x1018 = x1011.height
val x1019 = x1018 / 2
val x1020 = x1017 - x1019
val x1021 = x1020.asInstanceOf[Int]
val x1029 = {
def x1029thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1022 = new generated.scala.Rect(x1016,x1021,x1013,x1018)
val x1023 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1024 = new generated.scala.BiGGDetection(x856,x1009,x1022,null,x943,x875,x871,x944,x881)
val x1025 = x1023(0) = x1024
x1023
}
def x1029elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1027 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1027
}
if (x1010) {
x1029thenb()
} else { 
x1029elseb()
}
}
x1029
}
x1031 = {
val x1033 = x1031.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1034 = x1032.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1035 = x1031.length
val x1036 = x1032.length
val x1037 = x1035 + x1036
val x1038 = x1031.isRow
val x1059 = { 
val x1057 = {
def x1057thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1032
}
def x1057elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1055 = {
def x1055thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1031
}
def x1055elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1039 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1037,x1038)
var x1041 : Int = 0
val x1045 = while (x1041 < x1035) {
val x1042 = x1031(x1041)
val x1043 = x1039(x1041) = x1042
x1043
x1041 = x1041 + 1
}
var x1047 : Int = 0
val x1052 = while (x1047 < x1036) {
val x1048 = x1047 + x1035
val x1049 = x1032(x1047)
val x1050 = x1039(x1048) = x1049
x1050
x1047 = x1047 + 1
}
val x1053 = x1039// unsafe immutable
x1053
}
if (x1034) {
x1055thenb()
} else { 
x1055elseb()
}
}
x1055
}
if (x1033) {
x1057thenb()
} else { 
x1057elseb()
}
}
x1057
}
x1059
}
mapReduceIdx += 1
} // end mapReduce loop x1060
x1031
}
val x1060 = x1060_block
x1060
}
var mapReduceIdx = 1
while (mapReduceIdx < x874.size) { // begin mapReduce loop x1091
val x875 = x874.dcApply(mapReduceIdx)
val x1063 = {
val x879 = new generated.scala.IntVectorImpl(900,false)
val x880 = new generated.scala.IndexVectorSeqImpl(0)
val x881 = new generated.scala.BinarizedGradientTemplate(15,null,null,x863,x879,x880,null,null,null)
val x891 = x867.numCols
val x890 = x875 + 15
val x892 = x890 > x891
val x893 = {
def x893thenb(): Int = {
x891
}
def x893elseb(): Int = {
x890
}
if (x892) {
x893thenb()
} else { 
x893elseb()
}
}
val x903 = x867.numRows
val x904 = x902 > x903
val x905 = {
def x905thenb(): Int = {
x903
}
def x905elseb(): Int = {
x902
}
if (x904) {
x905thenb()
} else { 
x905elseb()
}
}
var x906: Int = x900
val x907 = x906
val x908 = x907 < x905
val x882 = x875 - 15
val x883 = x882 < 0
val x884 = 15 - x875
val x885 = (0,x884)
val x886 = (x882,0)
val x887 = {
def x887thenb(): scala.Tuple2[Int, Int] = {
x885
}
def x887elseb(): scala.Tuple2[Int, Int] = {
x886
}
if (x883) {
x887thenb()
} else { 
x887elseb()
}
}
val x888 = x887._1
val x913 = x901 + x907
val x914 = x913 - x900
val x915 = x914 * 30
val x889 = x887._2
val x935 = while ({x908}) {
val x909 = x867.getRow(x907)
var x910: Int = x888
val x911 = x910
val x912 = x911 < x893
val x916 = x889 + x911
val x917 = x916 - x888
val x918 = x915 + x917
val x932 = while ({x912}) {
var x919: Int = x918
val x920 = x881.binary_gradients
val x922 = x909(x911)
val x921 = x919
val x923 = x920(x921) = x922
val x924 = x922 > 0
val x929 = {
def x929thenb(): Unit = {
val x925 = x881.match_list
val x926 = x925.length
val x927 = x925.insert(x926, x921)
x927
}
if (x924) {
x929thenb()
}
}
val x930 = x910 += 1
()
}
val x933 = x906 += 1
()
}
val x936 = x881.match_list
val x937 = x936.length
val x938 = x937 < 0
val x941 = {
def x941thenb(): Unit = {
val x939 = println("dummy")
x939
}
if (x938) {
x941thenb()
}
}
val x1012 = x878 * x875
def x1060_block = {
val x943 = x942.dcApply(0)
var x1031 = {
val x946 = x881.radius
val x944 = x857(x943)
val x945 = x944.radius
val x947 = x945 != x946
val x948 = x944.match_list
val x949 = x948.length
val x950 = x949.asInstanceOf[Float]
val x951 = x950==0.0
val x958 = x950 * 0.18f
val x959 = x958 + 0.5f
val x960 = x959.asInstanceOf[Int]
val x969 = x944.binary_gradients
val x1009 = {
def x1009thenb(): Float = {
-1.0f
}
def x1009elseb(): Float = {
val x1007 = {
def x1007thenb(): Float = {
-1.0f
}
def x1007elseb(): Float = {
val x952 = x881.match_list
val x953 = x952.length
val x954 = x953.asInstanceOf[Float]
val x955 = x954 / x950
val x956 = x955 < 0.82f
val x1005 = {
def x1005thenb(): Float = {
x955
}
def x1005elseb(): Float = {
var x957: Float = 0.0f
var x961: Int = x960
var x962: Int = 0
var x963: Boolean = true
val x964 = x962
val x965 = x964 < x949
val x966 = x963
val x967 = x965 && x966
val x968 = x948(x964)
val x970 = x969(x968)
val x971 = x970==0
val x976 = x957
val x977 = x976 + 1.0f
val x986 = x961
val x987 = x986 - 1
val x989 = x986 <= 0
val x999 = while ({x967}) {
val x972 = x881.binary_gradients
val x973 = x972(x968)
val x974 = x973==0
val x975 = x971 && x974
val x996 = {
def x996thenb(): Unit = {
x957 = x977
()
}
def x996elseb(): Unit = {
val x980 = x881.binary_gradients
val x981 = x980(x968)
val x982 = x970 & x981
val x983 = x982 > 0
val x994 = {
def x994thenb(): Unit = {
x957 = x977
()
}
def x994elseb(): Unit = {
x961 = x987
val x992 = {
def x992thenb(): Unit = {
x963 = false
()
}
if (x989) {
x992thenb()
}
}
x992
}
if (x983) {
x994thenb()
} else { 
x994elseb()
}
}
x994
}
if (x975) {
x996thenb()
} else { 
x996elseb()
}
}
val x997 = x962 += 1
()
}
val x1000 = !x966
val x1001 = x976 / x950
val x1002 = x1001.asInstanceOf[Float]
val x1003 = {
def x1003thenb(): Float = {
0.819999f
}
def x1003elseb(): Float = {
x1002
}
if (x1000) {
x1003thenb()
} else { 
x1003elseb()
}
}
x1003
}
if (x956) {
x1005thenb()
} else { 
x1005elseb()
}
}
x1005
}
if (x951) {
x1007thenb()
} else { 
x1007elseb()
}
}
x1007
}
if (x947) {
x1009thenb()
} else { 
x1009elseb()
}
}
val x1010 = x1009 > 0.82f
val x1011 = x944.rect
val x1013 = x1011.width
val x1014 = x1013 / 2
val x1015 = x1012 - x1014
val x1016 = x1015.asInstanceOf[Int]
val x1018 = x1011.height
val x1019 = x1018 / 2
val x1020 = x1017 - x1019
val x1021 = x1020.asInstanceOf[Int]
val x1029 = {
def x1029thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1022 = new generated.scala.Rect(x1016,x1021,x1013,x1018)
val x1023 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1024 = new generated.scala.BiGGDetection(x856,x1009,x1022,null,x943,x875,x871,x944,x881)
val x1025 = x1023(0) = x1024
x1023
}
def x1029elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1027 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1027
}
if (x1010) {
x1029thenb()
} else { 
x1029elseb()
}
}
x1029
}
var mapReduceIdx = 1
while (mapReduceIdx < x942.size) { // begin mapReduce loop x1060
val x943 = x942.dcApply(mapReduceIdx)
val x1032 = {
val x946 = x881.radius
val x944 = x857(x943)
val x945 = x944.radius
val x947 = x945 != x946
val x948 = x944.match_list
val x949 = x948.length
val x950 = x949.asInstanceOf[Float]
val x951 = x950==0.0
val x958 = x950 * 0.18f
val x959 = x958 + 0.5f
val x960 = x959.asInstanceOf[Int]
val x969 = x944.binary_gradients
val x1009 = {
def x1009thenb(): Float = {
-1.0f
}
def x1009elseb(): Float = {
val x1007 = {
def x1007thenb(): Float = {
-1.0f
}
def x1007elseb(): Float = {
val x952 = x881.match_list
val x953 = x952.length
val x954 = x953.asInstanceOf[Float]
val x955 = x954 / x950
val x956 = x955 < 0.82f
val x1005 = {
def x1005thenb(): Float = {
x955
}
def x1005elseb(): Float = {
var x957: Float = 0.0f
var x961: Int = x960
var x962: Int = 0
var x963: Boolean = true
val x964 = x962
val x965 = x964 < x949
val x966 = x963
val x967 = x965 && x966
val x968 = x948(x964)
val x970 = x969(x968)
val x971 = x970==0
val x976 = x957
val x977 = x976 + 1.0f
val x986 = x961
val x987 = x986 - 1
val x989 = x986 <= 0
val x999 = while ({x967}) {
val x972 = x881.binary_gradients
val x973 = x972(x968)
val x974 = x973==0
val x975 = x971 && x974
val x996 = {
def x996thenb(): Unit = {
x957 = x977
()
}
def x996elseb(): Unit = {
val x980 = x881.binary_gradients
val x981 = x980(x968)
val x982 = x970 & x981
val x983 = x982 > 0
val x994 = {
def x994thenb(): Unit = {
x957 = x977
()
}
def x994elseb(): Unit = {
x961 = x987
val x992 = {
def x992thenb(): Unit = {
x963 = false
()
}
if (x989) {
x992thenb()
}
}
x992
}
if (x983) {
x994thenb()
} else { 
x994elseb()
}
}
x994
}
if (x975) {
x996thenb()
} else { 
x996elseb()
}
}
val x997 = x962 += 1
()
}
val x1000 = !x966
val x1001 = x976 / x950
val x1002 = x1001.asInstanceOf[Float]
val x1003 = {
def x1003thenb(): Float = {
0.819999f
}
def x1003elseb(): Float = {
x1002
}
if (x1000) {
x1003thenb()
} else { 
x1003elseb()
}
}
x1003
}
if (x956) {
x1005thenb()
} else { 
x1005elseb()
}
}
x1005
}
if (x951) {
x1007thenb()
} else { 
x1007elseb()
}
}
x1007
}
if (x947) {
x1009thenb()
} else { 
x1009elseb()
}
}
val x1010 = x1009 > 0.82f
val x1011 = x944.rect
val x1013 = x1011.width
val x1014 = x1013 / 2
val x1015 = x1012 - x1014
val x1016 = x1015.asInstanceOf[Int]
val x1018 = x1011.height
val x1019 = x1018 / 2
val x1020 = x1017 - x1019
val x1021 = x1020.asInstanceOf[Int]
val x1029 = {
def x1029thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1022 = new generated.scala.Rect(x1016,x1021,x1013,x1018)
val x1023 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1024 = new generated.scala.BiGGDetection(x856,x1009,x1022,null,x943,x875,x871,x944,x881)
val x1025 = x1023(0) = x1024
x1023
}
def x1029elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1027 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1027
}
if (x1010) {
x1029thenb()
} else { 
x1029elseb()
}
}
x1029
}
x1031 = {
val x1033 = x1031.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1034 = x1032.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1035 = x1031.length
val x1036 = x1032.length
val x1037 = x1035 + x1036
val x1038 = x1031.isRow
val x1059 = { 
val x1057 = {
def x1057thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1032
}
def x1057elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1055 = {
def x1055thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1031
}
def x1055elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1039 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1037,x1038)
var x1041 : Int = 0
val x1045 = while (x1041 < x1035) {
val x1042 = x1031(x1041)
val x1043 = x1039(x1041) = x1042
x1043
x1041 = x1041 + 1
}
var x1047 : Int = 0
val x1052 = while (x1047 < x1036) {
val x1048 = x1047 + x1035
val x1049 = x1032(x1047)
val x1050 = x1039(x1048) = x1049
x1050
x1047 = x1047 + 1
}
val x1053 = x1039// unsafe immutable
x1053
}
if (x1034) {
x1055thenb()
} else { 
x1055elseb()
}
}
x1055
}
if (x1033) {
x1057thenb()
} else { 
x1057elseb()
}
}
x1057
}
x1059
}
mapReduceIdx += 1
} // end mapReduce loop x1060
x1031
}
val x1060 = x1060_block
x1060
}
x1062 = {
val x1064 = x1062.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1065 = x1063.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1066 = x1062.length
val x1067 = x1063.length
val x1068 = x1066 + x1067
val x1069 = x1062.isRow
val x1090 = { 
val x1088 = {
def x1088thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1063
}
def x1088elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1086 = {
def x1086thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1062
}
def x1086elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1070 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1068,x1069)
var x1072 : Int = 0
val x1076 = while (x1072 < x1066) {
val x1073 = x1062(x1072)
val x1074 = x1070(x1072) = x1073
x1074
x1072 = x1072 + 1
}
var x1078 : Int = 0
val x1083 = while (x1078 < x1067) {
val x1079 = x1078 + x1066
val x1080 = x1063(x1078)
val x1081 = x1070(x1079) = x1080
x1081
x1078 = x1078 + 1
}
val x1084 = x1070// unsafe immutable
x1084
}
if (x1065) {
x1086thenb()
} else { 
x1086elseb()
}
}
x1086
}
if (x1064) {
x1088thenb()
} else { 
x1088elseb()
}
}
x1088
}
x1090
}
mapReduceIdx += 1
} // end mapReduce loop x1091
x1062
}
val x1091 = x1091_block
x1091
}
x1093 = {
val x1095 = x1093.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1096 = x1094.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1097 = x1093.length
val x1098 = x1094.length
val x1099 = x1097 + x1098
val x1100 = x1093.isRow
val x1121 = { 
val x1119 = {
def x1119thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1094
}
def x1119elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1117 = {
def x1117thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1093
}
def x1117elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1101 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1099,x1100)
var x1103 : Int = 0
val x1107 = while (x1103 < x1097) {
val x1104 = x1093(x1103)
val x1105 = x1101(x1103) = x1104
x1105
x1103 = x1103 + 1
}
var x1109 : Int = 0
val x1114 = while (x1109 < x1098) {
val x1110 = x1109 + x1097
val x1111 = x1094(x1109)
val x1112 = x1101(x1110) = x1111
x1112
x1109 = x1109 + 1
}
val x1115 = x1101// unsafe immutable
x1115
}
if (x1096) {
x1117thenb()
} else { 
x1117elseb()
}
}
x1117
}
if (x1095) {
x1119thenb()
} else { 
x1119elseb()
}
}
x1119
}
x1121
}
mapReduceIdx += 1
} // end mapReduce loop x1122
x1093
}
val x1122 = x1122_block
val x1123 = x1122.length
val x1124 = "Detections: "+x1123
val x1125 = println(x1124)
x1122
}
var mapReduceIdx = 1
while (mapReduceIdx < x222.size) { // begin mapReduce loop x1156
val x855 = x222.dcApply(mapReduceIdx)
val x1128 = {
val x856 = x855._1
val x858 = "Name: "+x856
val x859 = println(x858)
val x857 = x855._2
val x860 = x857.length
val x861 = "Templates: "+x860
val x862 = println(x861)
val x863 = x720.fixedLevelIndex
val x864 = x720.pyramid
val x865 = x720.start_level
val x866 = x863 - x865
val x867 = x864(x866)
val x868 = x867.numRows
val x869 = x868 - 5
val x870 = new generated.scala.IndexVectorRangeImpl(5,x869)
val x942 = new generated.scala.IndexVectorRangeImpl(0,x860)
val x876 = x863
val x877 = Math.pow(2.0,x876)
val x878 = x877.asInstanceOf[Int]
def x1122_block = {
val x871 = x870.dcApply(0)
var x1093 = {
val x872 = x867.numCols
val x873 = x872 - 5
val x874 = new generated.scala.IndexVectorRangeImpl(5,x873)
val x902 = x871 + 15
val x894 = x871 - 15
val x895 = x894 < 0
val x896 = 15 - x871
val x897 = (0,x896)
val x898 = (x894,0)
val x899 = {
def x899thenb(): scala.Tuple2[Int, Int] = {
x897
}
def x899elseb(): scala.Tuple2[Int, Int] = {
x898
}
if (x895) {
x899thenb()
} else { 
x899elseb()
}
}
val x900 = x899._1
val x901 = x899._2
val x1017 = x878 * x871
def x1091_block = {
val x875 = x874.dcApply(0)
var x1062 = {
val x879 = new generated.scala.IntVectorImpl(900,false)
val x880 = new generated.scala.IndexVectorSeqImpl(0)
val x881 = new generated.scala.BinarizedGradientTemplate(15,null,null,x863,x879,x880,null,null,null)
val x891 = x867.numCols
val x890 = x875 + 15
val x892 = x890 > x891
val x893 = {
def x893thenb(): Int = {
x891
}
def x893elseb(): Int = {
x890
}
if (x892) {
x893thenb()
} else { 
x893elseb()
}
}
val x903 = x867.numRows
val x904 = x902 > x903
val x905 = {
def x905thenb(): Int = {
x903
}
def x905elseb(): Int = {
x902
}
if (x904) {
x905thenb()
} else { 
x905elseb()
}
}
var x906: Int = x900
val x907 = x906
val x908 = x907 < x905
val x882 = x875 - 15
val x883 = x882 < 0
val x884 = 15 - x875
val x885 = (0,x884)
val x886 = (x882,0)
val x887 = {
def x887thenb(): scala.Tuple2[Int, Int] = {
x885
}
def x887elseb(): scala.Tuple2[Int, Int] = {
x886
}
if (x883) {
x887thenb()
} else { 
x887elseb()
}
}
val x888 = x887._1
val x913 = x901 + x907
val x914 = x913 - x900
val x915 = x914 * 30
val x889 = x887._2
val x935 = while ({x908}) {
val x909 = x867.getRow(x907)
var x910: Int = x888
val x911 = x910
val x912 = x911 < x893
val x916 = x889 + x911
val x917 = x916 - x888
val x918 = x915 + x917
val x932 = while ({x912}) {
var x919: Int = x918
val x920 = x881.binary_gradients
val x922 = x909(x911)
val x921 = x919
val x923 = x920(x921) = x922
val x924 = x922 > 0
val x929 = {
def x929thenb(): Unit = {
val x925 = x881.match_list
val x926 = x925.length
val x927 = x925.insert(x926, x921)
x927
}
if (x924) {
x929thenb()
}
}
val x930 = x910 += 1
()
}
val x933 = x906 += 1
()
}
val x936 = x881.match_list
val x937 = x936.length
val x938 = x937 < 0
val x941 = {
def x941thenb(): Unit = {
val x939 = println("dummy")
x939
}
if (x938) {
x941thenb()
}
}
val x1012 = x878 * x875
def x1060_block = {
val x943 = x942.dcApply(0)
var x1031 = {
val x946 = x881.radius
val x944 = x857(x943)
val x945 = x944.radius
val x947 = x945 != x946
val x948 = x944.match_list
val x949 = x948.length
val x950 = x949.asInstanceOf[Float]
val x951 = x950==0.0
val x958 = x950 * 0.18f
val x959 = x958 + 0.5f
val x960 = x959.asInstanceOf[Int]
val x969 = x944.binary_gradients
val x1009 = {
def x1009thenb(): Float = {
-1.0f
}
def x1009elseb(): Float = {
val x1007 = {
def x1007thenb(): Float = {
-1.0f
}
def x1007elseb(): Float = {
val x952 = x881.match_list
val x953 = x952.length
val x954 = x953.asInstanceOf[Float]
val x955 = x954 / x950
val x956 = x955 < 0.82f
val x1005 = {
def x1005thenb(): Float = {
x955
}
def x1005elseb(): Float = {
var x957: Float = 0.0f
var x961: Int = x960
var x962: Int = 0
var x963: Boolean = true
val x964 = x962
val x965 = x964 < x949
val x966 = x963
val x967 = x965 && x966
val x968 = x948(x964)
val x970 = x969(x968)
val x971 = x970==0
val x976 = x957
val x977 = x976 + 1.0f
val x986 = x961
val x987 = x986 - 1
val x989 = x986 <= 0
val x999 = while ({x967}) {
val x972 = x881.binary_gradients
val x973 = x972(x968)
val x974 = x973==0
val x975 = x971 && x974
val x996 = {
def x996thenb(): Unit = {
x957 = x977
()
}
def x996elseb(): Unit = {
val x980 = x881.binary_gradients
val x981 = x980(x968)
val x982 = x970 & x981
val x983 = x982 > 0
val x994 = {
def x994thenb(): Unit = {
x957 = x977
()
}
def x994elseb(): Unit = {
x961 = x987
val x992 = {
def x992thenb(): Unit = {
x963 = false
()
}
if (x989) {
x992thenb()
}
}
x992
}
if (x983) {
x994thenb()
} else { 
x994elseb()
}
}
x994
}
if (x975) {
x996thenb()
} else { 
x996elseb()
}
}
val x997 = x962 += 1
()
}
val x1000 = !x966
val x1001 = x976 / x950
val x1002 = x1001.asInstanceOf[Float]
val x1003 = {
def x1003thenb(): Float = {
0.819999f
}
def x1003elseb(): Float = {
x1002
}
if (x1000) {
x1003thenb()
} else { 
x1003elseb()
}
}
x1003
}
if (x956) {
x1005thenb()
} else { 
x1005elseb()
}
}
x1005
}
if (x951) {
x1007thenb()
} else { 
x1007elseb()
}
}
x1007
}
if (x947) {
x1009thenb()
} else { 
x1009elseb()
}
}
val x1010 = x1009 > 0.82f
val x1011 = x944.rect
val x1013 = x1011.width
val x1014 = x1013 / 2
val x1015 = x1012 - x1014
val x1016 = x1015.asInstanceOf[Int]
val x1018 = x1011.height
val x1019 = x1018 / 2
val x1020 = x1017 - x1019
val x1021 = x1020.asInstanceOf[Int]
val x1029 = {
def x1029thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1022 = new generated.scala.Rect(x1016,x1021,x1013,x1018)
val x1023 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1024 = new generated.scala.BiGGDetection(x856,x1009,x1022,null,x943,x875,x871,x944,x881)
val x1025 = x1023(0) = x1024
x1023
}
def x1029elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1027 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1027
}
if (x1010) {
x1029thenb()
} else { 
x1029elseb()
}
}
x1029
}
var mapReduceIdx = 1
while (mapReduceIdx < x942.size) { // begin mapReduce loop x1060
val x943 = x942.dcApply(mapReduceIdx)
val x1032 = {
val x946 = x881.radius
val x944 = x857(x943)
val x945 = x944.radius
val x947 = x945 != x946
val x948 = x944.match_list
val x949 = x948.length
val x950 = x949.asInstanceOf[Float]
val x951 = x950==0.0
val x958 = x950 * 0.18f
val x959 = x958 + 0.5f
val x960 = x959.asInstanceOf[Int]
val x969 = x944.binary_gradients
val x1009 = {
def x1009thenb(): Float = {
-1.0f
}
def x1009elseb(): Float = {
val x1007 = {
def x1007thenb(): Float = {
-1.0f
}
def x1007elseb(): Float = {
val x952 = x881.match_list
val x953 = x952.length
val x954 = x953.asInstanceOf[Float]
val x955 = x954 / x950
val x956 = x955 < 0.82f
val x1005 = {
def x1005thenb(): Float = {
x955
}
def x1005elseb(): Float = {
var x957: Float = 0.0f
var x961: Int = x960
var x962: Int = 0
var x963: Boolean = true
val x964 = x962
val x965 = x964 < x949
val x966 = x963
val x967 = x965 && x966
val x968 = x948(x964)
val x970 = x969(x968)
val x971 = x970==0
val x976 = x957
val x977 = x976 + 1.0f
val x986 = x961
val x987 = x986 - 1
val x989 = x986 <= 0
val x999 = while ({x967}) {
val x972 = x881.binary_gradients
val x973 = x972(x968)
val x974 = x973==0
val x975 = x971 && x974
val x996 = {
def x996thenb(): Unit = {
x957 = x977
()
}
def x996elseb(): Unit = {
val x980 = x881.binary_gradients
val x981 = x980(x968)
val x982 = x970 & x981
val x983 = x982 > 0
val x994 = {
def x994thenb(): Unit = {
x957 = x977
()
}
def x994elseb(): Unit = {
x961 = x987
val x992 = {
def x992thenb(): Unit = {
x963 = false
()
}
if (x989) {
x992thenb()
}
}
x992
}
if (x983) {
x994thenb()
} else { 
x994elseb()
}
}
x994
}
if (x975) {
x996thenb()
} else { 
x996elseb()
}
}
val x997 = x962 += 1
()
}
val x1000 = !x966
val x1001 = x976 / x950
val x1002 = x1001.asInstanceOf[Float]
val x1003 = {
def x1003thenb(): Float = {
0.819999f
}
def x1003elseb(): Float = {
x1002
}
if (x1000) {
x1003thenb()
} else { 
x1003elseb()
}
}
x1003
}
if (x956) {
x1005thenb()
} else { 
x1005elseb()
}
}
x1005
}
if (x951) {
x1007thenb()
} else { 
x1007elseb()
}
}
x1007
}
if (x947) {
x1009thenb()
} else { 
x1009elseb()
}
}
val x1010 = x1009 > 0.82f
val x1011 = x944.rect
val x1013 = x1011.width
val x1014 = x1013 / 2
val x1015 = x1012 - x1014
val x1016 = x1015.asInstanceOf[Int]
val x1018 = x1011.height
val x1019 = x1018 / 2
val x1020 = x1017 - x1019
val x1021 = x1020.asInstanceOf[Int]
val x1029 = {
def x1029thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1022 = new generated.scala.Rect(x1016,x1021,x1013,x1018)
val x1023 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1024 = new generated.scala.BiGGDetection(x856,x1009,x1022,null,x943,x875,x871,x944,x881)
val x1025 = x1023(0) = x1024
x1023
}
def x1029elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1027 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1027
}
if (x1010) {
x1029thenb()
} else { 
x1029elseb()
}
}
x1029
}
x1031 = {
val x1033 = x1031.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1034 = x1032.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1035 = x1031.length
val x1036 = x1032.length
val x1037 = x1035 + x1036
val x1038 = x1031.isRow
val x1059 = { 
val x1057 = {
def x1057thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1032
}
def x1057elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1055 = {
def x1055thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1031
}
def x1055elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1039 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1037,x1038)
var x1041 : Int = 0
val x1045 = while (x1041 < x1035) {
val x1042 = x1031(x1041)
val x1043 = x1039(x1041) = x1042
x1043
x1041 = x1041 + 1
}
var x1047 : Int = 0
val x1052 = while (x1047 < x1036) {
val x1048 = x1047 + x1035
val x1049 = x1032(x1047)
val x1050 = x1039(x1048) = x1049
x1050
x1047 = x1047 + 1
}
val x1053 = x1039// unsafe immutable
x1053
}
if (x1034) {
x1055thenb()
} else { 
x1055elseb()
}
}
x1055
}
if (x1033) {
x1057thenb()
} else { 
x1057elseb()
}
}
x1057
}
x1059
}
mapReduceIdx += 1
} // end mapReduce loop x1060
x1031
}
val x1060 = x1060_block
x1060
}
var mapReduceIdx = 1
while (mapReduceIdx < x874.size) { // begin mapReduce loop x1091
val x875 = x874.dcApply(mapReduceIdx)
val x1063 = {
val x879 = new generated.scala.IntVectorImpl(900,false)
val x880 = new generated.scala.IndexVectorSeqImpl(0)
val x881 = new generated.scala.BinarizedGradientTemplate(15,null,null,x863,x879,x880,null,null,null)
val x891 = x867.numCols
val x890 = x875 + 15
val x892 = x890 > x891
val x893 = {
def x893thenb(): Int = {
x891
}
def x893elseb(): Int = {
x890
}
if (x892) {
x893thenb()
} else { 
x893elseb()
}
}
val x903 = x867.numRows
val x904 = x902 > x903
val x905 = {
def x905thenb(): Int = {
x903
}
def x905elseb(): Int = {
x902
}
if (x904) {
x905thenb()
} else { 
x905elseb()
}
}
var x906: Int = x900
val x907 = x906
val x908 = x907 < x905
val x882 = x875 - 15
val x883 = x882 < 0
val x884 = 15 - x875
val x885 = (0,x884)
val x886 = (x882,0)
val x887 = {
def x887thenb(): scala.Tuple2[Int, Int] = {
x885
}
def x887elseb(): scala.Tuple2[Int, Int] = {
x886
}
if (x883) {
x887thenb()
} else { 
x887elseb()
}
}
val x888 = x887._1
val x913 = x901 + x907
val x914 = x913 - x900
val x915 = x914 * 30
val x889 = x887._2
val x935 = while ({x908}) {
val x909 = x867.getRow(x907)
var x910: Int = x888
val x911 = x910
val x912 = x911 < x893
val x916 = x889 + x911
val x917 = x916 - x888
val x918 = x915 + x917
val x932 = while ({x912}) {
var x919: Int = x918
val x920 = x881.binary_gradients
val x922 = x909(x911)
val x921 = x919
val x923 = x920(x921) = x922
val x924 = x922 > 0
val x929 = {
def x929thenb(): Unit = {
val x925 = x881.match_list
val x926 = x925.length
val x927 = x925.insert(x926, x921)
x927
}
if (x924) {
x929thenb()
}
}
val x930 = x910 += 1
()
}
val x933 = x906 += 1
()
}
val x936 = x881.match_list
val x937 = x936.length
val x938 = x937 < 0
val x941 = {
def x941thenb(): Unit = {
val x939 = println("dummy")
x939
}
if (x938) {
x941thenb()
}
}
val x1012 = x878 * x875
def x1060_block = {
val x943 = x942.dcApply(0)
var x1031 = {
val x946 = x881.radius
val x944 = x857(x943)
val x945 = x944.radius
val x947 = x945 != x946
val x948 = x944.match_list
val x949 = x948.length
val x950 = x949.asInstanceOf[Float]
val x951 = x950==0.0
val x958 = x950 * 0.18f
val x959 = x958 + 0.5f
val x960 = x959.asInstanceOf[Int]
val x969 = x944.binary_gradients
val x1009 = {
def x1009thenb(): Float = {
-1.0f
}
def x1009elseb(): Float = {
val x1007 = {
def x1007thenb(): Float = {
-1.0f
}
def x1007elseb(): Float = {
val x952 = x881.match_list
val x953 = x952.length
val x954 = x953.asInstanceOf[Float]
val x955 = x954 / x950
val x956 = x955 < 0.82f
val x1005 = {
def x1005thenb(): Float = {
x955
}
def x1005elseb(): Float = {
var x957: Float = 0.0f
var x961: Int = x960
var x962: Int = 0
var x963: Boolean = true
val x964 = x962
val x965 = x964 < x949
val x966 = x963
val x967 = x965 && x966
val x968 = x948(x964)
val x970 = x969(x968)
val x971 = x970==0
val x976 = x957
val x977 = x976 + 1.0f
val x986 = x961
val x987 = x986 - 1
val x989 = x986 <= 0
val x999 = while ({x967}) {
val x972 = x881.binary_gradients
val x973 = x972(x968)
val x974 = x973==0
val x975 = x971 && x974
val x996 = {
def x996thenb(): Unit = {
x957 = x977
()
}
def x996elseb(): Unit = {
val x980 = x881.binary_gradients
val x981 = x980(x968)
val x982 = x970 & x981
val x983 = x982 > 0
val x994 = {
def x994thenb(): Unit = {
x957 = x977
()
}
def x994elseb(): Unit = {
x961 = x987
val x992 = {
def x992thenb(): Unit = {
x963 = false
()
}
if (x989) {
x992thenb()
}
}
x992
}
if (x983) {
x994thenb()
} else { 
x994elseb()
}
}
x994
}
if (x975) {
x996thenb()
} else { 
x996elseb()
}
}
val x997 = x962 += 1
()
}
val x1000 = !x966
val x1001 = x976 / x950
val x1002 = x1001.asInstanceOf[Float]
val x1003 = {
def x1003thenb(): Float = {
0.819999f
}
def x1003elseb(): Float = {
x1002
}
if (x1000) {
x1003thenb()
} else { 
x1003elseb()
}
}
x1003
}
if (x956) {
x1005thenb()
} else { 
x1005elseb()
}
}
x1005
}
if (x951) {
x1007thenb()
} else { 
x1007elseb()
}
}
x1007
}
if (x947) {
x1009thenb()
} else { 
x1009elseb()
}
}
val x1010 = x1009 > 0.82f
val x1011 = x944.rect
val x1013 = x1011.width
val x1014 = x1013 / 2
val x1015 = x1012 - x1014
val x1016 = x1015.asInstanceOf[Int]
val x1018 = x1011.height
val x1019 = x1018 / 2
val x1020 = x1017 - x1019
val x1021 = x1020.asInstanceOf[Int]
val x1029 = {
def x1029thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1022 = new generated.scala.Rect(x1016,x1021,x1013,x1018)
val x1023 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1024 = new generated.scala.BiGGDetection(x856,x1009,x1022,null,x943,x875,x871,x944,x881)
val x1025 = x1023(0) = x1024
x1023
}
def x1029elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1027 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1027
}
if (x1010) {
x1029thenb()
} else { 
x1029elseb()
}
}
x1029
}
var mapReduceIdx = 1
while (mapReduceIdx < x942.size) { // begin mapReduce loop x1060
val x943 = x942.dcApply(mapReduceIdx)
val x1032 = {
val x946 = x881.radius
val x944 = x857(x943)
val x945 = x944.radius
val x947 = x945 != x946
val x948 = x944.match_list
val x949 = x948.length
val x950 = x949.asInstanceOf[Float]
val x951 = x950==0.0
val x958 = x950 * 0.18f
val x959 = x958 + 0.5f
val x960 = x959.asInstanceOf[Int]
val x969 = x944.binary_gradients
val x1009 = {
def x1009thenb(): Float = {
-1.0f
}
def x1009elseb(): Float = {
val x1007 = {
def x1007thenb(): Float = {
-1.0f
}
def x1007elseb(): Float = {
val x952 = x881.match_list
val x953 = x952.length
val x954 = x953.asInstanceOf[Float]
val x955 = x954 / x950
val x956 = x955 < 0.82f
val x1005 = {
def x1005thenb(): Float = {
x955
}
def x1005elseb(): Float = {
var x957: Float = 0.0f
var x961: Int = x960
var x962: Int = 0
var x963: Boolean = true
val x964 = x962
val x965 = x964 < x949
val x966 = x963
val x967 = x965 && x966
val x968 = x948(x964)
val x970 = x969(x968)
val x971 = x970==0
val x976 = x957
val x977 = x976 + 1.0f
val x986 = x961
val x987 = x986 - 1
val x989 = x986 <= 0
val x999 = while ({x967}) {
val x972 = x881.binary_gradients
val x973 = x972(x968)
val x974 = x973==0
val x975 = x971 && x974
val x996 = {
def x996thenb(): Unit = {
x957 = x977
()
}
def x996elseb(): Unit = {
val x980 = x881.binary_gradients
val x981 = x980(x968)
val x982 = x970 & x981
val x983 = x982 > 0
val x994 = {
def x994thenb(): Unit = {
x957 = x977
()
}
def x994elseb(): Unit = {
x961 = x987
val x992 = {
def x992thenb(): Unit = {
x963 = false
()
}
if (x989) {
x992thenb()
}
}
x992
}
if (x983) {
x994thenb()
} else { 
x994elseb()
}
}
x994
}
if (x975) {
x996thenb()
} else { 
x996elseb()
}
}
val x997 = x962 += 1
()
}
val x1000 = !x966
val x1001 = x976 / x950
val x1002 = x1001.asInstanceOf[Float]
val x1003 = {
def x1003thenb(): Float = {
0.819999f
}
def x1003elseb(): Float = {
x1002
}
if (x1000) {
x1003thenb()
} else { 
x1003elseb()
}
}
x1003
}
if (x956) {
x1005thenb()
} else { 
x1005elseb()
}
}
x1005
}
if (x951) {
x1007thenb()
} else { 
x1007elseb()
}
}
x1007
}
if (x947) {
x1009thenb()
} else { 
x1009elseb()
}
}
val x1010 = x1009 > 0.82f
val x1011 = x944.rect
val x1013 = x1011.width
val x1014 = x1013 / 2
val x1015 = x1012 - x1014
val x1016 = x1015.asInstanceOf[Int]
val x1018 = x1011.height
val x1019 = x1018 / 2
val x1020 = x1017 - x1019
val x1021 = x1020.asInstanceOf[Int]
val x1029 = {
def x1029thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1022 = new generated.scala.Rect(x1016,x1021,x1013,x1018)
val x1023 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1024 = new generated.scala.BiGGDetection(x856,x1009,x1022,null,x943,x875,x871,x944,x881)
val x1025 = x1023(0) = x1024
x1023
}
def x1029elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1027 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1027
}
if (x1010) {
x1029thenb()
} else { 
x1029elseb()
}
}
x1029
}
x1031 = {
val x1033 = x1031.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1034 = x1032.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1035 = x1031.length
val x1036 = x1032.length
val x1037 = x1035 + x1036
val x1038 = x1031.isRow
val x1059 = { 
val x1057 = {
def x1057thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1032
}
def x1057elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1055 = {
def x1055thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1031
}
def x1055elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1039 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1037,x1038)
var x1041 : Int = 0
val x1045 = while (x1041 < x1035) {
val x1042 = x1031(x1041)
val x1043 = x1039(x1041) = x1042
x1043
x1041 = x1041 + 1
}
var x1047 : Int = 0
val x1052 = while (x1047 < x1036) {
val x1048 = x1047 + x1035
val x1049 = x1032(x1047)
val x1050 = x1039(x1048) = x1049
x1050
x1047 = x1047 + 1
}
val x1053 = x1039// unsafe immutable
x1053
}
if (x1034) {
x1055thenb()
} else { 
x1055elseb()
}
}
x1055
}
if (x1033) {
x1057thenb()
} else { 
x1057elseb()
}
}
x1057
}
x1059
}
mapReduceIdx += 1
} // end mapReduce loop x1060
x1031
}
val x1060 = x1060_block
x1060
}
x1062 = {
val x1064 = x1062.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1065 = x1063.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1066 = x1062.length
val x1067 = x1063.length
val x1068 = x1066 + x1067
val x1069 = x1062.isRow
val x1090 = { 
val x1088 = {
def x1088thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1063
}
def x1088elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1086 = {
def x1086thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1062
}
def x1086elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1070 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1068,x1069)
var x1072 : Int = 0
val x1076 = while (x1072 < x1066) {
val x1073 = x1062(x1072)
val x1074 = x1070(x1072) = x1073
x1074
x1072 = x1072 + 1
}
var x1078 : Int = 0
val x1083 = while (x1078 < x1067) {
val x1079 = x1078 + x1066
val x1080 = x1063(x1078)
val x1081 = x1070(x1079) = x1080
x1081
x1078 = x1078 + 1
}
val x1084 = x1070// unsafe immutable
x1084
}
if (x1065) {
x1086thenb()
} else { 
x1086elseb()
}
}
x1086
}
if (x1064) {
x1088thenb()
} else { 
x1088elseb()
}
}
x1088
}
x1090
}
mapReduceIdx += 1
} // end mapReduce loop x1091
x1062
}
val x1091 = x1091_block
x1091
}
var mapReduceIdx = 1
while (mapReduceIdx < x870.size) { // begin mapReduce loop x1122
val x871 = x870.dcApply(mapReduceIdx)
val x1094 = {
val x872 = x867.numCols
val x873 = x872 - 5
val x874 = new generated.scala.IndexVectorRangeImpl(5,x873)
val x902 = x871 + 15
val x894 = x871 - 15
val x895 = x894 < 0
val x896 = 15 - x871
val x897 = (0,x896)
val x898 = (x894,0)
val x899 = {
def x899thenb(): scala.Tuple2[Int, Int] = {
x897
}
def x899elseb(): scala.Tuple2[Int, Int] = {
x898
}
if (x895) {
x899thenb()
} else { 
x899elseb()
}
}
val x900 = x899._1
val x901 = x899._2
val x1017 = x878 * x871
def x1091_block = {
val x875 = x874.dcApply(0)
var x1062 = {
val x879 = new generated.scala.IntVectorImpl(900,false)
val x880 = new generated.scala.IndexVectorSeqImpl(0)
val x881 = new generated.scala.BinarizedGradientTemplate(15,null,null,x863,x879,x880,null,null,null)
val x891 = x867.numCols
val x890 = x875 + 15
val x892 = x890 > x891
val x893 = {
def x893thenb(): Int = {
x891
}
def x893elseb(): Int = {
x890
}
if (x892) {
x893thenb()
} else { 
x893elseb()
}
}
val x903 = x867.numRows
val x904 = x902 > x903
val x905 = {
def x905thenb(): Int = {
x903
}
def x905elseb(): Int = {
x902
}
if (x904) {
x905thenb()
} else { 
x905elseb()
}
}
var x906: Int = x900
val x907 = x906
val x908 = x907 < x905
val x882 = x875 - 15
val x883 = x882 < 0
val x884 = 15 - x875
val x885 = (0,x884)
val x886 = (x882,0)
val x887 = {
def x887thenb(): scala.Tuple2[Int, Int] = {
x885
}
def x887elseb(): scala.Tuple2[Int, Int] = {
x886
}
if (x883) {
x887thenb()
} else { 
x887elseb()
}
}
val x888 = x887._1
val x913 = x901 + x907
val x914 = x913 - x900
val x915 = x914 * 30
val x889 = x887._2
val x935 = while ({x908}) {
val x909 = x867.getRow(x907)
var x910: Int = x888
val x911 = x910
val x912 = x911 < x893
val x916 = x889 + x911
val x917 = x916 - x888
val x918 = x915 + x917
val x932 = while ({x912}) {
var x919: Int = x918
val x920 = x881.binary_gradients
val x922 = x909(x911)
val x921 = x919
val x923 = x920(x921) = x922
val x924 = x922 > 0
val x929 = {
def x929thenb(): Unit = {
val x925 = x881.match_list
val x926 = x925.length
val x927 = x925.insert(x926, x921)
x927
}
if (x924) {
x929thenb()
}
}
val x930 = x910 += 1
()
}
val x933 = x906 += 1
()
}
val x936 = x881.match_list
val x937 = x936.length
val x938 = x937 < 0
val x941 = {
def x941thenb(): Unit = {
val x939 = println("dummy")
x939
}
if (x938) {
x941thenb()
}
}
val x1012 = x878 * x875
def x1060_block = {
val x943 = x942.dcApply(0)
var x1031 = {
val x946 = x881.radius
val x944 = x857(x943)
val x945 = x944.radius
val x947 = x945 != x946
val x948 = x944.match_list
val x949 = x948.length
val x950 = x949.asInstanceOf[Float]
val x951 = x950==0.0
val x958 = x950 * 0.18f
val x959 = x958 + 0.5f
val x960 = x959.asInstanceOf[Int]
val x969 = x944.binary_gradients
val x1009 = {
def x1009thenb(): Float = {
-1.0f
}
def x1009elseb(): Float = {
val x1007 = {
def x1007thenb(): Float = {
-1.0f
}
def x1007elseb(): Float = {
val x952 = x881.match_list
val x953 = x952.length
val x954 = x953.asInstanceOf[Float]
val x955 = x954 / x950
val x956 = x955 < 0.82f
val x1005 = {
def x1005thenb(): Float = {
x955
}
def x1005elseb(): Float = {
var x957: Float = 0.0f
var x961: Int = x960
var x962: Int = 0
var x963: Boolean = true
val x964 = x962
val x965 = x964 < x949
val x966 = x963
val x967 = x965 && x966
val x968 = x948(x964)
val x970 = x969(x968)
val x971 = x970==0
val x976 = x957
val x977 = x976 + 1.0f
val x986 = x961
val x987 = x986 - 1
val x989 = x986 <= 0
val x999 = while ({x967}) {
val x972 = x881.binary_gradients
val x973 = x972(x968)
val x974 = x973==0
val x975 = x971 && x974
val x996 = {
def x996thenb(): Unit = {
x957 = x977
()
}
def x996elseb(): Unit = {
val x980 = x881.binary_gradients
val x981 = x980(x968)
val x982 = x970 & x981
val x983 = x982 > 0
val x994 = {
def x994thenb(): Unit = {
x957 = x977
()
}
def x994elseb(): Unit = {
x961 = x987
val x992 = {
def x992thenb(): Unit = {
x963 = false
()
}
if (x989) {
x992thenb()
}
}
x992
}
if (x983) {
x994thenb()
} else { 
x994elseb()
}
}
x994
}
if (x975) {
x996thenb()
} else { 
x996elseb()
}
}
val x997 = x962 += 1
()
}
val x1000 = !x966
val x1001 = x976 / x950
val x1002 = x1001.asInstanceOf[Float]
val x1003 = {
def x1003thenb(): Float = {
0.819999f
}
def x1003elseb(): Float = {
x1002
}
if (x1000) {
x1003thenb()
} else { 
x1003elseb()
}
}
x1003
}
if (x956) {
x1005thenb()
} else { 
x1005elseb()
}
}
x1005
}
if (x951) {
x1007thenb()
} else { 
x1007elseb()
}
}
x1007
}
if (x947) {
x1009thenb()
} else { 
x1009elseb()
}
}
val x1010 = x1009 > 0.82f
val x1011 = x944.rect
val x1013 = x1011.width
val x1014 = x1013 / 2
val x1015 = x1012 - x1014
val x1016 = x1015.asInstanceOf[Int]
val x1018 = x1011.height
val x1019 = x1018 / 2
val x1020 = x1017 - x1019
val x1021 = x1020.asInstanceOf[Int]
val x1029 = {
def x1029thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1022 = new generated.scala.Rect(x1016,x1021,x1013,x1018)
val x1023 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1024 = new generated.scala.BiGGDetection(x856,x1009,x1022,null,x943,x875,x871,x944,x881)
val x1025 = x1023(0) = x1024
x1023
}
def x1029elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1027 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1027
}
if (x1010) {
x1029thenb()
} else { 
x1029elseb()
}
}
x1029
}
var mapReduceIdx = 1
while (mapReduceIdx < x942.size) { // begin mapReduce loop x1060
val x943 = x942.dcApply(mapReduceIdx)
val x1032 = {
val x946 = x881.radius
val x944 = x857(x943)
val x945 = x944.radius
val x947 = x945 != x946
val x948 = x944.match_list
val x949 = x948.length
val x950 = x949.asInstanceOf[Float]
val x951 = x950==0.0
val x958 = x950 * 0.18f
val x959 = x958 + 0.5f
val x960 = x959.asInstanceOf[Int]
val x969 = x944.binary_gradients
val x1009 = {
def x1009thenb(): Float = {
-1.0f
}
def x1009elseb(): Float = {
val x1007 = {
def x1007thenb(): Float = {
-1.0f
}
def x1007elseb(): Float = {
val x952 = x881.match_list
val x953 = x952.length
val x954 = x953.asInstanceOf[Float]
val x955 = x954 / x950
val x956 = x955 < 0.82f
val x1005 = {
def x1005thenb(): Float = {
x955
}
def x1005elseb(): Float = {
var x957: Float = 0.0f
var x961: Int = x960
var x962: Int = 0
var x963: Boolean = true
val x964 = x962
val x965 = x964 < x949
val x966 = x963
val x967 = x965 && x966
val x968 = x948(x964)
val x970 = x969(x968)
val x971 = x970==0
val x976 = x957
val x977 = x976 + 1.0f
val x986 = x961
val x987 = x986 - 1
val x989 = x986 <= 0
val x999 = while ({x967}) {
val x972 = x881.binary_gradients
val x973 = x972(x968)
val x974 = x973==0
val x975 = x971 && x974
val x996 = {
def x996thenb(): Unit = {
x957 = x977
()
}
def x996elseb(): Unit = {
val x980 = x881.binary_gradients
val x981 = x980(x968)
val x982 = x970 & x981
val x983 = x982 > 0
val x994 = {
def x994thenb(): Unit = {
x957 = x977
()
}
def x994elseb(): Unit = {
x961 = x987
val x992 = {
def x992thenb(): Unit = {
x963 = false
()
}
if (x989) {
x992thenb()
}
}
x992
}
if (x983) {
x994thenb()
} else { 
x994elseb()
}
}
x994
}
if (x975) {
x996thenb()
} else { 
x996elseb()
}
}
val x997 = x962 += 1
()
}
val x1000 = !x966
val x1001 = x976 / x950
val x1002 = x1001.asInstanceOf[Float]
val x1003 = {
def x1003thenb(): Float = {
0.819999f
}
def x1003elseb(): Float = {
x1002
}
if (x1000) {
x1003thenb()
} else { 
x1003elseb()
}
}
x1003
}
if (x956) {
x1005thenb()
} else { 
x1005elseb()
}
}
x1005
}
if (x951) {
x1007thenb()
} else { 
x1007elseb()
}
}
x1007
}
if (x947) {
x1009thenb()
} else { 
x1009elseb()
}
}
val x1010 = x1009 > 0.82f
val x1011 = x944.rect
val x1013 = x1011.width
val x1014 = x1013 / 2
val x1015 = x1012 - x1014
val x1016 = x1015.asInstanceOf[Int]
val x1018 = x1011.height
val x1019 = x1018 / 2
val x1020 = x1017 - x1019
val x1021 = x1020.asInstanceOf[Int]
val x1029 = {
def x1029thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1022 = new generated.scala.Rect(x1016,x1021,x1013,x1018)
val x1023 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1024 = new generated.scala.BiGGDetection(x856,x1009,x1022,null,x943,x875,x871,x944,x881)
val x1025 = x1023(0) = x1024
x1023
}
def x1029elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1027 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1027
}
if (x1010) {
x1029thenb()
} else { 
x1029elseb()
}
}
x1029
}
x1031 = {
val x1033 = x1031.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1034 = x1032.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1035 = x1031.length
val x1036 = x1032.length
val x1037 = x1035 + x1036
val x1038 = x1031.isRow
val x1059 = { 
val x1057 = {
def x1057thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1032
}
def x1057elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1055 = {
def x1055thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1031
}
def x1055elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1039 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1037,x1038)
var x1041 : Int = 0
val x1045 = while (x1041 < x1035) {
val x1042 = x1031(x1041)
val x1043 = x1039(x1041) = x1042
x1043
x1041 = x1041 + 1
}
var x1047 : Int = 0
val x1052 = while (x1047 < x1036) {
val x1048 = x1047 + x1035
val x1049 = x1032(x1047)
val x1050 = x1039(x1048) = x1049
x1050
x1047 = x1047 + 1
}
val x1053 = x1039// unsafe immutable
x1053
}
if (x1034) {
x1055thenb()
} else { 
x1055elseb()
}
}
x1055
}
if (x1033) {
x1057thenb()
} else { 
x1057elseb()
}
}
x1057
}
x1059
}
mapReduceIdx += 1
} // end mapReduce loop x1060
x1031
}
val x1060 = x1060_block
x1060
}
var mapReduceIdx = 1
while (mapReduceIdx < x874.size) { // begin mapReduce loop x1091
val x875 = x874.dcApply(mapReduceIdx)
val x1063 = {
val x879 = new generated.scala.IntVectorImpl(900,false)
val x880 = new generated.scala.IndexVectorSeqImpl(0)
val x881 = new generated.scala.BinarizedGradientTemplate(15,null,null,x863,x879,x880,null,null,null)
val x891 = x867.numCols
val x890 = x875 + 15
val x892 = x890 > x891
val x893 = {
def x893thenb(): Int = {
x891
}
def x893elseb(): Int = {
x890
}
if (x892) {
x893thenb()
} else { 
x893elseb()
}
}
val x903 = x867.numRows
val x904 = x902 > x903
val x905 = {
def x905thenb(): Int = {
x903
}
def x905elseb(): Int = {
x902
}
if (x904) {
x905thenb()
} else { 
x905elseb()
}
}
var x906: Int = x900
val x907 = x906
val x908 = x907 < x905
val x882 = x875 - 15
val x883 = x882 < 0
val x884 = 15 - x875
val x885 = (0,x884)
val x886 = (x882,0)
val x887 = {
def x887thenb(): scala.Tuple2[Int, Int] = {
x885
}
def x887elseb(): scala.Tuple2[Int, Int] = {
x886
}
if (x883) {
x887thenb()
} else { 
x887elseb()
}
}
val x888 = x887._1
val x913 = x901 + x907
val x914 = x913 - x900
val x915 = x914 * 30
val x889 = x887._2
val x935 = while ({x908}) {
val x909 = x867.getRow(x907)
var x910: Int = x888
val x911 = x910
val x912 = x911 < x893
val x916 = x889 + x911
val x917 = x916 - x888
val x918 = x915 + x917
val x932 = while ({x912}) {
var x919: Int = x918
val x920 = x881.binary_gradients
val x922 = x909(x911)
val x921 = x919
val x923 = x920(x921) = x922
val x924 = x922 > 0
val x929 = {
def x929thenb(): Unit = {
val x925 = x881.match_list
val x926 = x925.length
val x927 = x925.insert(x926, x921)
x927
}
if (x924) {
x929thenb()
}
}
val x930 = x910 += 1
()
}
val x933 = x906 += 1
()
}
val x936 = x881.match_list
val x937 = x936.length
val x938 = x937 < 0
val x941 = {
def x941thenb(): Unit = {
val x939 = println("dummy")
x939
}
if (x938) {
x941thenb()
}
}
val x1012 = x878 * x875
def x1060_block = {
val x943 = x942.dcApply(0)
var x1031 = {
val x946 = x881.radius
val x944 = x857(x943)
val x945 = x944.radius
val x947 = x945 != x946
val x948 = x944.match_list
val x949 = x948.length
val x950 = x949.asInstanceOf[Float]
val x951 = x950==0.0
val x958 = x950 * 0.18f
val x959 = x958 + 0.5f
val x960 = x959.asInstanceOf[Int]
val x969 = x944.binary_gradients
val x1009 = {
def x1009thenb(): Float = {
-1.0f
}
def x1009elseb(): Float = {
val x1007 = {
def x1007thenb(): Float = {
-1.0f
}
def x1007elseb(): Float = {
val x952 = x881.match_list
val x953 = x952.length
val x954 = x953.asInstanceOf[Float]
val x955 = x954 / x950
val x956 = x955 < 0.82f
val x1005 = {
def x1005thenb(): Float = {
x955
}
def x1005elseb(): Float = {
var x957: Float = 0.0f
var x961: Int = x960
var x962: Int = 0
var x963: Boolean = true
val x964 = x962
val x965 = x964 < x949
val x966 = x963
val x967 = x965 && x966
val x968 = x948(x964)
val x970 = x969(x968)
val x971 = x970==0
val x976 = x957
val x977 = x976 + 1.0f
val x986 = x961
val x987 = x986 - 1
val x989 = x986 <= 0
val x999 = while ({x967}) {
val x972 = x881.binary_gradients
val x973 = x972(x968)
val x974 = x973==0
val x975 = x971 && x974
val x996 = {
def x996thenb(): Unit = {
x957 = x977
()
}
def x996elseb(): Unit = {
val x980 = x881.binary_gradients
val x981 = x980(x968)
val x982 = x970 & x981
val x983 = x982 > 0
val x994 = {
def x994thenb(): Unit = {
x957 = x977
()
}
def x994elseb(): Unit = {
x961 = x987
val x992 = {
def x992thenb(): Unit = {
x963 = false
()
}
if (x989) {
x992thenb()
}
}
x992
}
if (x983) {
x994thenb()
} else { 
x994elseb()
}
}
x994
}
if (x975) {
x996thenb()
} else { 
x996elseb()
}
}
val x997 = x962 += 1
()
}
val x1000 = !x966
val x1001 = x976 / x950
val x1002 = x1001.asInstanceOf[Float]
val x1003 = {
def x1003thenb(): Float = {
0.819999f
}
def x1003elseb(): Float = {
x1002
}
if (x1000) {
x1003thenb()
} else { 
x1003elseb()
}
}
x1003
}
if (x956) {
x1005thenb()
} else { 
x1005elseb()
}
}
x1005
}
if (x951) {
x1007thenb()
} else { 
x1007elseb()
}
}
x1007
}
if (x947) {
x1009thenb()
} else { 
x1009elseb()
}
}
val x1010 = x1009 > 0.82f
val x1011 = x944.rect
val x1013 = x1011.width
val x1014 = x1013 / 2
val x1015 = x1012 - x1014
val x1016 = x1015.asInstanceOf[Int]
val x1018 = x1011.height
val x1019 = x1018 / 2
val x1020 = x1017 - x1019
val x1021 = x1020.asInstanceOf[Int]
val x1029 = {
def x1029thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1022 = new generated.scala.Rect(x1016,x1021,x1013,x1018)
val x1023 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1024 = new generated.scala.BiGGDetection(x856,x1009,x1022,null,x943,x875,x871,x944,x881)
val x1025 = x1023(0) = x1024
x1023
}
def x1029elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1027 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1027
}
if (x1010) {
x1029thenb()
} else { 
x1029elseb()
}
}
x1029
}
var mapReduceIdx = 1
while (mapReduceIdx < x942.size) { // begin mapReduce loop x1060
val x943 = x942.dcApply(mapReduceIdx)
val x1032 = {
val x946 = x881.radius
val x944 = x857(x943)
val x945 = x944.radius
val x947 = x945 != x946
val x948 = x944.match_list
val x949 = x948.length
val x950 = x949.asInstanceOf[Float]
val x951 = x950==0.0
val x958 = x950 * 0.18f
val x959 = x958 + 0.5f
val x960 = x959.asInstanceOf[Int]
val x969 = x944.binary_gradients
val x1009 = {
def x1009thenb(): Float = {
-1.0f
}
def x1009elseb(): Float = {
val x1007 = {
def x1007thenb(): Float = {
-1.0f
}
def x1007elseb(): Float = {
val x952 = x881.match_list
val x953 = x952.length
val x954 = x953.asInstanceOf[Float]
val x955 = x954 / x950
val x956 = x955 < 0.82f
val x1005 = {
def x1005thenb(): Float = {
x955
}
def x1005elseb(): Float = {
var x957: Float = 0.0f
var x961: Int = x960
var x962: Int = 0
var x963: Boolean = true
val x964 = x962
val x965 = x964 < x949
val x966 = x963
val x967 = x965 && x966
val x968 = x948(x964)
val x970 = x969(x968)
val x971 = x970==0
val x976 = x957
val x977 = x976 + 1.0f
val x986 = x961
val x987 = x986 - 1
val x989 = x986 <= 0
val x999 = while ({x967}) {
val x972 = x881.binary_gradients
val x973 = x972(x968)
val x974 = x973==0
val x975 = x971 && x974
val x996 = {
def x996thenb(): Unit = {
x957 = x977
()
}
def x996elseb(): Unit = {
val x980 = x881.binary_gradients
val x981 = x980(x968)
val x982 = x970 & x981
val x983 = x982 > 0
val x994 = {
def x994thenb(): Unit = {
x957 = x977
()
}
def x994elseb(): Unit = {
x961 = x987
val x992 = {
def x992thenb(): Unit = {
x963 = false
()
}
if (x989) {
x992thenb()
}
}
x992
}
if (x983) {
x994thenb()
} else { 
x994elseb()
}
}
x994
}
if (x975) {
x996thenb()
} else { 
x996elseb()
}
}
val x997 = x962 += 1
()
}
val x1000 = !x966
val x1001 = x976 / x950
val x1002 = x1001.asInstanceOf[Float]
val x1003 = {
def x1003thenb(): Float = {
0.819999f
}
def x1003elseb(): Float = {
x1002
}
if (x1000) {
x1003thenb()
} else { 
x1003elseb()
}
}
x1003
}
if (x956) {
x1005thenb()
} else { 
x1005elseb()
}
}
x1005
}
if (x951) {
x1007thenb()
} else { 
x1007elseb()
}
}
x1007
}
if (x947) {
x1009thenb()
} else { 
x1009elseb()
}
}
val x1010 = x1009 > 0.82f
val x1011 = x944.rect
val x1013 = x1011.width
val x1014 = x1013 / 2
val x1015 = x1012 - x1014
val x1016 = x1015.asInstanceOf[Int]
val x1018 = x1011.height
val x1019 = x1018 / 2
val x1020 = x1017 - x1019
val x1021 = x1020.asInstanceOf[Int]
val x1029 = {
def x1029thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1022 = new generated.scala.Rect(x1016,x1021,x1013,x1018)
val x1023 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1024 = new generated.scala.BiGGDetection(x856,x1009,x1022,null,x943,x875,x871,x944,x881)
val x1025 = x1023(0) = x1024
x1023
}
def x1029elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1027 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1027
}
if (x1010) {
x1029thenb()
} else { 
x1029elseb()
}
}
x1029
}
x1031 = {
val x1033 = x1031.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1034 = x1032.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1035 = x1031.length
val x1036 = x1032.length
val x1037 = x1035 + x1036
val x1038 = x1031.isRow
val x1059 = { 
val x1057 = {
def x1057thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1032
}
def x1057elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1055 = {
def x1055thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1031
}
def x1055elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1039 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1037,x1038)
var x1041 : Int = 0
val x1045 = while (x1041 < x1035) {
val x1042 = x1031(x1041)
val x1043 = x1039(x1041) = x1042
x1043
x1041 = x1041 + 1
}
var x1047 : Int = 0
val x1052 = while (x1047 < x1036) {
val x1048 = x1047 + x1035
val x1049 = x1032(x1047)
val x1050 = x1039(x1048) = x1049
x1050
x1047 = x1047 + 1
}
val x1053 = x1039// unsafe immutable
x1053
}
if (x1034) {
x1055thenb()
} else { 
x1055elseb()
}
}
x1055
}
if (x1033) {
x1057thenb()
} else { 
x1057elseb()
}
}
x1057
}
x1059
}
mapReduceIdx += 1
} // end mapReduce loop x1060
x1031
}
val x1060 = x1060_block
x1060
}
x1062 = {
val x1064 = x1062.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1065 = x1063.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1066 = x1062.length
val x1067 = x1063.length
val x1068 = x1066 + x1067
val x1069 = x1062.isRow
val x1090 = { 
val x1088 = {
def x1088thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1063
}
def x1088elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1086 = {
def x1086thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1062
}
def x1086elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1070 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1068,x1069)
var x1072 : Int = 0
val x1076 = while (x1072 < x1066) {
val x1073 = x1062(x1072)
val x1074 = x1070(x1072) = x1073
x1074
x1072 = x1072 + 1
}
var x1078 : Int = 0
val x1083 = while (x1078 < x1067) {
val x1079 = x1078 + x1066
val x1080 = x1063(x1078)
val x1081 = x1070(x1079) = x1080
x1081
x1078 = x1078 + 1
}
val x1084 = x1070// unsafe immutable
x1084
}
if (x1065) {
x1086thenb()
} else { 
x1086elseb()
}
}
x1086
}
if (x1064) {
x1088thenb()
} else { 
x1088elseb()
}
}
x1088
}
x1090
}
mapReduceIdx += 1
} // end mapReduce loop x1091
x1062
}
val x1091 = x1091_block
x1091
}
x1093 = {
val x1095 = x1093.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1096 = x1094.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1097 = x1093.length
val x1098 = x1094.length
val x1099 = x1097 + x1098
val x1100 = x1093.isRow
val x1121 = { 
val x1119 = {
def x1119thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1094
}
def x1119elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1117 = {
def x1117thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1093
}
def x1117elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1101 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1099,x1100)
var x1103 : Int = 0
val x1107 = while (x1103 < x1097) {
val x1104 = x1093(x1103)
val x1105 = x1101(x1103) = x1104
x1105
x1103 = x1103 + 1
}
var x1109 : Int = 0
val x1114 = while (x1109 < x1098) {
val x1110 = x1109 + x1097
val x1111 = x1094(x1109)
val x1112 = x1101(x1110) = x1111
x1112
x1109 = x1109 + 1
}
val x1115 = x1101// unsafe immutable
x1115
}
if (x1096) {
x1117thenb()
} else { 
x1117elseb()
}
}
x1117
}
if (x1095) {
x1119thenb()
} else { 
x1119elseb()
}
}
x1119
}
x1121
}
mapReduceIdx += 1
} // end mapReduce loop x1122
x1093
}
val x1122 = x1122_block
val x1123 = x1122.length
val x1124 = "Detections: "+x1123
val x1125 = println(x1124)
x1122
}
x1127 = {
val x1129 = x1127.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1130 = x1128.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1131 = x1127.length
val x1132 = x1128.length
val x1133 = x1131 + x1132
val x1134 = x1127.isRow
val x1155 = { 
val x1153 = {
def x1153thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1128
}
def x1153elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1151 = {
def x1151thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1127
}
def x1151elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1135 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1133,x1134)
var x1137 : Int = 0
val x1141 = while (x1137 < x1131) {
val x1138 = x1127(x1137)
val x1139 = x1135(x1137) = x1138
x1139
x1137 = x1137 + 1
}
var x1143 : Int = 0
val x1148 = while (x1143 < x1132) {
val x1144 = x1143 + x1131
val x1145 = x1128(x1143)
val x1146 = x1135(x1144) = x1145
x1146
x1143 = x1143 + 1
}
val x1149 = x1135// unsafe immutable
x1149
}
if (x1130) {
x1151thenb()
} else { 
x1151elseb()
}
}
x1151
}
if (x1129) {
x1153thenb()
} else { 
x1153elseb()
}
}
x1153
}
x1155
}
mapReduceIdx += 1
} // end mapReduce loop x1156
x1127
}
val x1156 = x1156_block
val x1157 = x1156.length
var x1158: Int = x1157
val x1159 = x1158
val x1160 = "Detections before NMS: "+x1159
val x1161 = println(x1160)
var x1162: Int = 0
val x1163 = x1162
val x1164 = x1159 - 1
val x1165 = x1163 < x1164
val x1166 = x1163 + 1
val x1234 = x1163 - 1
val x1246 = while ({x1165}) {
var x1167: Int = x1166
var x1168: Boolean = false
val x1169 = x1167
val x1170 = x1169 < x1159
val x1171 = x1168
val x1172 = x1171==false
val x1173 = x1170 && x1172
val x1227 = x1169 - 1
val x1243 = while ({x1173}) {
val x1174 = x1156(x1163)
val x1175 = x1174.roi
val x1176 = x1156(x1169)
val x1177 = x1176.roi
val x1178 = x1175.x
val x1179 = x1177.x
val x1180 = x1177.width
val x1183 = x1175.width
val x1187 = x1175.y
val x1188 = x1175.height
val x1190 = x1177.y
val x1193 = x1177.height
val x1181 = x1179 + x1180
val x1182 = x1178 < x1181
val x1184 = x1178 + x1183
val x1185 = x1184 > x1179
val x1186 = x1182 && x1185
val x1189 = x1187 + x1188
val x1191 = x1189 > x1190
val x1192 = x1186 && x1191
val x1194 = x1190 + x1193
val x1195 = x1187 < x1194
val x1196 = x1192 && x1195
val x1201 = x1178 > x1179
val x1203 = x1187 > x1190
val x1208 = x1189 < x1194
val x1209 = {
def x1209thenb(): Int = {
x1189
}
def x1209elseb(): Int = {
x1194
}
if (x1208) {
x1209thenb()
} else { 
x1209elseb()
}
}
val x1205 = x1184 < x1181
val x1206 = {
def x1206thenb(): Int = {
x1184
}
def x1206elseb(): Int = {
x1181
}
if (x1205) {
x1206thenb()
} else { 
x1206elseb()
}
}
val x1197 = x1193 * x1180
val x1198 = x1183 * x1188
val x1199 = x1197 + x1198
val x1200 = x1199
val x1215 = x1200 + 1.0E-6f
val x1218 = {
def x1218thenb(): Float = {
val x1202 = {
def x1202thenb(): Int = {
x1178
}
def x1202elseb(): Int = {
x1179
}
if (x1201) {
x1202thenb()
} else { 
x1202elseb()
}
}
val x1204 = {
def x1204thenb(): Int = {
x1187
}
def x1204elseb(): Int = {
x1190
}
if (x1203) {
x1204thenb()
} else { 
x1204elseb()
}
}
val x1210 = x1209 - x1204
val x1211 = x1210
val x1212 = 2.0f * x1211
val x1207 = x1206 - x1202
val x1213 = x1207
val x1214 = x1212 * x1213
val x1216 = x1214 / x1215
x1216
}
def x1218elseb(): Float = {
0.0f
}
if (x1196) {
x1218thenb()
} else { 
x1218elseb()
}
}
val x1219 = x1218 > 0.6f
val x1240 = {
def x1240thenb(): Unit = {
val x1220 = x1174.score
val x1221 = x1176.score
val x1222 = x1220 >= x1221
val x1238 = {
def x1238thenb(): Unit = {
val x1223 = x1156(x1164)
val x1224 = x1156(x1164) = x1176
val x1225 = x1156(x1169) = x1223
x1158 = x1164
x1167 = x1227
()
}
def x1238elseb(): Unit = {
val x1230 = x1156(x1164)
val x1231 = x1156(x1164) = x1174
val x1232 = x1156(x1163) = x1230
x1158 = x1164
x1162 = x1234
x1168 = true
()
}
if (x1222) {
x1238thenb()
} else { 
x1238elseb()
}
}
x1238
}
if (x1219) {
x1240thenb()
}
}
val x1241 = x1167 += 1
()
}
val x1244 = x1162 += 1
()
}
val x1247 = x1159 - 0
val x1259 = { 
val x1248 = x1156.isRow
val x1249 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1247,x1248)
var x1251 : Int = 0
val x1256 = while (x1251 < x1159) {
val x1253 = x1156(x1251)
val x1252 = x1251 - 0
val x1254 = x1249(x1252) = x1253
x1254
x1251 = x1251 + 1
}
val x1257 = x1249// unsafe immutable
x1257
}
val x1260 = x1259.length
val x1261 = "Total detections: "+x1260
val x1262 = println(x1261)
val x1263 = x225 += 1
()
}
val x1266 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
