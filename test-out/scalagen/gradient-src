/*****************************************
  Emitting Generated Code                  
*******************************************/
class gradientRunner extends ((Array[java.lang.String])=>(Unit)) {
def apply(x0:Array[java.lang.String]): Unit = {
val x1 = x0(0)
val x53 = { 
val x2 = new java.io.FileReader(x1)
val x3 = new java.io.BufferedReader(x2)
val x4 = x3.readLine()
var x5: java.lang.String = x4
val x6 = x5
val x7 = x6.trim()
x5 = x7
val x9 = x5
val x10 = x9.split("\\s+")
var x11: Array[java.lang.String] = x10
val x12 = x11
val x13 = x12.length
val x14 = new generated.scala.IntMatrixImpl(0,x13)
val x49 = while ({val x15 = x5
val x16 = x15 != null
x16}) {
val x18 = x11
val x19 = x18.length
val x20 = new generated.scala.IntVectorImpl(x19,true)
var x21: Int = 0
val x22 = x21
val x33 = while ({val x23 = x11
val x24 = x23.length
val x25 = x22 < x24
x25}) {
val x27 = x11
val x28 = x27(x22)
val x29 = java.lang.Integer.parseInt(x28)
val x30 = x20(x22) = x29
val x31 = x21 += 1
()
}
val x34 = x20.cloneL
val x35 = x14.numRows
val x36 = x14.insertRow(x35,x34)
val x37 = x3.readLine()
x5 = x37
val x39 = x5
val x40 = x39 != null
val x47 = {
def x47thenb(): Unit = {
val x41 = x39.trim()
x5 = x41
val x43 = x5
val x44 = x43.split("\\s+")
x11 = x44
()
}
if (x40) {
x47thenb()
}
}
x47
}
val x50 = x3.close()
val x51 = new generated.scala.GrayscaleImageImpl(x14)
x51
}
val x54 = x0(1)
val x220 = { 
val x55 = new generated.scala.VectorImpl[java.lang.String](0,true)
val x56 = new java.io.File(x54)
val x57 = x56.getCanonicalFile()
val x58 = x57.listFiles()
val x64=x58.foreach{
x59 => 
val x61 = x55.length
val x60 = x59.getPath()
val x62 = x55.insert(x61, x60)
x62
}
def x218_block = {
val x214 = x55.length
val x215 = x55.isRow
val x216 = new generated.scala.VectorImpl[scala.Tuple2[java.lang.String, generated.scala.Vector[generated.scala.BinarizedGradientTemplate]]](x214,x215)
var mapIdx = 0
while (mapIdx < x55.size) { // begin map loop x218
val x65 = x55.dcApply(mapIdx)
x216.dcUpdate(mapIdx,  {
val x66 = "Loading model: "+x65
val x67 = println(x66)
val x68 = new generated.scala.VectorImpl[generated.scala.BinarizedGradientTemplate](0,true)
val x69 = new java.io.FileReader(x65)
val x70 = new java.io.BufferedReader(x69)
val x71 = x70.readLine()
val x72 = x71 != "bigg_object:"
val x75 = {
def x75thenb(): Nothing = {
val x73 = error("Illegal data format")
x73
}
if (x72) {
x75thenb()
}
}
val x76 = x70.readLine()
val x77 = x70.readLine()
val x78 = x77.trim()
val x79 = x78.split(" ")
val x80 = x79(0)
val x81 = x80 != "obj_name/obj_num/num_objs:"
val x84 = {
def x84thenb(): Nothing = {
val x82 = error("Illegal data format")
x82
}
if (x81) {
x84thenb()
}
}
var x89: Int = 0
val x87 = x79(3)
val x88 = java.lang.Integer.parseInt(x87)
val x90 = x89
val x91 = x90 < x88
val x211 = while ({x91}) {
val x92 = x70.readLine()
val x93 = x92.trim()
val x94 = x93 != "====OneBiGG====:"
val x97 = {
def x97thenb(): Nothing = {
val x95 = error("Illegal data format")
x95
}
if (x94) {
x97thenb()
}
}
val x98 = x70.readLine()
val x99 = x98.trim()
val x100 = x99.split(" ")
var x101: Array[java.lang.String] = x100
val x102 = x101
val x103 = x102(0)
val x104 = x103 != "view/radius/reduction:"
val x107 = {
def x107thenb(): Nothing = {
val x105 = error("Illegal data format")
x105
}
if (x104) {
x107thenb()
}
}
val x108 = x101
val x115 = x70.readLine()
val x116 = x115.trim()
val x117 = x116.split(" ")
x101 = x117
val x119 = x101
val x120 = x119(0)
val x121 = x120 != "Gradients:"
val x124 = {
def x124thenb(): Nothing = {
val x122 = error("Illegal data format")
x122
}
if (x121) {
x124thenb()
}
}
val x125 = x101
val x126 = x125(1)
val x127 = java.lang.Integer.parseInt(x126)
val x128 = new generated.scala.IntVectorImpl(x127,true)
val x129 = x70.readLine()
var x132: Int = 0
val x133 = x132
val x134 = x133 < x127
val x130 = x129.trim()
val x131 = x130.split(" ")
val x135 = x131(x133)
val x136 = java.lang.Integer.parseInt(x135)
val x140 = while ({x134}) {
val x137 = x128(x133) = x136
val x138 = x132 += 1
()
}
val x141 = x70.readLine()
val x142 = x141.trim()
val x143 = x142.split(" ")
x101 = x143
val x145 = x101
val x146 = x145(0)
val x147 = x146 != "Match_list:"
val x150 = {
def x150thenb(): Nothing = {
val x148 = error("Illegal data format")
x148
}
if (x147) {
x150thenb()
}
}
val x151 = x101
val x154 = new generated.scala.IndexVectorSeqImpl(0)
val x155 = x70.readLine()
x132 = 0
val x152 = x151(1)
val x153 = java.lang.Integer.parseInt(x152)
val x159 = x133 < x153
val x156 = x155.trim()
val x157 = x156.split(" ")
val x160 = x157(x133)
val x161 = java.lang.Integer.parseInt(x160)
val x166 = while ({x159}) {
val x162 = x154.length
val x163 = x154.insert(x162, x161)
val x164 = x132 += 1
()
}
val x167 = x70.readLine()
val x168 = x167.trim()
val x169 = x168.split(" ")
x101 = x169
val x171 = x101
val x172 = x171(0)
val x173 = x172 != "Occlusions:"
val x176 = {
def x176thenb(): Nothing = {
val x174 = error("Illegal data format")
x174
}
if (x173) {
x176thenb()
}
}
val x177 = x101
val x180 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](0,true)
val x181 = x70.readLine()
val x178 = x177(1)
val x179 = java.lang.Integer.parseInt(x178)
val x184 = x179 != 0
val x187 = {
def x187thenb(): Nothing = {
val x185 = error("Occlusions not supported.")
x185
}
if (x184) {
x187thenb()
}
}
val x188 = x70.readLine()
val x189 = x188.trim()
val x190 = x189 != "BoundingBox:"
val x193 = {
def x193thenb(): Nothing = {
val x191 = error("Illegal data format")
x191
}
if (x190) {
x193thenb()
}
}
val x194 = x70.readLine()
val x195 = x194.trim()
val x196 = x195.split(" ")
val x197 = x196(0)
val x198 = java.lang.Integer.parseInt(x197)
val x199 = x196(1)
val x200 = java.lang.Integer.parseInt(x199)
val x201 = x196(2)
val x202 = java.lang.Integer.parseInt(x201)
val x203 = x196(3)
val x204 = java.lang.Integer.parseInt(x203)
val x205 = new generated.scala.Rect(x198,x200,x202,x204)
val x111 = x108(2)
val x112 = java.lang.Integer.parseInt(x111)
val x206 = new generated.scala.BinarizedGradientTemplate(x112,x205,null,0,x128,x154,x180,null,null)
val x207 = x68.length
val x208 = x68.insert(x207, x206)
val x209 = x89 += 1
()
}
val x85 = x79(1)
val x212 = (x85,x68)
x212
})
mapIdx += 1
} // end map loop x218
x216
}
val x218 = x218_block
x218
}
val x221 = Seq()
val x222 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
var x223: Int = 0
val x224 = x223
val x225 = x224 < 3
val x261 = x53.numRows
val x262 = new generated.scala.IndexVectorRangeImpl(0,x261)
val x263 = x53.numCols
val x264 = new generated.scala.IndexVectorRangeImpl(0,x263)
val x265 = new generated.scala.IndexVector2Impl(x262,x264)
val x266 = x265.rowInd
val x267 = x266.length
val x271 = x265.colInd
val x328 = x271.length
val x329 = x271.isRow
val x510 = Math.Pi
val x562 = 2 / 2
val x1241 = while ({x225}) {
val x226 = new generated.scala.IntMatrixImpl(3,3)
val x227 = x226(0, 0) = -3
val x228 = x226(0, 1) = -10
val x229 = x226(0, 2) = -3
val x230 = x226(2, 0) = 3
val x231 = x226(2, 1) = 10
val x232 = x226(2, 2) = 3
val x254 = { 
val x233 = x226.numCols
val x234 = x226.numRows
val x235 = new generated.scala.IntMatrixImpl(x233,x234)
val x236 = x235.numRows
var x238 : Int = 0
val x252 = while (x238 < x236) {
val x239 = x235.numCols
var x241 : Int = 0
val x250 = while (x241 < x239) {
val x247 = { 
val x242 = x226.numCols
val x243 = x241 * x242
val x244 = x243 + x238
val x245 = x226.dcApply(x244)
x245
}
val x248 = x235(x238, x241) = x247
x248
x241 = x241 + 1
}
x250
x238 = x238 + 1
}
x235
}
val x255 = x254.numRows
val x256 = x254.numCols
val x257 = x255 - 1
val x258 = x257 / 2
val x274 = x261 - x258
val x259 = x256 - 1
val x260 = x259 / 2
val x279 = x263 - x260
def x333_block = {
val x268 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](x267,true)
var mapIdx = 0
while (mapIdx < x266.size) { // begin map loop x333
val x270 = x266.dcApply(mapIdx)
x268.dcUpdate(mapIdx,  {
val x273 = x270 >= x258
val x275 = x270 < x274
val x276 = x273 && x275
def x332_block = {
val x330 = new generated.scala.IntVectorImpl(x328,x329)
var mapIdx = 0
while (mapIdx < x271.size) { // begin map loop x332
val x272 = x271.dcApply(mapIdx)
x330.dcUpdate(mapIdx,  {
val x277 = x272 >= x260
val x278 = x276 && x277
val x280 = x272 < x279
val x281 = x278 && x280
val x326 = {
def x326thenb(): Int = {
val x282 = x270 - x258
val x283 = x270 + x258
val x284 = x283 + 1
val x288 = x284 - x282
val x285 = x272 - x260
val x286 = x272 + x260
val x287 = x286 + 1
val x289 = x287 - x285
val x311 = { 
val x290 = new generated.scala.IntMatrixImpl(x288,x289)
var x291: Int = x282
val x292 = x291
val x293 = x292 < x284
val x297 = x292 - x282
val x299 = x292 * x263
val x309 = while ({x293}) {
var x294: Int = x285
val x295 = x294
val x296 = x295 < x287
val x298 = x295 - x285
val x300 = x299 + x295
val x301 = x53.dcApply(x300)
val x302 = { 
x301
}
val x306 = while ({x296}) {
val x303 = x290(x297, x298) = x302
val x304 = x294 += 1
()
}
val x307 = x291 += 1
()
}
x290
}
val x312 = x311.numRows
val x313 = x311.numCols
def x319_block = {
val x314 = new generated.scala.IntMatrixImpl(x312,x313)
var zipIdx = 0
while (zipIdx < x311.size) { // begin zip loop x319
val x316 = x311.dcApply(zipIdx)
val x317 = x254.dcApply(zipIdx)
x314.dcUpdate(zipIdx,  {
val x318 = x316 * x317
x318
})
zipIdx += 1
} // end zip loop x319
x314
}
val x319 = x319_block
def x323_block = {
var x320 = x319.dcApply(0)
var reduceIdx = 1
while (reduceIdx < x319.size) { // begin reduce loop x323
val x321 = x319.dcApply(reduceIdx)
x320 = {
val x322 = x320 + x321
x322
}
reduceIdx += 1
} // end reduce loop x323
x320
}
val x323 = x323_block
x323
}
def x326elseb(): Int = {
val x325 = 0.asInstanceOf[Int]
x325
}
if (x281) {
x326thenb()
} else { 
x326elseb()
}
}
x326
})
mapIdx += 1
} // end map loop x332
x330
}
val x332 = x332_block
x332
})
mapIdx += 1
} // end map loop x333
x268
}
val x333 = x333_block
val x334 = x333.length
val x335 = x334==0
val x369 = { 
val x367 = {
def x367thenb(): generated.scala.Matrix[Int] = {
val x336 = new generated.scala.IntMatrixImpl(0,0)
x336
}
def x367elseb(): generated.scala.Matrix[Int] = {
val x338 = x333(0)
val x339 = x338.isRow
val x365 = {
def x365thenb(): generated.scala.Matrix[Int] = {
val x340 = x338.length
val x341 = new generated.scala.IntMatrixImpl(x334,x340)
var x343 : Int = 0
val x352 = while (x343 < x334) {
val x346 = x333(x343)
var x345 : Int = 0
val x350 = while (x345 < x340) {
val x347 = x346(x345)
val x348 = x341(x343, x345) = x347
x348
x345 = x345 + 1
}
x350
x343 = x343 + 1
}
x341
}
def x365elseb(): generated.scala.Matrix[Int] = {
val x340 = x338.length
val x354 = new generated.scala.IntMatrixImpl(x340,x334)
var x355 : Int = 0
val x363 = while (x355 < x334) {
val x357 = x333(x355)
var x356 : Int = 0
val x361 = while (x356 < x340) {
val x358 = x357(x356)
val x359 = x354(x356, x355) = x358
x359
x356 = x356 + 1
}
x361
x355 = x355 + 1
}
x354
}
if (x339) {
x365thenb()
} else { 
x365elseb()
}
}
x365
}
if (x335) {
x367thenb()
} else { 
x367elseb()
}
}
x367
}
val x370 = new generated.scala.IntImageImpl(x369)
val x371 = x226.numRows
val x372 = x226.numCols
val x373 = x371 - 1
val x374 = x373 / 2
val x382 = x261 - x374
val x375 = x372 - 1
val x376 = x375 / 2
val x387 = x263 - x376
def x438_block = {
val x377 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](x267,true)
var mapIdx = 0
while (mapIdx < x266.size) { // begin map loop x438
val x379 = x266.dcApply(mapIdx)
x377.dcUpdate(mapIdx,  {
val x381 = x379 >= x374
val x383 = x379 < x382
val x384 = x381 && x383
def x437_block = {
val x435 = new generated.scala.IntVectorImpl(x328,x329)
var mapIdx = 0
while (mapIdx < x271.size) { // begin map loop x437
val x380 = x271.dcApply(mapIdx)
x435.dcUpdate(mapIdx,  {
val x385 = x380 >= x376
val x386 = x384 && x385
val x388 = x380 < x387
val x389 = x386 && x388
val x433 = {
def x433thenb(): Int = {
val x390 = x379 - x374
val x391 = x379 + x374
val x392 = x391 + 1
val x396 = x392 - x390
val x393 = x380 - x376
val x394 = x380 + x376
val x395 = x394 + 1
val x397 = x395 - x393
val x419 = { 
val x398 = new generated.scala.IntMatrixImpl(x396,x397)
var x399: Int = x390
val x400 = x399
val x401 = x400 < x392
val x405 = x400 - x390
val x407 = x400 * x263
val x417 = while ({x401}) {
var x402: Int = x393
val x403 = x402
val x404 = x403 < x395
val x406 = x403 - x393
val x408 = x407 + x403
val x409 = x53.dcApply(x408)
val x410 = { 
x409
}
val x414 = while ({x404}) {
val x411 = x398(x405, x406) = x410
val x412 = x402 += 1
()
}
val x415 = x399 += 1
()
}
x398
}
val x420 = x419.numRows
val x421 = x419.numCols
def x427_block = {
val x422 = new generated.scala.IntMatrixImpl(x420,x421)
var zipIdx = 0
while (zipIdx < x419.size) { // begin zip loop x427
val x424 = x419.dcApply(zipIdx)
val x425 = x226.dcApply(zipIdx)
x422.dcUpdate(zipIdx,  {
val x426 = x424 * x425
x426
})
zipIdx += 1
} // end zip loop x427
x422
}
val x427 = x427_block
def x431_block = {
var x428 = x427.dcApply(0)
var reduceIdx = 1
while (reduceIdx < x427.size) { // begin reduce loop x431
val x429 = x427.dcApply(reduceIdx)
x428 = {
val x430 = x428 + x429
x430
}
reduceIdx += 1
} // end reduce loop x431
x428
}
val x431 = x431_block
x431
}
def x433elseb(): Int = {
val x325 = 0.asInstanceOf[Int]
x325
}
if (x389) {
x433thenb()
} else { 
x433elseb()
}
}
x433
})
mapIdx += 1
} // end map loop x437
x435
}
val x437 = x437_block
x437
})
mapIdx += 1
} // end map loop x438
x377
}
val x438 = x438_block
val x439 = x438.length
val x440 = x439==0
val x474 = { 
val x472 = {
def x472thenb(): generated.scala.Matrix[Int] = {
val x441 = new generated.scala.IntMatrixImpl(0,0)
x441
}
def x472elseb(): generated.scala.Matrix[Int] = {
val x443 = x438(0)
val x444 = x443.isRow
val x470 = {
def x470thenb(): generated.scala.Matrix[Int] = {
val x445 = x443.length
val x446 = new generated.scala.IntMatrixImpl(x439,x445)
var x448 : Int = 0
val x457 = while (x448 < x439) {
val x451 = x438(x448)
var x450 : Int = 0
val x455 = while (x450 < x445) {
val x452 = x451(x450)
val x453 = x446(x448, x450) = x452
x453
x450 = x450 + 1
}
x455
x448 = x448 + 1
}
x446
}
def x470elseb(): generated.scala.Matrix[Int] = {
val x445 = x443.length
val x459 = new generated.scala.IntMatrixImpl(x445,x439)
var x460 : Int = 0
val x468 = while (x460 < x439) {
val x462 = x438(x460)
var x461 : Int = 0
val x466 = while (x461 < x445) {
val x463 = x462(x461)
val x464 = x459(x461, x460) = x463
x464
x461 = x461 + 1
}
x466
x460 = x460 + 1
}
x459
}
if (x444) {
x470thenb()
} else { 
x470elseb()
}
}
x470
}
if (x440) {
x472thenb()
} else { 
x472elseb()
}
}
x472
}
val x475 = new generated.scala.IntImageImpl(x474)
val x478 = x370.numRows
val x479 = x370.numCols
def x482_block = {
val x480 = new generated.scala.FloatMatrixImpl(x478,x479)
var mapIdx = 0
while (mapIdx < x370.size) { // begin map loop x482
val x476 = x370.dcApply(mapIdx)
x480.dcUpdate(mapIdx,  {
val x477 = x476
x477
})
mapIdx += 1
} // end map loop x482
x480
}
val x482 = x482_block
val x485 = x475.numRows
val x486 = x475.numCols
def x489_block = {
val x487 = new generated.scala.FloatMatrixImpl(x485,x486)
var mapIdx = 0
while (mapIdx < x475.size) { // begin map loop x489
val x483 = x475.dcApply(mapIdx)
x487.dcUpdate(mapIdx,  {
val x484 = x483
x484
})
mapIdx += 1
} // end map loop x489
x487
}
val x489 = x489_block
val x490 = x482.numRows
val x491 = x482.numCols
def x513_block = {
val x502 = new generated.scala.FloatMatrixImpl(x490,x491)
var zipIdx = 0
while (zipIdx < x482.size) { // begin zip loop x513
val x504 = x482.dcApply(zipIdx)
val x505 = x489.dcApply(zipIdx)
x502.dcUpdate(zipIdx,  {
val x506 = x505
val x507 = x504
val x508 = Math.atan2(x506, x507)
val x509 = x508 * 180.0
val x511 = x509 / x510
val x512 = x511.asInstanceOf[Float]
x512
})
zipIdx += 1
} // end zip loop x513
x502
}
val x513 = x513_block
def x518_block = {
var mapIdx = 0
while (mapIdx < x513.size) { // begin map loop x518
val x514 = x513.dcApply(mapIdx)
x513.dcUpdate(mapIdx,  {
val x515 = x514 < 0.0f
val x517 = {
def x517thenb(): Float = {
val x516 = x514 + 360.0f
x516
}
def x517elseb(): Float = {
x514
}
if (x515) {
x517thenb()
} else { 
x517elseb()
}
}
x517
})
mapIdx += 1
} // end map loop x518
x513
}
val x518 = x518_block
def x519_block = {
val x492 = new generated.scala.FloatMatrixImpl(x490,x491)
var zipIdx = 0
while (zipIdx < x482.size) { // begin zip loop x519
val x494 = x482.dcApply(zipIdx)
val x495 = x489.dcApply(zipIdx)
x492.dcUpdate(zipIdx,  {
val x496 = x494 * x494
val x497 = x495 * x495
val x498 = x496 + x497
val x499 = x498
val x500 = Math.sqrt(x499)
val x501 = x500.asInstanceOf[Float]
x501
})
zipIdx += 1
} // end zip loop x519
x492
}
val x519 = x519_block
val x540 = x519.numRows
val x541 = x519.numCols
def x544_block = {
val x542 = new generated.scala.IntMatrixImpl(x540,x541)
var zipIdx = 0
while (zipIdx < x519.size) { // begin zip loop x544
val x521 = x519.dcApply(zipIdx)
val x522 = x518.dcApply(zipIdx)
x542.dcUpdate(zipIdx,  {
val x523 = x521 >= 200.0f
val x538 = {
def x538thenb(): Int = {
var x524: Float = x522
val x525 = x524
val x526 = x525 >= 180.0f
val x530 = {
def x530thenb(): Unit = {
val x527 = x525 - 180.0f
x524 = x527
()
}
if (x526) {
x530thenb()
}
}
val x531 = x525.asInstanceOf[Double]
val x532 = x531 / 22.5
val x533 = x532.asInstanceOf[Int]
val x534 = x533
val x535 = Math.pow(2.0,x534)
val x536 = x535.asInstanceOf[Int]
x536
}
def x538elseb(): Int = {
0
}
if (x523) {
x538thenb()
} else { 
x538elseb()
}
}
x538
})
zipIdx += 1
} // end zip loop x544
x542
}
val x544 = x544_block
val x545 = new generated.scala.GrayscaleImageImpl(x544)
val x546 = x545.getRow(0)
def x548_block = {
var mapIdx = 0
while (mapIdx < x546.size) { // begin map loop x548
val x547 = x546.dcApply(mapIdx)
x546.dcUpdate(mapIdx,  {
0
})
mapIdx += 1
} // end map loop x548
x546
}
val x548 = x548_block
val x549 = x545.numRows
val x550 = x549 - 1
val x551 = x545.getRow(x550)
def x553_block = {
var mapIdx = 0
while (mapIdx < x551.size) { // begin map loop x553
val x552 = x551.dcApply(mapIdx)
x551.dcUpdate(mapIdx,  {
0
})
mapIdx += 1
} // end map loop x553
x551
}
val x553 = x553_block
val x554 = x545.getCol(0)
def x556_block = {
var mapIdx = 0
while (mapIdx < x554.size) { // begin map loop x556
val x555 = x554.dcApply(mapIdx)
x554.dcUpdate(mapIdx,  {
0
})
mapIdx += 1
} // end map loop x556
x554
}
val x556 = x556_block
val x557 = x545.numCols
val x558 = x557 - 1
val x559 = x545.getCol(x558)
def x561_block = {
var mapIdx = 0
while (mapIdx < x559.size) { // begin map loop x561
val x560 = x559.dcApply(mapIdx)
x559.dcUpdate(mapIdx,  {
0
})
mapIdx += 1
} // end map loop x561
x559
}
val x561 = x561_block
val x563 = new generated.scala.IndexVectorRangeImpl(0,x549)
val x564 = new generated.scala.IndexVectorRangeImpl(0,x557)
val x565 = new generated.scala.IndexVector2Impl(x563,x564)
val x566 = x565.rowInd
val x567 = x566.length
val x571 = x565.colInd
val x574 = x549 - x562
val x579 = x557 - x562
val x658 = x571.length
val x659 = x571.isRow
def x663_block = {
val x568 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](x567,true)
var mapIdx = 0
while (mapIdx < x566.size) { // begin map loop x663
val x570 = x566.dcApply(mapIdx)
x568.dcUpdate(mapIdx,  {
val x573 = x570 >= x562
val x575 = x570 < x574
val x576 = x573 && x575
def x662_block = {
val x660 = new generated.scala.IntVectorImpl(x658,x659)
var mapIdx = 0
while (mapIdx < x571.size) { // begin map loop x662
val x572 = x571.dcApply(mapIdx)
x660.dcUpdate(mapIdx,  {
val x577 = x572 >= x562
val x578 = x576 && x577
val x580 = x572 < x579
val x581 = x578 && x580
val x656 = {
def x656thenb(): Int = {
val x612 = new generated.scala.IntVectorImpl(256,true)
var x613: Int = 0
val x614 = x613
val x582 = x570 - x562
val x583 = x570 + x562
val x584 = x583 + 1
val x588 = x584 - x582
val x585 = x572 - x562
val x586 = x572 + x562
val x587 = x586 + 1
val x589 = x587 - x585
val x611 = { 
val x590 = new generated.scala.IntMatrixImpl(x588,x589)
var x591: Int = x582
val x592 = x591
val x593 = x592 < x584
val x597 = x592 - x582
val x599 = x592 * x557
val x609 = while ({x593}) {
var x594: Int = x585
val x595 = x594
val x596 = x595 < x587
val x598 = x595 - x585
val x600 = x599 + x595
val x601 = x545.dcApply(x600)
val x602 = { 
x601
}
val x606 = while ({x596}) {
val x603 = x590(x597, x598) = x602
val x604 = x594 += 1
()
}
val x607 = x591 += 1
()
}
x590
}
val x615 = x611.numRows
val x616 = x614 < x615
val x619 = x611.numCols
val x621 = x614 * x619
val x633 = while ({x616}) {
var x617: Int = 0
val x618 = x617
val x620 = x618 < x619
val x622 = x621 + x618
val x623 = x611.dcApply(x622)
val x624 = { 
x623
}
val x630 = while ({x620}) {
val x625 = x612(x624)
val x626 = x625 + 1
val x627 = x612(x624) = x626
val x628 = x617 += 1
()
}
val x631 = x613 += 1
()
}
var x634: Int = 2
val x635 = x612(1)
var x636: Int = x635
var x637: Int = 1
val x638 = x634
val x643 = x636
val x651 = while ({val x639 = x612.length
val x640 = x638 < x639
x640}) {
val x642 = x612(x638)
val x644 = x642 > x643
val x648 = {
def x648thenb(): Unit = {
x636 = x642
x637 = x638
()
}
if (x644) {
x648thenb()
}
}
val x649 = x634 += 1
()
}
val x652 = x643 > 1
val x654 = {
def x654thenb(): Int = {
val x653 = x637
x653
}
def x654elseb(): Int = {
0
}
if (x652) {
x654thenb()
} else { 
x654elseb()
}
}
x654
}
def x656elseb(): Int = {
val x325 = 0.asInstanceOf[Int]
x325
}
if (x581) {
x656thenb()
} else { 
x656elseb()
}
}
x656
})
mapIdx += 1
} // end map loop x662
x660
}
val x662 = x662_block
x662
})
mapIdx += 1
} // end map loop x663
x568
}
val x663 = x663_block
val x664 = x663.length
val x665 = x664==0
val x699 = { 
val x697 = {
def x697thenb(): generated.scala.Matrix[Int] = {
val x666 = new generated.scala.IntMatrixImpl(0,0)
x666
}
def x697elseb(): generated.scala.Matrix[Int] = {
val x668 = x663(0)
val x669 = x668.isRow
val x695 = {
def x695thenb(): generated.scala.Matrix[Int] = {
val x670 = x668.length
val x671 = new generated.scala.IntMatrixImpl(x664,x670)
var x673 : Int = 0
val x682 = while (x673 < x664) {
val x676 = x663(x673)
var x675 : Int = 0
val x680 = while (x675 < x670) {
val x677 = x676(x675)
val x678 = x671(x673, x675) = x677
x678
x675 = x675 + 1
}
x680
x673 = x673 + 1
}
x671
}
def x695elseb(): generated.scala.Matrix[Int] = {
val x670 = x668.length
val x684 = new generated.scala.IntMatrixImpl(x670,x664)
var x685 : Int = 0
val x693 = while (x685 < x664) {
val x687 = x663(x685)
var x686 : Int = 0
val x691 = while (x686 < x670) {
val x688 = x687(x686)
val x689 = x684(x686, x685) = x688
x689
x686 = x686 + 1
}
x691
x685 = x685 + 1
}
x684
}
if (x669) {
x695thenb()
} else { 
x695elseb()
}
}
x695
}
if (x665) {
x697thenb()
} else { 
x697elseb()
}
}
x697
}
val x700 = new generated.scala.IntImageImpl(x699)
val x701 = new generated.scala.GrayscaleImageImpl(x700)
var x702: generated.scala.GrayscaleImage = x701
var x703: Int = 0
val x704 = new generated.scala.VectorImpl[generated.scala.GrayscaleImage](0,true)
val x705 = new generated.scala.BinarizedGradientPyramid(x704,3,1,3)
val x706 = x703
val x835 = while ({val x707 = x705.start_level
val x708 = x705.levels
val x709 = x707 + x708
val x710 = x706 < x709
x710}) {
val x712 = x705.start_level
val x713 = x706 >= x712
val x719 = {
def x719thenb(): Unit = {
val x714 = x705.pyramid
val x715 = x702
val x716 = x714.length
val x717 = x714.insert(x716, x715)
x717
}
if (x713) {
x719thenb()
}
}
val x720 = x705.start_level
val x721 = x705.levels
val x722 = x720 + x721
val x723 = x722 - 1
val x724 = x706 != x723
val x832 = {
def x832thenb(): Unit = {
val x725 = x702
val x726 = x725.numRows
val x727 = x726 / 2
val x728 = new generated.scala.IndexVectorRangeImpl(0,x727)
val x729 = x725.numCols
val x730 = x729 / 2
val x731 = new generated.scala.IndexVectorRangeImpl(0,x730)
val x732 = new generated.scala.IndexVector2Impl(x728,x731)
val x733 = x732.rowInd
val x734 = x733.length
val x738 = x732.colInd
val x786 = x738.length
val x787 = x738.isRow
def x791_block = {
val x735 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](x734,true)
var mapIdx = 0
while (mapIdx < x733.size) { // begin map loop x791
val x737 = x733.dcApply(mapIdx)
x735.dcUpdate(mapIdx,  {
val x740 = 2 * x737
val x741 = x740 + 2
val x744 = x741 - x740
def x790_block = {
val x788 = new generated.scala.IntVectorImpl(x786,x787)
var mapIdx = 0
while (mapIdx < x738.size) { // begin map loop x790
val x739 = x738.dcApply(mapIdx)
x788.dcUpdate(mapIdx,  {
val x742 = 2 * x739
val x743 = x742 + 2
val x745 = x743 - x742
val x767 = { 
val x746 = new generated.scala.IntMatrixImpl(x744,x745)
var x747: Int = x740
val x748 = x747
val x749 = x748 < x741
val x753 = x748 - x740
val x755 = x748 * x729
val x765 = while ({x749}) {
var x750: Int = x742
val x751 = x750
val x752 = x751 < x743
val x754 = x751 - x742
val x756 = x755 + x751
val x757 = x725.dcApply(x756)
val x758 = { 
x757
}
val x762 = while ({x752}) {
val x759 = x746(x753, x754) = x758
val x760 = x750 += 1
()
}
val x763 = x747 += 1
()
}
x746
}
val x768 = x767.numCols
val x769 = 0 * x768
val x770 = x769 + 0
val x771 = x767.dcApply(x770)
val x772 = { 
x771
}
val x773 = 1 * x768
val x774 = x773 + 0
val x775 = x767.dcApply(x774)
val x776 = { 
x775
}
val x777 = x772 | x776
val x778 = x769 + 1
val x779 = x767.dcApply(x778)
val x780 = { 
x779
}
val x781 = x777 | x780
val x782 = x773 + 1
val x783 = x767.dcApply(x782)
val x784 = { 
x783
}
val x785 = x781 | x784
x785
})
mapIdx += 1
} // end map loop x790
x788
}
val x790 = x790_block
x790
})
mapIdx += 1
} // end map loop x791
x735
}
val x791 = x791_block
val x792 = x791.length
val x793 = x792==0
val x827 = { 
val x825 = {
def x825thenb(): generated.scala.Matrix[Int] = {
val x794 = new generated.scala.IntMatrixImpl(0,0)
x794
}
def x825elseb(): generated.scala.Matrix[Int] = {
val x796 = x791(0)
val x797 = x796.isRow
val x823 = {
def x823thenb(): generated.scala.Matrix[Int] = {
val x798 = x796.length
val x799 = new generated.scala.IntMatrixImpl(x792,x798)
var x801 : Int = 0
val x810 = while (x801 < x792) {
val x804 = x791(x801)
var x803 : Int = 0
val x808 = while (x803 < x798) {
val x805 = x804(x803)
val x806 = x799(x801, x803) = x805
x806
x803 = x803 + 1
}
x808
x801 = x801 + 1
}
x799
}
def x823elseb(): generated.scala.Matrix[Int] = {
val x798 = x796.length
val x812 = new generated.scala.IntMatrixImpl(x798,x792)
var x813 : Int = 0
val x821 = while (x813 < x792) {
val x815 = x791(x813)
var x814 : Int = 0
val x819 = while (x814 < x798) {
val x816 = x815(x814)
val x817 = x812(x814, x813) = x816
x817
x814 = x814 + 1
}
x819
x813 = x813 + 1
}
x812
}
if (x797) {
x823thenb()
} else { 
x823elseb()
}
}
x823
}
if (x793) {
x825thenb()
} else { 
x825elseb()
}
}
x825
}
val x828 = new generated.scala.IntImageImpl(x827)
val x829 = new generated.scala.GrayscaleImageImpl(x828)
x702 = x829
()
}
if (x724) {
x832thenb()
}
}
val x833 = x703 += 1
()
}
def x1133_block = {
val x836 = x220.dcApply(0)
var x1105 = {
val x837 = x836._1
val x839 = "Name: "+x837
val x840 = println(x839)
val x838 = x836._2
val x841 = x838.length
val x842 = "Templates: "+x841
val x843 = println(x842)
val x844 = x705.fixedLevelIndex
val x845 = x705.pyramid
val x846 = x705.start_level
val x847 = x844 - x846
val x848 = x845(x847)
val x849 = x848.numRows
val x850 = x849 - 5
val x851 = new generated.scala.IndexVectorRangeImpl(5,x850)
val x923 = new generated.scala.IndexVectorRangeImpl(0,x841)
def x1100_block = {
val x852 = x851.dcApply(0)
var x1072 = {
val x853 = x848.numCols
val x854 = x853 - 5
val x855 = new generated.scala.IndexVectorRangeImpl(5,x854)
val x883 = x852 + 15
val x875 = x852 - 15
val x876 = x875 < 0
val x880 = {
def x880thenb(): scala.Tuple2[Int, Int] = {
val x877 = 15 - x852
val x878 = (0,x877)
x878
}
def x880elseb(): scala.Tuple2[Int, Int] = {
val x879 = (x875,0)
x879
}
if (x876) {
x880thenb()
} else { 
x880elseb()
}
}
val x881 = x880._1
val x882 = x880._2
def x1070_block = {
val x856 = x855.dcApply(0)
var x1042 = {
val x860 = new generated.scala.IntVectorImpl(900,false)
val x861 = new generated.scala.IndexVectorSeqImpl(0)
val x862 = new generated.scala.BinarizedGradientTemplate(15,null,null,x844,x860,x861,null,null,null)
val x872 = x848.numCols
val x871 = x856 + 15
val x873 = x871 > x872
val x874 = {
def x874thenb(): Int = {
x872
}
def x874elseb(): Int = {
x871
}
if (x873) {
x874thenb()
} else { 
x874elseb()
}
}
val x884 = x848.numRows
val x885 = x883 > x884
val x886 = {
def x886thenb(): Int = {
x884
}
def x886elseb(): Int = {
x883
}
if (x885) {
x886thenb()
} else { 
x886elseb()
}
}
var x887: Int = x881
val x888 = x887
val x889 = x888 < x886
val x863 = x856 - 15
val x864 = x863 < 0
val x868 = {
def x868thenb(): scala.Tuple2[Int, Int] = {
val x865 = 15 - x856
val x866 = (0,x865)
x866
}
def x868elseb(): scala.Tuple2[Int, Int] = {
val x867 = (x863,0)
x867
}
if (x864) {
x868thenb()
} else { 
x868elseb()
}
}
val x869 = x868._1
val x894 = x882 + x888
val x895 = x894 - x881
val x896 = x895 * 30
val x870 = x868._2
val x916 = while ({x889}) {
val x890 = x848.getRow(x888)
var x891: Int = x869
val x892 = x891
val x893 = x892 < x874
val x897 = x870 + x892
val x898 = x897 - x869
val x899 = x896 + x898
val x913 = while ({x893}) {
var x900: Int = x899
val x901 = x862.binary_gradients
val x903 = x890(x892)
val x902 = x900
val x904 = x901(x902) = x903
val x905 = x903 > 0
val x910 = {
def x910thenb(): Unit = {
val x906 = x862.match_list
val x907 = x906.length
val x908 = x906.insert(x907, x902)
x908
}
if (x905) {
x910thenb()
}
}
val x911 = x891 += 1
()
}
val x914 = x887 += 1
()
}
val x917 = x862.match_list
val x918 = x917.length
val x919 = x918 < 0
val x922 = {
def x922thenb(): Unit = {
val x920 = println("dummy")
x920
}
if (x919) {
x922thenb()
}
}
def x1040_block = {
val x924 = x923.dcApply(0)
var x1012 = {
val x927 = x862.radius
val x925 = x838(x924)
val x926 = x925.radius
val x928 = x926 != x927
val x990 = {
def x990thenb(): Float = {
-1.0f
}
def x990elseb(): Float = {
val x929 = x925.match_list
val x930 = x929.length
val x931 = x930.asInstanceOf[Float]
val x932 = x931==0.0
val x988 = {
def x988thenb(): Float = {
-1.0f
}
def x988elseb(): Float = {
val x933 = x862.match_list
val x934 = x933.length
val x935 = x934.asInstanceOf[Float]
val x936 = x935 / x931
val x937 = x936 < 0.82f
val x986 = {
def x986thenb(): Float = {
x936
}
def x986elseb(): Float = {
var x938: Float = 0.0f
val x939 = x931 * 0.18f
val x940 = x939 + 0.5f
val x941 = x940.asInstanceOf[Int]
var x942: Int = x941
var x943: Int = 0
var x944: Boolean = true
val x945 = x943
val x946 = x945 < x930
val x947 = x944
val x948 = x946 && x947
val x949 = x929(x945)
val x950 = x925.binary_gradients
val x951 = x950(x949)
val x952 = x951==0
val x980 = while ({x948}) {
val x953 = x862.binary_gradients
val x954 = x953(x949)
val x955 = x954==0
val x956 = x952 && x955
val x977 = {
def x977thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x977elseb(): Unit = {
val x961 = x862.binary_gradients
val x962 = x961(x949)
val x963 = x951 & x962
val x964 = x963 > 0
val x975 = {
def x975thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x975elseb(): Unit = {
val x967 = x942
val x968 = x967 - 1
x942 = x968
val x970 = x967 <= 0
val x973 = {
def x973thenb(): Unit = {
x944 = false
()
}
if (x970) {
x973thenb()
}
}
x973
}
if (x964) {
x975thenb()
} else { 
x975elseb()
}
}
x975
}
if (x956) {
x977thenb()
} else { 
x977elseb()
}
}
val x978 = x943 += 1
()
}
val x981 = !x947
val x984 = {
def x984thenb(): Float = {
0.819999f
}
def x984elseb(): Float = {
val x957 = x938
val x982 = x957 / x931
val x983 = x982.asInstanceOf[Float]
x983
}
if (x981) {
x984thenb()
} else { 
x984elseb()
}
}
x984
}
if (x937) {
x986thenb()
} else { 
x986elseb()
}
}
x986
}
if (x932) {
x988thenb()
} else { 
x988elseb()
}
}
x988
}
if (x928) {
x990thenb()
} else { 
x990elseb()
}
}
val x991 = x990 > 0.82f
val x1010 = {
def x1010thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x992 = x925.rect
val x994 = x992.width
val x857 = x844
val x858 = Math.pow(2.0,x857)
val x859 = x858.asInstanceOf[Int]
val x993 = x859 * x856
val x995 = x994 / 2
val x996 = x993 - x995
val x997 = x996.asInstanceOf[Int]
val x999 = x992.height
val x998 = x859 * x852
val x1000 = x999 / 2
val x1001 = x998 - x1000
val x1002 = x1001.asInstanceOf[Int]
val x1003 = new generated.scala.Rect(x997,x1002,x994,x999)
val x1004 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1005 = new generated.scala.BiGGDetection(x837,x990,x1003,null,x924,x856,x852,x925,x862)
val x1006 = x1004(0) = x1005
x1004
}
def x1010elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1008 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1008
}
if (x991) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
var mapReduceIdx = 1
while (mapReduceIdx < x923.size) { // begin mapReduce loop x1040
val x924 = x923.dcApply(mapReduceIdx)
val x1013 = {
val x927 = x862.radius
val x925 = x838(x924)
val x926 = x925.radius
val x928 = x926 != x927
val x990 = {
def x990thenb(): Float = {
-1.0f
}
def x990elseb(): Float = {
val x929 = x925.match_list
val x930 = x929.length
val x931 = x930.asInstanceOf[Float]
val x932 = x931==0.0
val x988 = {
def x988thenb(): Float = {
-1.0f
}
def x988elseb(): Float = {
val x933 = x862.match_list
val x934 = x933.length
val x935 = x934.asInstanceOf[Float]
val x936 = x935 / x931
val x937 = x936 < 0.82f
val x986 = {
def x986thenb(): Float = {
x936
}
def x986elseb(): Float = {
var x938: Float = 0.0f
val x939 = x931 * 0.18f
val x940 = x939 + 0.5f
val x941 = x940.asInstanceOf[Int]
var x942: Int = x941
var x943: Int = 0
var x944: Boolean = true
val x945 = x943
val x946 = x945 < x930
val x947 = x944
val x948 = x946 && x947
val x949 = x929(x945)
val x950 = x925.binary_gradients
val x951 = x950(x949)
val x952 = x951==0
val x980 = while ({x948}) {
val x953 = x862.binary_gradients
val x954 = x953(x949)
val x955 = x954==0
val x956 = x952 && x955
val x977 = {
def x977thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x977elseb(): Unit = {
val x961 = x862.binary_gradients
val x962 = x961(x949)
val x963 = x951 & x962
val x964 = x963 > 0
val x975 = {
def x975thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x975elseb(): Unit = {
val x967 = x942
val x968 = x967 - 1
x942 = x968
val x970 = x967 <= 0
val x973 = {
def x973thenb(): Unit = {
x944 = false
()
}
if (x970) {
x973thenb()
}
}
x973
}
if (x964) {
x975thenb()
} else { 
x975elseb()
}
}
x975
}
if (x956) {
x977thenb()
} else { 
x977elseb()
}
}
val x978 = x943 += 1
()
}
val x981 = !x947
val x984 = {
def x984thenb(): Float = {
0.819999f
}
def x984elseb(): Float = {
val x957 = x938
val x982 = x957 / x931
val x983 = x982.asInstanceOf[Float]
x983
}
if (x981) {
x984thenb()
} else { 
x984elseb()
}
}
x984
}
if (x937) {
x986thenb()
} else { 
x986elseb()
}
}
x986
}
if (x932) {
x988thenb()
} else { 
x988elseb()
}
}
x988
}
if (x928) {
x990thenb()
} else { 
x990elseb()
}
}
val x991 = x990 > 0.82f
val x1010 = {
def x1010thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x992 = x925.rect
val x994 = x992.width
val x857 = x844
val x858 = Math.pow(2.0,x857)
val x859 = x858.asInstanceOf[Int]
val x993 = x859 * x856
val x995 = x994 / 2
val x996 = x993 - x995
val x997 = x996.asInstanceOf[Int]
val x999 = x992.height
val x998 = x859 * x852
val x1000 = x999 / 2
val x1001 = x998 - x1000
val x1002 = x1001.asInstanceOf[Int]
val x1003 = new generated.scala.Rect(x997,x1002,x994,x999)
val x1004 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1005 = new generated.scala.BiGGDetection(x837,x990,x1003,null,x924,x856,x852,x925,x862)
val x1006 = x1004(0) = x1005
x1004
}
def x1010elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1008 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1008
}
if (x991) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
x1012 = {
val x1014 = x1012.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1039 = { 
val x1037 = {
def x1037thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1013
}
def x1037elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1015 = x1013.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1035 = {
def x1035thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1012
}
def x1035elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1016 = x1012.length
val x1017 = x1013.length
val x1018 = x1016 + x1017
val x1019 = x1012.isRow
val x1020 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1018,x1019)
var x1022 : Int = 0
val x1026 = while (x1022 < x1016) {
val x1023 = x1012(x1022)
val x1024 = x1020(x1022) = x1023
x1024
x1022 = x1022 + 1
}
var x1028 : Int = 0
val x1033 = while (x1028 < x1017) {
val x1029 = x1028 + x1016
val x1030 = x1013(x1028)
val x1031 = x1020(x1029) = x1030
x1031
x1028 = x1028 + 1
}
x1020
}
if (x1015) {
x1035thenb()
} else { 
x1035elseb()
}
}
x1035
}
if (x1014) {
x1037thenb()
} else { 
x1037elseb()
}
}
x1037
}
x1039
}
mapReduceIdx += 1
} // end mapReduce loop x1040
x1012
}
val x1040 = x1040_block
x1040
}
var mapReduceIdx = 1
while (mapReduceIdx < x855.size) { // begin mapReduce loop x1070
val x856 = x855.dcApply(mapReduceIdx)
val x1043 = {
val x860 = new generated.scala.IntVectorImpl(900,false)
val x861 = new generated.scala.IndexVectorSeqImpl(0)
val x862 = new generated.scala.BinarizedGradientTemplate(15,null,null,x844,x860,x861,null,null,null)
val x872 = x848.numCols
val x871 = x856 + 15
val x873 = x871 > x872
val x874 = {
def x874thenb(): Int = {
x872
}
def x874elseb(): Int = {
x871
}
if (x873) {
x874thenb()
} else { 
x874elseb()
}
}
val x884 = x848.numRows
val x885 = x883 > x884
val x886 = {
def x886thenb(): Int = {
x884
}
def x886elseb(): Int = {
x883
}
if (x885) {
x886thenb()
} else { 
x886elseb()
}
}
var x887: Int = x881
val x888 = x887
val x889 = x888 < x886
val x863 = x856 - 15
val x864 = x863 < 0
val x868 = {
def x868thenb(): scala.Tuple2[Int, Int] = {
val x865 = 15 - x856
val x866 = (0,x865)
x866
}
def x868elseb(): scala.Tuple2[Int, Int] = {
val x867 = (x863,0)
x867
}
if (x864) {
x868thenb()
} else { 
x868elseb()
}
}
val x869 = x868._1
val x894 = x882 + x888
val x895 = x894 - x881
val x896 = x895 * 30
val x870 = x868._2
val x916 = while ({x889}) {
val x890 = x848.getRow(x888)
var x891: Int = x869
val x892 = x891
val x893 = x892 < x874
val x897 = x870 + x892
val x898 = x897 - x869
val x899 = x896 + x898
val x913 = while ({x893}) {
var x900: Int = x899
val x901 = x862.binary_gradients
val x903 = x890(x892)
val x902 = x900
val x904 = x901(x902) = x903
val x905 = x903 > 0
val x910 = {
def x910thenb(): Unit = {
val x906 = x862.match_list
val x907 = x906.length
val x908 = x906.insert(x907, x902)
x908
}
if (x905) {
x910thenb()
}
}
val x911 = x891 += 1
()
}
val x914 = x887 += 1
()
}
val x917 = x862.match_list
val x918 = x917.length
val x919 = x918 < 0
val x922 = {
def x922thenb(): Unit = {
val x920 = println("dummy")
x920
}
if (x919) {
x922thenb()
}
}
def x1040_block = {
val x924 = x923.dcApply(0)
var x1012 = {
val x927 = x862.radius
val x925 = x838(x924)
val x926 = x925.radius
val x928 = x926 != x927
val x990 = {
def x990thenb(): Float = {
-1.0f
}
def x990elseb(): Float = {
val x929 = x925.match_list
val x930 = x929.length
val x931 = x930.asInstanceOf[Float]
val x932 = x931==0.0
val x988 = {
def x988thenb(): Float = {
-1.0f
}
def x988elseb(): Float = {
val x933 = x862.match_list
val x934 = x933.length
val x935 = x934.asInstanceOf[Float]
val x936 = x935 / x931
val x937 = x936 < 0.82f
val x986 = {
def x986thenb(): Float = {
x936
}
def x986elseb(): Float = {
var x938: Float = 0.0f
val x939 = x931 * 0.18f
val x940 = x939 + 0.5f
val x941 = x940.asInstanceOf[Int]
var x942: Int = x941
var x943: Int = 0
var x944: Boolean = true
val x945 = x943
val x946 = x945 < x930
val x947 = x944
val x948 = x946 && x947
val x949 = x929(x945)
val x950 = x925.binary_gradients
val x951 = x950(x949)
val x952 = x951==0
val x980 = while ({x948}) {
val x953 = x862.binary_gradients
val x954 = x953(x949)
val x955 = x954==0
val x956 = x952 && x955
val x977 = {
def x977thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x977elseb(): Unit = {
val x961 = x862.binary_gradients
val x962 = x961(x949)
val x963 = x951 & x962
val x964 = x963 > 0
val x975 = {
def x975thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x975elseb(): Unit = {
val x967 = x942
val x968 = x967 - 1
x942 = x968
val x970 = x967 <= 0
val x973 = {
def x973thenb(): Unit = {
x944 = false
()
}
if (x970) {
x973thenb()
}
}
x973
}
if (x964) {
x975thenb()
} else { 
x975elseb()
}
}
x975
}
if (x956) {
x977thenb()
} else { 
x977elseb()
}
}
val x978 = x943 += 1
()
}
val x981 = !x947
val x984 = {
def x984thenb(): Float = {
0.819999f
}
def x984elseb(): Float = {
val x957 = x938
val x982 = x957 / x931
val x983 = x982.asInstanceOf[Float]
x983
}
if (x981) {
x984thenb()
} else { 
x984elseb()
}
}
x984
}
if (x937) {
x986thenb()
} else { 
x986elseb()
}
}
x986
}
if (x932) {
x988thenb()
} else { 
x988elseb()
}
}
x988
}
if (x928) {
x990thenb()
} else { 
x990elseb()
}
}
val x991 = x990 > 0.82f
val x1010 = {
def x1010thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x992 = x925.rect
val x994 = x992.width
val x857 = x844
val x858 = Math.pow(2.0,x857)
val x859 = x858.asInstanceOf[Int]
val x993 = x859 * x856
val x995 = x994 / 2
val x996 = x993 - x995
val x997 = x996.asInstanceOf[Int]
val x999 = x992.height
val x998 = x859 * x852
val x1000 = x999 / 2
val x1001 = x998 - x1000
val x1002 = x1001.asInstanceOf[Int]
val x1003 = new generated.scala.Rect(x997,x1002,x994,x999)
val x1004 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1005 = new generated.scala.BiGGDetection(x837,x990,x1003,null,x924,x856,x852,x925,x862)
val x1006 = x1004(0) = x1005
x1004
}
def x1010elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1008 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1008
}
if (x991) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
var mapReduceIdx = 1
while (mapReduceIdx < x923.size) { // begin mapReduce loop x1040
val x924 = x923.dcApply(mapReduceIdx)
val x1013 = {
val x927 = x862.radius
val x925 = x838(x924)
val x926 = x925.radius
val x928 = x926 != x927
val x990 = {
def x990thenb(): Float = {
-1.0f
}
def x990elseb(): Float = {
val x929 = x925.match_list
val x930 = x929.length
val x931 = x930.asInstanceOf[Float]
val x932 = x931==0.0
val x988 = {
def x988thenb(): Float = {
-1.0f
}
def x988elseb(): Float = {
val x933 = x862.match_list
val x934 = x933.length
val x935 = x934.asInstanceOf[Float]
val x936 = x935 / x931
val x937 = x936 < 0.82f
val x986 = {
def x986thenb(): Float = {
x936
}
def x986elseb(): Float = {
var x938: Float = 0.0f
val x939 = x931 * 0.18f
val x940 = x939 + 0.5f
val x941 = x940.asInstanceOf[Int]
var x942: Int = x941
var x943: Int = 0
var x944: Boolean = true
val x945 = x943
val x946 = x945 < x930
val x947 = x944
val x948 = x946 && x947
val x949 = x929(x945)
val x950 = x925.binary_gradients
val x951 = x950(x949)
val x952 = x951==0
val x980 = while ({x948}) {
val x953 = x862.binary_gradients
val x954 = x953(x949)
val x955 = x954==0
val x956 = x952 && x955
val x977 = {
def x977thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x977elseb(): Unit = {
val x961 = x862.binary_gradients
val x962 = x961(x949)
val x963 = x951 & x962
val x964 = x963 > 0
val x975 = {
def x975thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x975elseb(): Unit = {
val x967 = x942
val x968 = x967 - 1
x942 = x968
val x970 = x967 <= 0
val x973 = {
def x973thenb(): Unit = {
x944 = false
()
}
if (x970) {
x973thenb()
}
}
x973
}
if (x964) {
x975thenb()
} else { 
x975elseb()
}
}
x975
}
if (x956) {
x977thenb()
} else { 
x977elseb()
}
}
val x978 = x943 += 1
()
}
val x981 = !x947
val x984 = {
def x984thenb(): Float = {
0.819999f
}
def x984elseb(): Float = {
val x957 = x938
val x982 = x957 / x931
val x983 = x982.asInstanceOf[Float]
x983
}
if (x981) {
x984thenb()
} else { 
x984elseb()
}
}
x984
}
if (x937) {
x986thenb()
} else { 
x986elseb()
}
}
x986
}
if (x932) {
x988thenb()
} else { 
x988elseb()
}
}
x988
}
if (x928) {
x990thenb()
} else { 
x990elseb()
}
}
val x991 = x990 > 0.82f
val x1010 = {
def x1010thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x992 = x925.rect
val x994 = x992.width
val x857 = x844
val x858 = Math.pow(2.0,x857)
val x859 = x858.asInstanceOf[Int]
val x993 = x859 * x856
val x995 = x994 / 2
val x996 = x993 - x995
val x997 = x996.asInstanceOf[Int]
val x999 = x992.height
val x998 = x859 * x852
val x1000 = x999 / 2
val x1001 = x998 - x1000
val x1002 = x1001.asInstanceOf[Int]
val x1003 = new generated.scala.Rect(x997,x1002,x994,x999)
val x1004 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1005 = new generated.scala.BiGGDetection(x837,x990,x1003,null,x924,x856,x852,x925,x862)
val x1006 = x1004(0) = x1005
x1004
}
def x1010elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1008 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1008
}
if (x991) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
x1012 = {
val x1014 = x1012.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1039 = { 
val x1037 = {
def x1037thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1013
}
def x1037elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1015 = x1013.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1035 = {
def x1035thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1012
}
def x1035elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1016 = x1012.length
val x1017 = x1013.length
val x1018 = x1016 + x1017
val x1019 = x1012.isRow
val x1020 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1018,x1019)
var x1022 : Int = 0
val x1026 = while (x1022 < x1016) {
val x1023 = x1012(x1022)
val x1024 = x1020(x1022) = x1023
x1024
x1022 = x1022 + 1
}
var x1028 : Int = 0
val x1033 = while (x1028 < x1017) {
val x1029 = x1028 + x1016
val x1030 = x1013(x1028)
val x1031 = x1020(x1029) = x1030
x1031
x1028 = x1028 + 1
}
x1020
}
if (x1015) {
x1035thenb()
} else { 
x1035elseb()
}
}
x1035
}
if (x1014) {
x1037thenb()
} else { 
x1037elseb()
}
}
x1037
}
x1039
}
mapReduceIdx += 1
} // end mapReduce loop x1040
x1012
}
val x1040 = x1040_block
x1040
}
x1042 = {
val x1044 = x1042.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1069 = { 
val x1067 = {
def x1067thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1043
}
def x1067elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1045 = x1043.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1065 = {
def x1065thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1042
}
def x1065elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = x1042.length
val x1047 = x1043.length
val x1048 = x1046 + x1047
val x1049 = x1042.isRow
val x1050 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1048,x1049)
var x1052 : Int = 0
val x1056 = while (x1052 < x1046) {
val x1053 = x1042(x1052)
val x1054 = x1050(x1052) = x1053
x1054
x1052 = x1052 + 1
}
var x1058 : Int = 0
val x1063 = while (x1058 < x1047) {
val x1059 = x1058 + x1046
val x1060 = x1043(x1058)
val x1061 = x1050(x1059) = x1060
x1061
x1058 = x1058 + 1
}
x1050
}
if (x1045) {
x1065thenb()
} else { 
x1065elseb()
}
}
x1065
}
if (x1044) {
x1067thenb()
} else { 
x1067elseb()
}
}
x1067
}
x1069
}
mapReduceIdx += 1
} // end mapReduce loop x1070
x1042
}
val x1070 = x1070_block
x1070
}
var mapReduceIdx = 1
while (mapReduceIdx < x851.size) { // begin mapReduce loop x1100
val x852 = x851.dcApply(mapReduceIdx)
val x1073 = {
val x853 = x848.numCols
val x854 = x853 - 5
val x855 = new generated.scala.IndexVectorRangeImpl(5,x854)
val x883 = x852 + 15
val x875 = x852 - 15
val x876 = x875 < 0
val x880 = {
def x880thenb(): scala.Tuple2[Int, Int] = {
val x877 = 15 - x852
val x878 = (0,x877)
x878
}
def x880elseb(): scala.Tuple2[Int, Int] = {
val x879 = (x875,0)
x879
}
if (x876) {
x880thenb()
} else { 
x880elseb()
}
}
val x881 = x880._1
val x882 = x880._2
def x1070_block = {
val x856 = x855.dcApply(0)
var x1042 = {
val x860 = new generated.scala.IntVectorImpl(900,false)
val x861 = new generated.scala.IndexVectorSeqImpl(0)
val x862 = new generated.scala.BinarizedGradientTemplate(15,null,null,x844,x860,x861,null,null,null)
val x872 = x848.numCols
val x871 = x856 + 15
val x873 = x871 > x872
val x874 = {
def x874thenb(): Int = {
x872
}
def x874elseb(): Int = {
x871
}
if (x873) {
x874thenb()
} else { 
x874elseb()
}
}
val x884 = x848.numRows
val x885 = x883 > x884
val x886 = {
def x886thenb(): Int = {
x884
}
def x886elseb(): Int = {
x883
}
if (x885) {
x886thenb()
} else { 
x886elseb()
}
}
var x887: Int = x881
val x888 = x887
val x889 = x888 < x886
val x863 = x856 - 15
val x864 = x863 < 0
val x868 = {
def x868thenb(): scala.Tuple2[Int, Int] = {
val x865 = 15 - x856
val x866 = (0,x865)
x866
}
def x868elseb(): scala.Tuple2[Int, Int] = {
val x867 = (x863,0)
x867
}
if (x864) {
x868thenb()
} else { 
x868elseb()
}
}
val x869 = x868._1
val x894 = x882 + x888
val x895 = x894 - x881
val x896 = x895 * 30
val x870 = x868._2
val x916 = while ({x889}) {
val x890 = x848.getRow(x888)
var x891: Int = x869
val x892 = x891
val x893 = x892 < x874
val x897 = x870 + x892
val x898 = x897 - x869
val x899 = x896 + x898
val x913 = while ({x893}) {
var x900: Int = x899
val x901 = x862.binary_gradients
val x903 = x890(x892)
val x902 = x900
val x904 = x901(x902) = x903
val x905 = x903 > 0
val x910 = {
def x910thenb(): Unit = {
val x906 = x862.match_list
val x907 = x906.length
val x908 = x906.insert(x907, x902)
x908
}
if (x905) {
x910thenb()
}
}
val x911 = x891 += 1
()
}
val x914 = x887 += 1
()
}
val x917 = x862.match_list
val x918 = x917.length
val x919 = x918 < 0
val x922 = {
def x922thenb(): Unit = {
val x920 = println("dummy")
x920
}
if (x919) {
x922thenb()
}
}
def x1040_block = {
val x924 = x923.dcApply(0)
var x1012 = {
val x927 = x862.radius
val x925 = x838(x924)
val x926 = x925.radius
val x928 = x926 != x927
val x990 = {
def x990thenb(): Float = {
-1.0f
}
def x990elseb(): Float = {
val x929 = x925.match_list
val x930 = x929.length
val x931 = x930.asInstanceOf[Float]
val x932 = x931==0.0
val x988 = {
def x988thenb(): Float = {
-1.0f
}
def x988elseb(): Float = {
val x933 = x862.match_list
val x934 = x933.length
val x935 = x934.asInstanceOf[Float]
val x936 = x935 / x931
val x937 = x936 < 0.82f
val x986 = {
def x986thenb(): Float = {
x936
}
def x986elseb(): Float = {
var x938: Float = 0.0f
val x939 = x931 * 0.18f
val x940 = x939 + 0.5f
val x941 = x940.asInstanceOf[Int]
var x942: Int = x941
var x943: Int = 0
var x944: Boolean = true
val x945 = x943
val x946 = x945 < x930
val x947 = x944
val x948 = x946 && x947
val x949 = x929(x945)
val x950 = x925.binary_gradients
val x951 = x950(x949)
val x952 = x951==0
val x980 = while ({x948}) {
val x953 = x862.binary_gradients
val x954 = x953(x949)
val x955 = x954==0
val x956 = x952 && x955
val x977 = {
def x977thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x977elseb(): Unit = {
val x961 = x862.binary_gradients
val x962 = x961(x949)
val x963 = x951 & x962
val x964 = x963 > 0
val x975 = {
def x975thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x975elseb(): Unit = {
val x967 = x942
val x968 = x967 - 1
x942 = x968
val x970 = x967 <= 0
val x973 = {
def x973thenb(): Unit = {
x944 = false
()
}
if (x970) {
x973thenb()
}
}
x973
}
if (x964) {
x975thenb()
} else { 
x975elseb()
}
}
x975
}
if (x956) {
x977thenb()
} else { 
x977elseb()
}
}
val x978 = x943 += 1
()
}
val x981 = !x947
val x984 = {
def x984thenb(): Float = {
0.819999f
}
def x984elseb(): Float = {
val x957 = x938
val x982 = x957 / x931
val x983 = x982.asInstanceOf[Float]
x983
}
if (x981) {
x984thenb()
} else { 
x984elseb()
}
}
x984
}
if (x937) {
x986thenb()
} else { 
x986elseb()
}
}
x986
}
if (x932) {
x988thenb()
} else { 
x988elseb()
}
}
x988
}
if (x928) {
x990thenb()
} else { 
x990elseb()
}
}
val x991 = x990 > 0.82f
val x1010 = {
def x1010thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x992 = x925.rect
val x994 = x992.width
val x857 = x844
val x858 = Math.pow(2.0,x857)
val x859 = x858.asInstanceOf[Int]
val x993 = x859 * x856
val x995 = x994 / 2
val x996 = x993 - x995
val x997 = x996.asInstanceOf[Int]
val x999 = x992.height
val x998 = x859 * x852
val x1000 = x999 / 2
val x1001 = x998 - x1000
val x1002 = x1001.asInstanceOf[Int]
val x1003 = new generated.scala.Rect(x997,x1002,x994,x999)
val x1004 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1005 = new generated.scala.BiGGDetection(x837,x990,x1003,null,x924,x856,x852,x925,x862)
val x1006 = x1004(0) = x1005
x1004
}
def x1010elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1008 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1008
}
if (x991) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
var mapReduceIdx = 1
while (mapReduceIdx < x923.size) { // begin mapReduce loop x1040
val x924 = x923.dcApply(mapReduceIdx)
val x1013 = {
val x927 = x862.radius
val x925 = x838(x924)
val x926 = x925.radius
val x928 = x926 != x927
val x990 = {
def x990thenb(): Float = {
-1.0f
}
def x990elseb(): Float = {
val x929 = x925.match_list
val x930 = x929.length
val x931 = x930.asInstanceOf[Float]
val x932 = x931==0.0
val x988 = {
def x988thenb(): Float = {
-1.0f
}
def x988elseb(): Float = {
val x933 = x862.match_list
val x934 = x933.length
val x935 = x934.asInstanceOf[Float]
val x936 = x935 / x931
val x937 = x936 < 0.82f
val x986 = {
def x986thenb(): Float = {
x936
}
def x986elseb(): Float = {
var x938: Float = 0.0f
val x939 = x931 * 0.18f
val x940 = x939 + 0.5f
val x941 = x940.asInstanceOf[Int]
var x942: Int = x941
var x943: Int = 0
var x944: Boolean = true
val x945 = x943
val x946 = x945 < x930
val x947 = x944
val x948 = x946 && x947
val x949 = x929(x945)
val x950 = x925.binary_gradients
val x951 = x950(x949)
val x952 = x951==0
val x980 = while ({x948}) {
val x953 = x862.binary_gradients
val x954 = x953(x949)
val x955 = x954==0
val x956 = x952 && x955
val x977 = {
def x977thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x977elseb(): Unit = {
val x961 = x862.binary_gradients
val x962 = x961(x949)
val x963 = x951 & x962
val x964 = x963 > 0
val x975 = {
def x975thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x975elseb(): Unit = {
val x967 = x942
val x968 = x967 - 1
x942 = x968
val x970 = x967 <= 0
val x973 = {
def x973thenb(): Unit = {
x944 = false
()
}
if (x970) {
x973thenb()
}
}
x973
}
if (x964) {
x975thenb()
} else { 
x975elseb()
}
}
x975
}
if (x956) {
x977thenb()
} else { 
x977elseb()
}
}
val x978 = x943 += 1
()
}
val x981 = !x947
val x984 = {
def x984thenb(): Float = {
0.819999f
}
def x984elseb(): Float = {
val x957 = x938
val x982 = x957 / x931
val x983 = x982.asInstanceOf[Float]
x983
}
if (x981) {
x984thenb()
} else { 
x984elseb()
}
}
x984
}
if (x937) {
x986thenb()
} else { 
x986elseb()
}
}
x986
}
if (x932) {
x988thenb()
} else { 
x988elseb()
}
}
x988
}
if (x928) {
x990thenb()
} else { 
x990elseb()
}
}
val x991 = x990 > 0.82f
val x1010 = {
def x1010thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x992 = x925.rect
val x994 = x992.width
val x857 = x844
val x858 = Math.pow(2.0,x857)
val x859 = x858.asInstanceOf[Int]
val x993 = x859 * x856
val x995 = x994 / 2
val x996 = x993 - x995
val x997 = x996.asInstanceOf[Int]
val x999 = x992.height
val x998 = x859 * x852
val x1000 = x999 / 2
val x1001 = x998 - x1000
val x1002 = x1001.asInstanceOf[Int]
val x1003 = new generated.scala.Rect(x997,x1002,x994,x999)
val x1004 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1005 = new generated.scala.BiGGDetection(x837,x990,x1003,null,x924,x856,x852,x925,x862)
val x1006 = x1004(0) = x1005
x1004
}
def x1010elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1008 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1008
}
if (x991) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
x1012 = {
val x1014 = x1012.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1039 = { 
val x1037 = {
def x1037thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1013
}
def x1037elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1015 = x1013.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1035 = {
def x1035thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1012
}
def x1035elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1016 = x1012.length
val x1017 = x1013.length
val x1018 = x1016 + x1017
val x1019 = x1012.isRow
val x1020 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1018,x1019)
var x1022 : Int = 0
val x1026 = while (x1022 < x1016) {
val x1023 = x1012(x1022)
val x1024 = x1020(x1022) = x1023
x1024
x1022 = x1022 + 1
}
var x1028 : Int = 0
val x1033 = while (x1028 < x1017) {
val x1029 = x1028 + x1016
val x1030 = x1013(x1028)
val x1031 = x1020(x1029) = x1030
x1031
x1028 = x1028 + 1
}
x1020
}
if (x1015) {
x1035thenb()
} else { 
x1035elseb()
}
}
x1035
}
if (x1014) {
x1037thenb()
} else { 
x1037elseb()
}
}
x1037
}
x1039
}
mapReduceIdx += 1
} // end mapReduce loop x1040
x1012
}
val x1040 = x1040_block
x1040
}
var mapReduceIdx = 1
while (mapReduceIdx < x855.size) { // begin mapReduce loop x1070
val x856 = x855.dcApply(mapReduceIdx)
val x1043 = {
val x860 = new generated.scala.IntVectorImpl(900,false)
val x861 = new generated.scala.IndexVectorSeqImpl(0)
val x862 = new generated.scala.BinarizedGradientTemplate(15,null,null,x844,x860,x861,null,null,null)
val x872 = x848.numCols
val x871 = x856 + 15
val x873 = x871 > x872
val x874 = {
def x874thenb(): Int = {
x872
}
def x874elseb(): Int = {
x871
}
if (x873) {
x874thenb()
} else { 
x874elseb()
}
}
val x884 = x848.numRows
val x885 = x883 > x884
val x886 = {
def x886thenb(): Int = {
x884
}
def x886elseb(): Int = {
x883
}
if (x885) {
x886thenb()
} else { 
x886elseb()
}
}
var x887: Int = x881
val x888 = x887
val x889 = x888 < x886
val x863 = x856 - 15
val x864 = x863 < 0
val x868 = {
def x868thenb(): scala.Tuple2[Int, Int] = {
val x865 = 15 - x856
val x866 = (0,x865)
x866
}
def x868elseb(): scala.Tuple2[Int, Int] = {
val x867 = (x863,0)
x867
}
if (x864) {
x868thenb()
} else { 
x868elseb()
}
}
val x869 = x868._1
val x894 = x882 + x888
val x895 = x894 - x881
val x896 = x895 * 30
val x870 = x868._2
val x916 = while ({x889}) {
val x890 = x848.getRow(x888)
var x891: Int = x869
val x892 = x891
val x893 = x892 < x874
val x897 = x870 + x892
val x898 = x897 - x869
val x899 = x896 + x898
val x913 = while ({x893}) {
var x900: Int = x899
val x901 = x862.binary_gradients
val x903 = x890(x892)
val x902 = x900
val x904 = x901(x902) = x903
val x905 = x903 > 0
val x910 = {
def x910thenb(): Unit = {
val x906 = x862.match_list
val x907 = x906.length
val x908 = x906.insert(x907, x902)
x908
}
if (x905) {
x910thenb()
}
}
val x911 = x891 += 1
()
}
val x914 = x887 += 1
()
}
val x917 = x862.match_list
val x918 = x917.length
val x919 = x918 < 0
val x922 = {
def x922thenb(): Unit = {
val x920 = println("dummy")
x920
}
if (x919) {
x922thenb()
}
}
def x1040_block = {
val x924 = x923.dcApply(0)
var x1012 = {
val x927 = x862.radius
val x925 = x838(x924)
val x926 = x925.radius
val x928 = x926 != x927
val x990 = {
def x990thenb(): Float = {
-1.0f
}
def x990elseb(): Float = {
val x929 = x925.match_list
val x930 = x929.length
val x931 = x930.asInstanceOf[Float]
val x932 = x931==0.0
val x988 = {
def x988thenb(): Float = {
-1.0f
}
def x988elseb(): Float = {
val x933 = x862.match_list
val x934 = x933.length
val x935 = x934.asInstanceOf[Float]
val x936 = x935 / x931
val x937 = x936 < 0.82f
val x986 = {
def x986thenb(): Float = {
x936
}
def x986elseb(): Float = {
var x938: Float = 0.0f
val x939 = x931 * 0.18f
val x940 = x939 + 0.5f
val x941 = x940.asInstanceOf[Int]
var x942: Int = x941
var x943: Int = 0
var x944: Boolean = true
val x945 = x943
val x946 = x945 < x930
val x947 = x944
val x948 = x946 && x947
val x949 = x929(x945)
val x950 = x925.binary_gradients
val x951 = x950(x949)
val x952 = x951==0
val x980 = while ({x948}) {
val x953 = x862.binary_gradients
val x954 = x953(x949)
val x955 = x954==0
val x956 = x952 && x955
val x977 = {
def x977thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x977elseb(): Unit = {
val x961 = x862.binary_gradients
val x962 = x961(x949)
val x963 = x951 & x962
val x964 = x963 > 0
val x975 = {
def x975thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x975elseb(): Unit = {
val x967 = x942
val x968 = x967 - 1
x942 = x968
val x970 = x967 <= 0
val x973 = {
def x973thenb(): Unit = {
x944 = false
()
}
if (x970) {
x973thenb()
}
}
x973
}
if (x964) {
x975thenb()
} else { 
x975elseb()
}
}
x975
}
if (x956) {
x977thenb()
} else { 
x977elseb()
}
}
val x978 = x943 += 1
()
}
val x981 = !x947
val x984 = {
def x984thenb(): Float = {
0.819999f
}
def x984elseb(): Float = {
val x957 = x938
val x982 = x957 / x931
val x983 = x982.asInstanceOf[Float]
x983
}
if (x981) {
x984thenb()
} else { 
x984elseb()
}
}
x984
}
if (x937) {
x986thenb()
} else { 
x986elseb()
}
}
x986
}
if (x932) {
x988thenb()
} else { 
x988elseb()
}
}
x988
}
if (x928) {
x990thenb()
} else { 
x990elseb()
}
}
val x991 = x990 > 0.82f
val x1010 = {
def x1010thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x992 = x925.rect
val x994 = x992.width
val x857 = x844
val x858 = Math.pow(2.0,x857)
val x859 = x858.asInstanceOf[Int]
val x993 = x859 * x856
val x995 = x994 / 2
val x996 = x993 - x995
val x997 = x996.asInstanceOf[Int]
val x999 = x992.height
val x998 = x859 * x852
val x1000 = x999 / 2
val x1001 = x998 - x1000
val x1002 = x1001.asInstanceOf[Int]
val x1003 = new generated.scala.Rect(x997,x1002,x994,x999)
val x1004 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1005 = new generated.scala.BiGGDetection(x837,x990,x1003,null,x924,x856,x852,x925,x862)
val x1006 = x1004(0) = x1005
x1004
}
def x1010elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1008 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1008
}
if (x991) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
var mapReduceIdx = 1
while (mapReduceIdx < x923.size) { // begin mapReduce loop x1040
val x924 = x923.dcApply(mapReduceIdx)
val x1013 = {
val x927 = x862.radius
val x925 = x838(x924)
val x926 = x925.radius
val x928 = x926 != x927
val x990 = {
def x990thenb(): Float = {
-1.0f
}
def x990elseb(): Float = {
val x929 = x925.match_list
val x930 = x929.length
val x931 = x930.asInstanceOf[Float]
val x932 = x931==0.0
val x988 = {
def x988thenb(): Float = {
-1.0f
}
def x988elseb(): Float = {
val x933 = x862.match_list
val x934 = x933.length
val x935 = x934.asInstanceOf[Float]
val x936 = x935 / x931
val x937 = x936 < 0.82f
val x986 = {
def x986thenb(): Float = {
x936
}
def x986elseb(): Float = {
var x938: Float = 0.0f
val x939 = x931 * 0.18f
val x940 = x939 + 0.5f
val x941 = x940.asInstanceOf[Int]
var x942: Int = x941
var x943: Int = 0
var x944: Boolean = true
val x945 = x943
val x946 = x945 < x930
val x947 = x944
val x948 = x946 && x947
val x949 = x929(x945)
val x950 = x925.binary_gradients
val x951 = x950(x949)
val x952 = x951==0
val x980 = while ({x948}) {
val x953 = x862.binary_gradients
val x954 = x953(x949)
val x955 = x954==0
val x956 = x952 && x955
val x977 = {
def x977thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x977elseb(): Unit = {
val x961 = x862.binary_gradients
val x962 = x961(x949)
val x963 = x951 & x962
val x964 = x963 > 0
val x975 = {
def x975thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x975elseb(): Unit = {
val x967 = x942
val x968 = x967 - 1
x942 = x968
val x970 = x967 <= 0
val x973 = {
def x973thenb(): Unit = {
x944 = false
()
}
if (x970) {
x973thenb()
}
}
x973
}
if (x964) {
x975thenb()
} else { 
x975elseb()
}
}
x975
}
if (x956) {
x977thenb()
} else { 
x977elseb()
}
}
val x978 = x943 += 1
()
}
val x981 = !x947
val x984 = {
def x984thenb(): Float = {
0.819999f
}
def x984elseb(): Float = {
val x957 = x938
val x982 = x957 / x931
val x983 = x982.asInstanceOf[Float]
x983
}
if (x981) {
x984thenb()
} else { 
x984elseb()
}
}
x984
}
if (x937) {
x986thenb()
} else { 
x986elseb()
}
}
x986
}
if (x932) {
x988thenb()
} else { 
x988elseb()
}
}
x988
}
if (x928) {
x990thenb()
} else { 
x990elseb()
}
}
val x991 = x990 > 0.82f
val x1010 = {
def x1010thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x992 = x925.rect
val x994 = x992.width
val x857 = x844
val x858 = Math.pow(2.0,x857)
val x859 = x858.asInstanceOf[Int]
val x993 = x859 * x856
val x995 = x994 / 2
val x996 = x993 - x995
val x997 = x996.asInstanceOf[Int]
val x999 = x992.height
val x998 = x859 * x852
val x1000 = x999 / 2
val x1001 = x998 - x1000
val x1002 = x1001.asInstanceOf[Int]
val x1003 = new generated.scala.Rect(x997,x1002,x994,x999)
val x1004 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1005 = new generated.scala.BiGGDetection(x837,x990,x1003,null,x924,x856,x852,x925,x862)
val x1006 = x1004(0) = x1005
x1004
}
def x1010elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1008 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1008
}
if (x991) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
x1012 = {
val x1014 = x1012.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1039 = { 
val x1037 = {
def x1037thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1013
}
def x1037elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1015 = x1013.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1035 = {
def x1035thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1012
}
def x1035elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1016 = x1012.length
val x1017 = x1013.length
val x1018 = x1016 + x1017
val x1019 = x1012.isRow
val x1020 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1018,x1019)
var x1022 : Int = 0
val x1026 = while (x1022 < x1016) {
val x1023 = x1012(x1022)
val x1024 = x1020(x1022) = x1023
x1024
x1022 = x1022 + 1
}
var x1028 : Int = 0
val x1033 = while (x1028 < x1017) {
val x1029 = x1028 + x1016
val x1030 = x1013(x1028)
val x1031 = x1020(x1029) = x1030
x1031
x1028 = x1028 + 1
}
x1020
}
if (x1015) {
x1035thenb()
} else { 
x1035elseb()
}
}
x1035
}
if (x1014) {
x1037thenb()
} else { 
x1037elseb()
}
}
x1037
}
x1039
}
mapReduceIdx += 1
} // end mapReduce loop x1040
x1012
}
val x1040 = x1040_block
x1040
}
x1042 = {
val x1044 = x1042.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1069 = { 
val x1067 = {
def x1067thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1043
}
def x1067elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1045 = x1043.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1065 = {
def x1065thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1042
}
def x1065elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = x1042.length
val x1047 = x1043.length
val x1048 = x1046 + x1047
val x1049 = x1042.isRow
val x1050 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1048,x1049)
var x1052 : Int = 0
val x1056 = while (x1052 < x1046) {
val x1053 = x1042(x1052)
val x1054 = x1050(x1052) = x1053
x1054
x1052 = x1052 + 1
}
var x1058 : Int = 0
val x1063 = while (x1058 < x1047) {
val x1059 = x1058 + x1046
val x1060 = x1043(x1058)
val x1061 = x1050(x1059) = x1060
x1061
x1058 = x1058 + 1
}
x1050
}
if (x1045) {
x1065thenb()
} else { 
x1065elseb()
}
}
x1065
}
if (x1044) {
x1067thenb()
} else { 
x1067elseb()
}
}
x1067
}
x1069
}
mapReduceIdx += 1
} // end mapReduce loop x1070
x1042
}
val x1070 = x1070_block
x1070
}
x1072 = {
val x1074 = x1072.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1099 = { 
val x1097 = {
def x1097thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1073
}
def x1097elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1075 = x1073.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1095 = {
def x1095thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1072
}
def x1095elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1076 = x1072.length
val x1077 = x1073.length
val x1078 = x1076 + x1077
val x1079 = x1072.isRow
val x1080 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1078,x1079)
var x1082 : Int = 0
val x1086 = while (x1082 < x1076) {
val x1083 = x1072(x1082)
val x1084 = x1080(x1082) = x1083
x1084
x1082 = x1082 + 1
}
var x1088 : Int = 0
val x1093 = while (x1088 < x1077) {
val x1089 = x1088 + x1076
val x1090 = x1073(x1088)
val x1091 = x1080(x1089) = x1090
x1091
x1088 = x1088 + 1
}
x1080
}
if (x1075) {
x1095thenb()
} else { 
x1095elseb()
}
}
x1095
}
if (x1074) {
x1097thenb()
} else { 
x1097elseb()
}
}
x1097
}
x1099
}
mapReduceIdx += 1
} // end mapReduce loop x1100
x1072
}
val x1100 = x1100_block
val x1101 = x1100.length
val x1102 = "Detections: "+x1101
val x1103 = println(x1102)
x1100
}
var mapReduceIdx = 1
while (mapReduceIdx < x220.size) { // begin mapReduce loop x1133
val x836 = x220.dcApply(mapReduceIdx)
val x1106 = {
val x837 = x836._1
val x839 = "Name: "+x837
val x840 = println(x839)
val x838 = x836._2
val x841 = x838.length
val x842 = "Templates: "+x841
val x843 = println(x842)
val x844 = x705.fixedLevelIndex
val x845 = x705.pyramid
val x846 = x705.start_level
val x847 = x844 - x846
val x848 = x845(x847)
val x849 = x848.numRows
val x850 = x849 - 5
val x851 = new generated.scala.IndexVectorRangeImpl(5,x850)
val x923 = new generated.scala.IndexVectorRangeImpl(0,x841)
def x1100_block = {
val x852 = x851.dcApply(0)
var x1072 = {
val x853 = x848.numCols
val x854 = x853 - 5
val x855 = new generated.scala.IndexVectorRangeImpl(5,x854)
val x883 = x852 + 15
val x875 = x852 - 15
val x876 = x875 < 0
val x880 = {
def x880thenb(): scala.Tuple2[Int, Int] = {
val x877 = 15 - x852
val x878 = (0,x877)
x878
}
def x880elseb(): scala.Tuple2[Int, Int] = {
val x879 = (x875,0)
x879
}
if (x876) {
x880thenb()
} else { 
x880elseb()
}
}
val x881 = x880._1
val x882 = x880._2
def x1070_block = {
val x856 = x855.dcApply(0)
var x1042 = {
val x860 = new generated.scala.IntVectorImpl(900,false)
val x861 = new generated.scala.IndexVectorSeqImpl(0)
val x862 = new generated.scala.BinarizedGradientTemplate(15,null,null,x844,x860,x861,null,null,null)
val x872 = x848.numCols
val x871 = x856 + 15
val x873 = x871 > x872
val x874 = {
def x874thenb(): Int = {
x872
}
def x874elseb(): Int = {
x871
}
if (x873) {
x874thenb()
} else { 
x874elseb()
}
}
val x884 = x848.numRows
val x885 = x883 > x884
val x886 = {
def x886thenb(): Int = {
x884
}
def x886elseb(): Int = {
x883
}
if (x885) {
x886thenb()
} else { 
x886elseb()
}
}
var x887: Int = x881
val x888 = x887
val x889 = x888 < x886
val x863 = x856 - 15
val x864 = x863 < 0
val x868 = {
def x868thenb(): scala.Tuple2[Int, Int] = {
val x865 = 15 - x856
val x866 = (0,x865)
x866
}
def x868elseb(): scala.Tuple2[Int, Int] = {
val x867 = (x863,0)
x867
}
if (x864) {
x868thenb()
} else { 
x868elseb()
}
}
val x869 = x868._1
val x894 = x882 + x888
val x895 = x894 - x881
val x896 = x895 * 30
val x870 = x868._2
val x916 = while ({x889}) {
val x890 = x848.getRow(x888)
var x891: Int = x869
val x892 = x891
val x893 = x892 < x874
val x897 = x870 + x892
val x898 = x897 - x869
val x899 = x896 + x898
val x913 = while ({x893}) {
var x900: Int = x899
val x901 = x862.binary_gradients
val x903 = x890(x892)
val x902 = x900
val x904 = x901(x902) = x903
val x905 = x903 > 0
val x910 = {
def x910thenb(): Unit = {
val x906 = x862.match_list
val x907 = x906.length
val x908 = x906.insert(x907, x902)
x908
}
if (x905) {
x910thenb()
}
}
val x911 = x891 += 1
()
}
val x914 = x887 += 1
()
}
val x917 = x862.match_list
val x918 = x917.length
val x919 = x918 < 0
val x922 = {
def x922thenb(): Unit = {
val x920 = println("dummy")
x920
}
if (x919) {
x922thenb()
}
}
def x1040_block = {
val x924 = x923.dcApply(0)
var x1012 = {
val x927 = x862.radius
val x925 = x838(x924)
val x926 = x925.radius
val x928 = x926 != x927
val x990 = {
def x990thenb(): Float = {
-1.0f
}
def x990elseb(): Float = {
val x929 = x925.match_list
val x930 = x929.length
val x931 = x930.asInstanceOf[Float]
val x932 = x931==0.0
val x988 = {
def x988thenb(): Float = {
-1.0f
}
def x988elseb(): Float = {
val x933 = x862.match_list
val x934 = x933.length
val x935 = x934.asInstanceOf[Float]
val x936 = x935 / x931
val x937 = x936 < 0.82f
val x986 = {
def x986thenb(): Float = {
x936
}
def x986elseb(): Float = {
var x938: Float = 0.0f
val x939 = x931 * 0.18f
val x940 = x939 + 0.5f
val x941 = x940.asInstanceOf[Int]
var x942: Int = x941
var x943: Int = 0
var x944: Boolean = true
val x945 = x943
val x946 = x945 < x930
val x947 = x944
val x948 = x946 && x947
val x949 = x929(x945)
val x950 = x925.binary_gradients
val x951 = x950(x949)
val x952 = x951==0
val x980 = while ({x948}) {
val x953 = x862.binary_gradients
val x954 = x953(x949)
val x955 = x954==0
val x956 = x952 && x955
val x977 = {
def x977thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x977elseb(): Unit = {
val x961 = x862.binary_gradients
val x962 = x961(x949)
val x963 = x951 & x962
val x964 = x963 > 0
val x975 = {
def x975thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x975elseb(): Unit = {
val x967 = x942
val x968 = x967 - 1
x942 = x968
val x970 = x967 <= 0
val x973 = {
def x973thenb(): Unit = {
x944 = false
()
}
if (x970) {
x973thenb()
}
}
x973
}
if (x964) {
x975thenb()
} else { 
x975elseb()
}
}
x975
}
if (x956) {
x977thenb()
} else { 
x977elseb()
}
}
val x978 = x943 += 1
()
}
val x981 = !x947
val x984 = {
def x984thenb(): Float = {
0.819999f
}
def x984elseb(): Float = {
val x957 = x938
val x982 = x957 / x931
val x983 = x982.asInstanceOf[Float]
x983
}
if (x981) {
x984thenb()
} else { 
x984elseb()
}
}
x984
}
if (x937) {
x986thenb()
} else { 
x986elseb()
}
}
x986
}
if (x932) {
x988thenb()
} else { 
x988elseb()
}
}
x988
}
if (x928) {
x990thenb()
} else { 
x990elseb()
}
}
val x991 = x990 > 0.82f
val x1010 = {
def x1010thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x992 = x925.rect
val x994 = x992.width
val x857 = x844
val x858 = Math.pow(2.0,x857)
val x859 = x858.asInstanceOf[Int]
val x993 = x859 * x856
val x995 = x994 / 2
val x996 = x993 - x995
val x997 = x996.asInstanceOf[Int]
val x999 = x992.height
val x998 = x859 * x852
val x1000 = x999 / 2
val x1001 = x998 - x1000
val x1002 = x1001.asInstanceOf[Int]
val x1003 = new generated.scala.Rect(x997,x1002,x994,x999)
val x1004 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1005 = new generated.scala.BiGGDetection(x837,x990,x1003,null,x924,x856,x852,x925,x862)
val x1006 = x1004(0) = x1005
x1004
}
def x1010elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1008 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1008
}
if (x991) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
var mapReduceIdx = 1
while (mapReduceIdx < x923.size) { // begin mapReduce loop x1040
val x924 = x923.dcApply(mapReduceIdx)
val x1013 = {
val x927 = x862.radius
val x925 = x838(x924)
val x926 = x925.radius
val x928 = x926 != x927
val x990 = {
def x990thenb(): Float = {
-1.0f
}
def x990elseb(): Float = {
val x929 = x925.match_list
val x930 = x929.length
val x931 = x930.asInstanceOf[Float]
val x932 = x931==0.0
val x988 = {
def x988thenb(): Float = {
-1.0f
}
def x988elseb(): Float = {
val x933 = x862.match_list
val x934 = x933.length
val x935 = x934.asInstanceOf[Float]
val x936 = x935 / x931
val x937 = x936 < 0.82f
val x986 = {
def x986thenb(): Float = {
x936
}
def x986elseb(): Float = {
var x938: Float = 0.0f
val x939 = x931 * 0.18f
val x940 = x939 + 0.5f
val x941 = x940.asInstanceOf[Int]
var x942: Int = x941
var x943: Int = 0
var x944: Boolean = true
val x945 = x943
val x946 = x945 < x930
val x947 = x944
val x948 = x946 && x947
val x949 = x929(x945)
val x950 = x925.binary_gradients
val x951 = x950(x949)
val x952 = x951==0
val x980 = while ({x948}) {
val x953 = x862.binary_gradients
val x954 = x953(x949)
val x955 = x954==0
val x956 = x952 && x955
val x977 = {
def x977thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x977elseb(): Unit = {
val x961 = x862.binary_gradients
val x962 = x961(x949)
val x963 = x951 & x962
val x964 = x963 > 0
val x975 = {
def x975thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x975elseb(): Unit = {
val x967 = x942
val x968 = x967 - 1
x942 = x968
val x970 = x967 <= 0
val x973 = {
def x973thenb(): Unit = {
x944 = false
()
}
if (x970) {
x973thenb()
}
}
x973
}
if (x964) {
x975thenb()
} else { 
x975elseb()
}
}
x975
}
if (x956) {
x977thenb()
} else { 
x977elseb()
}
}
val x978 = x943 += 1
()
}
val x981 = !x947
val x984 = {
def x984thenb(): Float = {
0.819999f
}
def x984elseb(): Float = {
val x957 = x938
val x982 = x957 / x931
val x983 = x982.asInstanceOf[Float]
x983
}
if (x981) {
x984thenb()
} else { 
x984elseb()
}
}
x984
}
if (x937) {
x986thenb()
} else { 
x986elseb()
}
}
x986
}
if (x932) {
x988thenb()
} else { 
x988elseb()
}
}
x988
}
if (x928) {
x990thenb()
} else { 
x990elseb()
}
}
val x991 = x990 > 0.82f
val x1010 = {
def x1010thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x992 = x925.rect
val x994 = x992.width
val x857 = x844
val x858 = Math.pow(2.0,x857)
val x859 = x858.asInstanceOf[Int]
val x993 = x859 * x856
val x995 = x994 / 2
val x996 = x993 - x995
val x997 = x996.asInstanceOf[Int]
val x999 = x992.height
val x998 = x859 * x852
val x1000 = x999 / 2
val x1001 = x998 - x1000
val x1002 = x1001.asInstanceOf[Int]
val x1003 = new generated.scala.Rect(x997,x1002,x994,x999)
val x1004 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1005 = new generated.scala.BiGGDetection(x837,x990,x1003,null,x924,x856,x852,x925,x862)
val x1006 = x1004(0) = x1005
x1004
}
def x1010elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1008 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1008
}
if (x991) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
x1012 = {
val x1014 = x1012.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1039 = { 
val x1037 = {
def x1037thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1013
}
def x1037elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1015 = x1013.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1035 = {
def x1035thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1012
}
def x1035elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1016 = x1012.length
val x1017 = x1013.length
val x1018 = x1016 + x1017
val x1019 = x1012.isRow
val x1020 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1018,x1019)
var x1022 : Int = 0
val x1026 = while (x1022 < x1016) {
val x1023 = x1012(x1022)
val x1024 = x1020(x1022) = x1023
x1024
x1022 = x1022 + 1
}
var x1028 : Int = 0
val x1033 = while (x1028 < x1017) {
val x1029 = x1028 + x1016
val x1030 = x1013(x1028)
val x1031 = x1020(x1029) = x1030
x1031
x1028 = x1028 + 1
}
x1020
}
if (x1015) {
x1035thenb()
} else { 
x1035elseb()
}
}
x1035
}
if (x1014) {
x1037thenb()
} else { 
x1037elseb()
}
}
x1037
}
x1039
}
mapReduceIdx += 1
} // end mapReduce loop x1040
x1012
}
val x1040 = x1040_block
x1040
}
var mapReduceIdx = 1
while (mapReduceIdx < x855.size) { // begin mapReduce loop x1070
val x856 = x855.dcApply(mapReduceIdx)
val x1043 = {
val x860 = new generated.scala.IntVectorImpl(900,false)
val x861 = new generated.scala.IndexVectorSeqImpl(0)
val x862 = new generated.scala.BinarizedGradientTemplate(15,null,null,x844,x860,x861,null,null,null)
val x872 = x848.numCols
val x871 = x856 + 15
val x873 = x871 > x872
val x874 = {
def x874thenb(): Int = {
x872
}
def x874elseb(): Int = {
x871
}
if (x873) {
x874thenb()
} else { 
x874elseb()
}
}
val x884 = x848.numRows
val x885 = x883 > x884
val x886 = {
def x886thenb(): Int = {
x884
}
def x886elseb(): Int = {
x883
}
if (x885) {
x886thenb()
} else { 
x886elseb()
}
}
var x887: Int = x881
val x888 = x887
val x889 = x888 < x886
val x863 = x856 - 15
val x864 = x863 < 0
val x868 = {
def x868thenb(): scala.Tuple2[Int, Int] = {
val x865 = 15 - x856
val x866 = (0,x865)
x866
}
def x868elseb(): scala.Tuple2[Int, Int] = {
val x867 = (x863,0)
x867
}
if (x864) {
x868thenb()
} else { 
x868elseb()
}
}
val x869 = x868._1
val x894 = x882 + x888
val x895 = x894 - x881
val x896 = x895 * 30
val x870 = x868._2
val x916 = while ({x889}) {
val x890 = x848.getRow(x888)
var x891: Int = x869
val x892 = x891
val x893 = x892 < x874
val x897 = x870 + x892
val x898 = x897 - x869
val x899 = x896 + x898
val x913 = while ({x893}) {
var x900: Int = x899
val x901 = x862.binary_gradients
val x903 = x890(x892)
val x902 = x900
val x904 = x901(x902) = x903
val x905 = x903 > 0
val x910 = {
def x910thenb(): Unit = {
val x906 = x862.match_list
val x907 = x906.length
val x908 = x906.insert(x907, x902)
x908
}
if (x905) {
x910thenb()
}
}
val x911 = x891 += 1
()
}
val x914 = x887 += 1
()
}
val x917 = x862.match_list
val x918 = x917.length
val x919 = x918 < 0
val x922 = {
def x922thenb(): Unit = {
val x920 = println("dummy")
x920
}
if (x919) {
x922thenb()
}
}
def x1040_block = {
val x924 = x923.dcApply(0)
var x1012 = {
val x927 = x862.radius
val x925 = x838(x924)
val x926 = x925.radius
val x928 = x926 != x927
val x990 = {
def x990thenb(): Float = {
-1.0f
}
def x990elseb(): Float = {
val x929 = x925.match_list
val x930 = x929.length
val x931 = x930.asInstanceOf[Float]
val x932 = x931==0.0
val x988 = {
def x988thenb(): Float = {
-1.0f
}
def x988elseb(): Float = {
val x933 = x862.match_list
val x934 = x933.length
val x935 = x934.asInstanceOf[Float]
val x936 = x935 / x931
val x937 = x936 < 0.82f
val x986 = {
def x986thenb(): Float = {
x936
}
def x986elseb(): Float = {
var x938: Float = 0.0f
val x939 = x931 * 0.18f
val x940 = x939 + 0.5f
val x941 = x940.asInstanceOf[Int]
var x942: Int = x941
var x943: Int = 0
var x944: Boolean = true
val x945 = x943
val x946 = x945 < x930
val x947 = x944
val x948 = x946 && x947
val x949 = x929(x945)
val x950 = x925.binary_gradients
val x951 = x950(x949)
val x952 = x951==0
val x980 = while ({x948}) {
val x953 = x862.binary_gradients
val x954 = x953(x949)
val x955 = x954==0
val x956 = x952 && x955
val x977 = {
def x977thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x977elseb(): Unit = {
val x961 = x862.binary_gradients
val x962 = x961(x949)
val x963 = x951 & x962
val x964 = x963 > 0
val x975 = {
def x975thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x975elseb(): Unit = {
val x967 = x942
val x968 = x967 - 1
x942 = x968
val x970 = x967 <= 0
val x973 = {
def x973thenb(): Unit = {
x944 = false
()
}
if (x970) {
x973thenb()
}
}
x973
}
if (x964) {
x975thenb()
} else { 
x975elseb()
}
}
x975
}
if (x956) {
x977thenb()
} else { 
x977elseb()
}
}
val x978 = x943 += 1
()
}
val x981 = !x947
val x984 = {
def x984thenb(): Float = {
0.819999f
}
def x984elseb(): Float = {
val x957 = x938
val x982 = x957 / x931
val x983 = x982.asInstanceOf[Float]
x983
}
if (x981) {
x984thenb()
} else { 
x984elseb()
}
}
x984
}
if (x937) {
x986thenb()
} else { 
x986elseb()
}
}
x986
}
if (x932) {
x988thenb()
} else { 
x988elseb()
}
}
x988
}
if (x928) {
x990thenb()
} else { 
x990elseb()
}
}
val x991 = x990 > 0.82f
val x1010 = {
def x1010thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x992 = x925.rect
val x994 = x992.width
val x857 = x844
val x858 = Math.pow(2.0,x857)
val x859 = x858.asInstanceOf[Int]
val x993 = x859 * x856
val x995 = x994 / 2
val x996 = x993 - x995
val x997 = x996.asInstanceOf[Int]
val x999 = x992.height
val x998 = x859 * x852
val x1000 = x999 / 2
val x1001 = x998 - x1000
val x1002 = x1001.asInstanceOf[Int]
val x1003 = new generated.scala.Rect(x997,x1002,x994,x999)
val x1004 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1005 = new generated.scala.BiGGDetection(x837,x990,x1003,null,x924,x856,x852,x925,x862)
val x1006 = x1004(0) = x1005
x1004
}
def x1010elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1008 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1008
}
if (x991) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
var mapReduceIdx = 1
while (mapReduceIdx < x923.size) { // begin mapReduce loop x1040
val x924 = x923.dcApply(mapReduceIdx)
val x1013 = {
val x927 = x862.radius
val x925 = x838(x924)
val x926 = x925.radius
val x928 = x926 != x927
val x990 = {
def x990thenb(): Float = {
-1.0f
}
def x990elseb(): Float = {
val x929 = x925.match_list
val x930 = x929.length
val x931 = x930.asInstanceOf[Float]
val x932 = x931==0.0
val x988 = {
def x988thenb(): Float = {
-1.0f
}
def x988elseb(): Float = {
val x933 = x862.match_list
val x934 = x933.length
val x935 = x934.asInstanceOf[Float]
val x936 = x935 / x931
val x937 = x936 < 0.82f
val x986 = {
def x986thenb(): Float = {
x936
}
def x986elseb(): Float = {
var x938: Float = 0.0f
val x939 = x931 * 0.18f
val x940 = x939 + 0.5f
val x941 = x940.asInstanceOf[Int]
var x942: Int = x941
var x943: Int = 0
var x944: Boolean = true
val x945 = x943
val x946 = x945 < x930
val x947 = x944
val x948 = x946 && x947
val x949 = x929(x945)
val x950 = x925.binary_gradients
val x951 = x950(x949)
val x952 = x951==0
val x980 = while ({x948}) {
val x953 = x862.binary_gradients
val x954 = x953(x949)
val x955 = x954==0
val x956 = x952 && x955
val x977 = {
def x977thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x977elseb(): Unit = {
val x961 = x862.binary_gradients
val x962 = x961(x949)
val x963 = x951 & x962
val x964 = x963 > 0
val x975 = {
def x975thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x975elseb(): Unit = {
val x967 = x942
val x968 = x967 - 1
x942 = x968
val x970 = x967 <= 0
val x973 = {
def x973thenb(): Unit = {
x944 = false
()
}
if (x970) {
x973thenb()
}
}
x973
}
if (x964) {
x975thenb()
} else { 
x975elseb()
}
}
x975
}
if (x956) {
x977thenb()
} else { 
x977elseb()
}
}
val x978 = x943 += 1
()
}
val x981 = !x947
val x984 = {
def x984thenb(): Float = {
0.819999f
}
def x984elseb(): Float = {
val x957 = x938
val x982 = x957 / x931
val x983 = x982.asInstanceOf[Float]
x983
}
if (x981) {
x984thenb()
} else { 
x984elseb()
}
}
x984
}
if (x937) {
x986thenb()
} else { 
x986elseb()
}
}
x986
}
if (x932) {
x988thenb()
} else { 
x988elseb()
}
}
x988
}
if (x928) {
x990thenb()
} else { 
x990elseb()
}
}
val x991 = x990 > 0.82f
val x1010 = {
def x1010thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x992 = x925.rect
val x994 = x992.width
val x857 = x844
val x858 = Math.pow(2.0,x857)
val x859 = x858.asInstanceOf[Int]
val x993 = x859 * x856
val x995 = x994 / 2
val x996 = x993 - x995
val x997 = x996.asInstanceOf[Int]
val x999 = x992.height
val x998 = x859 * x852
val x1000 = x999 / 2
val x1001 = x998 - x1000
val x1002 = x1001.asInstanceOf[Int]
val x1003 = new generated.scala.Rect(x997,x1002,x994,x999)
val x1004 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1005 = new generated.scala.BiGGDetection(x837,x990,x1003,null,x924,x856,x852,x925,x862)
val x1006 = x1004(0) = x1005
x1004
}
def x1010elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1008 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1008
}
if (x991) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
x1012 = {
val x1014 = x1012.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1039 = { 
val x1037 = {
def x1037thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1013
}
def x1037elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1015 = x1013.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1035 = {
def x1035thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1012
}
def x1035elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1016 = x1012.length
val x1017 = x1013.length
val x1018 = x1016 + x1017
val x1019 = x1012.isRow
val x1020 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1018,x1019)
var x1022 : Int = 0
val x1026 = while (x1022 < x1016) {
val x1023 = x1012(x1022)
val x1024 = x1020(x1022) = x1023
x1024
x1022 = x1022 + 1
}
var x1028 : Int = 0
val x1033 = while (x1028 < x1017) {
val x1029 = x1028 + x1016
val x1030 = x1013(x1028)
val x1031 = x1020(x1029) = x1030
x1031
x1028 = x1028 + 1
}
x1020
}
if (x1015) {
x1035thenb()
} else { 
x1035elseb()
}
}
x1035
}
if (x1014) {
x1037thenb()
} else { 
x1037elseb()
}
}
x1037
}
x1039
}
mapReduceIdx += 1
} // end mapReduce loop x1040
x1012
}
val x1040 = x1040_block
x1040
}
x1042 = {
val x1044 = x1042.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1069 = { 
val x1067 = {
def x1067thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1043
}
def x1067elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1045 = x1043.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1065 = {
def x1065thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1042
}
def x1065elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = x1042.length
val x1047 = x1043.length
val x1048 = x1046 + x1047
val x1049 = x1042.isRow
val x1050 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1048,x1049)
var x1052 : Int = 0
val x1056 = while (x1052 < x1046) {
val x1053 = x1042(x1052)
val x1054 = x1050(x1052) = x1053
x1054
x1052 = x1052 + 1
}
var x1058 : Int = 0
val x1063 = while (x1058 < x1047) {
val x1059 = x1058 + x1046
val x1060 = x1043(x1058)
val x1061 = x1050(x1059) = x1060
x1061
x1058 = x1058 + 1
}
x1050
}
if (x1045) {
x1065thenb()
} else { 
x1065elseb()
}
}
x1065
}
if (x1044) {
x1067thenb()
} else { 
x1067elseb()
}
}
x1067
}
x1069
}
mapReduceIdx += 1
} // end mapReduce loop x1070
x1042
}
val x1070 = x1070_block
x1070
}
var mapReduceIdx = 1
while (mapReduceIdx < x851.size) { // begin mapReduce loop x1100
val x852 = x851.dcApply(mapReduceIdx)
val x1073 = {
val x853 = x848.numCols
val x854 = x853 - 5
val x855 = new generated.scala.IndexVectorRangeImpl(5,x854)
val x883 = x852 + 15
val x875 = x852 - 15
val x876 = x875 < 0
val x880 = {
def x880thenb(): scala.Tuple2[Int, Int] = {
val x877 = 15 - x852
val x878 = (0,x877)
x878
}
def x880elseb(): scala.Tuple2[Int, Int] = {
val x879 = (x875,0)
x879
}
if (x876) {
x880thenb()
} else { 
x880elseb()
}
}
val x881 = x880._1
val x882 = x880._2
def x1070_block = {
val x856 = x855.dcApply(0)
var x1042 = {
val x860 = new generated.scala.IntVectorImpl(900,false)
val x861 = new generated.scala.IndexVectorSeqImpl(0)
val x862 = new generated.scala.BinarizedGradientTemplate(15,null,null,x844,x860,x861,null,null,null)
val x872 = x848.numCols
val x871 = x856 + 15
val x873 = x871 > x872
val x874 = {
def x874thenb(): Int = {
x872
}
def x874elseb(): Int = {
x871
}
if (x873) {
x874thenb()
} else { 
x874elseb()
}
}
val x884 = x848.numRows
val x885 = x883 > x884
val x886 = {
def x886thenb(): Int = {
x884
}
def x886elseb(): Int = {
x883
}
if (x885) {
x886thenb()
} else { 
x886elseb()
}
}
var x887: Int = x881
val x888 = x887
val x889 = x888 < x886
val x863 = x856 - 15
val x864 = x863 < 0
val x868 = {
def x868thenb(): scala.Tuple2[Int, Int] = {
val x865 = 15 - x856
val x866 = (0,x865)
x866
}
def x868elseb(): scala.Tuple2[Int, Int] = {
val x867 = (x863,0)
x867
}
if (x864) {
x868thenb()
} else { 
x868elseb()
}
}
val x869 = x868._1
val x894 = x882 + x888
val x895 = x894 - x881
val x896 = x895 * 30
val x870 = x868._2
val x916 = while ({x889}) {
val x890 = x848.getRow(x888)
var x891: Int = x869
val x892 = x891
val x893 = x892 < x874
val x897 = x870 + x892
val x898 = x897 - x869
val x899 = x896 + x898
val x913 = while ({x893}) {
var x900: Int = x899
val x901 = x862.binary_gradients
val x903 = x890(x892)
val x902 = x900
val x904 = x901(x902) = x903
val x905 = x903 > 0
val x910 = {
def x910thenb(): Unit = {
val x906 = x862.match_list
val x907 = x906.length
val x908 = x906.insert(x907, x902)
x908
}
if (x905) {
x910thenb()
}
}
val x911 = x891 += 1
()
}
val x914 = x887 += 1
()
}
val x917 = x862.match_list
val x918 = x917.length
val x919 = x918 < 0
val x922 = {
def x922thenb(): Unit = {
val x920 = println("dummy")
x920
}
if (x919) {
x922thenb()
}
}
def x1040_block = {
val x924 = x923.dcApply(0)
var x1012 = {
val x927 = x862.radius
val x925 = x838(x924)
val x926 = x925.radius
val x928 = x926 != x927
val x990 = {
def x990thenb(): Float = {
-1.0f
}
def x990elseb(): Float = {
val x929 = x925.match_list
val x930 = x929.length
val x931 = x930.asInstanceOf[Float]
val x932 = x931==0.0
val x988 = {
def x988thenb(): Float = {
-1.0f
}
def x988elseb(): Float = {
val x933 = x862.match_list
val x934 = x933.length
val x935 = x934.asInstanceOf[Float]
val x936 = x935 / x931
val x937 = x936 < 0.82f
val x986 = {
def x986thenb(): Float = {
x936
}
def x986elseb(): Float = {
var x938: Float = 0.0f
val x939 = x931 * 0.18f
val x940 = x939 + 0.5f
val x941 = x940.asInstanceOf[Int]
var x942: Int = x941
var x943: Int = 0
var x944: Boolean = true
val x945 = x943
val x946 = x945 < x930
val x947 = x944
val x948 = x946 && x947
val x949 = x929(x945)
val x950 = x925.binary_gradients
val x951 = x950(x949)
val x952 = x951==0
val x980 = while ({x948}) {
val x953 = x862.binary_gradients
val x954 = x953(x949)
val x955 = x954==0
val x956 = x952 && x955
val x977 = {
def x977thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x977elseb(): Unit = {
val x961 = x862.binary_gradients
val x962 = x961(x949)
val x963 = x951 & x962
val x964 = x963 > 0
val x975 = {
def x975thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x975elseb(): Unit = {
val x967 = x942
val x968 = x967 - 1
x942 = x968
val x970 = x967 <= 0
val x973 = {
def x973thenb(): Unit = {
x944 = false
()
}
if (x970) {
x973thenb()
}
}
x973
}
if (x964) {
x975thenb()
} else { 
x975elseb()
}
}
x975
}
if (x956) {
x977thenb()
} else { 
x977elseb()
}
}
val x978 = x943 += 1
()
}
val x981 = !x947
val x984 = {
def x984thenb(): Float = {
0.819999f
}
def x984elseb(): Float = {
val x957 = x938
val x982 = x957 / x931
val x983 = x982.asInstanceOf[Float]
x983
}
if (x981) {
x984thenb()
} else { 
x984elseb()
}
}
x984
}
if (x937) {
x986thenb()
} else { 
x986elseb()
}
}
x986
}
if (x932) {
x988thenb()
} else { 
x988elseb()
}
}
x988
}
if (x928) {
x990thenb()
} else { 
x990elseb()
}
}
val x991 = x990 > 0.82f
val x1010 = {
def x1010thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x992 = x925.rect
val x994 = x992.width
val x857 = x844
val x858 = Math.pow(2.0,x857)
val x859 = x858.asInstanceOf[Int]
val x993 = x859 * x856
val x995 = x994 / 2
val x996 = x993 - x995
val x997 = x996.asInstanceOf[Int]
val x999 = x992.height
val x998 = x859 * x852
val x1000 = x999 / 2
val x1001 = x998 - x1000
val x1002 = x1001.asInstanceOf[Int]
val x1003 = new generated.scala.Rect(x997,x1002,x994,x999)
val x1004 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1005 = new generated.scala.BiGGDetection(x837,x990,x1003,null,x924,x856,x852,x925,x862)
val x1006 = x1004(0) = x1005
x1004
}
def x1010elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1008 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1008
}
if (x991) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
var mapReduceIdx = 1
while (mapReduceIdx < x923.size) { // begin mapReduce loop x1040
val x924 = x923.dcApply(mapReduceIdx)
val x1013 = {
val x927 = x862.radius
val x925 = x838(x924)
val x926 = x925.radius
val x928 = x926 != x927
val x990 = {
def x990thenb(): Float = {
-1.0f
}
def x990elseb(): Float = {
val x929 = x925.match_list
val x930 = x929.length
val x931 = x930.asInstanceOf[Float]
val x932 = x931==0.0
val x988 = {
def x988thenb(): Float = {
-1.0f
}
def x988elseb(): Float = {
val x933 = x862.match_list
val x934 = x933.length
val x935 = x934.asInstanceOf[Float]
val x936 = x935 / x931
val x937 = x936 < 0.82f
val x986 = {
def x986thenb(): Float = {
x936
}
def x986elseb(): Float = {
var x938: Float = 0.0f
val x939 = x931 * 0.18f
val x940 = x939 + 0.5f
val x941 = x940.asInstanceOf[Int]
var x942: Int = x941
var x943: Int = 0
var x944: Boolean = true
val x945 = x943
val x946 = x945 < x930
val x947 = x944
val x948 = x946 && x947
val x949 = x929(x945)
val x950 = x925.binary_gradients
val x951 = x950(x949)
val x952 = x951==0
val x980 = while ({x948}) {
val x953 = x862.binary_gradients
val x954 = x953(x949)
val x955 = x954==0
val x956 = x952 && x955
val x977 = {
def x977thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x977elseb(): Unit = {
val x961 = x862.binary_gradients
val x962 = x961(x949)
val x963 = x951 & x962
val x964 = x963 > 0
val x975 = {
def x975thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x975elseb(): Unit = {
val x967 = x942
val x968 = x967 - 1
x942 = x968
val x970 = x967 <= 0
val x973 = {
def x973thenb(): Unit = {
x944 = false
()
}
if (x970) {
x973thenb()
}
}
x973
}
if (x964) {
x975thenb()
} else { 
x975elseb()
}
}
x975
}
if (x956) {
x977thenb()
} else { 
x977elseb()
}
}
val x978 = x943 += 1
()
}
val x981 = !x947
val x984 = {
def x984thenb(): Float = {
0.819999f
}
def x984elseb(): Float = {
val x957 = x938
val x982 = x957 / x931
val x983 = x982.asInstanceOf[Float]
x983
}
if (x981) {
x984thenb()
} else { 
x984elseb()
}
}
x984
}
if (x937) {
x986thenb()
} else { 
x986elseb()
}
}
x986
}
if (x932) {
x988thenb()
} else { 
x988elseb()
}
}
x988
}
if (x928) {
x990thenb()
} else { 
x990elseb()
}
}
val x991 = x990 > 0.82f
val x1010 = {
def x1010thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x992 = x925.rect
val x994 = x992.width
val x857 = x844
val x858 = Math.pow(2.0,x857)
val x859 = x858.asInstanceOf[Int]
val x993 = x859 * x856
val x995 = x994 / 2
val x996 = x993 - x995
val x997 = x996.asInstanceOf[Int]
val x999 = x992.height
val x998 = x859 * x852
val x1000 = x999 / 2
val x1001 = x998 - x1000
val x1002 = x1001.asInstanceOf[Int]
val x1003 = new generated.scala.Rect(x997,x1002,x994,x999)
val x1004 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1005 = new generated.scala.BiGGDetection(x837,x990,x1003,null,x924,x856,x852,x925,x862)
val x1006 = x1004(0) = x1005
x1004
}
def x1010elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1008 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1008
}
if (x991) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
x1012 = {
val x1014 = x1012.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1039 = { 
val x1037 = {
def x1037thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1013
}
def x1037elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1015 = x1013.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1035 = {
def x1035thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1012
}
def x1035elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1016 = x1012.length
val x1017 = x1013.length
val x1018 = x1016 + x1017
val x1019 = x1012.isRow
val x1020 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1018,x1019)
var x1022 : Int = 0
val x1026 = while (x1022 < x1016) {
val x1023 = x1012(x1022)
val x1024 = x1020(x1022) = x1023
x1024
x1022 = x1022 + 1
}
var x1028 : Int = 0
val x1033 = while (x1028 < x1017) {
val x1029 = x1028 + x1016
val x1030 = x1013(x1028)
val x1031 = x1020(x1029) = x1030
x1031
x1028 = x1028 + 1
}
x1020
}
if (x1015) {
x1035thenb()
} else { 
x1035elseb()
}
}
x1035
}
if (x1014) {
x1037thenb()
} else { 
x1037elseb()
}
}
x1037
}
x1039
}
mapReduceIdx += 1
} // end mapReduce loop x1040
x1012
}
val x1040 = x1040_block
x1040
}
var mapReduceIdx = 1
while (mapReduceIdx < x855.size) { // begin mapReduce loop x1070
val x856 = x855.dcApply(mapReduceIdx)
val x1043 = {
val x860 = new generated.scala.IntVectorImpl(900,false)
val x861 = new generated.scala.IndexVectorSeqImpl(0)
val x862 = new generated.scala.BinarizedGradientTemplate(15,null,null,x844,x860,x861,null,null,null)
val x872 = x848.numCols
val x871 = x856 + 15
val x873 = x871 > x872
val x874 = {
def x874thenb(): Int = {
x872
}
def x874elseb(): Int = {
x871
}
if (x873) {
x874thenb()
} else { 
x874elseb()
}
}
val x884 = x848.numRows
val x885 = x883 > x884
val x886 = {
def x886thenb(): Int = {
x884
}
def x886elseb(): Int = {
x883
}
if (x885) {
x886thenb()
} else { 
x886elseb()
}
}
var x887: Int = x881
val x888 = x887
val x889 = x888 < x886
val x863 = x856 - 15
val x864 = x863 < 0
val x868 = {
def x868thenb(): scala.Tuple2[Int, Int] = {
val x865 = 15 - x856
val x866 = (0,x865)
x866
}
def x868elseb(): scala.Tuple2[Int, Int] = {
val x867 = (x863,0)
x867
}
if (x864) {
x868thenb()
} else { 
x868elseb()
}
}
val x869 = x868._1
val x894 = x882 + x888
val x895 = x894 - x881
val x896 = x895 * 30
val x870 = x868._2
val x916 = while ({x889}) {
val x890 = x848.getRow(x888)
var x891: Int = x869
val x892 = x891
val x893 = x892 < x874
val x897 = x870 + x892
val x898 = x897 - x869
val x899 = x896 + x898
val x913 = while ({x893}) {
var x900: Int = x899
val x901 = x862.binary_gradients
val x903 = x890(x892)
val x902 = x900
val x904 = x901(x902) = x903
val x905 = x903 > 0
val x910 = {
def x910thenb(): Unit = {
val x906 = x862.match_list
val x907 = x906.length
val x908 = x906.insert(x907, x902)
x908
}
if (x905) {
x910thenb()
}
}
val x911 = x891 += 1
()
}
val x914 = x887 += 1
()
}
val x917 = x862.match_list
val x918 = x917.length
val x919 = x918 < 0
val x922 = {
def x922thenb(): Unit = {
val x920 = println("dummy")
x920
}
if (x919) {
x922thenb()
}
}
def x1040_block = {
val x924 = x923.dcApply(0)
var x1012 = {
val x927 = x862.radius
val x925 = x838(x924)
val x926 = x925.radius
val x928 = x926 != x927
val x990 = {
def x990thenb(): Float = {
-1.0f
}
def x990elseb(): Float = {
val x929 = x925.match_list
val x930 = x929.length
val x931 = x930.asInstanceOf[Float]
val x932 = x931==0.0
val x988 = {
def x988thenb(): Float = {
-1.0f
}
def x988elseb(): Float = {
val x933 = x862.match_list
val x934 = x933.length
val x935 = x934.asInstanceOf[Float]
val x936 = x935 / x931
val x937 = x936 < 0.82f
val x986 = {
def x986thenb(): Float = {
x936
}
def x986elseb(): Float = {
var x938: Float = 0.0f
val x939 = x931 * 0.18f
val x940 = x939 + 0.5f
val x941 = x940.asInstanceOf[Int]
var x942: Int = x941
var x943: Int = 0
var x944: Boolean = true
val x945 = x943
val x946 = x945 < x930
val x947 = x944
val x948 = x946 && x947
val x949 = x929(x945)
val x950 = x925.binary_gradients
val x951 = x950(x949)
val x952 = x951==0
val x980 = while ({x948}) {
val x953 = x862.binary_gradients
val x954 = x953(x949)
val x955 = x954==0
val x956 = x952 && x955
val x977 = {
def x977thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x977elseb(): Unit = {
val x961 = x862.binary_gradients
val x962 = x961(x949)
val x963 = x951 & x962
val x964 = x963 > 0
val x975 = {
def x975thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x975elseb(): Unit = {
val x967 = x942
val x968 = x967 - 1
x942 = x968
val x970 = x967 <= 0
val x973 = {
def x973thenb(): Unit = {
x944 = false
()
}
if (x970) {
x973thenb()
}
}
x973
}
if (x964) {
x975thenb()
} else { 
x975elseb()
}
}
x975
}
if (x956) {
x977thenb()
} else { 
x977elseb()
}
}
val x978 = x943 += 1
()
}
val x981 = !x947
val x984 = {
def x984thenb(): Float = {
0.819999f
}
def x984elseb(): Float = {
val x957 = x938
val x982 = x957 / x931
val x983 = x982.asInstanceOf[Float]
x983
}
if (x981) {
x984thenb()
} else { 
x984elseb()
}
}
x984
}
if (x937) {
x986thenb()
} else { 
x986elseb()
}
}
x986
}
if (x932) {
x988thenb()
} else { 
x988elseb()
}
}
x988
}
if (x928) {
x990thenb()
} else { 
x990elseb()
}
}
val x991 = x990 > 0.82f
val x1010 = {
def x1010thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x992 = x925.rect
val x994 = x992.width
val x857 = x844
val x858 = Math.pow(2.0,x857)
val x859 = x858.asInstanceOf[Int]
val x993 = x859 * x856
val x995 = x994 / 2
val x996 = x993 - x995
val x997 = x996.asInstanceOf[Int]
val x999 = x992.height
val x998 = x859 * x852
val x1000 = x999 / 2
val x1001 = x998 - x1000
val x1002 = x1001.asInstanceOf[Int]
val x1003 = new generated.scala.Rect(x997,x1002,x994,x999)
val x1004 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1005 = new generated.scala.BiGGDetection(x837,x990,x1003,null,x924,x856,x852,x925,x862)
val x1006 = x1004(0) = x1005
x1004
}
def x1010elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1008 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1008
}
if (x991) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
var mapReduceIdx = 1
while (mapReduceIdx < x923.size) { // begin mapReduce loop x1040
val x924 = x923.dcApply(mapReduceIdx)
val x1013 = {
val x927 = x862.radius
val x925 = x838(x924)
val x926 = x925.radius
val x928 = x926 != x927
val x990 = {
def x990thenb(): Float = {
-1.0f
}
def x990elseb(): Float = {
val x929 = x925.match_list
val x930 = x929.length
val x931 = x930.asInstanceOf[Float]
val x932 = x931==0.0
val x988 = {
def x988thenb(): Float = {
-1.0f
}
def x988elseb(): Float = {
val x933 = x862.match_list
val x934 = x933.length
val x935 = x934.asInstanceOf[Float]
val x936 = x935 / x931
val x937 = x936 < 0.82f
val x986 = {
def x986thenb(): Float = {
x936
}
def x986elseb(): Float = {
var x938: Float = 0.0f
val x939 = x931 * 0.18f
val x940 = x939 + 0.5f
val x941 = x940.asInstanceOf[Int]
var x942: Int = x941
var x943: Int = 0
var x944: Boolean = true
val x945 = x943
val x946 = x945 < x930
val x947 = x944
val x948 = x946 && x947
val x949 = x929(x945)
val x950 = x925.binary_gradients
val x951 = x950(x949)
val x952 = x951==0
val x980 = while ({x948}) {
val x953 = x862.binary_gradients
val x954 = x953(x949)
val x955 = x954==0
val x956 = x952 && x955
val x977 = {
def x977thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x977elseb(): Unit = {
val x961 = x862.binary_gradients
val x962 = x961(x949)
val x963 = x951 & x962
val x964 = x963 > 0
val x975 = {
def x975thenb(): Unit = {
val x957 = x938
val x958 = x957 + 1.0f
x938 = x958
()
}
def x975elseb(): Unit = {
val x967 = x942
val x968 = x967 - 1
x942 = x968
val x970 = x967 <= 0
val x973 = {
def x973thenb(): Unit = {
x944 = false
()
}
if (x970) {
x973thenb()
}
}
x973
}
if (x964) {
x975thenb()
} else { 
x975elseb()
}
}
x975
}
if (x956) {
x977thenb()
} else { 
x977elseb()
}
}
val x978 = x943 += 1
()
}
val x981 = !x947
val x984 = {
def x984thenb(): Float = {
0.819999f
}
def x984elseb(): Float = {
val x957 = x938
val x982 = x957 / x931
val x983 = x982.asInstanceOf[Float]
x983
}
if (x981) {
x984thenb()
} else { 
x984elseb()
}
}
x984
}
if (x937) {
x986thenb()
} else { 
x986elseb()
}
}
x986
}
if (x932) {
x988thenb()
} else { 
x988elseb()
}
}
x988
}
if (x928) {
x990thenb()
} else { 
x990elseb()
}
}
val x991 = x990 > 0.82f
val x1010 = {
def x1010thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x992 = x925.rect
val x994 = x992.width
val x857 = x844
val x858 = Math.pow(2.0,x857)
val x859 = x858.asInstanceOf[Int]
val x993 = x859 * x856
val x995 = x994 / 2
val x996 = x993 - x995
val x997 = x996.asInstanceOf[Int]
val x999 = x992.height
val x998 = x859 * x852
val x1000 = x999 / 2
val x1001 = x998 - x1000
val x1002 = x1001.asInstanceOf[Int]
val x1003 = new generated.scala.Rect(x997,x1002,x994,x999)
val x1004 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1005 = new generated.scala.BiGGDetection(x837,x990,x1003,null,x924,x856,x852,x925,x862)
val x1006 = x1004(0) = x1005
x1004
}
def x1010elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1008 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1008
}
if (x991) {
x1010thenb()
} else { 
x1010elseb()
}
}
x1010
}
x1012 = {
val x1014 = x1012.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1039 = { 
val x1037 = {
def x1037thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1013
}
def x1037elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1015 = x1013.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1035 = {
def x1035thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1012
}
def x1035elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1016 = x1012.length
val x1017 = x1013.length
val x1018 = x1016 + x1017
val x1019 = x1012.isRow
val x1020 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1018,x1019)
var x1022 : Int = 0
val x1026 = while (x1022 < x1016) {
val x1023 = x1012(x1022)
val x1024 = x1020(x1022) = x1023
x1024
x1022 = x1022 + 1
}
var x1028 : Int = 0
val x1033 = while (x1028 < x1017) {
val x1029 = x1028 + x1016
val x1030 = x1013(x1028)
val x1031 = x1020(x1029) = x1030
x1031
x1028 = x1028 + 1
}
x1020
}
if (x1015) {
x1035thenb()
} else { 
x1035elseb()
}
}
x1035
}
if (x1014) {
x1037thenb()
} else { 
x1037elseb()
}
}
x1037
}
x1039
}
mapReduceIdx += 1
} // end mapReduce loop x1040
x1012
}
val x1040 = x1040_block
x1040
}
x1042 = {
val x1044 = x1042.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1069 = { 
val x1067 = {
def x1067thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1043
}
def x1067elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1045 = x1043.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1065 = {
def x1065thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1042
}
def x1065elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1046 = x1042.length
val x1047 = x1043.length
val x1048 = x1046 + x1047
val x1049 = x1042.isRow
val x1050 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1048,x1049)
var x1052 : Int = 0
val x1056 = while (x1052 < x1046) {
val x1053 = x1042(x1052)
val x1054 = x1050(x1052) = x1053
x1054
x1052 = x1052 + 1
}
var x1058 : Int = 0
val x1063 = while (x1058 < x1047) {
val x1059 = x1058 + x1046
val x1060 = x1043(x1058)
val x1061 = x1050(x1059) = x1060
x1061
x1058 = x1058 + 1
}
x1050
}
if (x1045) {
x1065thenb()
} else { 
x1065elseb()
}
}
x1065
}
if (x1044) {
x1067thenb()
} else { 
x1067elseb()
}
}
x1067
}
x1069
}
mapReduceIdx += 1
} // end mapReduce loop x1070
x1042
}
val x1070 = x1070_block
x1070
}
x1072 = {
val x1074 = x1072.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1099 = { 
val x1097 = {
def x1097thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1073
}
def x1097elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1075 = x1073.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1095 = {
def x1095thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1072
}
def x1095elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1076 = x1072.length
val x1077 = x1073.length
val x1078 = x1076 + x1077
val x1079 = x1072.isRow
val x1080 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1078,x1079)
var x1082 : Int = 0
val x1086 = while (x1082 < x1076) {
val x1083 = x1072(x1082)
val x1084 = x1080(x1082) = x1083
x1084
x1082 = x1082 + 1
}
var x1088 : Int = 0
val x1093 = while (x1088 < x1077) {
val x1089 = x1088 + x1076
val x1090 = x1073(x1088)
val x1091 = x1080(x1089) = x1090
x1091
x1088 = x1088 + 1
}
x1080
}
if (x1075) {
x1095thenb()
} else { 
x1095elseb()
}
}
x1095
}
if (x1074) {
x1097thenb()
} else { 
x1097elseb()
}
}
x1097
}
x1099
}
mapReduceIdx += 1
} // end mapReduce loop x1100
x1072
}
val x1100 = x1100_block
val x1101 = x1100.length
val x1102 = "Detections: "+x1101
val x1103 = println(x1102)
x1100
}
x1105 = {
val x1107 = x1105.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1132 = { 
val x1130 = {
def x1130thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1106
}
def x1130elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1108 = x1106.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1128 = {
def x1128thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1105
}
def x1128elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1109 = x1105.length
val x1110 = x1106.length
val x1111 = x1109 + x1110
val x1112 = x1105.isRow
val x1113 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1111,x1112)
var x1115 : Int = 0
val x1119 = while (x1115 < x1109) {
val x1116 = x1105(x1115)
val x1117 = x1113(x1115) = x1116
x1117
x1115 = x1115 + 1
}
var x1121 : Int = 0
val x1126 = while (x1121 < x1110) {
val x1122 = x1121 + x1109
val x1123 = x1106(x1121)
val x1124 = x1113(x1122) = x1123
x1124
x1121 = x1121 + 1
}
x1113
}
if (x1108) {
x1128thenb()
} else { 
x1128elseb()
}
}
x1128
}
if (x1107) {
x1130thenb()
} else { 
x1130elseb()
}
}
x1130
}
x1132
}
mapReduceIdx += 1
} // end mapReduce loop x1133
x1105
}
val x1133 = x1133_block
val x1134 = x1133.length
var x1135: Int = x1134
val x1136 = x1135
val x1137 = "Detections before NMS: "+x1136
val x1138 = println(x1137)
var x1139: Int = 0
val x1140 = x1139
val x1141 = x1136 - 1
val x1142 = x1140 < x1141
val x1143 = x1140 + 1
val x1223 = while ({x1142}) {
var x1144: Int = x1143
var x1145: Boolean = false
val x1146 = x1144
val x1147 = x1146 < x1136
val x1148 = x1145
val x1149 = x1148==false
val x1150 = x1147 && x1149
val x1220 = while ({x1150}) {
val x1151 = x1133(x1140)
val x1152 = x1151.roi
val x1153 = x1133(x1146)
val x1154 = x1153.roi
val x1155 = x1152.x
val x1156 = x1154.x
val x1157 = x1154.width
val x1160 = x1152.width
val x1164 = x1152.y
val x1165 = x1152.height
val x1167 = x1154.y
val x1170 = x1154.height
val x1158 = x1156 + x1157
val x1159 = x1155 < x1158
val x1161 = x1155 + x1160
val x1162 = x1161 > x1156
val x1163 = x1159 && x1162
val x1166 = x1164 + x1165
val x1168 = x1166 > x1167
val x1169 = x1163 && x1168
val x1171 = x1167 + x1170
val x1172 = x1164 < x1171
val x1173 = x1169 && x1172
val x1195 = {
def x1195thenb(): Float = {
val x1178 = x1155 > x1156
val x1179 = {
def x1179thenb(): Int = {
x1155
}
def x1179elseb(): Int = {
x1156
}
if (x1178) {
x1179thenb()
} else { 
x1179elseb()
}
}
val x1180 = x1164 > x1167
val x1181 = {
def x1181thenb(): Int = {
x1164
}
def x1181elseb(): Int = {
x1167
}
if (x1180) {
x1181thenb()
} else { 
x1181elseb()
}
}
val x1185 = x1166 < x1171
val x1186 = {
def x1186thenb(): Int = {
x1166
}
def x1186elseb(): Int = {
x1171
}
if (x1185) {
x1186thenb()
} else { 
x1186elseb()
}
}
val x1187 = x1186 - x1181
val x1188 = x1187
val x1189 = 2.0f * x1188
val x1182 = x1161 < x1158
val x1183 = {
def x1183thenb(): Int = {
x1161
}
def x1183elseb(): Int = {
x1158
}
if (x1182) {
x1183thenb()
} else { 
x1183elseb()
}
}
val x1184 = x1183 - x1179
val x1190 = x1184
val x1191 = x1189 * x1190
val x1174 = x1170 * x1157
val x1175 = x1160 * x1165
val x1176 = x1174 + x1175
val x1177 = x1176
val x1192 = x1177 + 1.0E-6f
val x1193 = x1191 / x1192
x1193
}
def x1195elseb(): Float = {
0.0f
}
if (x1173) {
x1195thenb()
} else { 
x1195elseb()
}
}
val x1196 = x1195 > 0.6f
val x1217 = {
def x1217thenb(): Unit = {
val x1197 = x1151.score
val x1198 = x1153.score
val x1199 = x1197 >= x1198
val x1215 = {
def x1215thenb(): Unit = {
val x1200 = x1133(x1141)
val x1201 = x1133(x1141) = x1153
val x1202 = x1133(x1146) = x1200
x1135 = x1141
val x1204 = x1146 - 1
x1144 = x1204
()
}
def x1215elseb(): Unit = {
val x1207 = x1133(x1141)
val x1208 = x1133(x1141) = x1151
val x1209 = x1133(x1140) = x1207
x1135 = x1141
val x1211 = x1140 - 1
x1139 = x1211
x1145 = true
()
}
if (x1199) {
x1215thenb()
} else { 
x1215elseb()
}
}
x1215
}
if (x1196) {
x1217thenb()
}
}
val x1218 = x1144 += 1
()
}
val x1221 = x1139 += 1
()
}
val x1224 = x1136 - 0
val x1235 = { 
val x1225 = x1133.isRow
val x1226 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1224,x1225)
var x1228 : Int = 0
val x1233 = while (x1228 < x1136) {
val x1230 = x1133(x1228)
val x1229 = x1228 - 0
val x1231 = x1226(x1229) = x1230
x1231
x1228 = x1228 + 1
}
x1226
}
val x1236 = x1235.length
val x1237 = "Total detections: "+x1236
val x1238 = println(x1237)
val x1239 = x223 += 1
()
}
val x1242 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
