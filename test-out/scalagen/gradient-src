/*****************************************
  Emitting Generated Code                  
*******************************************/
class gradientRunner extends ((Array[java.lang.String])=>(Unit)) {
def apply(x0:Array[java.lang.String]): Unit = {
val x1 = x0(0)
val x54 = { 
val x2 = new java.io.FileReader(x1)
val x3 = new java.io.BufferedReader(x2)
val x4 = x3.readLine()
var x5: java.lang.String = x4
val x6 = x5
val x7 = x6.trim()
x5 = x7
val x9 = x5
val x10 = x9.split("\\s+")
var x11: Array[java.lang.String] = x10
val x12 = x11
val x13 = x12.length
val x14 = new generated.scala.IntMatrixImpl(0,x13)
val x50 = while ({val x15 = x5
val x16 = x15 != null
x16}) {
val x18 = x11
val x19 = x18.length
val x20 = new generated.scala.IntVectorImpl(x19,true)
var x21: Int = 0
val x35 = while ({val x22 = x21
val x23 = x11
val x24 = x23.length
val x25 = x22 < x24
x25}) {
val x27 = x21
val x28 = x11
val x29 = x21
val x30 = x28(x29)
val x31 = java.lang.Integer.parseInt(x30)
val x32 = x20(x27) = x31
val x33 = x21 += 1
()
}
val x36 = x14.numRows
val x37 = x14.insertRow(x36,x20)
val x38 = x3.readLine()
x5 = x38
val x40 = x5
val x41 = x40 != null
val x48 = {
def x48thenb(): Unit = {
val x42 = x40.trim()
x5 = x42
val x44 = x5
val x45 = x44.split("\\s+")
x11 = x45
()
}
def x48elseb(): Unit = {
()
}
if (x41) {
x48thenb()
} else {
x48elseb()
}
}
x48
}
val x51 = x3.close()
val x52 = new generated.scala.GrayscaleImageImpl(x14)
x52
}
val x55 = x0(1)
val x229 = { 
val x56 = new generated.scala.VectorImpl[java.lang.String](0,true)
val x57 = new java.io.File(x55)
val x58 = x57.getCanonicalFile()
val x59 = x58.listFiles()
val x65=x59.foreach{
x60 => 
val x62 = x56.length
val x61 = x60.getPath()
val x63 = x56.insert(x62, x61)
x63
}
def x227_block = {
val x223 = x56.length
val x224 = x56.isRow
val x225 = new generated.scala.VectorImpl[scala.Tuple2[java.lang.String, generated.scala.Vector[generated.scala.BinarizedGradientTemplate]]](x223,x224)
var mapIdx = 0
while (mapIdx < x56.size) { // begin map loop x227
val x66 = x56.dcApply(mapIdx)
x225.dcUpdate(mapIdx,  {
val x67 = "Loading model: "+x66
val x68 = println(x67)
val x69 = new generated.scala.VectorImpl[generated.scala.BinarizedGradientTemplate](0,true)
val x70 = new java.io.FileReader(x66)
val x71 = new java.io.BufferedReader(x70)
val x72 = x71.readLine()
val x73 = x72 != "bigg_object:"
val x76 = {
def x76thenb(): Nothing = {
val x74 = error("Illegal data format")
x74
}
def x76elseb(): Unit = {
()
}
if (x73) {
x76thenb()
} else {
x76elseb()
}
}
val x77 = x71.readLine()
val x78 = x71.readLine()
val x79 = x78.trim()
val x80 = x79.split(" ")
val x81 = x80(0)
val x82 = x81 != "obj_name/obj_num/num_objs:"
val x85 = {
def x85thenb(): Nothing = {
val x83 = error("Illegal data format")
x83
}
def x85elseb(): Unit = {
()
}
if (x82) {
x85thenb()
} else {
x85elseb()
}
}
var x90: Int = 0
val x88 = x80(3)
val x89 = java.lang.Integer.parseInt(x88)
val x220 = while ({val x91 = x90
val x92 = x91 < x89
x92}) {
val x94 = x71.readLine()
val x95 = x94.trim()
val x96 = x95 != "====OneBiGG====:"
val x99 = {
def x99thenb(): Nothing = {
val x97 = error("Illegal data format")
x97
}
def x99elseb(): Unit = {
()
}
if (x96) {
x99thenb()
} else {
x99elseb()
}
}
val x100 = x71.readLine()
val x101 = x100.trim()
val x102 = x101.split(" ")
var x103: Array[java.lang.String] = x102
val x104 = x103
val x105 = x104(0)
val x106 = x105 != "view/radius/reduction:"
val x109 = {
def x109thenb(): Nothing = {
val x107 = error("Illegal data format")
x107
}
def x109elseb(): Unit = {
()
}
if (x106) {
x109thenb()
} else {
x109elseb()
}
}
val x110 = x103
val x117 = x71.readLine()
val x118 = x117.trim()
val x119 = x118.split(" ")
x103 = x119
val x121 = x103
val x122 = x121(0)
val x123 = x122 != "Gradients:"
val x126 = {
def x126thenb(): Nothing = {
val x124 = error("Illegal data format")
x124
}
def x126elseb(): Unit = {
()
}
if (x123) {
x126thenb()
} else {
x126elseb()
}
}
val x127 = x103
val x128 = x127(1)
val x129 = java.lang.Integer.parseInt(x128)
val x130 = new generated.scala.IntVectorImpl(x129,true)
val x131 = x71.readLine()
var x134: Int = 0
val x132 = x131.trim()
val x133 = x132.split(" ")
val x145 = while ({val x135 = x134
val x136 = x135 < x129
x136}) {
val x138 = x134
val x139 = x134
val x140 = x133(x139)
val x141 = java.lang.Integer.parseInt(x140)
val x142 = x130(x138) = x141
val x143 = x134 += 1
()
}
val x146 = x71.readLine()
val x147 = x146.trim()
val x148 = x147.split(" ")
x103 = x148
val x150 = x103
val x151 = x150(0)
val x152 = x151 != "Match_list:"
val x155 = {
def x155thenb(): Nothing = {
val x153 = error("Illegal data format")
x153
}
def x155elseb(): Unit = {
()
}
if (x152) {
x155thenb()
} else {
x155elseb()
}
}
val x156 = x103
val x159 = new generated.scala.IntVectorImpl(0,true)
val x160 = new generated.scala.IndexVectorSeqImpl(x159)
val x161 = x71.readLine()
x134 = 0
val x157 = x156(1)
val x158 = java.lang.Integer.parseInt(x157)
val x162 = x161.trim()
val x163 = x162.split(" ")
val x175 = while ({val x165 = x134
val x166 = x165 < x158
x166}) {
val x168 = x134
val x171 = x160.length
val x169 = x163(x168)
val x170 = java.lang.Integer.parseInt(x169)
val x172 = x160.insert(x171, x170)
val x173 = x134 += 1
()
}
val x176 = x71.readLine()
val x177 = x176.trim()
val x178 = x177.split(" ")
x103 = x178
val x180 = x103
val x181 = x180(0)
val x182 = x181 != "Occlusions:"
val x185 = {
def x185thenb(): Nothing = {
val x183 = error("Illegal data format")
x183
}
def x185elseb(): Unit = {
()
}
if (x182) {
x185thenb()
} else {
x185elseb()
}
}
val x186 = x103
val x189 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](0,true)
val x190 = x71.readLine()
val x187 = x186(1)
val x188 = java.lang.Integer.parseInt(x187)
val x193 = x188 != 0
val x196 = {
def x196thenb(): Nothing = {
val x194 = error("Occlusions not supported.")
x194
}
def x196elseb(): Unit = {
()
}
if (x193) {
x196thenb()
} else {
x196elseb()
}
}
val x197 = x71.readLine()
val x198 = x197.trim()
val x199 = x198 != "BoundingBox:"
val x202 = {
def x202thenb(): Nothing = {
val x200 = error("Illegal data format")
x200
}
def x202elseb(): Unit = {
()
}
if (x199) {
x202thenb()
} else {
x202elseb()
}
}
val x203 = x71.readLine()
val x204 = x203.trim()
val x205 = x204.split(" ")
val x206 = x205(0)
val x207 = java.lang.Integer.parseInt(x206)
val x208 = x205(1)
val x209 = java.lang.Integer.parseInt(x208)
val x210 = x205(2)
val x211 = java.lang.Integer.parseInt(x210)
val x212 = x205(3)
val x213 = java.lang.Integer.parseInt(x212)
val x214 = new generated.scala.Rect(x207,x209,x211,x213)
val x113 = x110(2)
val x114 = java.lang.Integer.parseInt(x113)
val x215 = new generated.scala.BinarizedGradientTemplate(x114,x214,null,0,x130,x160,x189,null,null)
val x216 = x69.length
val x217 = x69.insert(x216, x215)
val x218 = x90 += 1
()
}
val x86 = x80(1)
val x221 = (x86,x69)
x221
})
mapIdx += 1
} // end map loop x227
x225
}
val x227 = x227_block
x227
}
val x230 = Seq()
val x231 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
var x232: Int = 0
val x266 = x54.numRows
val x267 = new generated.scala.IndexVectorRangeImpl(0,x266)
val x268 = x54.numCols
val x269 = new generated.scala.IndexVectorRangeImpl(0,x268)
val x270 = new generated.scala.IndexVector2Impl(x267,x269)
val x271 = x270.rowInd
val x272 = x271.length
val x276 = x270.colInd
val x334 = x276.length
val x335 = x276.isRow
val x519 = Math.Pi
val x572 = 2 / 2
val x1300 = while ({val x233 = x232
val x234 = x233 < 3
x234}) {
val x236 = new generated.scala.IntMatrixImpl(3,3)
val x237 = x236(0, 0) = -3
val x238 = x236(0, 1) = -10
val x239 = x236(0, 2) = -3
val x240 = x236(2, 0) = 3
val x241 = x236(2, 1) = 10
val x242 = x236(2, 2) = 3
val x259 = { 
val x243 = x236.numCols
val x244 = x236.numRows
val x245 = new generated.scala.IntMatrixImpl(x243,x244)
val x246 = x245.numRows
var x248 : Int = 0
val x257 = while (x248 < x246) {
val x249 = x245.numCols
var x251 : Int = 0
val x255 = while (x251 < x249) {
val x252 = x236(x251, x248)
val x253 = x245(x248, x251) = x252
x253
x251 = x251 + 1
}
x255
x248 = x248 + 1
}
x245
}
val x260 = x259.numRows
val x262 = x260 - 1
val x263 = x262 / 2
val x279 = x266 - x263
val x261 = x259.numCols
val x264 = x261 - 1
val x265 = x264 / 2
val x284 = x268 - x265
def x339_block = {
val x273 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](x272,true)
var mapIdx = 0
while (mapIdx < x271.size) { // begin map loop x339
val x275 = x271.dcApply(mapIdx)
x273.dcUpdate(mapIdx,  {
val x278 = x275 >= x263
val x280 = x275 < x279
val x281 = x278 && x280
def x338_block = {
val x336 = new generated.scala.IntVectorImpl(x334,x335)
var mapIdx = 0
while (mapIdx < x276.size) { // begin map loop x338
val x277 = x276.dcApply(mapIdx)
x336.dcUpdate(mapIdx,  {
val x282 = x277 >= x265
val x283 = x281 && x282
val x285 = x277 < x284
val x286 = x283 && x285
val x333 = {
def x333thenb(): Int = {
val x287 = x275 - x263
val x288 = x275 + x263
val x289 = x288 + 1
val x293 = x289 - x287
val x290 = x277 - x265
val x291 = x277 + x265
val x292 = x291 + 1
val x294 = x292 - x290
val x319 = { 
val x295 = new generated.scala.IntMatrixImpl(x293,x294)
var x296: Int = x287
val x317 = while ({val x297 = x296
val x298 = x297 < x289
x298}) {
var x300: Int = x290
val x314 = while ({val x301 = x300
val x302 = x301 < x292
x302}) {
val x304 = x296
val x306 = x300
val x308 = x296
val x309 = x300
val x305 = x304 - x287
val x307 = x306 - x290
val x310 = x54(x308, x309)
val x311 = x295(x305, x307) = x310
val x312 = x300 += 1
()
}
val x315 = x296 += 1
()
}
x295
}
val x320 = x319.numRows
val x321 = x319.numCols
def x327_block = {
val x322 = new generated.scala.IntMatrixImpl(x320,x321)
var zipIdx = 0
while (zipIdx < x319.size) { // begin zip loop x327
val x324 = x319.dcApply(zipIdx)
val x325 = x259.dcApply(zipIdx)
x322.dcUpdate(zipIdx,  {
val x326 = x324 * x325
x326
})
zipIdx += 1
} // end zip loop x327
x322
}
val x327 = x327_block
def x331_block = {
var x328 = x327.dcApply(0)
var reduceIdx = 1
while (reduceIdx < x327.size) { // begin reduce loop x331
val x329 = x327.dcApply(reduceIdx)
x328 = {
val x330 = x328 + x329
x330
}
reduceIdx += 1
} // end reduce loop x331
x328
}
val x331 = x331_block
x331
}
def x333elseb(): Int = {
val x332 = 0.asInstanceOf[Int]
x332
}
if (x286) {
x333thenb()
} else {
x333elseb()
}
}
x333
})
mapIdx += 1
} // end map loop x338
x336
}
val x338 = x338_block
x338
})
mapIdx += 1
} // end map loop x339
x273
}
val x339 = x339_block
val x340 = x339.length
val x341 = x340==0
val x375 = { 
val x373 = {
def x373thenb(): generated.scala.Matrix[Int] = {
val x342 = new generated.scala.IntMatrixImpl(0,0)
x342
}
def x373elseb(): generated.scala.Matrix[Int] = {
val x344 = x339(0)
val x345 = x344.isRow
val x371 = {
def x371thenb(): generated.scala.Matrix[Int] = {
val x346 = x344.length
val x347 = new generated.scala.IntMatrixImpl(x340,x346)
var x349 : Int = 0
val x358 = while (x349 < x340) {
val x352 = x339(x349)
var x351 : Int = 0
val x356 = while (x351 < x346) {
val x353 = x352(x351)
val x354 = x347(x349, x351) = x353
x354
x351 = x351 + 1
}
x356
x349 = x349 + 1
}
x347
}
def x371elseb(): generated.scala.Matrix[Int] = {
val x346 = x344.length
val x360 = new generated.scala.IntMatrixImpl(x346,x340)
var x361 : Int = 0
val x369 = while (x361 < x340) {
val x363 = x339(x361)
var x362 : Int = 0
val x367 = while (x362 < x346) {
val x364 = x363(x362)
val x365 = x360(x362, x361) = x364
x365
x362 = x362 + 1
}
x367
x361 = x361 + 1
}
x360
}
if (x345) {
x371thenb()
} else {
x371elseb()
}
}
x371
}
if (x341) {
x373thenb()
} else {
x373elseb()
}
}
x373
}
val x376 = new generated.scala.IntImageImpl(x375)
val x377 = x236.numRows
val x378 = x236.numCols
val x379 = x377 - 1
val x380 = x379 / 2
val x388 = x266 - x380
val x381 = x378 - 1
val x382 = x381 / 2
val x393 = x268 - x382
def x447_block = {
val x383 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](x272,true)
var mapIdx = 0
while (mapIdx < x271.size) { // begin map loop x447
val x385 = x271.dcApply(mapIdx)
x383.dcUpdate(mapIdx,  {
val x387 = x385 >= x380
val x389 = x385 < x388
val x390 = x387 && x389
def x446_block = {
val x444 = new generated.scala.IntVectorImpl(x334,x335)
var mapIdx = 0
while (mapIdx < x276.size) { // begin map loop x446
val x386 = x276.dcApply(mapIdx)
x444.dcUpdate(mapIdx,  {
val x391 = x386 >= x382
val x392 = x390 && x391
val x394 = x386 < x393
val x395 = x392 && x394
val x442 = {
def x442thenb(): Int = {
val x396 = x385 - x380
val x397 = x385 + x380
val x398 = x397 + 1
val x402 = x398 - x396
val x399 = x386 - x382
val x400 = x386 + x382
val x401 = x400 + 1
val x403 = x401 - x399
val x428 = { 
val x404 = new generated.scala.IntMatrixImpl(x402,x403)
var x405: Int = x396
val x426 = while ({val x406 = x405
val x407 = x406 < x398
x407}) {
var x409: Int = x399
val x423 = while ({val x410 = x409
val x411 = x410 < x401
x411}) {
val x413 = x405
val x415 = x409
val x417 = x405
val x418 = x409
val x414 = x413 - x396
val x416 = x415 - x399
val x419 = x54(x417, x418)
val x420 = x404(x414, x416) = x419
val x421 = x409 += 1
()
}
val x424 = x405 += 1
()
}
x404
}
val x429 = x428.numRows
val x430 = x428.numCols
def x436_block = {
val x431 = new generated.scala.IntMatrixImpl(x429,x430)
var zipIdx = 0
while (zipIdx < x428.size) { // begin zip loop x436
val x433 = x428.dcApply(zipIdx)
val x434 = x236.dcApply(zipIdx)
x431.dcUpdate(zipIdx,  {
val x435 = x433 * x434
x435
})
zipIdx += 1
} // end zip loop x436
x431
}
val x436 = x436_block
def x440_block = {
var x437 = x436.dcApply(0)
var reduceIdx = 1
while (reduceIdx < x436.size) { // begin reduce loop x440
val x438 = x436.dcApply(reduceIdx)
x437 = {
val x439 = x437 + x438
x439
}
reduceIdx += 1
} // end reduce loop x440
x437
}
val x440 = x440_block
x440
}
def x442elseb(): Int = {
val x332 = 0.asInstanceOf[Int]
x332
}
if (x395) {
x442thenb()
} else {
x442elseb()
}
}
x442
})
mapIdx += 1
} // end map loop x446
x444
}
val x446 = x446_block
x446
})
mapIdx += 1
} // end map loop x447
x383
}
val x447 = x447_block
val x448 = x447.length
val x449 = x448==0
val x483 = { 
val x481 = {
def x481thenb(): generated.scala.Matrix[Int] = {
val x450 = new generated.scala.IntMatrixImpl(0,0)
x450
}
def x481elseb(): generated.scala.Matrix[Int] = {
val x452 = x447(0)
val x453 = x452.isRow
val x479 = {
def x479thenb(): generated.scala.Matrix[Int] = {
val x454 = x452.length
val x455 = new generated.scala.IntMatrixImpl(x448,x454)
var x457 : Int = 0
val x466 = while (x457 < x448) {
val x460 = x447(x457)
var x459 : Int = 0
val x464 = while (x459 < x454) {
val x461 = x460(x459)
val x462 = x455(x457, x459) = x461
x462
x459 = x459 + 1
}
x464
x457 = x457 + 1
}
x455
}
def x479elseb(): generated.scala.Matrix[Int] = {
val x454 = x452.length
val x468 = new generated.scala.IntMatrixImpl(x454,x448)
var x469 : Int = 0
val x477 = while (x469 < x448) {
val x471 = x447(x469)
var x470 : Int = 0
val x475 = while (x470 < x454) {
val x472 = x471(x470)
val x473 = x468(x470, x469) = x472
x473
x470 = x470 + 1
}
x475
x469 = x469 + 1
}
x468
}
if (x453) {
x479thenb()
} else {
x479elseb()
}
}
x479
}
if (x449) {
x481thenb()
} else {
x481elseb()
}
}
x481
}
val x484 = new generated.scala.IntImageImpl(x483)
val x487 = x376.numRows
val x488 = x376.numCols
def x491_block = {
val x489 = new generated.scala.FloatMatrixImpl(x487,x488)
var mapIdx = 0
while (mapIdx < x376.size) { // begin map loop x491
val x485 = x376.dcApply(mapIdx)
x489.dcUpdate(mapIdx,  {
val x486 = x485
x486
})
mapIdx += 1
} // end map loop x491
x489
}
val x491 = x491_block
val x494 = x484.numRows
val x495 = x484.numCols
def x498_block = {
val x496 = new generated.scala.FloatMatrixImpl(x494,x495)
var mapIdx = 0
while (mapIdx < x484.size) { // begin map loop x498
val x492 = x484.dcApply(mapIdx)
x496.dcUpdate(mapIdx,  {
val x493 = x492
x493
})
mapIdx += 1
} // end map loop x498
x496
}
val x498 = x498_block
val x499 = x491.numRows
val x500 = x491.numCols
def x522_block = {
val x511 = new generated.scala.FloatMatrixImpl(x499,x500)
var zipIdx = 0
while (zipIdx < x491.size) { // begin zip loop x522
val x513 = x491.dcApply(zipIdx)
val x514 = x498.dcApply(zipIdx)
x511.dcUpdate(zipIdx,  {
val x515 = x514
val x516 = x513
val x517 = Math.atan2(x515, x516)
val x518 = x517 * 180.0
val x520 = x518 / x519
val x521 = x520.asInstanceOf[Float]
x521
})
zipIdx += 1
} // end zip loop x522
x511
}
val x522 = x522_block
def x527_block = {
var mapIdx = 0
while (mapIdx < x522.size) { // begin map loop x527
val x523 = x522.dcApply(mapIdx)
x522.dcUpdate(mapIdx,  {
val x524 = x523 < 0.0f
val x526 = {
def x526thenb(): Float = {
val x525 = x523 + 360.0f
x525
}
def x526elseb(): Float = {
x523
}
if (x524) {
x526thenb()
} else {
x526elseb()
}
}
x526
})
mapIdx += 1
} // end map loop x527
x522
}
val x527 = x527_block
def x528_block = {
val x501 = new generated.scala.FloatMatrixImpl(x499,x500)
var zipIdx = 0
while (zipIdx < x491.size) { // begin zip loop x528
val x503 = x491.dcApply(zipIdx)
val x504 = x498.dcApply(zipIdx)
x501.dcUpdate(zipIdx,  {
val x505 = x503 * x503
val x506 = x504 * x504
val x507 = x505 + x506
val x508 = x507
val x509 = Math.sqrt(x508)
val x510 = x509.asInstanceOf[Float]
x510
})
zipIdx += 1
} // end zip loop x528
x501
}
val x528 = x528_block
val x550 = x528.numRows
val x551 = x528.numCols
def x554_block = {
val x552 = new generated.scala.IntMatrixImpl(x550,x551)
var zipIdx = 0
while (zipIdx < x528.size) { // begin zip loop x554
val x530 = x528.dcApply(zipIdx)
val x531 = x527.dcApply(zipIdx)
x552.dcUpdate(zipIdx,  {
val x532 = x530 >= 200.0f
val x548 = {
def x548thenb(): Int = {
var x533: Float = x531
val x534 = x533
val x535 = x534 >= 180.0f
val x539 = {
def x539thenb(): Unit = {
val x536 = x534 - 180.0f
x533 = x536
()
}
def x539elseb(): Unit = {
()
}
if (x535) {
x539thenb()
} else {
x539elseb()
}
}
val x540 = x533
val x541 = x540.asInstanceOf[Double]
val x542 = x541 / 22.5
val x543 = x542.asInstanceOf[Int]
val x544 = x543
val x545 = Math.pow(2.0,x544)
val x546 = x545.asInstanceOf[Int]
x546
}
def x548elseb(): Int = {
0
}
if (x532) {
x548thenb()
} else {
x548elseb()
}
}
x548
})
zipIdx += 1
} // end zip loop x554
x552
}
val x554 = x554_block
val x555 = new generated.scala.GrayscaleImageImpl(x554)
val x556 = x555.getRow(0)
def x558_block = {
var mapIdx = 0
while (mapIdx < x556.size) { // begin map loop x558
val x557 = x556.dcApply(mapIdx)
x556.dcUpdate(mapIdx,  {
0
})
mapIdx += 1
} // end map loop x558
x556
}
val x558 = x558_block
val x559 = x555.numRows
val x560 = x559 - 1
val x561 = x555.getRow(x560)
def x563_block = {
var mapIdx = 0
while (mapIdx < x561.size) { // begin map loop x563
val x562 = x561.dcApply(mapIdx)
x561.dcUpdate(mapIdx,  {
0
})
mapIdx += 1
} // end map loop x563
x561
}
val x563 = x563_block
val x564 = x555.getCol(0)
def x566_block = {
var mapIdx = 0
while (mapIdx < x564.size) { // begin map loop x566
val x565 = x564.dcApply(mapIdx)
x564.dcUpdate(mapIdx,  {
0
})
mapIdx += 1
} // end map loop x566
x564
}
val x566 = x566_block
val x567 = x555.numCols
val x568 = x567 - 1
val x569 = x555.getCol(x568)
def x571_block = {
var mapIdx = 0
while (mapIdx < x569.size) { // begin map loop x571
val x570 = x569.dcApply(mapIdx)
x569.dcUpdate(mapIdx,  {
0
})
mapIdx += 1
} // end map loop x571
x569
}
val x571 = x571_block
val x573 = new generated.scala.IndexVectorRangeImpl(0,x559)
val x574 = new generated.scala.IndexVectorRangeImpl(0,x567)
val x575 = new generated.scala.IndexVector2Impl(x573,x574)
val x576 = x575.rowInd
val x577 = x576.length
val x581 = x575.colInd
val x584 = x559 - x572
val x589 = x567 - x572
val x681 = x581.length
val x682 = x581.isRow
def x686_block = {
val x578 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](x577,true)
var mapIdx = 0
while (mapIdx < x576.size) { // begin map loop x686
val x580 = x576.dcApply(mapIdx)
x578.dcUpdate(mapIdx,  {
val x583 = x580 >= x572
val x585 = x580 < x584
val x586 = x583 && x585
def x685_block = {
val x683 = new generated.scala.IntVectorImpl(x681,x682)
var mapIdx = 0
while (mapIdx < x581.size) { // begin map loop x685
val x582 = x581.dcApply(mapIdx)
x683.dcUpdate(mapIdx,  {
val x587 = x582 >= x572
val x588 = x586 && x587
val x590 = x582 < x589
val x591 = x588 && x590
val x679 = {
def x679thenb(): Int = {
val x625 = new generated.scala.IntVectorImpl(256,true)
var x626: Int = 0
val x592 = x580 - x572
val x593 = x580 + x572
val x594 = x593 + 1
val x598 = x594 - x592
val x595 = x582 - x572
val x596 = x582 + x572
val x597 = x596 + 1
val x599 = x597 - x595
val x624 = { 
val x600 = new generated.scala.IntMatrixImpl(x598,x599)
var x601: Int = x592
val x622 = while ({val x602 = x601
val x603 = x602 < x594
x603}) {
var x605: Int = x595
val x619 = while ({val x606 = x605
val x607 = x606 < x597
x607}) {
val x609 = x601
val x611 = x605
val x613 = x601
val x614 = x605
val x610 = x609 - x592
val x612 = x611 - x595
val x615 = x555(x613, x614)
val x616 = x600(x610, x612) = x615
val x617 = x605 += 1
()
}
val x620 = x601 += 1
()
}
x600
}
val x628 = x624.numRows
val x633 = x624.numCols
val x650 = while ({val x627 = x626
val x629 = x627 < x628
x629}) {
var x631: Int = 0
val x647 = while ({val x632 = x631
val x634 = x632 < x633
x634}) {
val x636 = x626
val x637 = x631
val x639 = x626
val x640 = x631
val x641 = x624(x639, x640)
val x642 = x625(x641)
val x638 = x624(x636, x637)
val x643 = x642 + 1
val x644 = x625(x638) = x643
val x645 = x631 += 1
()
}
val x648 = x626 += 1
()
}
var x651: Int = 2
val x652 = x625(1)
var x653: Int = x652
var x654: Int = 1
val x672 = while ({val x655 = x651
val x656 = x625.length
val x657 = x655 < x656
x657}) {
val x659 = x651
val x660 = x625(x659)
val x661 = x653
val x662 = x660 > x661
val x669 = {
def x669thenb(): Unit = {
val x663 = x651
val x664 = x625(x663)
x653 = x664
val x666 = x651
x654 = x666
()
}
def x669elseb(): Unit = {
()
}
if (x662) {
x669thenb()
} else {
x669elseb()
}
}
val x670 = x651 += 1
()
}
val x673 = x653
val x674 = x673 > 1
val x677 = {
def x677thenb(): Int = {
val x675 = x654
x675
}
def x677elseb(): Int = {
0
}
if (x674) {
x677thenb()
} else {
x677elseb()
}
}
x677
}
def x679elseb(): Int = {
val x332 = 0.asInstanceOf[Int]
x332
}
if (x591) {
x679thenb()
} else {
x679elseb()
}
}
x679
})
mapIdx += 1
} // end map loop x685
x683
}
val x685 = x685_block
x685
})
mapIdx += 1
} // end map loop x686
x578
}
val x686 = x686_block
val x687 = x686.length
val x688 = x687==0
val x722 = { 
val x720 = {
def x720thenb(): generated.scala.Matrix[Int] = {
val x689 = new generated.scala.IntMatrixImpl(0,0)
x689
}
def x720elseb(): generated.scala.Matrix[Int] = {
val x691 = x686(0)
val x692 = x691.isRow
val x718 = {
def x718thenb(): generated.scala.Matrix[Int] = {
val x693 = x691.length
val x694 = new generated.scala.IntMatrixImpl(x687,x693)
var x696 : Int = 0
val x705 = while (x696 < x687) {
val x699 = x686(x696)
var x698 : Int = 0
val x703 = while (x698 < x693) {
val x700 = x699(x698)
val x701 = x694(x696, x698) = x700
x701
x698 = x698 + 1
}
x703
x696 = x696 + 1
}
x694
}
def x718elseb(): generated.scala.Matrix[Int] = {
val x693 = x691.length
val x707 = new generated.scala.IntMatrixImpl(x693,x687)
var x708 : Int = 0
val x716 = while (x708 < x687) {
val x710 = x686(x708)
var x709 : Int = 0
val x714 = while (x709 < x693) {
val x711 = x710(x709)
val x712 = x707(x709, x708) = x711
x712
x709 = x709 + 1
}
x714
x708 = x708 + 1
}
x707
}
if (x692) {
x718thenb()
} else {
x718elseb()
}
}
x718
}
if (x688) {
x720thenb()
} else {
x720elseb()
}
}
x720
}
val x723 = new generated.scala.IntImageImpl(x722)
val x724 = new generated.scala.GrayscaleImageImpl(x723)
var x725: generated.scala.GrayscaleImage = x724
var x726: Int = 0
val x727 = new generated.scala.VectorImpl[generated.scala.GrayscaleImage](0,true)
val x728 = new generated.scala.BinarizedGradientPyramid(x727,3,1,3)
val x730 = x728.start_level
val x731 = x728.levels
val x732 = x730 + x731
val x737 = x728.pyramid
val x743 = x732 - 1
val x848 = while ({val x729 = x726
val x733 = x729 < x732
x733}) {
val x735 = x726
val x736 = x735 >= x730
val x742 = {
def x742thenb(): Unit = {
val x738 = x725
val x739 = x737.length
val x740 = x737.insert(x739, x738)
x740
}
def x742elseb(): Unit = {
()
}
if (x736) {
x742thenb()
} else {
x742elseb()
}
}
val x744 = x726
val x745 = x744 != x743
val x845 = {
def x845thenb(): Unit = {
val x746 = x725
val x747 = x746.numRows
val x748 = x747 / 2
val x749 = new generated.scala.IndexVectorRangeImpl(0,x748)
val x750 = x746.numCols
val x751 = x750 / 2
val x752 = new generated.scala.IndexVectorRangeImpl(0,x751)
val x753 = new generated.scala.IndexVector2Impl(x749,x752)
val x754 = x753.rowInd
val x755 = x754.length
val x759 = x753.colInd
val x799 = x759.length
val x800 = x759.isRow
def x804_block = {
val x756 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](x755,true)
var mapIdx = 0
while (mapIdx < x754.size) { // begin map loop x804
val x758 = x754.dcApply(mapIdx)
x756.dcUpdate(mapIdx,  {
val x761 = 2 * x758
val x762 = x761 + 2
val x765 = x762 - x761
def x803_block = {
val x801 = new generated.scala.IntVectorImpl(x799,x800)
var mapIdx = 0
while (mapIdx < x759.size) { // begin map loop x803
val x760 = x759.dcApply(mapIdx)
x801.dcUpdate(mapIdx,  {
val x763 = 2 * x760
val x764 = x763 + 2
val x766 = x764 - x763
val x791 = { 
val x767 = new generated.scala.IntMatrixImpl(x765,x766)
var x768: Int = x761
val x789 = while ({val x769 = x768
val x770 = x769 < x762
x770}) {
var x772: Int = x763
val x786 = while ({val x773 = x772
val x774 = x773 < x764
x774}) {
val x776 = x768
val x778 = x772
val x780 = x768
val x781 = x772
val x777 = x776 - x761
val x779 = x778 - x763
val x782 = x746(x780, x781)
val x783 = x767(x777, x779) = x782
val x784 = x772 += 1
()
}
val x787 = x768 += 1
()
}
x767
}
val x792 = x791(0, 0)
val x793 = x791(1, 0)
val x794 = x792 | x793
val x795 = x791(0, 1)
val x796 = x794 | x795
val x797 = x791(1, 1)
val x798 = x796 | x797
x798
})
mapIdx += 1
} // end map loop x803
x801
}
val x803 = x803_block
x803
})
mapIdx += 1
} // end map loop x804
x756
}
val x804 = x804_block
val x805 = x804.length
val x806 = x805==0
val x840 = { 
val x838 = {
def x838thenb(): generated.scala.Matrix[Int] = {
val x807 = new generated.scala.IntMatrixImpl(0,0)
x807
}
def x838elseb(): generated.scala.Matrix[Int] = {
val x809 = x804(0)
val x810 = x809.isRow
val x836 = {
def x836thenb(): generated.scala.Matrix[Int] = {
val x811 = x809.length
val x812 = new generated.scala.IntMatrixImpl(x805,x811)
var x814 : Int = 0
val x823 = while (x814 < x805) {
val x817 = x804(x814)
var x816 : Int = 0
val x821 = while (x816 < x811) {
val x818 = x817(x816)
val x819 = x812(x814, x816) = x818
x819
x816 = x816 + 1
}
x821
x814 = x814 + 1
}
x812
}
def x836elseb(): generated.scala.Matrix[Int] = {
val x811 = x809.length
val x825 = new generated.scala.IntMatrixImpl(x811,x805)
var x826 : Int = 0
val x834 = while (x826 < x805) {
val x828 = x804(x826)
var x827 : Int = 0
val x832 = while (x827 < x811) {
val x829 = x828(x827)
val x830 = x825(x827, x826) = x829
x830
x827 = x827 + 1
}
x832
x826 = x826 + 1
}
x825
}
if (x810) {
x836thenb()
} else {
x836elseb()
}
}
x836
}
if (x806) {
x838thenb()
} else {
x838elseb()
}
}
x838
}
val x841 = new generated.scala.IntImageImpl(x840)
val x842 = new generated.scala.GrayscaleImageImpl(x841)
x725 = x842
()
}
def x845elseb(): Unit = {
()
}
if (x745) {
x845thenb()
} else {
x845elseb()
}
}
val x846 = x726 += 1
()
}
val x857 = x728.fixedLevelIndex
val x858 = x857 - x730
val x859 = x737(x858)
val x860 = x859.numRows
val x861 = x860 - 5
val x862 = new generated.scala.IndexVectorRangeImpl(5,x861)
val x864 = x859.numCols
val x865 = x864 - 5
val x866 = new generated.scala.IndexVectorRangeImpl(5,x865)
def x1161_block = {
val x849 = x229.dcApply(0)
var x1133 = {
val x850 = x849._1
val x852 = "Name: "+x850
val x853 = println(x852)
val x851 = x849._2
val x854 = x851.length
val x855 = "Templates: "+x854
val x856 = println(x855)
val x939 = new generated.scala.IndexVectorRangeImpl(0,x854)
def x1128_block = {
val x863 = x862.dcApply(0)
var x1100 = {
val x886 = x863 - 15
val x887 = x886 < 0
val x891 = {
def x891thenb(): scala.Tuple2[Int, Int] = {
val x888 = 15 - x863
val x889 = (0,x888)
x889
}
def x891elseb(): scala.Tuple2[Int, Int] = {
val x890 = (x886,0)
x890
}
if (x887) {
x891thenb()
} else {
x891elseb()
}
}
val x892 = x891._1
val x894 = x863 + 15
val x895 = x894 > x860
val x896 = {
def x896thenb(): Int = {
x860
}
def x896elseb(): Int = {
x894
}
if (x895) {
x896thenb()
} else {
x896elseb()
}
}
val x893 = x891._2
def x1099_block = {
val x867 = x866.dcApply(0)
var x1071 = {
val x871 = new generated.scala.IntVectorImpl(900,false)
val x872 = new generated.scala.IntVectorImpl(0,true)
val x873 = new generated.scala.IndexVectorSeqImpl(x872)
val x874 = new generated.scala.BinarizedGradientTemplate(15,null,null,x857,x871,x873,null,null,null)
var x897: Int = x892
val x875 = x867 - 15
val x876 = x875 < 0
val x880 = {
def x880thenb(): scala.Tuple2[Int, Int] = {
val x877 = 15 - x867
val x878 = (0,x877)
x878
}
def x880elseb(): scala.Tuple2[Int, Int] = {
val x879 = (x875,0)
x879
}
if (x876) {
x880thenb()
} else {
x880elseb()
}
}
val x881 = x880._1
val x883 = x867 + 15
val x884 = x883 > x864
val x885 = {
def x885thenb(): Int = {
x864
}
def x885elseb(): Int = {
x883
}
if (x884) {
x885thenb()
} else {
x885elseb()
}
}
val x882 = x880._2
val x916 = x874.binary_gradients
val x924 = x874.match_list
val x925 = x924.length
val x934 = while ({val x898 = x897
val x899 = x898 < x896
x899}) {
val x901 = x897
var x903: Int = x881
val x931 = while ({val x904 = x903
val x905 = x904 < x885
x905}) {
val x907 = x897
val x911 = x903
val x908 = x893 + x907
val x909 = x908 - x892
val x910 = x909 * 30
val x912 = x882 + x911
val x913 = x912 - x881
val x914 = x910 + x913
var x915: Int = x914
val x917 = x915
val x918 = x903
val x919 = x859(x901, x918)
val x920 = x916(x917) = x919
val x921 = x903
val x922 = x859(x901, x921)
val x923 = x922 > 0
val x928 = {
def x928thenb(): Unit = {
val x926 = x924.insert(x925, x917)
x926
}
def x928elseb(): Unit = {
()
}
if (x923) {
x928thenb()
} else {
x928elseb()
}
}
val x929 = x903 += 1
()
}
val x932 = x897 += 1
()
}
val x935 = x925 < 0
val x938 = {
def x938thenb(): Unit = {
val x936 = println("dummy")
x936
}
def x938elseb(): Unit = {
()
}
if (x935) {
x938thenb()
} else {
x938elseb()
}
}
val x943 = x874.radius
def x1069_block = {
val x940 = x939.dcApply(0)
var x1041 = {
val x941 = x851(x940)
val x942 = x941.radius
val x944 = x942 != x943
val x1019 = {
def x1019thenb(): Float = {
-1.0f
}
def x1019elseb(): Float = {
val x945 = x941.match_list
val x946 = x945.length
val x947 = x946.asInstanceOf[Float]
val x948 = x947==0.0
val x1017 = {
def x1017thenb(): Float = {
-1.0f
}
def x1017elseb(): Float = {
val x949 = x925.asInstanceOf[Float]
val x950 = x949 / x947
val x951 = x950 < 0.82f
val x1015 = {
def x1015thenb(): Float = {
x950
}
def x1015elseb(): Float = {
var x952: Float = 0.0f
val x953 = x947 * 0.18f
val x954 = x953 + 0.5f
val x955 = x954.asInstanceOf[Int]
var x956: Int = x955
var x957: Int = 0
var x958: Boolean = true
val x966 = x941.binary_gradients
val x1006 = while ({val x959 = x957
val x961 = x958
val x960 = x959 < x946
val x962 = x960 && x961
x962}) {
val x964 = x957
val x967 = x957
val x971 = x957
val x968 = x945(x967)
val x969 = x966(x968)
val x970 = x969==0
val x972 = x945(x971)
val x973 = x916(x972)
val x974 = x973==0
val x975 = x970 && x974
val x1003 = {
def x1003thenb(): Unit = {
val x976 = x952
val x977 = x976 + 1.0f
x952 = x977
()
}
def x1003elseb(): Unit = {
val x980 = x957
val x983 = x957
val x981 = x945(x980)
val x982 = x966(x981)
val x984 = x945(x983)
val x985 = x916(x984)
val x986 = x982 & x985
val x987 = x986 > 0
val x1001 = {
def x1001thenb(): Unit = {
val x988 = x952
val x989 = x988 + 1.0f
x952 = x989
()
}
def x1001elseb(): Unit = {
val x992 = x956
val x993 = x992 - 1
x956 = x993
val x995 = x956
val x996 = x995 <= 0
val x999 = {
def x999thenb(): Unit = {
x958 = false
()
}
def x999elseb(): Unit = {
()
}
if (x996) {
x999thenb()
} else {
x999elseb()
}
}
x999
}
if (x987) {
x1001thenb()
} else {
x1001elseb()
}
}
x1001
}
if (x975) {
x1003thenb()
} else {
x1003elseb()
}
}
val x1004 = x957 += 1
()
}
val x1007 = x958
val x1008 = !x1007
val x1013 = {
def x1013thenb(): Float = {
0.819999f
}
def x1013elseb(): Float = {
val x1009 = x952
val x1010 = x1009 / x947
val x1011 = x1010.asInstanceOf[Float]
x1011
}
if (x1008) {
x1013thenb()
} else {
x1013elseb()
}
}
x1013
}
if (x951) {
x1015thenb()
} else {
x1015elseb()
}
}
x1015
}
if (x948) {
x1017thenb()
} else {
x1017elseb()
}
}
x1017
}
if (x944) {
x1019thenb()
} else {
x1019elseb()
}
}
val x1020 = x1019 > 0.82f
val x1039 = {
def x1039thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1021 = x941.rect
val x1023 = x1021.width
val x868 = x857
val x869 = Math.pow(2.0,x868)
val x870 = x869.asInstanceOf[Int]
val x1022 = x870 * x867
val x1024 = x1023 / 2
val x1025 = x1022 - x1024
val x1026 = x1025.asInstanceOf[Int]
val x1028 = x1021.height
val x1027 = x870 * x863
val x1029 = x1028 / 2
val x1030 = x1027 - x1029
val x1031 = x1030.asInstanceOf[Int]
val x1032 = new generated.scala.Rect(x1026,x1031,x1023,x1028)
val x1033 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1034 = new generated.scala.BiGGDetection(x850,x1019,x1032,null,x940,x867,x863,x941,x874)
val x1035 = x1033(0) = x1034
x1033
}
def x1039elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1037 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1037
}
if (x1020) {
x1039thenb()
} else {
x1039elseb()
}
}
x1039
}
var mapReduceIdx = 1
while (mapReduceIdx < x939.size) { // begin mapReduce loop x1069
val x940 = x939.dcApply(mapReduceIdx)
val x1042 = {
val x941 = x851(x940)
val x942 = x941.radius
val x944 = x942 != x943
val x1019 = {
def x1019thenb(): Float = {
-1.0f
}
def x1019elseb(): Float = {
val x945 = x941.match_list
val x946 = x945.length
val x947 = x946.asInstanceOf[Float]
val x948 = x947==0.0
val x1017 = {
def x1017thenb(): Float = {
-1.0f
}
def x1017elseb(): Float = {
val x949 = x925.asInstanceOf[Float]
val x950 = x949 / x947
val x951 = x950 < 0.82f
val x1015 = {
def x1015thenb(): Float = {
x950
}
def x1015elseb(): Float = {
var x952: Float = 0.0f
val x953 = x947 * 0.18f
val x954 = x953 + 0.5f
val x955 = x954.asInstanceOf[Int]
var x956: Int = x955
var x957: Int = 0
var x958: Boolean = true
val x966 = x941.binary_gradients
val x1006 = while ({val x959 = x957
val x961 = x958
val x960 = x959 < x946
val x962 = x960 && x961
x962}) {
val x964 = x957
val x967 = x957
val x971 = x957
val x968 = x945(x967)
val x969 = x966(x968)
val x970 = x969==0
val x972 = x945(x971)
val x973 = x916(x972)
val x974 = x973==0
val x975 = x970 && x974
val x1003 = {
def x1003thenb(): Unit = {
val x976 = x952
val x977 = x976 + 1.0f
x952 = x977
()
}
def x1003elseb(): Unit = {
val x980 = x957
val x983 = x957
val x981 = x945(x980)
val x982 = x966(x981)
val x984 = x945(x983)
val x985 = x916(x984)
val x986 = x982 & x985
val x987 = x986 > 0
val x1001 = {
def x1001thenb(): Unit = {
val x988 = x952
val x989 = x988 + 1.0f
x952 = x989
()
}
def x1001elseb(): Unit = {
val x992 = x956
val x993 = x992 - 1
x956 = x993
val x995 = x956
val x996 = x995 <= 0
val x999 = {
def x999thenb(): Unit = {
x958 = false
()
}
def x999elseb(): Unit = {
()
}
if (x996) {
x999thenb()
} else {
x999elseb()
}
}
x999
}
if (x987) {
x1001thenb()
} else {
x1001elseb()
}
}
x1001
}
if (x975) {
x1003thenb()
} else {
x1003elseb()
}
}
val x1004 = x957 += 1
()
}
val x1007 = x958
val x1008 = !x1007
val x1013 = {
def x1013thenb(): Float = {
0.819999f
}
def x1013elseb(): Float = {
val x1009 = x952
val x1010 = x1009 / x947
val x1011 = x1010.asInstanceOf[Float]
x1011
}
if (x1008) {
x1013thenb()
} else {
x1013elseb()
}
}
x1013
}
if (x951) {
x1015thenb()
} else {
x1015elseb()
}
}
x1015
}
if (x948) {
x1017thenb()
} else {
x1017elseb()
}
}
x1017
}
if (x944) {
x1019thenb()
} else {
x1019elseb()
}
}
val x1020 = x1019 > 0.82f
val x1039 = {
def x1039thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1021 = x941.rect
val x1023 = x1021.width
val x868 = x857
val x869 = Math.pow(2.0,x868)
val x870 = x869.asInstanceOf[Int]
val x1022 = x870 * x867
val x1024 = x1023 / 2
val x1025 = x1022 - x1024
val x1026 = x1025.asInstanceOf[Int]
val x1028 = x1021.height
val x1027 = x870 * x863
val x1029 = x1028 / 2
val x1030 = x1027 - x1029
val x1031 = x1030.asInstanceOf[Int]
val x1032 = new generated.scala.Rect(x1026,x1031,x1023,x1028)
val x1033 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1034 = new generated.scala.BiGGDetection(x850,x1019,x1032,null,x940,x867,x863,x941,x874)
val x1035 = x1033(0) = x1034
x1033
}
def x1039elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1037 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1037
}
if (x1020) {
x1039thenb()
} else {
x1039elseb()
}
}
x1039
}
x1041 = {
val x1043 = x1041.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1068 = { 
val x1066 = {
def x1066thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1042
}
def x1066elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1044 = x1042.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1064 = {
def x1064thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1041
}
def x1064elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1045 = x1041.length
val x1046 = x1042.length
val x1047 = x1045 + x1046
val x1048 = x1041.isRow
val x1049 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1047,x1048)
var x1051 : Int = 0
val x1055 = while (x1051 < x1045) {
val x1052 = x1041(x1051)
val x1053 = x1049(x1051) = x1052
x1053
x1051 = x1051 + 1
}
var x1057 : Int = 0
val x1062 = while (x1057 < x1046) {
val x1058 = x1057 + x1045
val x1059 = x1042(x1057)
val x1060 = x1049(x1058) = x1059
x1060
x1057 = x1057 + 1
}
x1049
}
if (x1044) {
x1064thenb()
} else {
x1064elseb()
}
}
x1064
}
if (x1043) {
x1066thenb()
} else {
x1066elseb()
}
}
x1066
}
x1068
}
mapReduceIdx += 1
} // end mapReduce loop x1069
x1041
}
val x1069 = x1069_block
x1069
}
var mapReduceIdx = 1
while (mapReduceIdx < x866.size) { // begin mapReduce loop x1099
val x867 = x866.dcApply(mapReduceIdx)
val x1072 = {
val x871 = new generated.scala.IntVectorImpl(900,false)
val x872 = new generated.scala.IntVectorImpl(0,true)
val x873 = new generated.scala.IndexVectorSeqImpl(x872)
val x874 = new generated.scala.BinarizedGradientTemplate(15,null,null,x857,x871,x873,null,null,null)
var x897: Int = x892
val x875 = x867 - 15
val x876 = x875 < 0
val x880 = {
def x880thenb(): scala.Tuple2[Int, Int] = {
val x877 = 15 - x867
val x878 = (0,x877)
x878
}
def x880elseb(): scala.Tuple2[Int, Int] = {
val x879 = (x875,0)
x879
}
if (x876) {
x880thenb()
} else {
x880elseb()
}
}
val x881 = x880._1
val x883 = x867 + 15
val x884 = x883 > x864
val x885 = {
def x885thenb(): Int = {
x864
}
def x885elseb(): Int = {
x883
}
if (x884) {
x885thenb()
} else {
x885elseb()
}
}
val x882 = x880._2
val x916 = x874.binary_gradients
val x924 = x874.match_list
val x925 = x924.length
val x934 = while ({val x898 = x897
val x899 = x898 < x896
x899}) {
val x901 = x897
var x903: Int = x881
val x931 = while ({val x904 = x903
val x905 = x904 < x885
x905}) {
val x907 = x897
val x911 = x903
val x908 = x893 + x907
val x909 = x908 - x892
val x910 = x909 * 30
val x912 = x882 + x911
val x913 = x912 - x881
val x914 = x910 + x913
var x915: Int = x914
val x917 = x915
val x918 = x903
val x919 = x859(x901, x918)
val x920 = x916(x917) = x919
val x921 = x903
val x922 = x859(x901, x921)
val x923 = x922 > 0
val x928 = {
def x928thenb(): Unit = {
val x926 = x924.insert(x925, x917)
x926
}
def x928elseb(): Unit = {
()
}
if (x923) {
x928thenb()
} else {
x928elseb()
}
}
val x929 = x903 += 1
()
}
val x932 = x897 += 1
()
}
val x935 = x925 < 0
val x938 = {
def x938thenb(): Unit = {
val x936 = println("dummy")
x936
}
def x938elseb(): Unit = {
()
}
if (x935) {
x938thenb()
} else {
x938elseb()
}
}
val x943 = x874.radius
def x1069_block = {
val x940 = x939.dcApply(0)
var x1041 = {
val x941 = x851(x940)
val x942 = x941.radius
val x944 = x942 != x943
val x1019 = {
def x1019thenb(): Float = {
-1.0f
}
def x1019elseb(): Float = {
val x945 = x941.match_list
val x946 = x945.length
val x947 = x946.asInstanceOf[Float]
val x948 = x947==0.0
val x1017 = {
def x1017thenb(): Float = {
-1.0f
}
def x1017elseb(): Float = {
val x949 = x925.asInstanceOf[Float]
val x950 = x949 / x947
val x951 = x950 < 0.82f
val x1015 = {
def x1015thenb(): Float = {
x950
}
def x1015elseb(): Float = {
var x952: Float = 0.0f
val x953 = x947 * 0.18f
val x954 = x953 + 0.5f
val x955 = x954.asInstanceOf[Int]
var x956: Int = x955
var x957: Int = 0
var x958: Boolean = true
val x966 = x941.binary_gradients
val x1006 = while ({val x959 = x957
val x961 = x958
val x960 = x959 < x946
val x962 = x960 && x961
x962}) {
val x964 = x957
val x967 = x957
val x971 = x957
val x968 = x945(x967)
val x969 = x966(x968)
val x970 = x969==0
val x972 = x945(x971)
val x973 = x916(x972)
val x974 = x973==0
val x975 = x970 && x974
val x1003 = {
def x1003thenb(): Unit = {
val x976 = x952
val x977 = x976 + 1.0f
x952 = x977
()
}
def x1003elseb(): Unit = {
val x980 = x957
val x983 = x957
val x981 = x945(x980)
val x982 = x966(x981)
val x984 = x945(x983)
val x985 = x916(x984)
val x986 = x982 & x985
val x987 = x986 > 0
val x1001 = {
def x1001thenb(): Unit = {
val x988 = x952
val x989 = x988 + 1.0f
x952 = x989
()
}
def x1001elseb(): Unit = {
val x992 = x956
val x993 = x992 - 1
x956 = x993
val x995 = x956
val x996 = x995 <= 0
val x999 = {
def x999thenb(): Unit = {
x958 = false
()
}
def x999elseb(): Unit = {
()
}
if (x996) {
x999thenb()
} else {
x999elseb()
}
}
x999
}
if (x987) {
x1001thenb()
} else {
x1001elseb()
}
}
x1001
}
if (x975) {
x1003thenb()
} else {
x1003elseb()
}
}
val x1004 = x957 += 1
()
}
val x1007 = x958
val x1008 = !x1007
val x1013 = {
def x1013thenb(): Float = {
0.819999f
}
def x1013elseb(): Float = {
val x1009 = x952
val x1010 = x1009 / x947
val x1011 = x1010.asInstanceOf[Float]
x1011
}
if (x1008) {
x1013thenb()
} else {
x1013elseb()
}
}
x1013
}
if (x951) {
x1015thenb()
} else {
x1015elseb()
}
}
x1015
}
if (x948) {
x1017thenb()
} else {
x1017elseb()
}
}
x1017
}
if (x944) {
x1019thenb()
} else {
x1019elseb()
}
}
val x1020 = x1019 > 0.82f
val x1039 = {
def x1039thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1021 = x941.rect
val x1023 = x1021.width
val x868 = x857
val x869 = Math.pow(2.0,x868)
val x870 = x869.asInstanceOf[Int]
val x1022 = x870 * x867
val x1024 = x1023 / 2
val x1025 = x1022 - x1024
val x1026 = x1025.asInstanceOf[Int]
val x1028 = x1021.height
val x1027 = x870 * x863
val x1029 = x1028 / 2
val x1030 = x1027 - x1029
val x1031 = x1030.asInstanceOf[Int]
val x1032 = new generated.scala.Rect(x1026,x1031,x1023,x1028)
val x1033 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1034 = new generated.scala.BiGGDetection(x850,x1019,x1032,null,x940,x867,x863,x941,x874)
val x1035 = x1033(0) = x1034
x1033
}
def x1039elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1037 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1037
}
if (x1020) {
x1039thenb()
} else {
x1039elseb()
}
}
x1039
}
var mapReduceIdx = 1
while (mapReduceIdx < x939.size) { // begin mapReduce loop x1069
val x940 = x939.dcApply(mapReduceIdx)
val x1042 = {
val x941 = x851(x940)
val x942 = x941.radius
val x944 = x942 != x943
val x1019 = {
def x1019thenb(): Float = {
-1.0f
}
def x1019elseb(): Float = {
val x945 = x941.match_list
val x946 = x945.length
val x947 = x946.asInstanceOf[Float]
val x948 = x947==0.0
val x1017 = {
def x1017thenb(): Float = {
-1.0f
}
def x1017elseb(): Float = {
val x949 = x925.asInstanceOf[Float]
val x950 = x949 / x947
val x951 = x950 < 0.82f
val x1015 = {
def x1015thenb(): Float = {
x950
}
def x1015elseb(): Float = {
var x952: Float = 0.0f
val x953 = x947 * 0.18f
val x954 = x953 + 0.5f
val x955 = x954.asInstanceOf[Int]
var x956: Int = x955
var x957: Int = 0
var x958: Boolean = true
val x966 = x941.binary_gradients
val x1006 = while ({val x959 = x957
val x961 = x958
val x960 = x959 < x946
val x962 = x960 && x961
x962}) {
val x964 = x957
val x967 = x957
val x971 = x957
val x968 = x945(x967)
val x969 = x966(x968)
val x970 = x969==0
val x972 = x945(x971)
val x973 = x916(x972)
val x974 = x973==0
val x975 = x970 && x974
val x1003 = {
def x1003thenb(): Unit = {
val x976 = x952
val x977 = x976 + 1.0f
x952 = x977
()
}
def x1003elseb(): Unit = {
val x980 = x957
val x983 = x957
val x981 = x945(x980)
val x982 = x966(x981)
val x984 = x945(x983)
val x985 = x916(x984)
val x986 = x982 & x985
val x987 = x986 > 0
val x1001 = {
def x1001thenb(): Unit = {
val x988 = x952
val x989 = x988 + 1.0f
x952 = x989
()
}
def x1001elseb(): Unit = {
val x992 = x956
val x993 = x992 - 1
x956 = x993
val x995 = x956
val x996 = x995 <= 0
val x999 = {
def x999thenb(): Unit = {
x958 = false
()
}
def x999elseb(): Unit = {
()
}
if (x996) {
x999thenb()
} else {
x999elseb()
}
}
x999
}
if (x987) {
x1001thenb()
} else {
x1001elseb()
}
}
x1001
}
if (x975) {
x1003thenb()
} else {
x1003elseb()
}
}
val x1004 = x957 += 1
()
}
val x1007 = x958
val x1008 = !x1007
val x1013 = {
def x1013thenb(): Float = {
0.819999f
}
def x1013elseb(): Float = {
val x1009 = x952
val x1010 = x1009 / x947
val x1011 = x1010.asInstanceOf[Float]
x1011
}
if (x1008) {
x1013thenb()
} else {
x1013elseb()
}
}
x1013
}
if (x951) {
x1015thenb()
} else {
x1015elseb()
}
}
x1015
}
if (x948) {
x1017thenb()
} else {
x1017elseb()
}
}
x1017
}
if (x944) {
x1019thenb()
} else {
x1019elseb()
}
}
val x1020 = x1019 > 0.82f
val x1039 = {
def x1039thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1021 = x941.rect
val x1023 = x1021.width
val x868 = x857
val x869 = Math.pow(2.0,x868)
val x870 = x869.asInstanceOf[Int]
val x1022 = x870 * x867
val x1024 = x1023 / 2
val x1025 = x1022 - x1024
val x1026 = x1025.asInstanceOf[Int]
val x1028 = x1021.height
val x1027 = x870 * x863
val x1029 = x1028 / 2
val x1030 = x1027 - x1029
val x1031 = x1030.asInstanceOf[Int]
val x1032 = new generated.scala.Rect(x1026,x1031,x1023,x1028)
val x1033 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1034 = new generated.scala.BiGGDetection(x850,x1019,x1032,null,x940,x867,x863,x941,x874)
val x1035 = x1033(0) = x1034
x1033
}
def x1039elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1037 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1037
}
if (x1020) {
x1039thenb()
} else {
x1039elseb()
}
}
x1039
}
x1041 = {
val x1043 = x1041.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1068 = { 
val x1066 = {
def x1066thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1042
}
def x1066elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1044 = x1042.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1064 = {
def x1064thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1041
}
def x1064elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1045 = x1041.length
val x1046 = x1042.length
val x1047 = x1045 + x1046
val x1048 = x1041.isRow
val x1049 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1047,x1048)
var x1051 : Int = 0
val x1055 = while (x1051 < x1045) {
val x1052 = x1041(x1051)
val x1053 = x1049(x1051) = x1052
x1053
x1051 = x1051 + 1
}
var x1057 : Int = 0
val x1062 = while (x1057 < x1046) {
val x1058 = x1057 + x1045
val x1059 = x1042(x1057)
val x1060 = x1049(x1058) = x1059
x1060
x1057 = x1057 + 1
}
x1049
}
if (x1044) {
x1064thenb()
} else {
x1064elseb()
}
}
x1064
}
if (x1043) {
x1066thenb()
} else {
x1066elseb()
}
}
x1066
}
x1068
}
mapReduceIdx += 1
} // end mapReduce loop x1069
x1041
}
val x1069 = x1069_block
x1069
}
x1071 = {
val x1073 = x1071.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1098 = { 
val x1096 = {
def x1096thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1072
}
def x1096elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1074 = x1072.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1094 = {
def x1094thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1071
}
def x1094elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1075 = x1071.length
val x1076 = x1072.length
val x1077 = x1075 + x1076
val x1078 = x1071.isRow
val x1079 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1077,x1078)
var x1081 : Int = 0
val x1085 = while (x1081 < x1075) {
val x1082 = x1071(x1081)
val x1083 = x1079(x1081) = x1082
x1083
x1081 = x1081 + 1
}
var x1087 : Int = 0
val x1092 = while (x1087 < x1076) {
val x1088 = x1087 + x1075
val x1089 = x1072(x1087)
val x1090 = x1079(x1088) = x1089
x1090
x1087 = x1087 + 1
}
x1079
}
if (x1074) {
x1094thenb()
} else {
x1094elseb()
}
}
x1094
}
if (x1073) {
x1096thenb()
} else {
x1096elseb()
}
}
x1096
}
x1098
}
mapReduceIdx += 1
} // end mapReduce loop x1099
x1071
}
val x1099 = x1099_block
x1099
}
var mapReduceIdx = 1
while (mapReduceIdx < x862.size) { // begin mapReduce loop x1128
val x863 = x862.dcApply(mapReduceIdx)
val x1101 = {
val x886 = x863 - 15
val x887 = x886 < 0
val x891 = {
def x891thenb(): scala.Tuple2[Int, Int] = {
val x888 = 15 - x863
val x889 = (0,x888)
x889
}
def x891elseb(): scala.Tuple2[Int, Int] = {
val x890 = (x886,0)
x890
}
if (x887) {
x891thenb()
} else {
x891elseb()
}
}
val x892 = x891._1
val x894 = x863 + 15
val x895 = x894 > x860
val x896 = {
def x896thenb(): Int = {
x860
}
def x896elseb(): Int = {
x894
}
if (x895) {
x896thenb()
} else {
x896elseb()
}
}
val x893 = x891._2
def x1099_block = {
val x867 = x866.dcApply(0)
var x1071 = {
val x871 = new generated.scala.IntVectorImpl(900,false)
val x872 = new generated.scala.IntVectorImpl(0,true)
val x873 = new generated.scala.IndexVectorSeqImpl(x872)
val x874 = new generated.scala.BinarizedGradientTemplate(15,null,null,x857,x871,x873,null,null,null)
var x897: Int = x892
val x875 = x867 - 15
val x876 = x875 < 0
val x880 = {
def x880thenb(): scala.Tuple2[Int, Int] = {
val x877 = 15 - x867
val x878 = (0,x877)
x878
}
def x880elseb(): scala.Tuple2[Int, Int] = {
val x879 = (x875,0)
x879
}
if (x876) {
x880thenb()
} else {
x880elseb()
}
}
val x881 = x880._1
val x883 = x867 + 15
val x884 = x883 > x864
val x885 = {
def x885thenb(): Int = {
x864
}
def x885elseb(): Int = {
x883
}
if (x884) {
x885thenb()
} else {
x885elseb()
}
}
val x882 = x880._2
val x916 = x874.binary_gradients
val x924 = x874.match_list
val x925 = x924.length
val x934 = while ({val x898 = x897
val x899 = x898 < x896
x899}) {
val x901 = x897
var x903: Int = x881
val x931 = while ({val x904 = x903
val x905 = x904 < x885
x905}) {
val x907 = x897
val x911 = x903
val x908 = x893 + x907
val x909 = x908 - x892
val x910 = x909 * 30
val x912 = x882 + x911
val x913 = x912 - x881
val x914 = x910 + x913
var x915: Int = x914
val x917 = x915
val x918 = x903
val x919 = x859(x901, x918)
val x920 = x916(x917) = x919
val x921 = x903
val x922 = x859(x901, x921)
val x923 = x922 > 0
val x928 = {
def x928thenb(): Unit = {
val x926 = x924.insert(x925, x917)
x926
}
def x928elseb(): Unit = {
()
}
if (x923) {
x928thenb()
} else {
x928elseb()
}
}
val x929 = x903 += 1
()
}
val x932 = x897 += 1
()
}
val x935 = x925 < 0
val x938 = {
def x938thenb(): Unit = {
val x936 = println("dummy")
x936
}
def x938elseb(): Unit = {
()
}
if (x935) {
x938thenb()
} else {
x938elseb()
}
}
val x943 = x874.radius
def x1069_block = {
val x940 = x939.dcApply(0)
var x1041 = {
val x941 = x851(x940)
val x942 = x941.radius
val x944 = x942 != x943
val x1019 = {
def x1019thenb(): Float = {
-1.0f
}
def x1019elseb(): Float = {
val x945 = x941.match_list
val x946 = x945.length
val x947 = x946.asInstanceOf[Float]
val x948 = x947==0.0
val x1017 = {
def x1017thenb(): Float = {
-1.0f
}
def x1017elseb(): Float = {
val x949 = x925.asInstanceOf[Float]
val x950 = x949 / x947
val x951 = x950 < 0.82f
val x1015 = {
def x1015thenb(): Float = {
x950
}
def x1015elseb(): Float = {
var x952: Float = 0.0f
val x953 = x947 * 0.18f
val x954 = x953 + 0.5f
val x955 = x954.asInstanceOf[Int]
var x956: Int = x955
var x957: Int = 0
var x958: Boolean = true
val x966 = x941.binary_gradients
val x1006 = while ({val x959 = x957
val x961 = x958
val x960 = x959 < x946
val x962 = x960 && x961
x962}) {
val x964 = x957
val x967 = x957
val x971 = x957
val x968 = x945(x967)
val x969 = x966(x968)
val x970 = x969==0
val x972 = x945(x971)
val x973 = x916(x972)
val x974 = x973==0
val x975 = x970 && x974
val x1003 = {
def x1003thenb(): Unit = {
val x976 = x952
val x977 = x976 + 1.0f
x952 = x977
()
}
def x1003elseb(): Unit = {
val x980 = x957
val x983 = x957
val x981 = x945(x980)
val x982 = x966(x981)
val x984 = x945(x983)
val x985 = x916(x984)
val x986 = x982 & x985
val x987 = x986 > 0
val x1001 = {
def x1001thenb(): Unit = {
val x988 = x952
val x989 = x988 + 1.0f
x952 = x989
()
}
def x1001elseb(): Unit = {
val x992 = x956
val x993 = x992 - 1
x956 = x993
val x995 = x956
val x996 = x995 <= 0
val x999 = {
def x999thenb(): Unit = {
x958 = false
()
}
def x999elseb(): Unit = {
()
}
if (x996) {
x999thenb()
} else {
x999elseb()
}
}
x999
}
if (x987) {
x1001thenb()
} else {
x1001elseb()
}
}
x1001
}
if (x975) {
x1003thenb()
} else {
x1003elseb()
}
}
val x1004 = x957 += 1
()
}
val x1007 = x958
val x1008 = !x1007
val x1013 = {
def x1013thenb(): Float = {
0.819999f
}
def x1013elseb(): Float = {
val x1009 = x952
val x1010 = x1009 / x947
val x1011 = x1010.asInstanceOf[Float]
x1011
}
if (x1008) {
x1013thenb()
} else {
x1013elseb()
}
}
x1013
}
if (x951) {
x1015thenb()
} else {
x1015elseb()
}
}
x1015
}
if (x948) {
x1017thenb()
} else {
x1017elseb()
}
}
x1017
}
if (x944) {
x1019thenb()
} else {
x1019elseb()
}
}
val x1020 = x1019 > 0.82f
val x1039 = {
def x1039thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1021 = x941.rect
val x1023 = x1021.width
val x868 = x857
val x869 = Math.pow(2.0,x868)
val x870 = x869.asInstanceOf[Int]
val x1022 = x870 * x867
val x1024 = x1023 / 2
val x1025 = x1022 - x1024
val x1026 = x1025.asInstanceOf[Int]
val x1028 = x1021.height
val x1027 = x870 * x863
val x1029 = x1028 / 2
val x1030 = x1027 - x1029
val x1031 = x1030.asInstanceOf[Int]
val x1032 = new generated.scala.Rect(x1026,x1031,x1023,x1028)
val x1033 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1034 = new generated.scala.BiGGDetection(x850,x1019,x1032,null,x940,x867,x863,x941,x874)
val x1035 = x1033(0) = x1034
x1033
}
def x1039elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1037 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1037
}
if (x1020) {
x1039thenb()
} else {
x1039elseb()
}
}
x1039
}
var mapReduceIdx = 1
while (mapReduceIdx < x939.size) { // begin mapReduce loop x1069
val x940 = x939.dcApply(mapReduceIdx)
val x1042 = {
val x941 = x851(x940)
val x942 = x941.radius
val x944 = x942 != x943
val x1019 = {
def x1019thenb(): Float = {
-1.0f
}
def x1019elseb(): Float = {
val x945 = x941.match_list
val x946 = x945.length
val x947 = x946.asInstanceOf[Float]
val x948 = x947==0.0
val x1017 = {
def x1017thenb(): Float = {
-1.0f
}
def x1017elseb(): Float = {
val x949 = x925.asInstanceOf[Float]
val x950 = x949 / x947
val x951 = x950 < 0.82f
val x1015 = {
def x1015thenb(): Float = {
x950
}
def x1015elseb(): Float = {
var x952: Float = 0.0f
val x953 = x947 * 0.18f
val x954 = x953 + 0.5f
val x955 = x954.asInstanceOf[Int]
var x956: Int = x955
var x957: Int = 0
var x958: Boolean = true
val x966 = x941.binary_gradients
val x1006 = while ({val x959 = x957
val x961 = x958
val x960 = x959 < x946
val x962 = x960 && x961
x962}) {
val x964 = x957
val x967 = x957
val x971 = x957
val x968 = x945(x967)
val x969 = x966(x968)
val x970 = x969==0
val x972 = x945(x971)
val x973 = x916(x972)
val x974 = x973==0
val x975 = x970 && x974
val x1003 = {
def x1003thenb(): Unit = {
val x976 = x952
val x977 = x976 + 1.0f
x952 = x977
()
}
def x1003elseb(): Unit = {
val x980 = x957
val x983 = x957
val x981 = x945(x980)
val x982 = x966(x981)
val x984 = x945(x983)
val x985 = x916(x984)
val x986 = x982 & x985
val x987 = x986 > 0
val x1001 = {
def x1001thenb(): Unit = {
val x988 = x952
val x989 = x988 + 1.0f
x952 = x989
()
}
def x1001elseb(): Unit = {
val x992 = x956
val x993 = x992 - 1
x956 = x993
val x995 = x956
val x996 = x995 <= 0
val x999 = {
def x999thenb(): Unit = {
x958 = false
()
}
def x999elseb(): Unit = {
()
}
if (x996) {
x999thenb()
} else {
x999elseb()
}
}
x999
}
if (x987) {
x1001thenb()
} else {
x1001elseb()
}
}
x1001
}
if (x975) {
x1003thenb()
} else {
x1003elseb()
}
}
val x1004 = x957 += 1
()
}
val x1007 = x958
val x1008 = !x1007
val x1013 = {
def x1013thenb(): Float = {
0.819999f
}
def x1013elseb(): Float = {
val x1009 = x952
val x1010 = x1009 / x947
val x1011 = x1010.asInstanceOf[Float]
x1011
}
if (x1008) {
x1013thenb()
} else {
x1013elseb()
}
}
x1013
}
if (x951) {
x1015thenb()
} else {
x1015elseb()
}
}
x1015
}
if (x948) {
x1017thenb()
} else {
x1017elseb()
}
}
x1017
}
if (x944) {
x1019thenb()
} else {
x1019elseb()
}
}
val x1020 = x1019 > 0.82f
val x1039 = {
def x1039thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1021 = x941.rect
val x1023 = x1021.width
val x868 = x857
val x869 = Math.pow(2.0,x868)
val x870 = x869.asInstanceOf[Int]
val x1022 = x870 * x867
val x1024 = x1023 / 2
val x1025 = x1022 - x1024
val x1026 = x1025.asInstanceOf[Int]
val x1028 = x1021.height
val x1027 = x870 * x863
val x1029 = x1028 / 2
val x1030 = x1027 - x1029
val x1031 = x1030.asInstanceOf[Int]
val x1032 = new generated.scala.Rect(x1026,x1031,x1023,x1028)
val x1033 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1034 = new generated.scala.BiGGDetection(x850,x1019,x1032,null,x940,x867,x863,x941,x874)
val x1035 = x1033(0) = x1034
x1033
}
def x1039elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1037 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1037
}
if (x1020) {
x1039thenb()
} else {
x1039elseb()
}
}
x1039
}
x1041 = {
val x1043 = x1041.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1068 = { 
val x1066 = {
def x1066thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1042
}
def x1066elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1044 = x1042.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1064 = {
def x1064thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1041
}
def x1064elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1045 = x1041.length
val x1046 = x1042.length
val x1047 = x1045 + x1046
val x1048 = x1041.isRow
val x1049 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1047,x1048)
var x1051 : Int = 0
val x1055 = while (x1051 < x1045) {
val x1052 = x1041(x1051)
val x1053 = x1049(x1051) = x1052
x1053
x1051 = x1051 + 1
}
var x1057 : Int = 0
val x1062 = while (x1057 < x1046) {
val x1058 = x1057 + x1045
val x1059 = x1042(x1057)
val x1060 = x1049(x1058) = x1059
x1060
x1057 = x1057 + 1
}
x1049
}
if (x1044) {
x1064thenb()
} else {
x1064elseb()
}
}
x1064
}
if (x1043) {
x1066thenb()
} else {
x1066elseb()
}
}
x1066
}
x1068
}
mapReduceIdx += 1
} // end mapReduce loop x1069
x1041
}
val x1069 = x1069_block
x1069
}
var mapReduceIdx = 1
while (mapReduceIdx < x866.size) { // begin mapReduce loop x1099
val x867 = x866.dcApply(mapReduceIdx)
val x1072 = {
val x871 = new generated.scala.IntVectorImpl(900,false)
val x872 = new generated.scala.IntVectorImpl(0,true)
val x873 = new generated.scala.IndexVectorSeqImpl(x872)
val x874 = new generated.scala.BinarizedGradientTemplate(15,null,null,x857,x871,x873,null,null,null)
var x897: Int = x892
val x875 = x867 - 15
val x876 = x875 < 0
val x880 = {
def x880thenb(): scala.Tuple2[Int, Int] = {
val x877 = 15 - x867
val x878 = (0,x877)
x878
}
def x880elseb(): scala.Tuple2[Int, Int] = {
val x879 = (x875,0)
x879
}
if (x876) {
x880thenb()
} else {
x880elseb()
}
}
val x881 = x880._1
val x883 = x867 + 15
val x884 = x883 > x864
val x885 = {
def x885thenb(): Int = {
x864
}
def x885elseb(): Int = {
x883
}
if (x884) {
x885thenb()
} else {
x885elseb()
}
}
val x882 = x880._2
val x916 = x874.binary_gradients
val x924 = x874.match_list
val x925 = x924.length
val x934 = while ({val x898 = x897
val x899 = x898 < x896
x899}) {
val x901 = x897
var x903: Int = x881
val x931 = while ({val x904 = x903
val x905 = x904 < x885
x905}) {
val x907 = x897
val x911 = x903
val x908 = x893 + x907
val x909 = x908 - x892
val x910 = x909 * 30
val x912 = x882 + x911
val x913 = x912 - x881
val x914 = x910 + x913
var x915: Int = x914
val x917 = x915
val x918 = x903
val x919 = x859(x901, x918)
val x920 = x916(x917) = x919
val x921 = x903
val x922 = x859(x901, x921)
val x923 = x922 > 0
val x928 = {
def x928thenb(): Unit = {
val x926 = x924.insert(x925, x917)
x926
}
def x928elseb(): Unit = {
()
}
if (x923) {
x928thenb()
} else {
x928elseb()
}
}
val x929 = x903 += 1
()
}
val x932 = x897 += 1
()
}
val x935 = x925 < 0
val x938 = {
def x938thenb(): Unit = {
val x936 = println("dummy")
x936
}
def x938elseb(): Unit = {
()
}
if (x935) {
x938thenb()
} else {
x938elseb()
}
}
val x943 = x874.radius
def x1069_block = {
val x940 = x939.dcApply(0)
var x1041 = {
val x941 = x851(x940)
val x942 = x941.radius
val x944 = x942 != x943
val x1019 = {
def x1019thenb(): Float = {
-1.0f
}
def x1019elseb(): Float = {
val x945 = x941.match_list
val x946 = x945.length
val x947 = x946.asInstanceOf[Float]
val x948 = x947==0.0
val x1017 = {
def x1017thenb(): Float = {
-1.0f
}
def x1017elseb(): Float = {
val x949 = x925.asInstanceOf[Float]
val x950 = x949 / x947
val x951 = x950 < 0.82f
val x1015 = {
def x1015thenb(): Float = {
x950
}
def x1015elseb(): Float = {
var x952: Float = 0.0f
val x953 = x947 * 0.18f
val x954 = x953 + 0.5f
val x955 = x954.asInstanceOf[Int]
var x956: Int = x955
var x957: Int = 0
var x958: Boolean = true
val x966 = x941.binary_gradients
val x1006 = while ({val x959 = x957
val x961 = x958
val x960 = x959 < x946
val x962 = x960 && x961
x962}) {
val x964 = x957
val x967 = x957
val x971 = x957
val x968 = x945(x967)
val x969 = x966(x968)
val x970 = x969==0
val x972 = x945(x971)
val x973 = x916(x972)
val x974 = x973==0
val x975 = x970 && x974
val x1003 = {
def x1003thenb(): Unit = {
val x976 = x952
val x977 = x976 + 1.0f
x952 = x977
()
}
def x1003elseb(): Unit = {
val x980 = x957
val x983 = x957
val x981 = x945(x980)
val x982 = x966(x981)
val x984 = x945(x983)
val x985 = x916(x984)
val x986 = x982 & x985
val x987 = x986 > 0
val x1001 = {
def x1001thenb(): Unit = {
val x988 = x952
val x989 = x988 + 1.0f
x952 = x989
()
}
def x1001elseb(): Unit = {
val x992 = x956
val x993 = x992 - 1
x956 = x993
val x995 = x956
val x996 = x995 <= 0
val x999 = {
def x999thenb(): Unit = {
x958 = false
()
}
def x999elseb(): Unit = {
()
}
if (x996) {
x999thenb()
} else {
x999elseb()
}
}
x999
}
if (x987) {
x1001thenb()
} else {
x1001elseb()
}
}
x1001
}
if (x975) {
x1003thenb()
} else {
x1003elseb()
}
}
val x1004 = x957 += 1
()
}
val x1007 = x958
val x1008 = !x1007
val x1013 = {
def x1013thenb(): Float = {
0.819999f
}
def x1013elseb(): Float = {
val x1009 = x952
val x1010 = x1009 / x947
val x1011 = x1010.asInstanceOf[Float]
x1011
}
if (x1008) {
x1013thenb()
} else {
x1013elseb()
}
}
x1013
}
if (x951) {
x1015thenb()
} else {
x1015elseb()
}
}
x1015
}
if (x948) {
x1017thenb()
} else {
x1017elseb()
}
}
x1017
}
if (x944) {
x1019thenb()
} else {
x1019elseb()
}
}
val x1020 = x1019 > 0.82f
val x1039 = {
def x1039thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1021 = x941.rect
val x1023 = x1021.width
val x868 = x857
val x869 = Math.pow(2.0,x868)
val x870 = x869.asInstanceOf[Int]
val x1022 = x870 * x867
val x1024 = x1023 / 2
val x1025 = x1022 - x1024
val x1026 = x1025.asInstanceOf[Int]
val x1028 = x1021.height
val x1027 = x870 * x863
val x1029 = x1028 / 2
val x1030 = x1027 - x1029
val x1031 = x1030.asInstanceOf[Int]
val x1032 = new generated.scala.Rect(x1026,x1031,x1023,x1028)
val x1033 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1034 = new generated.scala.BiGGDetection(x850,x1019,x1032,null,x940,x867,x863,x941,x874)
val x1035 = x1033(0) = x1034
x1033
}
def x1039elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1037 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1037
}
if (x1020) {
x1039thenb()
} else {
x1039elseb()
}
}
x1039
}
var mapReduceIdx = 1
while (mapReduceIdx < x939.size) { // begin mapReduce loop x1069
val x940 = x939.dcApply(mapReduceIdx)
val x1042 = {
val x941 = x851(x940)
val x942 = x941.radius
val x944 = x942 != x943
val x1019 = {
def x1019thenb(): Float = {
-1.0f
}
def x1019elseb(): Float = {
val x945 = x941.match_list
val x946 = x945.length
val x947 = x946.asInstanceOf[Float]
val x948 = x947==0.0
val x1017 = {
def x1017thenb(): Float = {
-1.0f
}
def x1017elseb(): Float = {
val x949 = x925.asInstanceOf[Float]
val x950 = x949 / x947
val x951 = x950 < 0.82f
val x1015 = {
def x1015thenb(): Float = {
x950
}
def x1015elseb(): Float = {
var x952: Float = 0.0f
val x953 = x947 * 0.18f
val x954 = x953 + 0.5f
val x955 = x954.asInstanceOf[Int]
var x956: Int = x955
var x957: Int = 0
var x958: Boolean = true
val x966 = x941.binary_gradients
val x1006 = while ({val x959 = x957
val x961 = x958
val x960 = x959 < x946
val x962 = x960 && x961
x962}) {
val x964 = x957
val x967 = x957
val x971 = x957
val x968 = x945(x967)
val x969 = x966(x968)
val x970 = x969==0
val x972 = x945(x971)
val x973 = x916(x972)
val x974 = x973==0
val x975 = x970 && x974
val x1003 = {
def x1003thenb(): Unit = {
val x976 = x952
val x977 = x976 + 1.0f
x952 = x977
()
}
def x1003elseb(): Unit = {
val x980 = x957
val x983 = x957
val x981 = x945(x980)
val x982 = x966(x981)
val x984 = x945(x983)
val x985 = x916(x984)
val x986 = x982 & x985
val x987 = x986 > 0
val x1001 = {
def x1001thenb(): Unit = {
val x988 = x952
val x989 = x988 + 1.0f
x952 = x989
()
}
def x1001elseb(): Unit = {
val x992 = x956
val x993 = x992 - 1
x956 = x993
val x995 = x956
val x996 = x995 <= 0
val x999 = {
def x999thenb(): Unit = {
x958 = false
()
}
def x999elseb(): Unit = {
()
}
if (x996) {
x999thenb()
} else {
x999elseb()
}
}
x999
}
if (x987) {
x1001thenb()
} else {
x1001elseb()
}
}
x1001
}
if (x975) {
x1003thenb()
} else {
x1003elseb()
}
}
val x1004 = x957 += 1
()
}
val x1007 = x958
val x1008 = !x1007
val x1013 = {
def x1013thenb(): Float = {
0.819999f
}
def x1013elseb(): Float = {
val x1009 = x952
val x1010 = x1009 / x947
val x1011 = x1010.asInstanceOf[Float]
x1011
}
if (x1008) {
x1013thenb()
} else {
x1013elseb()
}
}
x1013
}
if (x951) {
x1015thenb()
} else {
x1015elseb()
}
}
x1015
}
if (x948) {
x1017thenb()
} else {
x1017elseb()
}
}
x1017
}
if (x944) {
x1019thenb()
} else {
x1019elseb()
}
}
val x1020 = x1019 > 0.82f
val x1039 = {
def x1039thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1021 = x941.rect
val x1023 = x1021.width
val x868 = x857
val x869 = Math.pow(2.0,x868)
val x870 = x869.asInstanceOf[Int]
val x1022 = x870 * x867
val x1024 = x1023 / 2
val x1025 = x1022 - x1024
val x1026 = x1025.asInstanceOf[Int]
val x1028 = x1021.height
val x1027 = x870 * x863
val x1029 = x1028 / 2
val x1030 = x1027 - x1029
val x1031 = x1030.asInstanceOf[Int]
val x1032 = new generated.scala.Rect(x1026,x1031,x1023,x1028)
val x1033 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1034 = new generated.scala.BiGGDetection(x850,x1019,x1032,null,x940,x867,x863,x941,x874)
val x1035 = x1033(0) = x1034
x1033
}
def x1039elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1037 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1037
}
if (x1020) {
x1039thenb()
} else {
x1039elseb()
}
}
x1039
}
x1041 = {
val x1043 = x1041.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1068 = { 
val x1066 = {
def x1066thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1042
}
def x1066elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1044 = x1042.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1064 = {
def x1064thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1041
}
def x1064elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1045 = x1041.length
val x1046 = x1042.length
val x1047 = x1045 + x1046
val x1048 = x1041.isRow
val x1049 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1047,x1048)
var x1051 : Int = 0
val x1055 = while (x1051 < x1045) {
val x1052 = x1041(x1051)
val x1053 = x1049(x1051) = x1052
x1053
x1051 = x1051 + 1
}
var x1057 : Int = 0
val x1062 = while (x1057 < x1046) {
val x1058 = x1057 + x1045
val x1059 = x1042(x1057)
val x1060 = x1049(x1058) = x1059
x1060
x1057 = x1057 + 1
}
x1049
}
if (x1044) {
x1064thenb()
} else {
x1064elseb()
}
}
x1064
}
if (x1043) {
x1066thenb()
} else {
x1066elseb()
}
}
x1066
}
x1068
}
mapReduceIdx += 1
} // end mapReduce loop x1069
x1041
}
val x1069 = x1069_block
x1069
}
x1071 = {
val x1073 = x1071.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1098 = { 
val x1096 = {
def x1096thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1072
}
def x1096elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1074 = x1072.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1094 = {
def x1094thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1071
}
def x1094elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1075 = x1071.length
val x1076 = x1072.length
val x1077 = x1075 + x1076
val x1078 = x1071.isRow
val x1079 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1077,x1078)
var x1081 : Int = 0
val x1085 = while (x1081 < x1075) {
val x1082 = x1071(x1081)
val x1083 = x1079(x1081) = x1082
x1083
x1081 = x1081 + 1
}
var x1087 : Int = 0
val x1092 = while (x1087 < x1076) {
val x1088 = x1087 + x1075
val x1089 = x1072(x1087)
val x1090 = x1079(x1088) = x1089
x1090
x1087 = x1087 + 1
}
x1079
}
if (x1074) {
x1094thenb()
} else {
x1094elseb()
}
}
x1094
}
if (x1073) {
x1096thenb()
} else {
x1096elseb()
}
}
x1096
}
x1098
}
mapReduceIdx += 1
} // end mapReduce loop x1099
x1071
}
val x1099 = x1099_block
x1099
}
x1100 = {
val x1102 = x1100.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1127 = { 
val x1125 = {
def x1125thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1101
}
def x1125elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1103 = x1101.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1123 = {
def x1123thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1100
}
def x1123elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1104 = x1100.length
val x1105 = x1101.length
val x1106 = x1104 + x1105
val x1107 = x1100.isRow
val x1108 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1106,x1107)
var x1110 : Int = 0
val x1114 = while (x1110 < x1104) {
val x1111 = x1100(x1110)
val x1112 = x1108(x1110) = x1111
x1112
x1110 = x1110 + 1
}
var x1116 : Int = 0
val x1121 = while (x1116 < x1105) {
val x1117 = x1116 + x1104
val x1118 = x1101(x1116)
val x1119 = x1108(x1117) = x1118
x1119
x1116 = x1116 + 1
}
x1108
}
if (x1103) {
x1123thenb()
} else {
x1123elseb()
}
}
x1123
}
if (x1102) {
x1125thenb()
} else {
x1125elseb()
}
}
x1125
}
x1127
}
mapReduceIdx += 1
} // end mapReduce loop x1128
x1100
}
val x1128 = x1128_block
val x1129 = x1128.length
val x1130 = "Detections: "+x1129
val x1131 = println(x1130)
x1128
}
var mapReduceIdx = 1
while (mapReduceIdx < x229.size) { // begin mapReduce loop x1161
val x849 = x229.dcApply(mapReduceIdx)
val x1134 = {
val x850 = x849._1
val x852 = "Name: "+x850
val x853 = println(x852)
val x851 = x849._2
val x854 = x851.length
val x855 = "Templates: "+x854
val x856 = println(x855)
val x939 = new generated.scala.IndexVectorRangeImpl(0,x854)
def x1128_block = {
val x863 = x862.dcApply(0)
var x1100 = {
val x886 = x863 - 15
val x887 = x886 < 0
val x891 = {
def x891thenb(): scala.Tuple2[Int, Int] = {
val x888 = 15 - x863
val x889 = (0,x888)
x889
}
def x891elseb(): scala.Tuple2[Int, Int] = {
val x890 = (x886,0)
x890
}
if (x887) {
x891thenb()
} else {
x891elseb()
}
}
val x892 = x891._1
val x894 = x863 + 15
val x895 = x894 > x860
val x896 = {
def x896thenb(): Int = {
x860
}
def x896elseb(): Int = {
x894
}
if (x895) {
x896thenb()
} else {
x896elseb()
}
}
val x893 = x891._2
def x1099_block = {
val x867 = x866.dcApply(0)
var x1071 = {
val x871 = new generated.scala.IntVectorImpl(900,false)
val x872 = new generated.scala.IntVectorImpl(0,true)
val x873 = new generated.scala.IndexVectorSeqImpl(x872)
val x874 = new generated.scala.BinarizedGradientTemplate(15,null,null,x857,x871,x873,null,null,null)
var x897: Int = x892
val x875 = x867 - 15
val x876 = x875 < 0
val x880 = {
def x880thenb(): scala.Tuple2[Int, Int] = {
val x877 = 15 - x867
val x878 = (0,x877)
x878
}
def x880elseb(): scala.Tuple2[Int, Int] = {
val x879 = (x875,0)
x879
}
if (x876) {
x880thenb()
} else {
x880elseb()
}
}
val x881 = x880._1
val x883 = x867 + 15
val x884 = x883 > x864
val x885 = {
def x885thenb(): Int = {
x864
}
def x885elseb(): Int = {
x883
}
if (x884) {
x885thenb()
} else {
x885elseb()
}
}
val x882 = x880._2
val x916 = x874.binary_gradients
val x924 = x874.match_list
val x925 = x924.length
val x934 = while ({val x898 = x897
val x899 = x898 < x896
x899}) {
val x901 = x897
var x903: Int = x881
val x931 = while ({val x904 = x903
val x905 = x904 < x885
x905}) {
val x907 = x897
val x911 = x903
val x908 = x893 + x907
val x909 = x908 - x892
val x910 = x909 * 30
val x912 = x882 + x911
val x913 = x912 - x881
val x914 = x910 + x913
var x915: Int = x914
val x917 = x915
val x918 = x903
val x919 = x859(x901, x918)
val x920 = x916(x917) = x919
val x921 = x903
val x922 = x859(x901, x921)
val x923 = x922 > 0
val x928 = {
def x928thenb(): Unit = {
val x926 = x924.insert(x925, x917)
x926
}
def x928elseb(): Unit = {
()
}
if (x923) {
x928thenb()
} else {
x928elseb()
}
}
val x929 = x903 += 1
()
}
val x932 = x897 += 1
()
}
val x935 = x925 < 0
val x938 = {
def x938thenb(): Unit = {
val x936 = println("dummy")
x936
}
def x938elseb(): Unit = {
()
}
if (x935) {
x938thenb()
} else {
x938elseb()
}
}
val x943 = x874.radius
def x1069_block = {
val x940 = x939.dcApply(0)
var x1041 = {
val x941 = x851(x940)
val x942 = x941.radius
val x944 = x942 != x943
val x1019 = {
def x1019thenb(): Float = {
-1.0f
}
def x1019elseb(): Float = {
val x945 = x941.match_list
val x946 = x945.length
val x947 = x946.asInstanceOf[Float]
val x948 = x947==0.0
val x1017 = {
def x1017thenb(): Float = {
-1.0f
}
def x1017elseb(): Float = {
val x949 = x925.asInstanceOf[Float]
val x950 = x949 / x947
val x951 = x950 < 0.82f
val x1015 = {
def x1015thenb(): Float = {
x950
}
def x1015elseb(): Float = {
var x952: Float = 0.0f
val x953 = x947 * 0.18f
val x954 = x953 + 0.5f
val x955 = x954.asInstanceOf[Int]
var x956: Int = x955
var x957: Int = 0
var x958: Boolean = true
val x966 = x941.binary_gradients
val x1006 = while ({val x959 = x957
val x961 = x958
val x960 = x959 < x946
val x962 = x960 && x961
x962}) {
val x964 = x957
val x967 = x957
val x971 = x957
val x968 = x945(x967)
val x969 = x966(x968)
val x970 = x969==0
val x972 = x945(x971)
val x973 = x916(x972)
val x974 = x973==0
val x975 = x970 && x974
val x1003 = {
def x1003thenb(): Unit = {
val x976 = x952
val x977 = x976 + 1.0f
x952 = x977
()
}
def x1003elseb(): Unit = {
val x980 = x957
val x983 = x957
val x981 = x945(x980)
val x982 = x966(x981)
val x984 = x945(x983)
val x985 = x916(x984)
val x986 = x982 & x985
val x987 = x986 > 0
val x1001 = {
def x1001thenb(): Unit = {
val x988 = x952
val x989 = x988 + 1.0f
x952 = x989
()
}
def x1001elseb(): Unit = {
val x992 = x956
val x993 = x992 - 1
x956 = x993
val x995 = x956
val x996 = x995 <= 0
val x999 = {
def x999thenb(): Unit = {
x958 = false
()
}
def x999elseb(): Unit = {
()
}
if (x996) {
x999thenb()
} else {
x999elseb()
}
}
x999
}
if (x987) {
x1001thenb()
} else {
x1001elseb()
}
}
x1001
}
if (x975) {
x1003thenb()
} else {
x1003elseb()
}
}
val x1004 = x957 += 1
()
}
val x1007 = x958
val x1008 = !x1007
val x1013 = {
def x1013thenb(): Float = {
0.819999f
}
def x1013elseb(): Float = {
val x1009 = x952
val x1010 = x1009 / x947
val x1011 = x1010.asInstanceOf[Float]
x1011
}
if (x1008) {
x1013thenb()
} else {
x1013elseb()
}
}
x1013
}
if (x951) {
x1015thenb()
} else {
x1015elseb()
}
}
x1015
}
if (x948) {
x1017thenb()
} else {
x1017elseb()
}
}
x1017
}
if (x944) {
x1019thenb()
} else {
x1019elseb()
}
}
val x1020 = x1019 > 0.82f
val x1039 = {
def x1039thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1021 = x941.rect
val x1023 = x1021.width
val x868 = x857
val x869 = Math.pow(2.0,x868)
val x870 = x869.asInstanceOf[Int]
val x1022 = x870 * x867
val x1024 = x1023 / 2
val x1025 = x1022 - x1024
val x1026 = x1025.asInstanceOf[Int]
val x1028 = x1021.height
val x1027 = x870 * x863
val x1029 = x1028 / 2
val x1030 = x1027 - x1029
val x1031 = x1030.asInstanceOf[Int]
val x1032 = new generated.scala.Rect(x1026,x1031,x1023,x1028)
val x1033 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1034 = new generated.scala.BiGGDetection(x850,x1019,x1032,null,x940,x867,x863,x941,x874)
val x1035 = x1033(0) = x1034
x1033
}
def x1039elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1037 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1037
}
if (x1020) {
x1039thenb()
} else {
x1039elseb()
}
}
x1039
}
var mapReduceIdx = 1
while (mapReduceIdx < x939.size) { // begin mapReduce loop x1069
val x940 = x939.dcApply(mapReduceIdx)
val x1042 = {
val x941 = x851(x940)
val x942 = x941.radius
val x944 = x942 != x943
val x1019 = {
def x1019thenb(): Float = {
-1.0f
}
def x1019elseb(): Float = {
val x945 = x941.match_list
val x946 = x945.length
val x947 = x946.asInstanceOf[Float]
val x948 = x947==0.0
val x1017 = {
def x1017thenb(): Float = {
-1.0f
}
def x1017elseb(): Float = {
val x949 = x925.asInstanceOf[Float]
val x950 = x949 / x947
val x951 = x950 < 0.82f
val x1015 = {
def x1015thenb(): Float = {
x950
}
def x1015elseb(): Float = {
var x952: Float = 0.0f
val x953 = x947 * 0.18f
val x954 = x953 + 0.5f
val x955 = x954.asInstanceOf[Int]
var x956: Int = x955
var x957: Int = 0
var x958: Boolean = true
val x966 = x941.binary_gradients
val x1006 = while ({val x959 = x957
val x961 = x958
val x960 = x959 < x946
val x962 = x960 && x961
x962}) {
val x964 = x957
val x967 = x957
val x971 = x957
val x968 = x945(x967)
val x969 = x966(x968)
val x970 = x969==0
val x972 = x945(x971)
val x973 = x916(x972)
val x974 = x973==0
val x975 = x970 && x974
val x1003 = {
def x1003thenb(): Unit = {
val x976 = x952
val x977 = x976 + 1.0f
x952 = x977
()
}
def x1003elseb(): Unit = {
val x980 = x957
val x983 = x957
val x981 = x945(x980)
val x982 = x966(x981)
val x984 = x945(x983)
val x985 = x916(x984)
val x986 = x982 & x985
val x987 = x986 > 0
val x1001 = {
def x1001thenb(): Unit = {
val x988 = x952
val x989 = x988 + 1.0f
x952 = x989
()
}
def x1001elseb(): Unit = {
val x992 = x956
val x993 = x992 - 1
x956 = x993
val x995 = x956
val x996 = x995 <= 0
val x999 = {
def x999thenb(): Unit = {
x958 = false
()
}
def x999elseb(): Unit = {
()
}
if (x996) {
x999thenb()
} else {
x999elseb()
}
}
x999
}
if (x987) {
x1001thenb()
} else {
x1001elseb()
}
}
x1001
}
if (x975) {
x1003thenb()
} else {
x1003elseb()
}
}
val x1004 = x957 += 1
()
}
val x1007 = x958
val x1008 = !x1007
val x1013 = {
def x1013thenb(): Float = {
0.819999f
}
def x1013elseb(): Float = {
val x1009 = x952
val x1010 = x1009 / x947
val x1011 = x1010.asInstanceOf[Float]
x1011
}
if (x1008) {
x1013thenb()
} else {
x1013elseb()
}
}
x1013
}
if (x951) {
x1015thenb()
} else {
x1015elseb()
}
}
x1015
}
if (x948) {
x1017thenb()
} else {
x1017elseb()
}
}
x1017
}
if (x944) {
x1019thenb()
} else {
x1019elseb()
}
}
val x1020 = x1019 > 0.82f
val x1039 = {
def x1039thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1021 = x941.rect
val x1023 = x1021.width
val x868 = x857
val x869 = Math.pow(2.0,x868)
val x870 = x869.asInstanceOf[Int]
val x1022 = x870 * x867
val x1024 = x1023 / 2
val x1025 = x1022 - x1024
val x1026 = x1025.asInstanceOf[Int]
val x1028 = x1021.height
val x1027 = x870 * x863
val x1029 = x1028 / 2
val x1030 = x1027 - x1029
val x1031 = x1030.asInstanceOf[Int]
val x1032 = new generated.scala.Rect(x1026,x1031,x1023,x1028)
val x1033 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1034 = new generated.scala.BiGGDetection(x850,x1019,x1032,null,x940,x867,x863,x941,x874)
val x1035 = x1033(0) = x1034
x1033
}
def x1039elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1037 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1037
}
if (x1020) {
x1039thenb()
} else {
x1039elseb()
}
}
x1039
}
x1041 = {
val x1043 = x1041.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1068 = { 
val x1066 = {
def x1066thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1042
}
def x1066elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1044 = x1042.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1064 = {
def x1064thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1041
}
def x1064elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1045 = x1041.length
val x1046 = x1042.length
val x1047 = x1045 + x1046
val x1048 = x1041.isRow
val x1049 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1047,x1048)
var x1051 : Int = 0
val x1055 = while (x1051 < x1045) {
val x1052 = x1041(x1051)
val x1053 = x1049(x1051) = x1052
x1053
x1051 = x1051 + 1
}
var x1057 : Int = 0
val x1062 = while (x1057 < x1046) {
val x1058 = x1057 + x1045
val x1059 = x1042(x1057)
val x1060 = x1049(x1058) = x1059
x1060
x1057 = x1057 + 1
}
x1049
}
if (x1044) {
x1064thenb()
} else {
x1064elseb()
}
}
x1064
}
if (x1043) {
x1066thenb()
} else {
x1066elseb()
}
}
x1066
}
x1068
}
mapReduceIdx += 1
} // end mapReduce loop x1069
x1041
}
val x1069 = x1069_block
x1069
}
var mapReduceIdx = 1
while (mapReduceIdx < x866.size) { // begin mapReduce loop x1099
val x867 = x866.dcApply(mapReduceIdx)
val x1072 = {
val x871 = new generated.scala.IntVectorImpl(900,false)
val x872 = new generated.scala.IntVectorImpl(0,true)
val x873 = new generated.scala.IndexVectorSeqImpl(x872)
val x874 = new generated.scala.BinarizedGradientTemplate(15,null,null,x857,x871,x873,null,null,null)
var x897: Int = x892
val x875 = x867 - 15
val x876 = x875 < 0
val x880 = {
def x880thenb(): scala.Tuple2[Int, Int] = {
val x877 = 15 - x867
val x878 = (0,x877)
x878
}
def x880elseb(): scala.Tuple2[Int, Int] = {
val x879 = (x875,0)
x879
}
if (x876) {
x880thenb()
} else {
x880elseb()
}
}
val x881 = x880._1
val x883 = x867 + 15
val x884 = x883 > x864
val x885 = {
def x885thenb(): Int = {
x864
}
def x885elseb(): Int = {
x883
}
if (x884) {
x885thenb()
} else {
x885elseb()
}
}
val x882 = x880._2
val x916 = x874.binary_gradients
val x924 = x874.match_list
val x925 = x924.length
val x934 = while ({val x898 = x897
val x899 = x898 < x896
x899}) {
val x901 = x897
var x903: Int = x881
val x931 = while ({val x904 = x903
val x905 = x904 < x885
x905}) {
val x907 = x897
val x911 = x903
val x908 = x893 + x907
val x909 = x908 - x892
val x910 = x909 * 30
val x912 = x882 + x911
val x913 = x912 - x881
val x914 = x910 + x913
var x915: Int = x914
val x917 = x915
val x918 = x903
val x919 = x859(x901, x918)
val x920 = x916(x917) = x919
val x921 = x903
val x922 = x859(x901, x921)
val x923 = x922 > 0
val x928 = {
def x928thenb(): Unit = {
val x926 = x924.insert(x925, x917)
x926
}
def x928elseb(): Unit = {
()
}
if (x923) {
x928thenb()
} else {
x928elseb()
}
}
val x929 = x903 += 1
()
}
val x932 = x897 += 1
()
}
val x935 = x925 < 0
val x938 = {
def x938thenb(): Unit = {
val x936 = println("dummy")
x936
}
def x938elseb(): Unit = {
()
}
if (x935) {
x938thenb()
} else {
x938elseb()
}
}
val x943 = x874.radius
def x1069_block = {
val x940 = x939.dcApply(0)
var x1041 = {
val x941 = x851(x940)
val x942 = x941.radius
val x944 = x942 != x943
val x1019 = {
def x1019thenb(): Float = {
-1.0f
}
def x1019elseb(): Float = {
val x945 = x941.match_list
val x946 = x945.length
val x947 = x946.asInstanceOf[Float]
val x948 = x947==0.0
val x1017 = {
def x1017thenb(): Float = {
-1.0f
}
def x1017elseb(): Float = {
val x949 = x925.asInstanceOf[Float]
val x950 = x949 / x947
val x951 = x950 < 0.82f
val x1015 = {
def x1015thenb(): Float = {
x950
}
def x1015elseb(): Float = {
var x952: Float = 0.0f
val x953 = x947 * 0.18f
val x954 = x953 + 0.5f
val x955 = x954.asInstanceOf[Int]
var x956: Int = x955
var x957: Int = 0
var x958: Boolean = true
val x966 = x941.binary_gradients
val x1006 = while ({val x959 = x957
val x961 = x958
val x960 = x959 < x946
val x962 = x960 && x961
x962}) {
val x964 = x957
val x967 = x957
val x971 = x957
val x968 = x945(x967)
val x969 = x966(x968)
val x970 = x969==0
val x972 = x945(x971)
val x973 = x916(x972)
val x974 = x973==0
val x975 = x970 && x974
val x1003 = {
def x1003thenb(): Unit = {
val x976 = x952
val x977 = x976 + 1.0f
x952 = x977
()
}
def x1003elseb(): Unit = {
val x980 = x957
val x983 = x957
val x981 = x945(x980)
val x982 = x966(x981)
val x984 = x945(x983)
val x985 = x916(x984)
val x986 = x982 & x985
val x987 = x986 > 0
val x1001 = {
def x1001thenb(): Unit = {
val x988 = x952
val x989 = x988 + 1.0f
x952 = x989
()
}
def x1001elseb(): Unit = {
val x992 = x956
val x993 = x992 - 1
x956 = x993
val x995 = x956
val x996 = x995 <= 0
val x999 = {
def x999thenb(): Unit = {
x958 = false
()
}
def x999elseb(): Unit = {
()
}
if (x996) {
x999thenb()
} else {
x999elseb()
}
}
x999
}
if (x987) {
x1001thenb()
} else {
x1001elseb()
}
}
x1001
}
if (x975) {
x1003thenb()
} else {
x1003elseb()
}
}
val x1004 = x957 += 1
()
}
val x1007 = x958
val x1008 = !x1007
val x1013 = {
def x1013thenb(): Float = {
0.819999f
}
def x1013elseb(): Float = {
val x1009 = x952
val x1010 = x1009 / x947
val x1011 = x1010.asInstanceOf[Float]
x1011
}
if (x1008) {
x1013thenb()
} else {
x1013elseb()
}
}
x1013
}
if (x951) {
x1015thenb()
} else {
x1015elseb()
}
}
x1015
}
if (x948) {
x1017thenb()
} else {
x1017elseb()
}
}
x1017
}
if (x944) {
x1019thenb()
} else {
x1019elseb()
}
}
val x1020 = x1019 > 0.82f
val x1039 = {
def x1039thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1021 = x941.rect
val x1023 = x1021.width
val x868 = x857
val x869 = Math.pow(2.0,x868)
val x870 = x869.asInstanceOf[Int]
val x1022 = x870 * x867
val x1024 = x1023 / 2
val x1025 = x1022 - x1024
val x1026 = x1025.asInstanceOf[Int]
val x1028 = x1021.height
val x1027 = x870 * x863
val x1029 = x1028 / 2
val x1030 = x1027 - x1029
val x1031 = x1030.asInstanceOf[Int]
val x1032 = new generated.scala.Rect(x1026,x1031,x1023,x1028)
val x1033 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1034 = new generated.scala.BiGGDetection(x850,x1019,x1032,null,x940,x867,x863,x941,x874)
val x1035 = x1033(0) = x1034
x1033
}
def x1039elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1037 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1037
}
if (x1020) {
x1039thenb()
} else {
x1039elseb()
}
}
x1039
}
var mapReduceIdx = 1
while (mapReduceIdx < x939.size) { // begin mapReduce loop x1069
val x940 = x939.dcApply(mapReduceIdx)
val x1042 = {
val x941 = x851(x940)
val x942 = x941.radius
val x944 = x942 != x943
val x1019 = {
def x1019thenb(): Float = {
-1.0f
}
def x1019elseb(): Float = {
val x945 = x941.match_list
val x946 = x945.length
val x947 = x946.asInstanceOf[Float]
val x948 = x947==0.0
val x1017 = {
def x1017thenb(): Float = {
-1.0f
}
def x1017elseb(): Float = {
val x949 = x925.asInstanceOf[Float]
val x950 = x949 / x947
val x951 = x950 < 0.82f
val x1015 = {
def x1015thenb(): Float = {
x950
}
def x1015elseb(): Float = {
var x952: Float = 0.0f
val x953 = x947 * 0.18f
val x954 = x953 + 0.5f
val x955 = x954.asInstanceOf[Int]
var x956: Int = x955
var x957: Int = 0
var x958: Boolean = true
val x966 = x941.binary_gradients
val x1006 = while ({val x959 = x957
val x961 = x958
val x960 = x959 < x946
val x962 = x960 && x961
x962}) {
val x964 = x957
val x967 = x957
val x971 = x957
val x968 = x945(x967)
val x969 = x966(x968)
val x970 = x969==0
val x972 = x945(x971)
val x973 = x916(x972)
val x974 = x973==0
val x975 = x970 && x974
val x1003 = {
def x1003thenb(): Unit = {
val x976 = x952
val x977 = x976 + 1.0f
x952 = x977
()
}
def x1003elseb(): Unit = {
val x980 = x957
val x983 = x957
val x981 = x945(x980)
val x982 = x966(x981)
val x984 = x945(x983)
val x985 = x916(x984)
val x986 = x982 & x985
val x987 = x986 > 0
val x1001 = {
def x1001thenb(): Unit = {
val x988 = x952
val x989 = x988 + 1.0f
x952 = x989
()
}
def x1001elseb(): Unit = {
val x992 = x956
val x993 = x992 - 1
x956 = x993
val x995 = x956
val x996 = x995 <= 0
val x999 = {
def x999thenb(): Unit = {
x958 = false
()
}
def x999elseb(): Unit = {
()
}
if (x996) {
x999thenb()
} else {
x999elseb()
}
}
x999
}
if (x987) {
x1001thenb()
} else {
x1001elseb()
}
}
x1001
}
if (x975) {
x1003thenb()
} else {
x1003elseb()
}
}
val x1004 = x957 += 1
()
}
val x1007 = x958
val x1008 = !x1007
val x1013 = {
def x1013thenb(): Float = {
0.819999f
}
def x1013elseb(): Float = {
val x1009 = x952
val x1010 = x1009 / x947
val x1011 = x1010.asInstanceOf[Float]
x1011
}
if (x1008) {
x1013thenb()
} else {
x1013elseb()
}
}
x1013
}
if (x951) {
x1015thenb()
} else {
x1015elseb()
}
}
x1015
}
if (x948) {
x1017thenb()
} else {
x1017elseb()
}
}
x1017
}
if (x944) {
x1019thenb()
} else {
x1019elseb()
}
}
val x1020 = x1019 > 0.82f
val x1039 = {
def x1039thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1021 = x941.rect
val x1023 = x1021.width
val x868 = x857
val x869 = Math.pow(2.0,x868)
val x870 = x869.asInstanceOf[Int]
val x1022 = x870 * x867
val x1024 = x1023 / 2
val x1025 = x1022 - x1024
val x1026 = x1025.asInstanceOf[Int]
val x1028 = x1021.height
val x1027 = x870 * x863
val x1029 = x1028 / 2
val x1030 = x1027 - x1029
val x1031 = x1030.asInstanceOf[Int]
val x1032 = new generated.scala.Rect(x1026,x1031,x1023,x1028)
val x1033 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1034 = new generated.scala.BiGGDetection(x850,x1019,x1032,null,x940,x867,x863,x941,x874)
val x1035 = x1033(0) = x1034
x1033
}
def x1039elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1037 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1037
}
if (x1020) {
x1039thenb()
} else {
x1039elseb()
}
}
x1039
}
x1041 = {
val x1043 = x1041.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1068 = { 
val x1066 = {
def x1066thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1042
}
def x1066elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1044 = x1042.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1064 = {
def x1064thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1041
}
def x1064elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1045 = x1041.length
val x1046 = x1042.length
val x1047 = x1045 + x1046
val x1048 = x1041.isRow
val x1049 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1047,x1048)
var x1051 : Int = 0
val x1055 = while (x1051 < x1045) {
val x1052 = x1041(x1051)
val x1053 = x1049(x1051) = x1052
x1053
x1051 = x1051 + 1
}
var x1057 : Int = 0
val x1062 = while (x1057 < x1046) {
val x1058 = x1057 + x1045
val x1059 = x1042(x1057)
val x1060 = x1049(x1058) = x1059
x1060
x1057 = x1057 + 1
}
x1049
}
if (x1044) {
x1064thenb()
} else {
x1064elseb()
}
}
x1064
}
if (x1043) {
x1066thenb()
} else {
x1066elseb()
}
}
x1066
}
x1068
}
mapReduceIdx += 1
} // end mapReduce loop x1069
x1041
}
val x1069 = x1069_block
x1069
}
x1071 = {
val x1073 = x1071.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1098 = { 
val x1096 = {
def x1096thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1072
}
def x1096elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1074 = x1072.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1094 = {
def x1094thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1071
}
def x1094elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1075 = x1071.length
val x1076 = x1072.length
val x1077 = x1075 + x1076
val x1078 = x1071.isRow
val x1079 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1077,x1078)
var x1081 : Int = 0
val x1085 = while (x1081 < x1075) {
val x1082 = x1071(x1081)
val x1083 = x1079(x1081) = x1082
x1083
x1081 = x1081 + 1
}
var x1087 : Int = 0
val x1092 = while (x1087 < x1076) {
val x1088 = x1087 + x1075
val x1089 = x1072(x1087)
val x1090 = x1079(x1088) = x1089
x1090
x1087 = x1087 + 1
}
x1079
}
if (x1074) {
x1094thenb()
} else {
x1094elseb()
}
}
x1094
}
if (x1073) {
x1096thenb()
} else {
x1096elseb()
}
}
x1096
}
x1098
}
mapReduceIdx += 1
} // end mapReduce loop x1099
x1071
}
val x1099 = x1099_block
x1099
}
var mapReduceIdx = 1
while (mapReduceIdx < x862.size) { // begin mapReduce loop x1128
val x863 = x862.dcApply(mapReduceIdx)
val x1101 = {
val x886 = x863 - 15
val x887 = x886 < 0
val x891 = {
def x891thenb(): scala.Tuple2[Int, Int] = {
val x888 = 15 - x863
val x889 = (0,x888)
x889
}
def x891elseb(): scala.Tuple2[Int, Int] = {
val x890 = (x886,0)
x890
}
if (x887) {
x891thenb()
} else {
x891elseb()
}
}
val x892 = x891._1
val x894 = x863 + 15
val x895 = x894 > x860
val x896 = {
def x896thenb(): Int = {
x860
}
def x896elseb(): Int = {
x894
}
if (x895) {
x896thenb()
} else {
x896elseb()
}
}
val x893 = x891._2
def x1099_block = {
val x867 = x866.dcApply(0)
var x1071 = {
val x871 = new generated.scala.IntVectorImpl(900,false)
val x872 = new generated.scala.IntVectorImpl(0,true)
val x873 = new generated.scala.IndexVectorSeqImpl(x872)
val x874 = new generated.scala.BinarizedGradientTemplate(15,null,null,x857,x871,x873,null,null,null)
var x897: Int = x892
val x875 = x867 - 15
val x876 = x875 < 0
val x880 = {
def x880thenb(): scala.Tuple2[Int, Int] = {
val x877 = 15 - x867
val x878 = (0,x877)
x878
}
def x880elseb(): scala.Tuple2[Int, Int] = {
val x879 = (x875,0)
x879
}
if (x876) {
x880thenb()
} else {
x880elseb()
}
}
val x881 = x880._1
val x883 = x867 + 15
val x884 = x883 > x864
val x885 = {
def x885thenb(): Int = {
x864
}
def x885elseb(): Int = {
x883
}
if (x884) {
x885thenb()
} else {
x885elseb()
}
}
val x882 = x880._2
val x916 = x874.binary_gradients
val x924 = x874.match_list
val x925 = x924.length
val x934 = while ({val x898 = x897
val x899 = x898 < x896
x899}) {
val x901 = x897
var x903: Int = x881
val x931 = while ({val x904 = x903
val x905 = x904 < x885
x905}) {
val x907 = x897
val x911 = x903
val x908 = x893 + x907
val x909 = x908 - x892
val x910 = x909 * 30
val x912 = x882 + x911
val x913 = x912 - x881
val x914 = x910 + x913
var x915: Int = x914
val x917 = x915
val x918 = x903
val x919 = x859(x901, x918)
val x920 = x916(x917) = x919
val x921 = x903
val x922 = x859(x901, x921)
val x923 = x922 > 0
val x928 = {
def x928thenb(): Unit = {
val x926 = x924.insert(x925, x917)
x926
}
def x928elseb(): Unit = {
()
}
if (x923) {
x928thenb()
} else {
x928elseb()
}
}
val x929 = x903 += 1
()
}
val x932 = x897 += 1
()
}
val x935 = x925 < 0
val x938 = {
def x938thenb(): Unit = {
val x936 = println("dummy")
x936
}
def x938elseb(): Unit = {
()
}
if (x935) {
x938thenb()
} else {
x938elseb()
}
}
val x943 = x874.radius
def x1069_block = {
val x940 = x939.dcApply(0)
var x1041 = {
val x941 = x851(x940)
val x942 = x941.radius
val x944 = x942 != x943
val x1019 = {
def x1019thenb(): Float = {
-1.0f
}
def x1019elseb(): Float = {
val x945 = x941.match_list
val x946 = x945.length
val x947 = x946.asInstanceOf[Float]
val x948 = x947==0.0
val x1017 = {
def x1017thenb(): Float = {
-1.0f
}
def x1017elseb(): Float = {
val x949 = x925.asInstanceOf[Float]
val x950 = x949 / x947
val x951 = x950 < 0.82f
val x1015 = {
def x1015thenb(): Float = {
x950
}
def x1015elseb(): Float = {
var x952: Float = 0.0f
val x953 = x947 * 0.18f
val x954 = x953 + 0.5f
val x955 = x954.asInstanceOf[Int]
var x956: Int = x955
var x957: Int = 0
var x958: Boolean = true
val x966 = x941.binary_gradients
val x1006 = while ({val x959 = x957
val x961 = x958
val x960 = x959 < x946
val x962 = x960 && x961
x962}) {
val x964 = x957
val x967 = x957
val x971 = x957
val x968 = x945(x967)
val x969 = x966(x968)
val x970 = x969==0
val x972 = x945(x971)
val x973 = x916(x972)
val x974 = x973==0
val x975 = x970 && x974
val x1003 = {
def x1003thenb(): Unit = {
val x976 = x952
val x977 = x976 + 1.0f
x952 = x977
()
}
def x1003elseb(): Unit = {
val x980 = x957
val x983 = x957
val x981 = x945(x980)
val x982 = x966(x981)
val x984 = x945(x983)
val x985 = x916(x984)
val x986 = x982 & x985
val x987 = x986 > 0
val x1001 = {
def x1001thenb(): Unit = {
val x988 = x952
val x989 = x988 + 1.0f
x952 = x989
()
}
def x1001elseb(): Unit = {
val x992 = x956
val x993 = x992 - 1
x956 = x993
val x995 = x956
val x996 = x995 <= 0
val x999 = {
def x999thenb(): Unit = {
x958 = false
()
}
def x999elseb(): Unit = {
()
}
if (x996) {
x999thenb()
} else {
x999elseb()
}
}
x999
}
if (x987) {
x1001thenb()
} else {
x1001elseb()
}
}
x1001
}
if (x975) {
x1003thenb()
} else {
x1003elseb()
}
}
val x1004 = x957 += 1
()
}
val x1007 = x958
val x1008 = !x1007
val x1013 = {
def x1013thenb(): Float = {
0.819999f
}
def x1013elseb(): Float = {
val x1009 = x952
val x1010 = x1009 / x947
val x1011 = x1010.asInstanceOf[Float]
x1011
}
if (x1008) {
x1013thenb()
} else {
x1013elseb()
}
}
x1013
}
if (x951) {
x1015thenb()
} else {
x1015elseb()
}
}
x1015
}
if (x948) {
x1017thenb()
} else {
x1017elseb()
}
}
x1017
}
if (x944) {
x1019thenb()
} else {
x1019elseb()
}
}
val x1020 = x1019 > 0.82f
val x1039 = {
def x1039thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1021 = x941.rect
val x1023 = x1021.width
val x868 = x857
val x869 = Math.pow(2.0,x868)
val x870 = x869.asInstanceOf[Int]
val x1022 = x870 * x867
val x1024 = x1023 / 2
val x1025 = x1022 - x1024
val x1026 = x1025.asInstanceOf[Int]
val x1028 = x1021.height
val x1027 = x870 * x863
val x1029 = x1028 / 2
val x1030 = x1027 - x1029
val x1031 = x1030.asInstanceOf[Int]
val x1032 = new generated.scala.Rect(x1026,x1031,x1023,x1028)
val x1033 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1034 = new generated.scala.BiGGDetection(x850,x1019,x1032,null,x940,x867,x863,x941,x874)
val x1035 = x1033(0) = x1034
x1033
}
def x1039elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1037 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1037
}
if (x1020) {
x1039thenb()
} else {
x1039elseb()
}
}
x1039
}
var mapReduceIdx = 1
while (mapReduceIdx < x939.size) { // begin mapReduce loop x1069
val x940 = x939.dcApply(mapReduceIdx)
val x1042 = {
val x941 = x851(x940)
val x942 = x941.radius
val x944 = x942 != x943
val x1019 = {
def x1019thenb(): Float = {
-1.0f
}
def x1019elseb(): Float = {
val x945 = x941.match_list
val x946 = x945.length
val x947 = x946.asInstanceOf[Float]
val x948 = x947==0.0
val x1017 = {
def x1017thenb(): Float = {
-1.0f
}
def x1017elseb(): Float = {
val x949 = x925.asInstanceOf[Float]
val x950 = x949 / x947
val x951 = x950 < 0.82f
val x1015 = {
def x1015thenb(): Float = {
x950
}
def x1015elseb(): Float = {
var x952: Float = 0.0f
val x953 = x947 * 0.18f
val x954 = x953 + 0.5f
val x955 = x954.asInstanceOf[Int]
var x956: Int = x955
var x957: Int = 0
var x958: Boolean = true
val x966 = x941.binary_gradients
val x1006 = while ({val x959 = x957
val x961 = x958
val x960 = x959 < x946
val x962 = x960 && x961
x962}) {
val x964 = x957
val x967 = x957
val x971 = x957
val x968 = x945(x967)
val x969 = x966(x968)
val x970 = x969==0
val x972 = x945(x971)
val x973 = x916(x972)
val x974 = x973==0
val x975 = x970 && x974
val x1003 = {
def x1003thenb(): Unit = {
val x976 = x952
val x977 = x976 + 1.0f
x952 = x977
()
}
def x1003elseb(): Unit = {
val x980 = x957
val x983 = x957
val x981 = x945(x980)
val x982 = x966(x981)
val x984 = x945(x983)
val x985 = x916(x984)
val x986 = x982 & x985
val x987 = x986 > 0
val x1001 = {
def x1001thenb(): Unit = {
val x988 = x952
val x989 = x988 + 1.0f
x952 = x989
()
}
def x1001elseb(): Unit = {
val x992 = x956
val x993 = x992 - 1
x956 = x993
val x995 = x956
val x996 = x995 <= 0
val x999 = {
def x999thenb(): Unit = {
x958 = false
()
}
def x999elseb(): Unit = {
()
}
if (x996) {
x999thenb()
} else {
x999elseb()
}
}
x999
}
if (x987) {
x1001thenb()
} else {
x1001elseb()
}
}
x1001
}
if (x975) {
x1003thenb()
} else {
x1003elseb()
}
}
val x1004 = x957 += 1
()
}
val x1007 = x958
val x1008 = !x1007
val x1013 = {
def x1013thenb(): Float = {
0.819999f
}
def x1013elseb(): Float = {
val x1009 = x952
val x1010 = x1009 / x947
val x1011 = x1010.asInstanceOf[Float]
x1011
}
if (x1008) {
x1013thenb()
} else {
x1013elseb()
}
}
x1013
}
if (x951) {
x1015thenb()
} else {
x1015elseb()
}
}
x1015
}
if (x948) {
x1017thenb()
} else {
x1017elseb()
}
}
x1017
}
if (x944) {
x1019thenb()
} else {
x1019elseb()
}
}
val x1020 = x1019 > 0.82f
val x1039 = {
def x1039thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1021 = x941.rect
val x1023 = x1021.width
val x868 = x857
val x869 = Math.pow(2.0,x868)
val x870 = x869.asInstanceOf[Int]
val x1022 = x870 * x867
val x1024 = x1023 / 2
val x1025 = x1022 - x1024
val x1026 = x1025.asInstanceOf[Int]
val x1028 = x1021.height
val x1027 = x870 * x863
val x1029 = x1028 / 2
val x1030 = x1027 - x1029
val x1031 = x1030.asInstanceOf[Int]
val x1032 = new generated.scala.Rect(x1026,x1031,x1023,x1028)
val x1033 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1034 = new generated.scala.BiGGDetection(x850,x1019,x1032,null,x940,x867,x863,x941,x874)
val x1035 = x1033(0) = x1034
x1033
}
def x1039elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1037 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1037
}
if (x1020) {
x1039thenb()
} else {
x1039elseb()
}
}
x1039
}
x1041 = {
val x1043 = x1041.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1068 = { 
val x1066 = {
def x1066thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1042
}
def x1066elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1044 = x1042.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1064 = {
def x1064thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1041
}
def x1064elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1045 = x1041.length
val x1046 = x1042.length
val x1047 = x1045 + x1046
val x1048 = x1041.isRow
val x1049 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1047,x1048)
var x1051 : Int = 0
val x1055 = while (x1051 < x1045) {
val x1052 = x1041(x1051)
val x1053 = x1049(x1051) = x1052
x1053
x1051 = x1051 + 1
}
var x1057 : Int = 0
val x1062 = while (x1057 < x1046) {
val x1058 = x1057 + x1045
val x1059 = x1042(x1057)
val x1060 = x1049(x1058) = x1059
x1060
x1057 = x1057 + 1
}
x1049
}
if (x1044) {
x1064thenb()
} else {
x1064elseb()
}
}
x1064
}
if (x1043) {
x1066thenb()
} else {
x1066elseb()
}
}
x1066
}
x1068
}
mapReduceIdx += 1
} // end mapReduce loop x1069
x1041
}
val x1069 = x1069_block
x1069
}
var mapReduceIdx = 1
while (mapReduceIdx < x866.size) { // begin mapReduce loop x1099
val x867 = x866.dcApply(mapReduceIdx)
val x1072 = {
val x871 = new generated.scala.IntVectorImpl(900,false)
val x872 = new generated.scala.IntVectorImpl(0,true)
val x873 = new generated.scala.IndexVectorSeqImpl(x872)
val x874 = new generated.scala.BinarizedGradientTemplate(15,null,null,x857,x871,x873,null,null,null)
var x897: Int = x892
val x875 = x867 - 15
val x876 = x875 < 0
val x880 = {
def x880thenb(): scala.Tuple2[Int, Int] = {
val x877 = 15 - x867
val x878 = (0,x877)
x878
}
def x880elseb(): scala.Tuple2[Int, Int] = {
val x879 = (x875,0)
x879
}
if (x876) {
x880thenb()
} else {
x880elseb()
}
}
val x881 = x880._1
val x883 = x867 + 15
val x884 = x883 > x864
val x885 = {
def x885thenb(): Int = {
x864
}
def x885elseb(): Int = {
x883
}
if (x884) {
x885thenb()
} else {
x885elseb()
}
}
val x882 = x880._2
val x916 = x874.binary_gradients
val x924 = x874.match_list
val x925 = x924.length
val x934 = while ({val x898 = x897
val x899 = x898 < x896
x899}) {
val x901 = x897
var x903: Int = x881
val x931 = while ({val x904 = x903
val x905 = x904 < x885
x905}) {
val x907 = x897
val x911 = x903
val x908 = x893 + x907
val x909 = x908 - x892
val x910 = x909 * 30
val x912 = x882 + x911
val x913 = x912 - x881
val x914 = x910 + x913
var x915: Int = x914
val x917 = x915
val x918 = x903
val x919 = x859(x901, x918)
val x920 = x916(x917) = x919
val x921 = x903
val x922 = x859(x901, x921)
val x923 = x922 > 0
val x928 = {
def x928thenb(): Unit = {
val x926 = x924.insert(x925, x917)
x926
}
def x928elseb(): Unit = {
()
}
if (x923) {
x928thenb()
} else {
x928elseb()
}
}
val x929 = x903 += 1
()
}
val x932 = x897 += 1
()
}
val x935 = x925 < 0
val x938 = {
def x938thenb(): Unit = {
val x936 = println("dummy")
x936
}
def x938elseb(): Unit = {
()
}
if (x935) {
x938thenb()
} else {
x938elseb()
}
}
val x943 = x874.radius
def x1069_block = {
val x940 = x939.dcApply(0)
var x1041 = {
val x941 = x851(x940)
val x942 = x941.radius
val x944 = x942 != x943
val x1019 = {
def x1019thenb(): Float = {
-1.0f
}
def x1019elseb(): Float = {
val x945 = x941.match_list
val x946 = x945.length
val x947 = x946.asInstanceOf[Float]
val x948 = x947==0.0
val x1017 = {
def x1017thenb(): Float = {
-1.0f
}
def x1017elseb(): Float = {
val x949 = x925.asInstanceOf[Float]
val x950 = x949 / x947
val x951 = x950 < 0.82f
val x1015 = {
def x1015thenb(): Float = {
x950
}
def x1015elseb(): Float = {
var x952: Float = 0.0f
val x953 = x947 * 0.18f
val x954 = x953 + 0.5f
val x955 = x954.asInstanceOf[Int]
var x956: Int = x955
var x957: Int = 0
var x958: Boolean = true
val x966 = x941.binary_gradients
val x1006 = while ({val x959 = x957
val x961 = x958
val x960 = x959 < x946
val x962 = x960 && x961
x962}) {
val x964 = x957
val x967 = x957
val x971 = x957
val x968 = x945(x967)
val x969 = x966(x968)
val x970 = x969==0
val x972 = x945(x971)
val x973 = x916(x972)
val x974 = x973==0
val x975 = x970 && x974
val x1003 = {
def x1003thenb(): Unit = {
val x976 = x952
val x977 = x976 + 1.0f
x952 = x977
()
}
def x1003elseb(): Unit = {
val x980 = x957
val x983 = x957
val x981 = x945(x980)
val x982 = x966(x981)
val x984 = x945(x983)
val x985 = x916(x984)
val x986 = x982 & x985
val x987 = x986 > 0
val x1001 = {
def x1001thenb(): Unit = {
val x988 = x952
val x989 = x988 + 1.0f
x952 = x989
()
}
def x1001elseb(): Unit = {
val x992 = x956
val x993 = x992 - 1
x956 = x993
val x995 = x956
val x996 = x995 <= 0
val x999 = {
def x999thenb(): Unit = {
x958 = false
()
}
def x999elseb(): Unit = {
()
}
if (x996) {
x999thenb()
} else {
x999elseb()
}
}
x999
}
if (x987) {
x1001thenb()
} else {
x1001elseb()
}
}
x1001
}
if (x975) {
x1003thenb()
} else {
x1003elseb()
}
}
val x1004 = x957 += 1
()
}
val x1007 = x958
val x1008 = !x1007
val x1013 = {
def x1013thenb(): Float = {
0.819999f
}
def x1013elseb(): Float = {
val x1009 = x952
val x1010 = x1009 / x947
val x1011 = x1010.asInstanceOf[Float]
x1011
}
if (x1008) {
x1013thenb()
} else {
x1013elseb()
}
}
x1013
}
if (x951) {
x1015thenb()
} else {
x1015elseb()
}
}
x1015
}
if (x948) {
x1017thenb()
} else {
x1017elseb()
}
}
x1017
}
if (x944) {
x1019thenb()
} else {
x1019elseb()
}
}
val x1020 = x1019 > 0.82f
val x1039 = {
def x1039thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1021 = x941.rect
val x1023 = x1021.width
val x868 = x857
val x869 = Math.pow(2.0,x868)
val x870 = x869.asInstanceOf[Int]
val x1022 = x870 * x867
val x1024 = x1023 / 2
val x1025 = x1022 - x1024
val x1026 = x1025.asInstanceOf[Int]
val x1028 = x1021.height
val x1027 = x870 * x863
val x1029 = x1028 / 2
val x1030 = x1027 - x1029
val x1031 = x1030.asInstanceOf[Int]
val x1032 = new generated.scala.Rect(x1026,x1031,x1023,x1028)
val x1033 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1034 = new generated.scala.BiGGDetection(x850,x1019,x1032,null,x940,x867,x863,x941,x874)
val x1035 = x1033(0) = x1034
x1033
}
def x1039elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1037 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1037
}
if (x1020) {
x1039thenb()
} else {
x1039elseb()
}
}
x1039
}
var mapReduceIdx = 1
while (mapReduceIdx < x939.size) { // begin mapReduce loop x1069
val x940 = x939.dcApply(mapReduceIdx)
val x1042 = {
val x941 = x851(x940)
val x942 = x941.radius
val x944 = x942 != x943
val x1019 = {
def x1019thenb(): Float = {
-1.0f
}
def x1019elseb(): Float = {
val x945 = x941.match_list
val x946 = x945.length
val x947 = x946.asInstanceOf[Float]
val x948 = x947==0.0
val x1017 = {
def x1017thenb(): Float = {
-1.0f
}
def x1017elseb(): Float = {
val x949 = x925.asInstanceOf[Float]
val x950 = x949 / x947
val x951 = x950 < 0.82f
val x1015 = {
def x1015thenb(): Float = {
x950
}
def x1015elseb(): Float = {
var x952: Float = 0.0f
val x953 = x947 * 0.18f
val x954 = x953 + 0.5f
val x955 = x954.asInstanceOf[Int]
var x956: Int = x955
var x957: Int = 0
var x958: Boolean = true
val x966 = x941.binary_gradients
val x1006 = while ({val x959 = x957
val x961 = x958
val x960 = x959 < x946
val x962 = x960 && x961
x962}) {
val x964 = x957
val x967 = x957
val x971 = x957
val x968 = x945(x967)
val x969 = x966(x968)
val x970 = x969==0
val x972 = x945(x971)
val x973 = x916(x972)
val x974 = x973==0
val x975 = x970 && x974
val x1003 = {
def x1003thenb(): Unit = {
val x976 = x952
val x977 = x976 + 1.0f
x952 = x977
()
}
def x1003elseb(): Unit = {
val x980 = x957
val x983 = x957
val x981 = x945(x980)
val x982 = x966(x981)
val x984 = x945(x983)
val x985 = x916(x984)
val x986 = x982 & x985
val x987 = x986 > 0
val x1001 = {
def x1001thenb(): Unit = {
val x988 = x952
val x989 = x988 + 1.0f
x952 = x989
()
}
def x1001elseb(): Unit = {
val x992 = x956
val x993 = x992 - 1
x956 = x993
val x995 = x956
val x996 = x995 <= 0
val x999 = {
def x999thenb(): Unit = {
x958 = false
()
}
def x999elseb(): Unit = {
()
}
if (x996) {
x999thenb()
} else {
x999elseb()
}
}
x999
}
if (x987) {
x1001thenb()
} else {
x1001elseb()
}
}
x1001
}
if (x975) {
x1003thenb()
} else {
x1003elseb()
}
}
val x1004 = x957 += 1
()
}
val x1007 = x958
val x1008 = !x1007
val x1013 = {
def x1013thenb(): Float = {
0.819999f
}
def x1013elseb(): Float = {
val x1009 = x952
val x1010 = x1009 / x947
val x1011 = x1010.asInstanceOf[Float]
x1011
}
if (x1008) {
x1013thenb()
} else {
x1013elseb()
}
}
x1013
}
if (x951) {
x1015thenb()
} else {
x1015elseb()
}
}
x1015
}
if (x948) {
x1017thenb()
} else {
x1017elseb()
}
}
x1017
}
if (x944) {
x1019thenb()
} else {
x1019elseb()
}
}
val x1020 = x1019 > 0.82f
val x1039 = {
def x1039thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1021 = x941.rect
val x1023 = x1021.width
val x868 = x857
val x869 = Math.pow(2.0,x868)
val x870 = x869.asInstanceOf[Int]
val x1022 = x870 * x867
val x1024 = x1023 / 2
val x1025 = x1022 - x1024
val x1026 = x1025.asInstanceOf[Int]
val x1028 = x1021.height
val x1027 = x870 * x863
val x1029 = x1028 / 2
val x1030 = x1027 - x1029
val x1031 = x1030.asInstanceOf[Int]
val x1032 = new generated.scala.Rect(x1026,x1031,x1023,x1028)
val x1033 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1034 = new generated.scala.BiGGDetection(x850,x1019,x1032,null,x940,x867,x863,x941,x874)
val x1035 = x1033(0) = x1034
x1033
}
def x1039elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1037 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1037
}
if (x1020) {
x1039thenb()
} else {
x1039elseb()
}
}
x1039
}
x1041 = {
val x1043 = x1041.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1068 = { 
val x1066 = {
def x1066thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1042
}
def x1066elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1044 = x1042.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1064 = {
def x1064thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1041
}
def x1064elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1045 = x1041.length
val x1046 = x1042.length
val x1047 = x1045 + x1046
val x1048 = x1041.isRow
val x1049 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1047,x1048)
var x1051 : Int = 0
val x1055 = while (x1051 < x1045) {
val x1052 = x1041(x1051)
val x1053 = x1049(x1051) = x1052
x1053
x1051 = x1051 + 1
}
var x1057 : Int = 0
val x1062 = while (x1057 < x1046) {
val x1058 = x1057 + x1045
val x1059 = x1042(x1057)
val x1060 = x1049(x1058) = x1059
x1060
x1057 = x1057 + 1
}
x1049
}
if (x1044) {
x1064thenb()
} else {
x1064elseb()
}
}
x1064
}
if (x1043) {
x1066thenb()
} else {
x1066elseb()
}
}
x1066
}
x1068
}
mapReduceIdx += 1
} // end mapReduce loop x1069
x1041
}
val x1069 = x1069_block
x1069
}
x1071 = {
val x1073 = x1071.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1098 = { 
val x1096 = {
def x1096thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1072
}
def x1096elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1074 = x1072.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1094 = {
def x1094thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1071
}
def x1094elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1075 = x1071.length
val x1076 = x1072.length
val x1077 = x1075 + x1076
val x1078 = x1071.isRow
val x1079 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1077,x1078)
var x1081 : Int = 0
val x1085 = while (x1081 < x1075) {
val x1082 = x1071(x1081)
val x1083 = x1079(x1081) = x1082
x1083
x1081 = x1081 + 1
}
var x1087 : Int = 0
val x1092 = while (x1087 < x1076) {
val x1088 = x1087 + x1075
val x1089 = x1072(x1087)
val x1090 = x1079(x1088) = x1089
x1090
x1087 = x1087 + 1
}
x1079
}
if (x1074) {
x1094thenb()
} else {
x1094elseb()
}
}
x1094
}
if (x1073) {
x1096thenb()
} else {
x1096elseb()
}
}
x1096
}
x1098
}
mapReduceIdx += 1
} // end mapReduce loop x1099
x1071
}
val x1099 = x1099_block
x1099
}
x1100 = {
val x1102 = x1100.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1127 = { 
val x1125 = {
def x1125thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1101
}
def x1125elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1103 = x1101.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1123 = {
def x1123thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1100
}
def x1123elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1104 = x1100.length
val x1105 = x1101.length
val x1106 = x1104 + x1105
val x1107 = x1100.isRow
val x1108 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1106,x1107)
var x1110 : Int = 0
val x1114 = while (x1110 < x1104) {
val x1111 = x1100(x1110)
val x1112 = x1108(x1110) = x1111
x1112
x1110 = x1110 + 1
}
var x1116 : Int = 0
val x1121 = while (x1116 < x1105) {
val x1117 = x1116 + x1104
val x1118 = x1101(x1116)
val x1119 = x1108(x1117) = x1118
x1119
x1116 = x1116 + 1
}
x1108
}
if (x1103) {
x1123thenb()
} else {
x1123elseb()
}
}
x1123
}
if (x1102) {
x1125thenb()
} else {
x1125elseb()
}
}
x1125
}
x1127
}
mapReduceIdx += 1
} // end mapReduce loop x1128
x1100
}
val x1128 = x1128_block
val x1129 = x1128.length
val x1130 = "Detections: "+x1129
val x1131 = println(x1130)
x1128
}
x1133 = {
val x1135 = x1133.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1160 = { 
val x1158 = {
def x1158thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1134
}
def x1158elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1136 = x1134.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1156 = {
def x1156thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1133
}
def x1156elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1137 = x1133.length
val x1138 = x1134.length
val x1139 = x1137 + x1138
val x1140 = x1133.isRow
val x1141 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1139,x1140)
var x1143 : Int = 0
val x1147 = while (x1143 < x1137) {
val x1144 = x1133(x1143)
val x1145 = x1141(x1143) = x1144
x1145
x1143 = x1143 + 1
}
var x1149 : Int = 0
val x1154 = while (x1149 < x1138) {
val x1150 = x1149 + x1137
val x1151 = x1134(x1149)
val x1152 = x1141(x1150) = x1151
x1152
x1149 = x1149 + 1
}
x1141
}
if (x1136) {
x1156thenb()
} else {
x1156elseb()
}
}
x1156
}
if (x1135) {
x1158thenb()
} else {
x1158elseb()
}
}
x1158
}
x1160
}
mapReduceIdx += 1
} // end mapReduce loop x1161
x1133
}
val x1161 = x1161_block
val x1162 = x1161.length
var x1163: Int = x1162
val x1164 = x1163
val x1165 = "Detections before NMS: "+x1164
val x1166 = println(x1165)
var x1167: Int = 0
val x1281 = while ({val x1168 = x1167
val x1169 = x1163
val x1170 = x1169 - 1
val x1171 = x1168 < x1170
x1171}) {
val x1173 = x1167
val x1174 = x1173 + 1
var x1175: Int = x1174
var x1176: Boolean = false
val x1278 = while ({val x1177 = x1175
val x1178 = x1163
val x1180 = x1176
val x1179 = x1177 < x1178
val x1181 = x1180==false
val x1182 = x1179 && x1181
x1182}) {
val x1184 = x1167
val x1187 = x1175
val x1185 = x1161(x1184)
val x1186 = x1185.roi
val x1190 = x1186.x
val x1188 = x1161(x1187)
val x1189 = x1188.roi
val x1191 = x1189.x
val x1192 = x1189.width
val x1193 = x1191 + x1192
val x1194 = x1190 < x1193
val x1195 = x1186.width
val x1196 = x1190 + x1195
val x1197 = x1196 > x1191
val x1198 = x1194 && x1197
val x1199 = x1186.y
val x1200 = x1186.height
val x1201 = x1199 + x1200
val x1202 = x1189.y
val x1203 = x1201 > x1202
val x1204 = x1198 && x1203
val x1205 = x1189.height
val x1206 = x1202 + x1205
val x1207 = x1199 < x1206
val x1208 = x1204 && x1207
val x1229 = {
def x1229thenb(): Float = {
val x1215 = x1199 > x1202
val x1216 = {
def x1216thenb(): Int = {
x1199
}
def x1216elseb(): Int = {
x1202
}
if (x1215) {
x1216thenb()
} else {
x1216elseb()
}
}
val x1220 = x1201 < x1206
val x1221 = {
def x1221thenb(): Int = {
x1201
}
def x1221elseb(): Int = {
x1206
}
if (x1220) {
x1221thenb()
} else {
x1221elseb()
}
}
val x1222 = x1221 - x1216
val x1223 = x1222
val x1224 = 2.0f * x1223
val x1213 = x1190 > x1191
val x1214 = {
def x1214thenb(): Int = {
x1190
}
def x1214elseb(): Int = {
x1191
}
if (x1213) {
x1214thenb()
} else {
x1214elseb()
}
}
val x1217 = x1196 < x1193
val x1218 = {
def x1218thenb(): Int = {
x1196
}
def x1218elseb(): Int = {
x1193
}
if (x1217) {
x1218thenb()
} else {
x1218elseb()
}
}
val x1219 = x1218 - x1214
val x1225 = x1219
val x1226 = x1224 * x1225
val x1209 = x1205 * x1192
val x1210 = x1195 * x1200
val x1211 = x1209 + x1210
val x1212 = x1211
val x1227 = x1212 + 1.0E-6f
val x1228 = x1226 / x1227
x1228
}
def x1229elseb(): Float = {
0.0f
}
if (x1208) {
x1229thenb()
} else {
x1229elseb()
}
}
val x1230 = x1229 > 0.6f
val x1275 = {
def x1275thenb(): Unit = {
val x1231 = x1167
val x1234 = x1175
val x1232 = x1161(x1231)
val x1233 = x1232.score
val x1235 = x1161(x1234)
val x1236 = x1235.score
val x1237 = x1233 >= x1236
val x1273 = {
def x1273thenb(): Unit = {
val x1238 = x1163
val x1241 = x1163
val x1243 = x1175
val x1242 = x1241 - 1
val x1244 = x1161(x1243)
val x1245 = x1161(x1242) = x1244
val x1246 = x1175
val x1239 = x1238 - 1
val x1240 = x1161(x1239)
val x1247 = x1161(x1246) = x1240
val x1248 = x1163
val x1249 = x1248 - 1
x1163 = x1249
val x1251 = x1175
val x1252 = x1251 - 1
x1175 = x1252
()
}
def x1273elseb(): Unit = {
val x1255 = x1163
val x1258 = x1163
val x1260 = x1167
val x1259 = x1258 - 1
val x1261 = x1161(x1260)
val x1262 = x1161(x1259) = x1261
val x1263 = x1167
val x1256 = x1255 - 1
val x1257 = x1161(x1256)
val x1264 = x1161(x1263) = x1257
val x1265 = x1163
val x1266 = x1265 - 1
x1163 = x1266
val x1268 = x1167
val x1269 = x1268 - 1
x1167 = x1269
x1176 = true
()
}
if (x1237) {
x1273thenb()
} else {
x1273elseb()
}
}
x1273
}
def x1275elseb(): Unit = {
()
}
if (x1230) {
x1275thenb()
} else {
x1275elseb()
}
}
val x1276 = x1175 += 1
()
}
val x1279 = x1167 += 1
()
}
val x1282 = x1163
val x1283 = x1282 - 0
val x1284 = x1161.isRow
val x1294 = { 
val x1285 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1283,x1284)
var x1287 : Int = 0
val x1292 = while (x1287 < x1282) {
val x1288 = x1287 - 0
val x1289 = x1161(x1287)
val x1290 = x1285(x1288) = x1289
x1290
x1287 = x1287 + 1
}
x1285
}
val x1295 = x1294.length
val x1296 = "Total detections: "+x1295
val x1297 = println(x1296)
val x1298 = x232 += 1
()
}
val x1301 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
