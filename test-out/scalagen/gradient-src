/*****************************************
  Emitting Generated Code                  
*******************************************/
class gradientRunner extends ((Array[java.lang.String])=>(Unit)) {
def apply(x0:Array[java.lang.String]): Unit = {
val x1 = x0(0)
val x54 = { 
val x2 = new java.io.FileReader(x1)
val x3 = new java.io.BufferedReader(x2)
val x4 = x3.readLine()
var x5: java.lang.String = x4
val x6 = x5
val x7 = x6.trim()
x5 = x7
val x9 = x5
val x10 = x9.split("\\s+")
var x11: Array[java.lang.String] = x10
val x12 = x11
val x13 = x12.length
val x14 = new generated.scala.IntMatrixImpl(0,x13)
val x50 = while ({val x15 = x5
val x16 = x15 != null
x16}) {
val x18 = x11
val x19 = x18.length
val x20 = new generated.scala.IntVectorImpl(x19,true)
var x21: Int = 0
val x35 = while ({val x22 = x21
val x23 = x11
val x24 = x23.length
val x25 = x22 < x24
x25}) {
val x27 = x21
val x28 = x11
val x29 = x21
val x30 = x28(x29)
val x31 = java.lang.Integer.parseInt(x30)
val x32 = x20(x27) = x31
val x33 = x21 += 1
()
}
val x36 = x14.numRows
val x37 = x14.insertRow(x36,x20)
val x38 = x3.readLine()
x5 = x38
val x40 = x5
val x41 = x40 != null
val x48 = {
def x48thenb(): Unit = {
val x42 = x40.trim()
x5 = x42
val x44 = x5
val x45 = x44.split("\\s+")
x11 = x45
()
}
def x48elseb(): Unit = {
()
}
if (x41) {
x48thenb()
} else {
x48elseb()
}
}
x48
}
val x51 = x3.close()
val x52 = new generated.scala.GrayscaleImageImpl(x14)
x52
}
val x55 = x0(1)
val x229 = { 
val x56 = new generated.scala.VectorImpl[java.lang.String](0,true)
val x57 = new java.io.File(x55)
val x58 = x57.getCanonicalFile()
val x59 = x58.listFiles()
val x65=x59.foreach{
x60 => 
val x62 = x56.length
val x61 = x60.getPath()
val x63 = x56.insert(x62, x61)
x63
}
def x227_block = {
val x223 = x56.length
val x224 = x56.isRow
val x225 = new generated.scala.VectorImpl[scala.Tuple2[java.lang.String, generated.scala.Vector[generated.scala.BinarizedGradientTemplate]]](x223,x224)
var mapIdx = 0
while (mapIdx < x56.size) { // begin map loop x227
val x66 = x56.dcApply(mapIdx)
x225.dcUpdate(mapIdx,  {
val x67 = "Loading model: "+x66
val x68 = println(x67)
val x69 = new generated.scala.VectorImpl[generated.scala.BinarizedGradientTemplate](0,true)
val x70 = new java.io.FileReader(x66)
val x71 = new java.io.BufferedReader(x70)
val x72 = x71.readLine()
val x73 = x72 != "bigg_object:"
val x76 = {
def x76thenb(): Nothing = {
val x74 = error("Illegal data format")
x74
}
def x76elseb(): Unit = {
()
}
if (x73) {
x76thenb()
} else {
x76elseb()
}
}
val x77 = x71.readLine()
val x78 = x71.readLine()
val x79 = x78.trim()
val x80 = x79.split(" ")
val x81 = x80(0)
val x82 = x81 != "obj_name/obj_num/num_objs:"
val x85 = {
def x85thenb(): Nothing = {
val x83 = error("Illegal data format")
x83
}
def x85elseb(): Unit = {
()
}
if (x82) {
x85thenb()
} else {
x85elseb()
}
}
var x90: Int = 0
val x88 = x80(3)
val x89 = java.lang.Integer.parseInt(x88)
val x220 = while ({val x91 = x90
val x92 = x91 < x89
x92}) {
val x94 = x71.readLine()
val x95 = x94.trim()
val x96 = x95 != "====OneBiGG====:"
val x99 = {
def x99thenb(): Nothing = {
val x97 = error("Illegal data format")
x97
}
def x99elseb(): Unit = {
()
}
if (x96) {
x99thenb()
} else {
x99elseb()
}
}
val x100 = x71.readLine()
val x101 = x100.trim()
val x102 = x101.split(" ")
var x103: Array[java.lang.String] = x102
val x104 = x103
val x105 = x104(0)
val x106 = x105 != "view/radius/reduction:"
val x109 = {
def x109thenb(): Nothing = {
val x107 = error("Illegal data format")
x107
}
def x109elseb(): Unit = {
()
}
if (x106) {
x109thenb()
} else {
x109elseb()
}
}
val x110 = x103
val x117 = x71.readLine()
val x118 = x117.trim()
val x119 = x118.split(" ")
x103 = x119
val x121 = x103
val x122 = x121(0)
val x123 = x122 != "Gradients:"
val x126 = {
def x126thenb(): Nothing = {
val x124 = error("Illegal data format")
x124
}
def x126elseb(): Unit = {
()
}
if (x123) {
x126thenb()
} else {
x126elseb()
}
}
val x127 = x103
val x128 = x127(1)
val x129 = java.lang.Integer.parseInt(x128)
val x130 = new generated.scala.IntVectorImpl(x129,true)
val x131 = x71.readLine()
var x134: Int = 0
val x132 = x131.trim()
val x133 = x132.split(" ")
val x145 = while ({val x135 = x134
val x136 = x135 < x129
x136}) {
val x138 = x134
val x139 = x134
val x140 = x133(x139)
val x141 = java.lang.Integer.parseInt(x140)
val x142 = x130(x138) = x141
val x143 = x134 += 1
()
}
val x146 = x71.readLine()
val x147 = x146.trim()
val x148 = x147.split(" ")
x103 = x148
val x150 = x103
val x151 = x150(0)
val x152 = x151 != "Match_list:"
val x155 = {
def x155thenb(): Nothing = {
val x153 = error("Illegal data format")
x153
}
def x155elseb(): Unit = {
()
}
if (x152) {
x155thenb()
} else {
x155elseb()
}
}
val x156 = x103
val x159 = new generated.scala.IntVectorImpl(0,true)
val x160 = new generated.scala.IndexVectorSeqImpl(x159)
val x161 = x71.readLine()
x134 = 0
val x157 = x156(1)
val x158 = java.lang.Integer.parseInt(x157)
val x162 = x161.trim()
val x163 = x162.split(" ")
val x175 = while ({val x165 = x134
val x166 = x165 < x158
x166}) {
val x168 = x134
val x171 = x160.length
val x169 = x163(x168)
val x170 = java.lang.Integer.parseInt(x169)
val x172 = x160.insert(x171, x170)
val x173 = x134 += 1
()
}
val x176 = x71.readLine()
val x177 = x176.trim()
val x178 = x177.split(" ")
x103 = x178
val x180 = x103
val x181 = x180(0)
val x182 = x181 != "Occlusions:"
val x185 = {
def x185thenb(): Nothing = {
val x183 = error("Illegal data format")
x183
}
def x185elseb(): Unit = {
()
}
if (x182) {
x185thenb()
} else {
x185elseb()
}
}
val x186 = x103
val x189 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](0,true)
val x190 = x71.readLine()
val x187 = x186(1)
val x188 = java.lang.Integer.parseInt(x187)
val x193 = x188 != 0
val x196 = {
def x196thenb(): Nothing = {
val x194 = error("Occlusions not supported.")
x194
}
def x196elseb(): Unit = {
()
}
if (x193) {
x196thenb()
} else {
x196elseb()
}
}
val x197 = x71.readLine()
val x198 = x197.trim()
val x199 = x198 != "BoundingBox:"
val x202 = {
def x202thenb(): Nothing = {
val x200 = error("Illegal data format")
x200
}
def x202elseb(): Unit = {
()
}
if (x199) {
x202thenb()
} else {
x202elseb()
}
}
val x203 = x71.readLine()
val x204 = x203.trim()
val x205 = x204.split(" ")
val x206 = x205(0)
val x207 = java.lang.Integer.parseInt(x206)
val x208 = x205(1)
val x209 = java.lang.Integer.parseInt(x208)
val x210 = x205(2)
val x211 = java.lang.Integer.parseInt(x210)
val x212 = x205(3)
val x213 = java.lang.Integer.parseInt(x212)
val x214 = new generated.scala.Rect(x207,x209,x211,x213)
val x113 = x110(2)
val x114 = java.lang.Integer.parseInt(x113)
val x215 = new generated.scala.BinarizedGradientTemplate(x114,x214,null,0,x130,x160,x189,null,null)
val x216 = x69.length
val x217 = x69.insert(x216, x215)
val x218 = x90 += 1
()
}
val x86 = x80(1)
val x221 = (x86,x69)
x221
})
mapIdx += 1
} // end map loop x227
x225
}
val x227 = x227_block
x227
}
val x230 = Seq()
val x231 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
var x232: Int = 0
val x271 = x54.numRows
val x272 = new generated.scala.IndexVectorRangeImpl(0,x271)
val x273 = x54.numCols
val x274 = new generated.scala.IndexVectorRangeImpl(0,x273)
val x275 = new generated.scala.IndexVector2Impl(x272,x274)
val x276 = x275.rowInd
val x277 = x276.length
val x281 = x275.colInd
val x342 = x281.length
val x343 = x281.isRow
val x530 = Math.Pi
val x583 = 2 / 2
val x1339 = while ({val x233 = x232
val x234 = x233 < 3
x234}) {
val x236 = new generated.scala.IntMatrixImpl(3,3)
val x237 = x236(0, 0) = -3
val x238 = x236(0, 1) = -10
val x239 = x236(0, 2) = -3
val x240 = x236(2, 0) = 3
val x241 = x236(2, 1) = 10
val x242 = x236(2, 2) = 3
val x264 = { 
val x243 = x236.numCols
val x244 = x236.numRows
val x245 = new generated.scala.IntMatrixImpl(x243,x244)
val x246 = x245.numRows
var x248 : Int = 0
val x262 = while (x248 < x246) {
val x249 = x245.numCols
var x251 : Int = 0
val x260 = while (x251 < x249) {
val x257 = { 
val x252 = x236.numCols
val x253 = x251 * x252
val x254 = x253 + x248
val x255 = x236.dcApply(x254)
x255
}
val x258 = x245(x248, x251) = x257
x258
x251 = x251 + 1
}
x260
x248 = x248 + 1
}
x245
}
val x265 = x264.numRows
val x267 = x265 - 1
val x268 = x267 / 2
val x284 = x271 - x268
val x266 = x264.numCols
val x269 = x266 - 1
val x270 = x269 / 2
val x289 = x273 - x270
def x347_block = {
val x278 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](x277,true)
var mapIdx = 0
while (mapIdx < x276.size) { // begin map loop x347
val x280 = x276.dcApply(mapIdx)
x278.dcUpdate(mapIdx,  {
val x283 = x280 >= x268
val x285 = x280 < x284
val x286 = x283 && x285
def x346_block = {
val x344 = new generated.scala.IntVectorImpl(x342,x343)
var mapIdx = 0
while (mapIdx < x281.size) { // begin map loop x346
val x282 = x281.dcApply(mapIdx)
x344.dcUpdate(mapIdx,  {
val x287 = x282 >= x270
val x288 = x286 && x287
val x290 = x282 < x289
val x291 = x288 && x290
val x341 = {
def x341thenb(): Int = {
val x292 = x280 - x268
val x293 = x280 + x268
val x294 = x293 + 1
val x298 = x294 - x292
val x295 = x282 - x270
val x296 = x282 + x270
val x297 = x296 + 1
val x299 = x297 - x295
val x327 = { 
val x300 = new generated.scala.IntMatrixImpl(x298,x299)
var x301: Int = x292
val x325 = while ({val x302 = x301
val x303 = x302 < x294
x303}) {
var x305: Int = x295
val x322 = while ({val x306 = x305
val x307 = x306 < x297
x307}) {
val x309 = x301
val x311 = x305
val x313 = x301
val x314 = x305
val x310 = x309 - x292
val x312 = x311 - x295
val x315 = x313 * x273
val x316 = x315 + x314
val x317 = x54.dcApply(x316)
val x318 = { 
x317
}
val x319 = x300(x310, x312) = x318
val x320 = x305 += 1
()
}
val x323 = x301 += 1
()
}
x300
}
val x328 = x327.numRows
val x329 = x327.numCols
def x335_block = {
val x330 = new generated.scala.IntMatrixImpl(x328,x329)
var zipIdx = 0
while (zipIdx < x327.size) { // begin zip loop x335
val x332 = x327.dcApply(zipIdx)
val x333 = x264.dcApply(zipIdx)
x330.dcUpdate(zipIdx,  {
val x334 = x332 * x333
x334
})
zipIdx += 1
} // end zip loop x335
x330
}
val x335 = x335_block
def x339_block = {
var x336 = x335.dcApply(0)
var reduceIdx = 1
while (reduceIdx < x335.size) { // begin reduce loop x339
val x337 = x335.dcApply(reduceIdx)
x336 = {
val x338 = x336 + x337
x338
}
reduceIdx += 1
} // end reduce loop x339
x336
}
val x339 = x339_block
x339
}
def x341elseb(): Int = {
val x340 = 0.asInstanceOf[Int]
x340
}
if (x291) {
x341thenb()
} else {
x341elseb()
}
}
x341
})
mapIdx += 1
} // end map loop x346
x344
}
val x346 = x346_block
x346
})
mapIdx += 1
} // end map loop x347
x278
}
val x347 = x347_block
val x348 = x347.length
val x349 = x348==0
val x383 = { 
val x381 = {
def x381thenb(): generated.scala.Matrix[Int] = {
val x350 = new generated.scala.IntMatrixImpl(0,0)
x350
}
def x381elseb(): generated.scala.Matrix[Int] = {
val x352 = x347(0)
val x353 = x352.isRow
val x379 = {
def x379thenb(): generated.scala.Matrix[Int] = {
val x354 = x352.length
val x355 = new generated.scala.IntMatrixImpl(x348,x354)
var x357 : Int = 0
val x366 = while (x357 < x348) {
val x360 = x347(x357)
var x359 : Int = 0
val x364 = while (x359 < x354) {
val x361 = x360(x359)
val x362 = x355(x357, x359) = x361
x362
x359 = x359 + 1
}
x364
x357 = x357 + 1
}
x355
}
def x379elseb(): generated.scala.Matrix[Int] = {
val x354 = x352.length
val x368 = new generated.scala.IntMatrixImpl(x354,x348)
var x369 : Int = 0
val x377 = while (x369 < x348) {
val x371 = x347(x369)
var x370 : Int = 0
val x375 = while (x370 < x354) {
val x372 = x371(x370)
val x373 = x368(x370, x369) = x372
x373
x370 = x370 + 1
}
x375
x369 = x369 + 1
}
x368
}
if (x353) {
x379thenb()
} else {
x379elseb()
}
}
x379
}
if (x349) {
x381thenb()
} else {
x381elseb()
}
}
x381
}
val x384 = new generated.scala.IntImageImpl(x383)
val x385 = x236.numRows
val x386 = x236.numCols
val x387 = x385 - 1
val x388 = x387 / 2
val x396 = x271 - x388
val x389 = x386 - 1
val x390 = x389 / 2
val x401 = x273 - x390
def x458_block = {
val x391 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](x277,true)
var mapIdx = 0
while (mapIdx < x276.size) { // begin map loop x458
val x393 = x276.dcApply(mapIdx)
x391.dcUpdate(mapIdx,  {
val x395 = x393 >= x388
val x397 = x393 < x396
val x398 = x395 && x397
def x457_block = {
val x455 = new generated.scala.IntVectorImpl(x342,x343)
var mapIdx = 0
while (mapIdx < x281.size) { // begin map loop x457
val x394 = x281.dcApply(mapIdx)
x455.dcUpdate(mapIdx,  {
val x399 = x394 >= x390
val x400 = x398 && x399
val x402 = x394 < x401
val x403 = x400 && x402
val x453 = {
def x453thenb(): Int = {
val x404 = x393 - x388
val x405 = x393 + x388
val x406 = x405 + 1
val x410 = x406 - x404
val x407 = x394 - x390
val x408 = x394 + x390
val x409 = x408 + 1
val x411 = x409 - x407
val x439 = { 
val x412 = new generated.scala.IntMatrixImpl(x410,x411)
var x413: Int = x404
val x437 = while ({val x414 = x413
val x415 = x414 < x406
x415}) {
var x417: Int = x407
val x434 = while ({val x418 = x417
val x419 = x418 < x409
x419}) {
val x421 = x413
val x423 = x417
val x425 = x413
val x426 = x417
val x422 = x421 - x404
val x424 = x423 - x407
val x427 = x425 * x273
val x428 = x427 + x426
val x429 = x54.dcApply(x428)
val x430 = { 
x429
}
val x431 = x412(x422, x424) = x430
val x432 = x417 += 1
()
}
val x435 = x413 += 1
()
}
x412
}
val x440 = x439.numRows
val x441 = x439.numCols
def x447_block = {
val x442 = new generated.scala.IntMatrixImpl(x440,x441)
var zipIdx = 0
while (zipIdx < x439.size) { // begin zip loop x447
val x444 = x439.dcApply(zipIdx)
val x445 = x236.dcApply(zipIdx)
x442.dcUpdate(zipIdx,  {
val x446 = x444 * x445
x446
})
zipIdx += 1
} // end zip loop x447
x442
}
val x447 = x447_block
def x451_block = {
var x448 = x447.dcApply(0)
var reduceIdx = 1
while (reduceIdx < x447.size) { // begin reduce loop x451
val x449 = x447.dcApply(reduceIdx)
x448 = {
val x450 = x448 + x449
x450
}
reduceIdx += 1
} // end reduce loop x451
x448
}
val x451 = x451_block
x451
}
def x453elseb(): Int = {
val x340 = 0.asInstanceOf[Int]
x340
}
if (x403) {
x453thenb()
} else {
x453elseb()
}
}
x453
})
mapIdx += 1
} // end map loop x457
x455
}
val x457 = x457_block
x457
})
mapIdx += 1
} // end map loop x458
x391
}
val x458 = x458_block
val x459 = x458.length
val x460 = x459==0
val x494 = { 
val x492 = {
def x492thenb(): generated.scala.Matrix[Int] = {
val x461 = new generated.scala.IntMatrixImpl(0,0)
x461
}
def x492elseb(): generated.scala.Matrix[Int] = {
val x463 = x458(0)
val x464 = x463.isRow
val x490 = {
def x490thenb(): generated.scala.Matrix[Int] = {
val x465 = x463.length
val x466 = new generated.scala.IntMatrixImpl(x459,x465)
var x468 : Int = 0
val x477 = while (x468 < x459) {
val x471 = x458(x468)
var x470 : Int = 0
val x475 = while (x470 < x465) {
val x472 = x471(x470)
val x473 = x466(x468, x470) = x472
x473
x470 = x470 + 1
}
x475
x468 = x468 + 1
}
x466
}
def x490elseb(): generated.scala.Matrix[Int] = {
val x465 = x463.length
val x479 = new generated.scala.IntMatrixImpl(x465,x459)
var x480 : Int = 0
val x488 = while (x480 < x459) {
val x482 = x458(x480)
var x481 : Int = 0
val x486 = while (x481 < x465) {
val x483 = x482(x481)
val x484 = x479(x481, x480) = x483
x484
x481 = x481 + 1
}
x486
x480 = x480 + 1
}
x479
}
if (x464) {
x490thenb()
} else {
x490elseb()
}
}
x490
}
if (x460) {
x492thenb()
} else {
x492elseb()
}
}
x492
}
val x495 = new generated.scala.IntImageImpl(x494)
val x498 = x384.numRows
val x499 = x384.numCols
def x502_block = {
val x500 = new generated.scala.FloatMatrixImpl(x498,x499)
var mapIdx = 0
while (mapIdx < x384.size) { // begin map loop x502
val x496 = x384.dcApply(mapIdx)
x500.dcUpdate(mapIdx,  {
val x497 = x496
x497
})
mapIdx += 1
} // end map loop x502
x500
}
val x502 = x502_block
val x505 = x495.numRows
val x506 = x495.numCols
def x509_block = {
val x507 = new generated.scala.FloatMatrixImpl(x505,x506)
var mapIdx = 0
while (mapIdx < x495.size) { // begin map loop x509
val x503 = x495.dcApply(mapIdx)
x507.dcUpdate(mapIdx,  {
val x504 = x503
x504
})
mapIdx += 1
} // end map loop x509
x507
}
val x509 = x509_block
val x510 = x502.numRows
val x511 = x502.numCols
def x533_block = {
val x522 = new generated.scala.FloatMatrixImpl(x510,x511)
var zipIdx = 0
while (zipIdx < x502.size) { // begin zip loop x533
val x524 = x502.dcApply(zipIdx)
val x525 = x509.dcApply(zipIdx)
x522.dcUpdate(zipIdx,  {
val x526 = x525
val x527 = x524
val x528 = Math.atan2(x526, x527)
val x529 = x528 * 180.0
val x531 = x529 / x530
val x532 = x531.asInstanceOf[Float]
x532
})
zipIdx += 1
} // end zip loop x533
x522
}
val x533 = x533_block
def x538_block = {
var mapIdx = 0
while (mapIdx < x533.size) { // begin map loop x538
val x534 = x533.dcApply(mapIdx)
x533.dcUpdate(mapIdx,  {
val x535 = x534 < 0.0f
val x537 = {
def x537thenb(): Float = {
val x536 = x534 + 360.0f
x536
}
def x537elseb(): Float = {
x534
}
if (x535) {
x537thenb()
} else {
x537elseb()
}
}
x537
})
mapIdx += 1
} // end map loop x538
x533
}
val x538 = x538_block
def x539_block = {
val x512 = new generated.scala.FloatMatrixImpl(x510,x511)
var zipIdx = 0
while (zipIdx < x502.size) { // begin zip loop x539
val x514 = x502.dcApply(zipIdx)
val x515 = x509.dcApply(zipIdx)
x512.dcUpdate(zipIdx,  {
val x516 = x514 * x514
val x517 = x515 * x515
val x518 = x516 + x517
val x519 = x518
val x520 = Math.sqrt(x519)
val x521 = x520.asInstanceOf[Float]
x521
})
zipIdx += 1
} // end zip loop x539
x512
}
val x539 = x539_block
val x561 = x539.numRows
val x562 = x539.numCols
def x565_block = {
val x563 = new generated.scala.IntMatrixImpl(x561,x562)
var zipIdx = 0
while (zipIdx < x539.size) { // begin zip loop x565
val x541 = x539.dcApply(zipIdx)
val x542 = x538.dcApply(zipIdx)
x563.dcUpdate(zipIdx,  {
val x543 = x541 >= 200.0f
val x559 = {
def x559thenb(): Int = {
var x544: Float = x542
val x545 = x544
val x546 = x545 >= 180.0f
val x550 = {
def x550thenb(): Unit = {
val x547 = x545 - 180.0f
x544 = x547
()
}
def x550elseb(): Unit = {
()
}
if (x546) {
x550thenb()
} else {
x550elseb()
}
}
val x551 = x544
val x552 = x551.asInstanceOf[Double]
val x553 = x552 / 22.5
val x554 = x553.asInstanceOf[Int]
val x555 = x554
val x556 = Math.pow(2.0,x555)
val x557 = x556.asInstanceOf[Int]
x557
}
def x559elseb(): Int = {
0
}
if (x543) {
x559thenb()
} else {
x559elseb()
}
}
x559
})
zipIdx += 1
} // end zip loop x565
x563
}
val x565 = x565_block
val x566 = new generated.scala.GrayscaleImageImpl(x565)
val x567 = x566.getRow(0)
def x569_block = {
var mapIdx = 0
while (mapIdx < x567.size) { // begin map loop x569
val x568 = x567.dcApply(mapIdx)
x567.dcUpdate(mapIdx,  {
0
})
mapIdx += 1
} // end map loop x569
x567
}
val x569 = x569_block
val x570 = x566.numRows
val x571 = x570 - 1
val x572 = x566.getRow(x571)
def x574_block = {
var mapIdx = 0
while (mapIdx < x572.size) { // begin map loop x574
val x573 = x572.dcApply(mapIdx)
x572.dcUpdate(mapIdx,  {
0
})
mapIdx += 1
} // end map loop x574
x572
}
val x574 = x574_block
val x575 = x566.getCol(0)
def x577_block = {
var mapIdx = 0
while (mapIdx < x575.size) { // begin map loop x577
val x576 = x575.dcApply(mapIdx)
x575.dcUpdate(mapIdx,  {
0
})
mapIdx += 1
} // end map loop x577
x575
}
val x577 = x577_block
val x578 = x566.numCols
val x579 = x578 - 1
val x580 = x566.getCol(x579)
def x582_block = {
var mapIdx = 0
while (mapIdx < x580.size) { // begin map loop x582
val x581 = x580.dcApply(mapIdx)
x580.dcUpdate(mapIdx,  {
0
})
mapIdx += 1
} // end map loop x582
x580
}
val x582 = x582_block
val x584 = new generated.scala.IndexVectorRangeImpl(0,x570)
val x585 = new generated.scala.IndexVectorRangeImpl(0,x578)
val x586 = new generated.scala.IndexVector2Impl(x584,x585)
val x587 = x586.rowInd
val x588 = x587.length
val x592 = x586.colInd
val x595 = x570 - x583
val x600 = x578 - x583
val x701 = x592.length
val x702 = x592.isRow
def x706_block = {
val x589 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](x588,true)
var mapIdx = 0
while (mapIdx < x587.size) { // begin map loop x706
val x591 = x587.dcApply(mapIdx)
x589.dcUpdate(mapIdx,  {
val x594 = x591 >= x583
val x596 = x591 < x595
val x597 = x594 && x596
def x705_block = {
val x703 = new generated.scala.IntVectorImpl(x701,x702)
var mapIdx = 0
while (mapIdx < x592.size) { // begin map loop x705
val x593 = x592.dcApply(mapIdx)
x703.dcUpdate(mapIdx,  {
val x598 = x593 >= x583
val x599 = x597 && x598
val x601 = x593 < x600
val x602 = x599 && x601
val x699 = {
def x699thenb(): Int = {
val x639 = new generated.scala.IntVectorImpl(256,true)
var x640: Int = 0
val x603 = x591 - x583
val x604 = x591 + x583
val x605 = x604 + 1
val x609 = x605 - x603
val x606 = x593 - x583
val x607 = x593 + x583
val x608 = x607 + 1
val x610 = x608 - x606
val x638 = { 
val x611 = new generated.scala.IntMatrixImpl(x609,x610)
var x612: Int = x603
val x636 = while ({val x613 = x612
val x614 = x613 < x605
x614}) {
var x616: Int = x606
val x633 = while ({val x617 = x616
val x618 = x617 < x608
x618}) {
val x620 = x612
val x622 = x616
val x624 = x612
val x625 = x616
val x621 = x620 - x603
val x623 = x622 - x606
val x626 = x624 * x578
val x627 = x626 + x625
val x628 = x566.dcApply(x627)
val x629 = { 
x628
}
val x630 = x611(x621, x623) = x629
val x631 = x616 += 1
()
}
val x634 = x612 += 1
()
}
x611
}
val x642 = x638.numRows
val x647 = x638.numCols
val x670 = while ({val x641 = x640
val x643 = x641 < x642
x643}) {
var x645: Int = 0
val x667 = while ({val x646 = x645
val x648 = x646 < x647
x648}) {
val x650 = x640
val x651 = x645
val x656 = x640
val x657 = x645
val x658 = x656 * x647
val x659 = x658 + x657
val x660 = x638.dcApply(x659)
val x661 = { 
x660
}
val x662 = x639(x661)
val x652 = x650 * x647
val x653 = x652 + x651
val x654 = x638.dcApply(x653)
val x655 = { 
x654
}
val x663 = x662 + 1
val x664 = x639(x655) = x663
val x665 = x645 += 1
()
}
val x668 = x640 += 1
()
}
var x671: Int = 2
val x672 = x639(1)
var x673: Int = x672
var x674: Int = 1
val x692 = while ({val x675 = x671
val x676 = x639.length
val x677 = x675 < x676
x677}) {
val x679 = x671
val x680 = x639(x679)
val x681 = x673
val x682 = x680 > x681
val x689 = {
def x689thenb(): Unit = {
val x683 = x671
val x684 = x639(x683)
x673 = x684
val x686 = x671
x674 = x686
()
}
def x689elseb(): Unit = {
()
}
if (x682) {
x689thenb()
} else {
x689elseb()
}
}
val x690 = x671 += 1
()
}
val x693 = x673
val x694 = x693 > 1
val x697 = {
def x697thenb(): Int = {
val x695 = x674
x695
}
def x697elseb(): Int = {
0
}
if (x694) {
x697thenb()
} else {
x697elseb()
}
}
x697
}
def x699elseb(): Int = {
val x340 = 0.asInstanceOf[Int]
x340
}
if (x602) {
x699thenb()
} else {
x699elseb()
}
}
x699
})
mapIdx += 1
} // end map loop x705
x703
}
val x705 = x705_block
x705
})
mapIdx += 1
} // end map loop x706
x589
}
val x706 = x706_block
val x707 = x706.length
val x708 = x707==0
val x742 = { 
val x740 = {
def x740thenb(): generated.scala.Matrix[Int] = {
val x709 = new generated.scala.IntMatrixImpl(0,0)
x709
}
def x740elseb(): generated.scala.Matrix[Int] = {
val x711 = x706(0)
val x712 = x711.isRow
val x738 = {
def x738thenb(): generated.scala.Matrix[Int] = {
val x713 = x711.length
val x714 = new generated.scala.IntMatrixImpl(x707,x713)
var x716 : Int = 0
val x725 = while (x716 < x707) {
val x719 = x706(x716)
var x718 : Int = 0
val x723 = while (x718 < x713) {
val x720 = x719(x718)
val x721 = x714(x716, x718) = x720
x721
x718 = x718 + 1
}
x723
x716 = x716 + 1
}
x714
}
def x738elseb(): generated.scala.Matrix[Int] = {
val x713 = x711.length
val x727 = new generated.scala.IntMatrixImpl(x713,x707)
var x728 : Int = 0
val x736 = while (x728 < x707) {
val x730 = x706(x728)
var x729 : Int = 0
val x734 = while (x729 < x713) {
val x731 = x730(x729)
val x732 = x727(x729, x728) = x731
x732
x729 = x729 + 1
}
x734
x728 = x728 + 1
}
x727
}
if (x712) {
x738thenb()
} else {
x738elseb()
}
}
x738
}
if (x708) {
x740thenb()
} else {
x740elseb()
}
}
x740
}
val x743 = new generated.scala.IntImageImpl(x742)
val x744 = new generated.scala.GrayscaleImageImpl(x743)
var x745: generated.scala.GrayscaleImage = x744
var x746: Int = 0
val x747 = new generated.scala.VectorImpl[generated.scala.GrayscaleImage](0,true)
val x748 = new generated.scala.BinarizedGradientPyramid(x747,3,1,3)
val x750 = x748.start_level
val x751 = x748.levels
val x752 = x750 + x751
val x757 = x748.pyramid
val x763 = x752 - 1
val x882 = while ({val x749 = x746
val x753 = x749 < x752
x753}) {
val x755 = x746
val x756 = x755 >= x750
val x762 = {
def x762thenb(): Unit = {
val x758 = x745
val x759 = x757.length
val x760 = x757.insert(x759, x758)
x760
}
def x762elseb(): Unit = {
()
}
if (x756) {
x762thenb()
} else {
x762elseb()
}
}
val x764 = x746
val x765 = x764 != x763
val x879 = {
def x879thenb(): Unit = {
val x766 = x745
val x767 = x766.numRows
val x768 = x767 / 2
val x769 = new generated.scala.IndexVectorRangeImpl(0,x768)
val x770 = x766.numCols
val x771 = x770 / 2
val x772 = new generated.scala.IndexVectorRangeImpl(0,x771)
val x773 = new generated.scala.IndexVector2Impl(x769,x772)
val x774 = x773.rowInd
val x775 = x774.length
val x779 = x773.colInd
val x833 = x779.length
val x834 = x779.isRow
def x838_block = {
val x776 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](x775,true)
var mapIdx = 0
while (mapIdx < x774.size) { // begin map loop x838
val x778 = x774.dcApply(mapIdx)
x776.dcUpdate(mapIdx,  {
val x781 = 2 * x778
val x782 = x781 + 2
val x785 = x782 - x781
def x837_block = {
val x835 = new generated.scala.IntVectorImpl(x833,x834)
var mapIdx = 0
while (mapIdx < x779.size) { // begin map loop x837
val x780 = x779.dcApply(mapIdx)
x835.dcUpdate(mapIdx,  {
val x783 = 2 * x780
val x784 = x783 + 2
val x786 = x784 - x783
val x814 = { 
val x787 = new generated.scala.IntMatrixImpl(x785,x786)
var x788: Int = x781
val x812 = while ({val x789 = x788
val x790 = x789 < x782
x790}) {
var x792: Int = x783
val x809 = while ({val x793 = x792
val x794 = x793 < x784
x794}) {
val x796 = x788
val x798 = x792
val x800 = x788
val x801 = x792
val x797 = x796 - x781
val x799 = x798 - x783
val x802 = x800 * x770
val x803 = x802 + x801
val x804 = x766.dcApply(x803)
val x805 = { 
x804
}
val x806 = x787(x797, x799) = x805
val x807 = x792 += 1
()
}
val x810 = x788 += 1
()
}
x787
}
val x815 = x814.numCols
val x816 = 0 * x815
val x817 = x816 + 0
val x818 = x814.dcApply(x817)
val x819 = { 
x818
}
val x820 = 1 * x815
val x821 = x820 + 0
val x822 = x814.dcApply(x821)
val x823 = { 
x822
}
val x824 = x819 | x823
val x825 = x816 + 1
val x826 = x814.dcApply(x825)
val x827 = { 
x826
}
val x828 = x824 | x827
val x829 = x820 + 1
val x830 = x814.dcApply(x829)
val x831 = { 
x830
}
val x832 = x828 | x831
x832
})
mapIdx += 1
} // end map loop x837
x835
}
val x837 = x837_block
x837
})
mapIdx += 1
} // end map loop x838
x776
}
val x838 = x838_block
val x839 = x838.length
val x840 = x839==0
val x874 = { 
val x872 = {
def x872thenb(): generated.scala.Matrix[Int] = {
val x841 = new generated.scala.IntMatrixImpl(0,0)
x841
}
def x872elseb(): generated.scala.Matrix[Int] = {
val x843 = x838(0)
val x844 = x843.isRow
val x870 = {
def x870thenb(): generated.scala.Matrix[Int] = {
val x845 = x843.length
val x846 = new generated.scala.IntMatrixImpl(x839,x845)
var x848 : Int = 0
val x857 = while (x848 < x839) {
val x851 = x838(x848)
var x850 : Int = 0
val x855 = while (x850 < x845) {
val x852 = x851(x850)
val x853 = x846(x848, x850) = x852
x853
x850 = x850 + 1
}
x855
x848 = x848 + 1
}
x846
}
def x870elseb(): generated.scala.Matrix[Int] = {
val x845 = x843.length
val x859 = new generated.scala.IntMatrixImpl(x845,x839)
var x860 : Int = 0
val x868 = while (x860 < x839) {
val x862 = x838(x860)
var x861 : Int = 0
val x866 = while (x861 < x845) {
val x863 = x862(x861)
val x864 = x859(x861, x860) = x863
x864
x861 = x861 + 1
}
x866
x860 = x860 + 1
}
x859
}
if (x844) {
x870thenb()
} else {
x870elseb()
}
}
x870
}
if (x840) {
x872thenb()
} else {
x872elseb()
}
}
x872
}
val x875 = new generated.scala.IntImageImpl(x874)
val x876 = new generated.scala.GrayscaleImageImpl(x875)
x745 = x876
()
}
def x879elseb(): Unit = {
()
}
if (x765) {
x879thenb()
} else {
x879elseb()
}
}
val x880 = x746 += 1
()
}
val x891 = x748.fixedLevelIndex
val x892 = x891 - x750
val x893 = x757(x892)
val x894 = x893.numRows
val x895 = x894 - 5
val x896 = new generated.scala.IndexVectorRangeImpl(5,x895)
val x898 = x893.numCols
val x899 = x898 - 5
val x900 = new generated.scala.IndexVectorRangeImpl(5,x899)
def x1200_block = {
val x883 = x229.dcApply(0)
var x1172 = {
val x884 = x883._1
val x886 = "Name: "+x884
val x887 = println(x886)
val x885 = x883._2
val x888 = x885.length
val x889 = "Templates: "+x888
val x890 = println(x889)
val x978 = new generated.scala.IndexVectorRangeImpl(0,x888)
def x1167_block = {
val x897 = x896.dcApply(0)
var x1139 = {
val x920 = x897 - 15
val x921 = x920 < 0
val x925 = {
def x925thenb(): scala.Tuple2[Int, Int] = {
val x922 = 15 - x897
val x923 = (0,x922)
x923
}
def x925elseb(): scala.Tuple2[Int, Int] = {
val x924 = (x920,0)
x924
}
if (x921) {
x925thenb()
} else {
x925elseb()
}
}
val x926 = x925._1
val x928 = x897 + 15
val x929 = x928 > x894
val x930 = {
def x930thenb(): Int = {
x894
}
def x930elseb(): Int = {
x928
}
if (x929) {
x930thenb()
} else {
x930elseb()
}
}
val x927 = x925._2
def x1138_block = {
val x901 = x900.dcApply(0)
var x1110 = {
val x905 = new generated.scala.IntVectorImpl(900,false)
val x906 = new generated.scala.IntVectorImpl(0,true)
val x907 = new generated.scala.IndexVectorSeqImpl(x906)
val x908 = new generated.scala.BinarizedGradientTemplate(15,null,null,x891,x905,x907,null,null,null)
var x931: Int = x926
val x909 = x901 - 15
val x910 = x909 < 0
val x914 = {
def x914thenb(): scala.Tuple2[Int, Int] = {
val x911 = 15 - x901
val x912 = (0,x911)
x912
}
def x914elseb(): scala.Tuple2[Int, Int] = {
val x913 = (x909,0)
x913
}
if (x910) {
x914thenb()
} else {
x914elseb()
}
}
val x915 = x914._1
val x917 = x901 + 15
val x918 = x917 > x898
val x919 = {
def x919thenb(): Int = {
x898
}
def x919elseb(): Int = {
x917
}
if (x918) {
x919thenb()
} else {
x919elseb()
}
}
val x916 = x914._2
val x950 = x908.binary_gradients
val x963 = x908.match_list
val x964 = x963.length
val x973 = while ({val x932 = x931
val x933 = x932 < x930
x933}) {
val x935 = x931
var x937: Int = x915
val x953 = x935 * x898
val x970 = while ({val x938 = x937
val x939 = x938 < x919
x939}) {
val x941 = x931
val x945 = x937
val x942 = x927 + x941
val x943 = x942 - x926
val x944 = x943 * 30
val x946 = x916 + x945
val x947 = x946 - x915
val x948 = x944 + x947
var x949: Int = x948
val x951 = x949
val x952 = x937
val x954 = x953 + x952
val x955 = x893.dcApply(x954)
val x956 = { 
x955
}
val x957 = x950(x951) = x956
val x958 = x937
val x959 = x953 + x958
val x960 = x893.dcApply(x959)
val x961 = { 
x960
}
val x962 = x961 > 0
val x967 = {
def x967thenb(): Unit = {
val x965 = x963.insert(x964, x951)
x965
}
def x967elseb(): Unit = {
()
}
if (x962) {
x967thenb()
} else {
x967elseb()
}
}
val x968 = x937 += 1
()
}
val x971 = x931 += 1
()
}
val x974 = x964 < 0
val x977 = {
def x977thenb(): Unit = {
val x975 = println("dummy")
x975
}
def x977elseb(): Unit = {
()
}
if (x974) {
x977thenb()
} else {
x977elseb()
}
}
val x982 = x908.radius
def x1108_block = {
val x979 = x978.dcApply(0)
var x1080 = {
val x980 = x885(x979)
val x981 = x980.radius
val x983 = x981 != x982
val x1058 = {
def x1058thenb(): Float = {
-1.0f
}
def x1058elseb(): Float = {
val x984 = x980.match_list
val x985 = x984.length
val x986 = x985.asInstanceOf[Float]
val x987 = x986==0.0
val x1056 = {
def x1056thenb(): Float = {
-1.0f
}
def x1056elseb(): Float = {
val x988 = x964.asInstanceOf[Float]
val x989 = x988 / x986
val x990 = x989 < 0.82f
val x1054 = {
def x1054thenb(): Float = {
x989
}
def x1054elseb(): Float = {
var x991: Float = 0.0f
val x992 = x986 * 0.18f
val x993 = x992 + 0.5f
val x994 = x993.asInstanceOf[Int]
var x995: Int = x994
var x996: Int = 0
var x997: Boolean = true
val x1005 = x980.binary_gradients
val x1045 = while ({val x998 = x996
val x1000 = x997
val x999 = x998 < x985
val x1001 = x999 && x1000
x1001}) {
val x1003 = x996
val x1006 = x996
val x1010 = x996
val x1007 = x984(x1006)
val x1008 = x1005(x1007)
val x1009 = x1008==0
val x1011 = x984(x1010)
val x1012 = x950(x1011)
val x1013 = x1012==0
val x1014 = x1009 && x1013
val x1042 = {
def x1042thenb(): Unit = {
val x1015 = x991
val x1016 = x1015 + 1.0f
x991 = x1016
()
}
def x1042elseb(): Unit = {
val x1019 = x996
val x1022 = x996
val x1020 = x984(x1019)
val x1021 = x1005(x1020)
val x1023 = x984(x1022)
val x1024 = x950(x1023)
val x1025 = x1021 & x1024
val x1026 = x1025 > 0
val x1040 = {
def x1040thenb(): Unit = {
val x1027 = x991
val x1028 = x1027 + 1.0f
x991 = x1028
()
}
def x1040elseb(): Unit = {
val x1031 = x995
val x1032 = x1031 - 1
x995 = x1032
val x1034 = x995
val x1035 = x1034 <= 0
val x1038 = {
def x1038thenb(): Unit = {
x997 = false
()
}
def x1038elseb(): Unit = {
()
}
if (x1035) {
x1038thenb()
} else {
x1038elseb()
}
}
x1038
}
if (x1026) {
x1040thenb()
} else {
x1040elseb()
}
}
x1040
}
if (x1014) {
x1042thenb()
} else {
x1042elseb()
}
}
val x1043 = x996 += 1
()
}
val x1046 = x997
val x1047 = !x1046
val x1052 = {
def x1052thenb(): Float = {
0.819999f
}
def x1052elseb(): Float = {
val x1048 = x991
val x1049 = x1048 / x986
val x1050 = x1049.asInstanceOf[Float]
x1050
}
if (x1047) {
x1052thenb()
} else {
x1052elseb()
}
}
x1052
}
if (x990) {
x1054thenb()
} else {
x1054elseb()
}
}
x1054
}
if (x987) {
x1056thenb()
} else {
x1056elseb()
}
}
x1056
}
if (x983) {
x1058thenb()
} else {
x1058elseb()
}
}
val x1059 = x1058 > 0.82f
val x1078 = {
def x1078thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1060 = x980.rect
val x1062 = x1060.width
val x902 = x891
val x903 = Math.pow(2.0,x902)
val x904 = x903.asInstanceOf[Int]
val x1061 = x904 * x901
val x1063 = x1062 / 2
val x1064 = x1061 - x1063
val x1065 = x1064.asInstanceOf[Int]
val x1067 = x1060.height
val x1066 = x904 * x897
val x1068 = x1067 / 2
val x1069 = x1066 - x1068
val x1070 = x1069.asInstanceOf[Int]
val x1071 = new generated.scala.Rect(x1065,x1070,x1062,x1067)
val x1072 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1073 = new generated.scala.BiGGDetection(x884,x1058,x1071,null,x979,x901,x897,x980,x908)
val x1074 = x1072(0) = x1073
x1072
}
def x1078elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1076 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1076
}
if (x1059) {
x1078thenb()
} else {
x1078elseb()
}
}
x1078
}
var mapReduceIdx = 1
while (mapReduceIdx < x978.size) { // begin mapReduce loop x1108
val x979 = x978.dcApply(mapReduceIdx)
val x1081 = {
val x980 = x885(x979)
val x981 = x980.radius
val x983 = x981 != x982
val x1058 = {
def x1058thenb(): Float = {
-1.0f
}
def x1058elseb(): Float = {
val x984 = x980.match_list
val x985 = x984.length
val x986 = x985.asInstanceOf[Float]
val x987 = x986==0.0
val x1056 = {
def x1056thenb(): Float = {
-1.0f
}
def x1056elseb(): Float = {
val x988 = x964.asInstanceOf[Float]
val x989 = x988 / x986
val x990 = x989 < 0.82f
val x1054 = {
def x1054thenb(): Float = {
x989
}
def x1054elseb(): Float = {
var x991: Float = 0.0f
val x992 = x986 * 0.18f
val x993 = x992 + 0.5f
val x994 = x993.asInstanceOf[Int]
var x995: Int = x994
var x996: Int = 0
var x997: Boolean = true
val x1005 = x980.binary_gradients
val x1045 = while ({val x998 = x996
val x1000 = x997
val x999 = x998 < x985
val x1001 = x999 && x1000
x1001}) {
val x1003 = x996
val x1006 = x996
val x1010 = x996
val x1007 = x984(x1006)
val x1008 = x1005(x1007)
val x1009 = x1008==0
val x1011 = x984(x1010)
val x1012 = x950(x1011)
val x1013 = x1012==0
val x1014 = x1009 && x1013
val x1042 = {
def x1042thenb(): Unit = {
val x1015 = x991
val x1016 = x1015 + 1.0f
x991 = x1016
()
}
def x1042elseb(): Unit = {
val x1019 = x996
val x1022 = x996
val x1020 = x984(x1019)
val x1021 = x1005(x1020)
val x1023 = x984(x1022)
val x1024 = x950(x1023)
val x1025 = x1021 & x1024
val x1026 = x1025 > 0
val x1040 = {
def x1040thenb(): Unit = {
val x1027 = x991
val x1028 = x1027 + 1.0f
x991 = x1028
()
}
def x1040elseb(): Unit = {
val x1031 = x995
val x1032 = x1031 - 1
x995 = x1032
val x1034 = x995
val x1035 = x1034 <= 0
val x1038 = {
def x1038thenb(): Unit = {
x997 = false
()
}
def x1038elseb(): Unit = {
()
}
if (x1035) {
x1038thenb()
} else {
x1038elseb()
}
}
x1038
}
if (x1026) {
x1040thenb()
} else {
x1040elseb()
}
}
x1040
}
if (x1014) {
x1042thenb()
} else {
x1042elseb()
}
}
val x1043 = x996 += 1
()
}
val x1046 = x997
val x1047 = !x1046
val x1052 = {
def x1052thenb(): Float = {
0.819999f
}
def x1052elseb(): Float = {
val x1048 = x991
val x1049 = x1048 / x986
val x1050 = x1049.asInstanceOf[Float]
x1050
}
if (x1047) {
x1052thenb()
} else {
x1052elseb()
}
}
x1052
}
if (x990) {
x1054thenb()
} else {
x1054elseb()
}
}
x1054
}
if (x987) {
x1056thenb()
} else {
x1056elseb()
}
}
x1056
}
if (x983) {
x1058thenb()
} else {
x1058elseb()
}
}
val x1059 = x1058 > 0.82f
val x1078 = {
def x1078thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1060 = x980.rect
val x1062 = x1060.width
val x902 = x891
val x903 = Math.pow(2.0,x902)
val x904 = x903.asInstanceOf[Int]
val x1061 = x904 * x901
val x1063 = x1062 / 2
val x1064 = x1061 - x1063
val x1065 = x1064.asInstanceOf[Int]
val x1067 = x1060.height
val x1066 = x904 * x897
val x1068 = x1067 / 2
val x1069 = x1066 - x1068
val x1070 = x1069.asInstanceOf[Int]
val x1071 = new generated.scala.Rect(x1065,x1070,x1062,x1067)
val x1072 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1073 = new generated.scala.BiGGDetection(x884,x1058,x1071,null,x979,x901,x897,x980,x908)
val x1074 = x1072(0) = x1073
x1072
}
def x1078elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1076 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1076
}
if (x1059) {
x1078thenb()
} else {
x1078elseb()
}
}
x1078
}
x1080 = {
val x1082 = x1080.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1107 = { 
val x1105 = {
def x1105thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1081
}
def x1105elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1083 = x1081.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1103 = {
def x1103thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1080
}
def x1103elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1084 = x1080.length
val x1085 = x1081.length
val x1086 = x1084 + x1085
val x1087 = x1080.isRow
val x1088 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1086,x1087)
var x1090 : Int = 0
val x1094 = while (x1090 < x1084) {
val x1091 = x1080(x1090)
val x1092 = x1088(x1090) = x1091
x1092
x1090 = x1090 + 1
}
var x1096 : Int = 0
val x1101 = while (x1096 < x1085) {
val x1097 = x1096 + x1084
val x1098 = x1081(x1096)
val x1099 = x1088(x1097) = x1098
x1099
x1096 = x1096 + 1
}
x1088
}
if (x1083) {
x1103thenb()
} else {
x1103elseb()
}
}
x1103
}
if (x1082) {
x1105thenb()
} else {
x1105elseb()
}
}
x1105
}
x1107
}
mapReduceIdx += 1
} // end mapReduce loop x1108
x1080
}
val x1108 = x1108_block
x1108
}
var mapReduceIdx = 1
while (mapReduceIdx < x900.size) { // begin mapReduce loop x1138
val x901 = x900.dcApply(mapReduceIdx)
val x1111 = {
val x905 = new generated.scala.IntVectorImpl(900,false)
val x906 = new generated.scala.IntVectorImpl(0,true)
val x907 = new generated.scala.IndexVectorSeqImpl(x906)
val x908 = new generated.scala.BinarizedGradientTemplate(15,null,null,x891,x905,x907,null,null,null)
var x931: Int = x926
val x909 = x901 - 15
val x910 = x909 < 0
val x914 = {
def x914thenb(): scala.Tuple2[Int, Int] = {
val x911 = 15 - x901
val x912 = (0,x911)
x912
}
def x914elseb(): scala.Tuple2[Int, Int] = {
val x913 = (x909,0)
x913
}
if (x910) {
x914thenb()
} else {
x914elseb()
}
}
val x915 = x914._1
val x917 = x901 + 15
val x918 = x917 > x898
val x919 = {
def x919thenb(): Int = {
x898
}
def x919elseb(): Int = {
x917
}
if (x918) {
x919thenb()
} else {
x919elseb()
}
}
val x916 = x914._2
val x950 = x908.binary_gradients
val x963 = x908.match_list
val x964 = x963.length
val x973 = while ({val x932 = x931
val x933 = x932 < x930
x933}) {
val x935 = x931
var x937: Int = x915
val x953 = x935 * x898
val x970 = while ({val x938 = x937
val x939 = x938 < x919
x939}) {
val x941 = x931
val x945 = x937
val x942 = x927 + x941
val x943 = x942 - x926
val x944 = x943 * 30
val x946 = x916 + x945
val x947 = x946 - x915
val x948 = x944 + x947
var x949: Int = x948
val x951 = x949
val x952 = x937
val x954 = x953 + x952
val x955 = x893.dcApply(x954)
val x956 = { 
x955
}
val x957 = x950(x951) = x956
val x958 = x937
val x959 = x953 + x958
val x960 = x893.dcApply(x959)
val x961 = { 
x960
}
val x962 = x961 > 0
val x967 = {
def x967thenb(): Unit = {
val x965 = x963.insert(x964, x951)
x965
}
def x967elseb(): Unit = {
()
}
if (x962) {
x967thenb()
} else {
x967elseb()
}
}
val x968 = x937 += 1
()
}
val x971 = x931 += 1
()
}
val x974 = x964 < 0
val x977 = {
def x977thenb(): Unit = {
val x975 = println("dummy")
x975
}
def x977elseb(): Unit = {
()
}
if (x974) {
x977thenb()
} else {
x977elseb()
}
}
val x982 = x908.radius
def x1108_block = {
val x979 = x978.dcApply(0)
var x1080 = {
val x980 = x885(x979)
val x981 = x980.radius
val x983 = x981 != x982
val x1058 = {
def x1058thenb(): Float = {
-1.0f
}
def x1058elseb(): Float = {
val x984 = x980.match_list
val x985 = x984.length
val x986 = x985.asInstanceOf[Float]
val x987 = x986==0.0
val x1056 = {
def x1056thenb(): Float = {
-1.0f
}
def x1056elseb(): Float = {
val x988 = x964.asInstanceOf[Float]
val x989 = x988 / x986
val x990 = x989 < 0.82f
val x1054 = {
def x1054thenb(): Float = {
x989
}
def x1054elseb(): Float = {
var x991: Float = 0.0f
val x992 = x986 * 0.18f
val x993 = x992 + 0.5f
val x994 = x993.asInstanceOf[Int]
var x995: Int = x994
var x996: Int = 0
var x997: Boolean = true
val x1005 = x980.binary_gradients
val x1045 = while ({val x998 = x996
val x1000 = x997
val x999 = x998 < x985
val x1001 = x999 && x1000
x1001}) {
val x1003 = x996
val x1006 = x996
val x1010 = x996
val x1007 = x984(x1006)
val x1008 = x1005(x1007)
val x1009 = x1008==0
val x1011 = x984(x1010)
val x1012 = x950(x1011)
val x1013 = x1012==0
val x1014 = x1009 && x1013
val x1042 = {
def x1042thenb(): Unit = {
val x1015 = x991
val x1016 = x1015 + 1.0f
x991 = x1016
()
}
def x1042elseb(): Unit = {
val x1019 = x996
val x1022 = x996
val x1020 = x984(x1019)
val x1021 = x1005(x1020)
val x1023 = x984(x1022)
val x1024 = x950(x1023)
val x1025 = x1021 & x1024
val x1026 = x1025 > 0
val x1040 = {
def x1040thenb(): Unit = {
val x1027 = x991
val x1028 = x1027 + 1.0f
x991 = x1028
()
}
def x1040elseb(): Unit = {
val x1031 = x995
val x1032 = x1031 - 1
x995 = x1032
val x1034 = x995
val x1035 = x1034 <= 0
val x1038 = {
def x1038thenb(): Unit = {
x997 = false
()
}
def x1038elseb(): Unit = {
()
}
if (x1035) {
x1038thenb()
} else {
x1038elseb()
}
}
x1038
}
if (x1026) {
x1040thenb()
} else {
x1040elseb()
}
}
x1040
}
if (x1014) {
x1042thenb()
} else {
x1042elseb()
}
}
val x1043 = x996 += 1
()
}
val x1046 = x997
val x1047 = !x1046
val x1052 = {
def x1052thenb(): Float = {
0.819999f
}
def x1052elseb(): Float = {
val x1048 = x991
val x1049 = x1048 / x986
val x1050 = x1049.asInstanceOf[Float]
x1050
}
if (x1047) {
x1052thenb()
} else {
x1052elseb()
}
}
x1052
}
if (x990) {
x1054thenb()
} else {
x1054elseb()
}
}
x1054
}
if (x987) {
x1056thenb()
} else {
x1056elseb()
}
}
x1056
}
if (x983) {
x1058thenb()
} else {
x1058elseb()
}
}
val x1059 = x1058 > 0.82f
val x1078 = {
def x1078thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1060 = x980.rect
val x1062 = x1060.width
val x902 = x891
val x903 = Math.pow(2.0,x902)
val x904 = x903.asInstanceOf[Int]
val x1061 = x904 * x901
val x1063 = x1062 / 2
val x1064 = x1061 - x1063
val x1065 = x1064.asInstanceOf[Int]
val x1067 = x1060.height
val x1066 = x904 * x897
val x1068 = x1067 / 2
val x1069 = x1066 - x1068
val x1070 = x1069.asInstanceOf[Int]
val x1071 = new generated.scala.Rect(x1065,x1070,x1062,x1067)
val x1072 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1073 = new generated.scala.BiGGDetection(x884,x1058,x1071,null,x979,x901,x897,x980,x908)
val x1074 = x1072(0) = x1073
x1072
}
def x1078elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1076 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1076
}
if (x1059) {
x1078thenb()
} else {
x1078elseb()
}
}
x1078
}
var mapReduceIdx = 1
while (mapReduceIdx < x978.size) { // begin mapReduce loop x1108
val x979 = x978.dcApply(mapReduceIdx)
val x1081 = {
val x980 = x885(x979)
val x981 = x980.radius
val x983 = x981 != x982
val x1058 = {
def x1058thenb(): Float = {
-1.0f
}
def x1058elseb(): Float = {
val x984 = x980.match_list
val x985 = x984.length
val x986 = x985.asInstanceOf[Float]
val x987 = x986==0.0
val x1056 = {
def x1056thenb(): Float = {
-1.0f
}
def x1056elseb(): Float = {
val x988 = x964.asInstanceOf[Float]
val x989 = x988 / x986
val x990 = x989 < 0.82f
val x1054 = {
def x1054thenb(): Float = {
x989
}
def x1054elseb(): Float = {
var x991: Float = 0.0f
val x992 = x986 * 0.18f
val x993 = x992 + 0.5f
val x994 = x993.asInstanceOf[Int]
var x995: Int = x994
var x996: Int = 0
var x997: Boolean = true
val x1005 = x980.binary_gradients
val x1045 = while ({val x998 = x996
val x1000 = x997
val x999 = x998 < x985
val x1001 = x999 && x1000
x1001}) {
val x1003 = x996
val x1006 = x996
val x1010 = x996
val x1007 = x984(x1006)
val x1008 = x1005(x1007)
val x1009 = x1008==0
val x1011 = x984(x1010)
val x1012 = x950(x1011)
val x1013 = x1012==0
val x1014 = x1009 && x1013
val x1042 = {
def x1042thenb(): Unit = {
val x1015 = x991
val x1016 = x1015 + 1.0f
x991 = x1016
()
}
def x1042elseb(): Unit = {
val x1019 = x996
val x1022 = x996
val x1020 = x984(x1019)
val x1021 = x1005(x1020)
val x1023 = x984(x1022)
val x1024 = x950(x1023)
val x1025 = x1021 & x1024
val x1026 = x1025 > 0
val x1040 = {
def x1040thenb(): Unit = {
val x1027 = x991
val x1028 = x1027 + 1.0f
x991 = x1028
()
}
def x1040elseb(): Unit = {
val x1031 = x995
val x1032 = x1031 - 1
x995 = x1032
val x1034 = x995
val x1035 = x1034 <= 0
val x1038 = {
def x1038thenb(): Unit = {
x997 = false
()
}
def x1038elseb(): Unit = {
()
}
if (x1035) {
x1038thenb()
} else {
x1038elseb()
}
}
x1038
}
if (x1026) {
x1040thenb()
} else {
x1040elseb()
}
}
x1040
}
if (x1014) {
x1042thenb()
} else {
x1042elseb()
}
}
val x1043 = x996 += 1
()
}
val x1046 = x997
val x1047 = !x1046
val x1052 = {
def x1052thenb(): Float = {
0.819999f
}
def x1052elseb(): Float = {
val x1048 = x991
val x1049 = x1048 / x986
val x1050 = x1049.asInstanceOf[Float]
x1050
}
if (x1047) {
x1052thenb()
} else {
x1052elseb()
}
}
x1052
}
if (x990) {
x1054thenb()
} else {
x1054elseb()
}
}
x1054
}
if (x987) {
x1056thenb()
} else {
x1056elseb()
}
}
x1056
}
if (x983) {
x1058thenb()
} else {
x1058elseb()
}
}
val x1059 = x1058 > 0.82f
val x1078 = {
def x1078thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1060 = x980.rect
val x1062 = x1060.width
val x902 = x891
val x903 = Math.pow(2.0,x902)
val x904 = x903.asInstanceOf[Int]
val x1061 = x904 * x901
val x1063 = x1062 / 2
val x1064 = x1061 - x1063
val x1065 = x1064.asInstanceOf[Int]
val x1067 = x1060.height
val x1066 = x904 * x897
val x1068 = x1067 / 2
val x1069 = x1066 - x1068
val x1070 = x1069.asInstanceOf[Int]
val x1071 = new generated.scala.Rect(x1065,x1070,x1062,x1067)
val x1072 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1073 = new generated.scala.BiGGDetection(x884,x1058,x1071,null,x979,x901,x897,x980,x908)
val x1074 = x1072(0) = x1073
x1072
}
def x1078elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1076 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1076
}
if (x1059) {
x1078thenb()
} else {
x1078elseb()
}
}
x1078
}
x1080 = {
val x1082 = x1080.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1107 = { 
val x1105 = {
def x1105thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1081
}
def x1105elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1083 = x1081.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1103 = {
def x1103thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1080
}
def x1103elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1084 = x1080.length
val x1085 = x1081.length
val x1086 = x1084 + x1085
val x1087 = x1080.isRow
val x1088 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1086,x1087)
var x1090 : Int = 0
val x1094 = while (x1090 < x1084) {
val x1091 = x1080(x1090)
val x1092 = x1088(x1090) = x1091
x1092
x1090 = x1090 + 1
}
var x1096 : Int = 0
val x1101 = while (x1096 < x1085) {
val x1097 = x1096 + x1084
val x1098 = x1081(x1096)
val x1099 = x1088(x1097) = x1098
x1099
x1096 = x1096 + 1
}
x1088
}
if (x1083) {
x1103thenb()
} else {
x1103elseb()
}
}
x1103
}
if (x1082) {
x1105thenb()
} else {
x1105elseb()
}
}
x1105
}
x1107
}
mapReduceIdx += 1
} // end mapReduce loop x1108
x1080
}
val x1108 = x1108_block
x1108
}
x1110 = {
val x1112 = x1110.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1137 = { 
val x1135 = {
def x1135thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1111
}
def x1135elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1113 = x1111.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1133 = {
def x1133thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1110
}
def x1133elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1114 = x1110.length
val x1115 = x1111.length
val x1116 = x1114 + x1115
val x1117 = x1110.isRow
val x1118 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1116,x1117)
var x1120 : Int = 0
val x1124 = while (x1120 < x1114) {
val x1121 = x1110(x1120)
val x1122 = x1118(x1120) = x1121
x1122
x1120 = x1120 + 1
}
var x1126 : Int = 0
val x1131 = while (x1126 < x1115) {
val x1127 = x1126 + x1114
val x1128 = x1111(x1126)
val x1129 = x1118(x1127) = x1128
x1129
x1126 = x1126 + 1
}
x1118
}
if (x1113) {
x1133thenb()
} else {
x1133elseb()
}
}
x1133
}
if (x1112) {
x1135thenb()
} else {
x1135elseb()
}
}
x1135
}
x1137
}
mapReduceIdx += 1
} // end mapReduce loop x1138
x1110
}
val x1138 = x1138_block
x1138
}
var mapReduceIdx = 1
while (mapReduceIdx < x896.size) { // begin mapReduce loop x1167
val x897 = x896.dcApply(mapReduceIdx)
val x1140 = {
val x920 = x897 - 15
val x921 = x920 < 0
val x925 = {
def x925thenb(): scala.Tuple2[Int, Int] = {
val x922 = 15 - x897
val x923 = (0,x922)
x923
}
def x925elseb(): scala.Tuple2[Int, Int] = {
val x924 = (x920,0)
x924
}
if (x921) {
x925thenb()
} else {
x925elseb()
}
}
val x926 = x925._1
val x928 = x897 + 15
val x929 = x928 > x894
val x930 = {
def x930thenb(): Int = {
x894
}
def x930elseb(): Int = {
x928
}
if (x929) {
x930thenb()
} else {
x930elseb()
}
}
val x927 = x925._2
def x1138_block = {
val x901 = x900.dcApply(0)
var x1110 = {
val x905 = new generated.scala.IntVectorImpl(900,false)
val x906 = new generated.scala.IntVectorImpl(0,true)
val x907 = new generated.scala.IndexVectorSeqImpl(x906)
val x908 = new generated.scala.BinarizedGradientTemplate(15,null,null,x891,x905,x907,null,null,null)
var x931: Int = x926
val x909 = x901 - 15
val x910 = x909 < 0
val x914 = {
def x914thenb(): scala.Tuple2[Int, Int] = {
val x911 = 15 - x901
val x912 = (0,x911)
x912
}
def x914elseb(): scala.Tuple2[Int, Int] = {
val x913 = (x909,0)
x913
}
if (x910) {
x914thenb()
} else {
x914elseb()
}
}
val x915 = x914._1
val x917 = x901 + 15
val x918 = x917 > x898
val x919 = {
def x919thenb(): Int = {
x898
}
def x919elseb(): Int = {
x917
}
if (x918) {
x919thenb()
} else {
x919elseb()
}
}
val x916 = x914._2
val x950 = x908.binary_gradients
val x963 = x908.match_list
val x964 = x963.length
val x973 = while ({val x932 = x931
val x933 = x932 < x930
x933}) {
val x935 = x931
var x937: Int = x915
val x953 = x935 * x898
val x970 = while ({val x938 = x937
val x939 = x938 < x919
x939}) {
val x941 = x931
val x945 = x937
val x942 = x927 + x941
val x943 = x942 - x926
val x944 = x943 * 30
val x946 = x916 + x945
val x947 = x946 - x915
val x948 = x944 + x947
var x949: Int = x948
val x951 = x949
val x952 = x937
val x954 = x953 + x952
val x955 = x893.dcApply(x954)
val x956 = { 
x955
}
val x957 = x950(x951) = x956
val x958 = x937
val x959 = x953 + x958
val x960 = x893.dcApply(x959)
val x961 = { 
x960
}
val x962 = x961 > 0
val x967 = {
def x967thenb(): Unit = {
val x965 = x963.insert(x964, x951)
x965
}
def x967elseb(): Unit = {
()
}
if (x962) {
x967thenb()
} else {
x967elseb()
}
}
val x968 = x937 += 1
()
}
val x971 = x931 += 1
()
}
val x974 = x964 < 0
val x977 = {
def x977thenb(): Unit = {
val x975 = println("dummy")
x975
}
def x977elseb(): Unit = {
()
}
if (x974) {
x977thenb()
} else {
x977elseb()
}
}
val x982 = x908.radius
def x1108_block = {
val x979 = x978.dcApply(0)
var x1080 = {
val x980 = x885(x979)
val x981 = x980.radius
val x983 = x981 != x982
val x1058 = {
def x1058thenb(): Float = {
-1.0f
}
def x1058elseb(): Float = {
val x984 = x980.match_list
val x985 = x984.length
val x986 = x985.asInstanceOf[Float]
val x987 = x986==0.0
val x1056 = {
def x1056thenb(): Float = {
-1.0f
}
def x1056elseb(): Float = {
val x988 = x964.asInstanceOf[Float]
val x989 = x988 / x986
val x990 = x989 < 0.82f
val x1054 = {
def x1054thenb(): Float = {
x989
}
def x1054elseb(): Float = {
var x991: Float = 0.0f
val x992 = x986 * 0.18f
val x993 = x992 + 0.5f
val x994 = x993.asInstanceOf[Int]
var x995: Int = x994
var x996: Int = 0
var x997: Boolean = true
val x1005 = x980.binary_gradients
val x1045 = while ({val x998 = x996
val x1000 = x997
val x999 = x998 < x985
val x1001 = x999 && x1000
x1001}) {
val x1003 = x996
val x1006 = x996
val x1010 = x996
val x1007 = x984(x1006)
val x1008 = x1005(x1007)
val x1009 = x1008==0
val x1011 = x984(x1010)
val x1012 = x950(x1011)
val x1013 = x1012==0
val x1014 = x1009 && x1013
val x1042 = {
def x1042thenb(): Unit = {
val x1015 = x991
val x1016 = x1015 + 1.0f
x991 = x1016
()
}
def x1042elseb(): Unit = {
val x1019 = x996
val x1022 = x996
val x1020 = x984(x1019)
val x1021 = x1005(x1020)
val x1023 = x984(x1022)
val x1024 = x950(x1023)
val x1025 = x1021 & x1024
val x1026 = x1025 > 0
val x1040 = {
def x1040thenb(): Unit = {
val x1027 = x991
val x1028 = x1027 + 1.0f
x991 = x1028
()
}
def x1040elseb(): Unit = {
val x1031 = x995
val x1032 = x1031 - 1
x995 = x1032
val x1034 = x995
val x1035 = x1034 <= 0
val x1038 = {
def x1038thenb(): Unit = {
x997 = false
()
}
def x1038elseb(): Unit = {
()
}
if (x1035) {
x1038thenb()
} else {
x1038elseb()
}
}
x1038
}
if (x1026) {
x1040thenb()
} else {
x1040elseb()
}
}
x1040
}
if (x1014) {
x1042thenb()
} else {
x1042elseb()
}
}
val x1043 = x996 += 1
()
}
val x1046 = x997
val x1047 = !x1046
val x1052 = {
def x1052thenb(): Float = {
0.819999f
}
def x1052elseb(): Float = {
val x1048 = x991
val x1049 = x1048 / x986
val x1050 = x1049.asInstanceOf[Float]
x1050
}
if (x1047) {
x1052thenb()
} else {
x1052elseb()
}
}
x1052
}
if (x990) {
x1054thenb()
} else {
x1054elseb()
}
}
x1054
}
if (x987) {
x1056thenb()
} else {
x1056elseb()
}
}
x1056
}
if (x983) {
x1058thenb()
} else {
x1058elseb()
}
}
val x1059 = x1058 > 0.82f
val x1078 = {
def x1078thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1060 = x980.rect
val x1062 = x1060.width
val x902 = x891
val x903 = Math.pow(2.0,x902)
val x904 = x903.asInstanceOf[Int]
val x1061 = x904 * x901
val x1063 = x1062 / 2
val x1064 = x1061 - x1063
val x1065 = x1064.asInstanceOf[Int]
val x1067 = x1060.height
val x1066 = x904 * x897
val x1068 = x1067 / 2
val x1069 = x1066 - x1068
val x1070 = x1069.asInstanceOf[Int]
val x1071 = new generated.scala.Rect(x1065,x1070,x1062,x1067)
val x1072 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1073 = new generated.scala.BiGGDetection(x884,x1058,x1071,null,x979,x901,x897,x980,x908)
val x1074 = x1072(0) = x1073
x1072
}
def x1078elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1076 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1076
}
if (x1059) {
x1078thenb()
} else {
x1078elseb()
}
}
x1078
}
var mapReduceIdx = 1
while (mapReduceIdx < x978.size) { // begin mapReduce loop x1108
val x979 = x978.dcApply(mapReduceIdx)
val x1081 = {
val x980 = x885(x979)
val x981 = x980.radius
val x983 = x981 != x982
val x1058 = {
def x1058thenb(): Float = {
-1.0f
}
def x1058elseb(): Float = {
val x984 = x980.match_list
val x985 = x984.length
val x986 = x985.asInstanceOf[Float]
val x987 = x986==0.0
val x1056 = {
def x1056thenb(): Float = {
-1.0f
}
def x1056elseb(): Float = {
val x988 = x964.asInstanceOf[Float]
val x989 = x988 / x986
val x990 = x989 < 0.82f
val x1054 = {
def x1054thenb(): Float = {
x989
}
def x1054elseb(): Float = {
var x991: Float = 0.0f
val x992 = x986 * 0.18f
val x993 = x992 + 0.5f
val x994 = x993.asInstanceOf[Int]
var x995: Int = x994
var x996: Int = 0
var x997: Boolean = true
val x1005 = x980.binary_gradients
val x1045 = while ({val x998 = x996
val x1000 = x997
val x999 = x998 < x985
val x1001 = x999 && x1000
x1001}) {
val x1003 = x996
val x1006 = x996
val x1010 = x996
val x1007 = x984(x1006)
val x1008 = x1005(x1007)
val x1009 = x1008==0
val x1011 = x984(x1010)
val x1012 = x950(x1011)
val x1013 = x1012==0
val x1014 = x1009 && x1013
val x1042 = {
def x1042thenb(): Unit = {
val x1015 = x991
val x1016 = x1015 + 1.0f
x991 = x1016
()
}
def x1042elseb(): Unit = {
val x1019 = x996
val x1022 = x996
val x1020 = x984(x1019)
val x1021 = x1005(x1020)
val x1023 = x984(x1022)
val x1024 = x950(x1023)
val x1025 = x1021 & x1024
val x1026 = x1025 > 0
val x1040 = {
def x1040thenb(): Unit = {
val x1027 = x991
val x1028 = x1027 + 1.0f
x991 = x1028
()
}
def x1040elseb(): Unit = {
val x1031 = x995
val x1032 = x1031 - 1
x995 = x1032
val x1034 = x995
val x1035 = x1034 <= 0
val x1038 = {
def x1038thenb(): Unit = {
x997 = false
()
}
def x1038elseb(): Unit = {
()
}
if (x1035) {
x1038thenb()
} else {
x1038elseb()
}
}
x1038
}
if (x1026) {
x1040thenb()
} else {
x1040elseb()
}
}
x1040
}
if (x1014) {
x1042thenb()
} else {
x1042elseb()
}
}
val x1043 = x996 += 1
()
}
val x1046 = x997
val x1047 = !x1046
val x1052 = {
def x1052thenb(): Float = {
0.819999f
}
def x1052elseb(): Float = {
val x1048 = x991
val x1049 = x1048 / x986
val x1050 = x1049.asInstanceOf[Float]
x1050
}
if (x1047) {
x1052thenb()
} else {
x1052elseb()
}
}
x1052
}
if (x990) {
x1054thenb()
} else {
x1054elseb()
}
}
x1054
}
if (x987) {
x1056thenb()
} else {
x1056elseb()
}
}
x1056
}
if (x983) {
x1058thenb()
} else {
x1058elseb()
}
}
val x1059 = x1058 > 0.82f
val x1078 = {
def x1078thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1060 = x980.rect
val x1062 = x1060.width
val x902 = x891
val x903 = Math.pow(2.0,x902)
val x904 = x903.asInstanceOf[Int]
val x1061 = x904 * x901
val x1063 = x1062 / 2
val x1064 = x1061 - x1063
val x1065 = x1064.asInstanceOf[Int]
val x1067 = x1060.height
val x1066 = x904 * x897
val x1068 = x1067 / 2
val x1069 = x1066 - x1068
val x1070 = x1069.asInstanceOf[Int]
val x1071 = new generated.scala.Rect(x1065,x1070,x1062,x1067)
val x1072 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1073 = new generated.scala.BiGGDetection(x884,x1058,x1071,null,x979,x901,x897,x980,x908)
val x1074 = x1072(0) = x1073
x1072
}
def x1078elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1076 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1076
}
if (x1059) {
x1078thenb()
} else {
x1078elseb()
}
}
x1078
}
x1080 = {
val x1082 = x1080.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1107 = { 
val x1105 = {
def x1105thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1081
}
def x1105elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1083 = x1081.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1103 = {
def x1103thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1080
}
def x1103elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1084 = x1080.length
val x1085 = x1081.length
val x1086 = x1084 + x1085
val x1087 = x1080.isRow
val x1088 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1086,x1087)
var x1090 : Int = 0
val x1094 = while (x1090 < x1084) {
val x1091 = x1080(x1090)
val x1092 = x1088(x1090) = x1091
x1092
x1090 = x1090 + 1
}
var x1096 : Int = 0
val x1101 = while (x1096 < x1085) {
val x1097 = x1096 + x1084
val x1098 = x1081(x1096)
val x1099 = x1088(x1097) = x1098
x1099
x1096 = x1096 + 1
}
x1088
}
if (x1083) {
x1103thenb()
} else {
x1103elseb()
}
}
x1103
}
if (x1082) {
x1105thenb()
} else {
x1105elseb()
}
}
x1105
}
x1107
}
mapReduceIdx += 1
} // end mapReduce loop x1108
x1080
}
val x1108 = x1108_block
x1108
}
var mapReduceIdx = 1
while (mapReduceIdx < x900.size) { // begin mapReduce loop x1138
val x901 = x900.dcApply(mapReduceIdx)
val x1111 = {
val x905 = new generated.scala.IntVectorImpl(900,false)
val x906 = new generated.scala.IntVectorImpl(0,true)
val x907 = new generated.scala.IndexVectorSeqImpl(x906)
val x908 = new generated.scala.BinarizedGradientTemplate(15,null,null,x891,x905,x907,null,null,null)
var x931: Int = x926
val x909 = x901 - 15
val x910 = x909 < 0
val x914 = {
def x914thenb(): scala.Tuple2[Int, Int] = {
val x911 = 15 - x901
val x912 = (0,x911)
x912
}
def x914elseb(): scala.Tuple2[Int, Int] = {
val x913 = (x909,0)
x913
}
if (x910) {
x914thenb()
} else {
x914elseb()
}
}
val x915 = x914._1
val x917 = x901 + 15
val x918 = x917 > x898
val x919 = {
def x919thenb(): Int = {
x898
}
def x919elseb(): Int = {
x917
}
if (x918) {
x919thenb()
} else {
x919elseb()
}
}
val x916 = x914._2
val x950 = x908.binary_gradients
val x963 = x908.match_list
val x964 = x963.length
val x973 = while ({val x932 = x931
val x933 = x932 < x930
x933}) {
val x935 = x931
var x937: Int = x915
val x953 = x935 * x898
val x970 = while ({val x938 = x937
val x939 = x938 < x919
x939}) {
val x941 = x931
val x945 = x937
val x942 = x927 + x941
val x943 = x942 - x926
val x944 = x943 * 30
val x946 = x916 + x945
val x947 = x946 - x915
val x948 = x944 + x947
var x949: Int = x948
val x951 = x949
val x952 = x937
val x954 = x953 + x952
val x955 = x893.dcApply(x954)
val x956 = { 
x955
}
val x957 = x950(x951) = x956
val x958 = x937
val x959 = x953 + x958
val x960 = x893.dcApply(x959)
val x961 = { 
x960
}
val x962 = x961 > 0
val x967 = {
def x967thenb(): Unit = {
val x965 = x963.insert(x964, x951)
x965
}
def x967elseb(): Unit = {
()
}
if (x962) {
x967thenb()
} else {
x967elseb()
}
}
val x968 = x937 += 1
()
}
val x971 = x931 += 1
()
}
val x974 = x964 < 0
val x977 = {
def x977thenb(): Unit = {
val x975 = println("dummy")
x975
}
def x977elseb(): Unit = {
()
}
if (x974) {
x977thenb()
} else {
x977elseb()
}
}
val x982 = x908.radius
def x1108_block = {
val x979 = x978.dcApply(0)
var x1080 = {
val x980 = x885(x979)
val x981 = x980.radius
val x983 = x981 != x982
val x1058 = {
def x1058thenb(): Float = {
-1.0f
}
def x1058elseb(): Float = {
val x984 = x980.match_list
val x985 = x984.length
val x986 = x985.asInstanceOf[Float]
val x987 = x986==0.0
val x1056 = {
def x1056thenb(): Float = {
-1.0f
}
def x1056elseb(): Float = {
val x988 = x964.asInstanceOf[Float]
val x989 = x988 / x986
val x990 = x989 < 0.82f
val x1054 = {
def x1054thenb(): Float = {
x989
}
def x1054elseb(): Float = {
var x991: Float = 0.0f
val x992 = x986 * 0.18f
val x993 = x992 + 0.5f
val x994 = x993.asInstanceOf[Int]
var x995: Int = x994
var x996: Int = 0
var x997: Boolean = true
val x1005 = x980.binary_gradients
val x1045 = while ({val x998 = x996
val x1000 = x997
val x999 = x998 < x985
val x1001 = x999 && x1000
x1001}) {
val x1003 = x996
val x1006 = x996
val x1010 = x996
val x1007 = x984(x1006)
val x1008 = x1005(x1007)
val x1009 = x1008==0
val x1011 = x984(x1010)
val x1012 = x950(x1011)
val x1013 = x1012==0
val x1014 = x1009 && x1013
val x1042 = {
def x1042thenb(): Unit = {
val x1015 = x991
val x1016 = x1015 + 1.0f
x991 = x1016
()
}
def x1042elseb(): Unit = {
val x1019 = x996
val x1022 = x996
val x1020 = x984(x1019)
val x1021 = x1005(x1020)
val x1023 = x984(x1022)
val x1024 = x950(x1023)
val x1025 = x1021 & x1024
val x1026 = x1025 > 0
val x1040 = {
def x1040thenb(): Unit = {
val x1027 = x991
val x1028 = x1027 + 1.0f
x991 = x1028
()
}
def x1040elseb(): Unit = {
val x1031 = x995
val x1032 = x1031 - 1
x995 = x1032
val x1034 = x995
val x1035 = x1034 <= 0
val x1038 = {
def x1038thenb(): Unit = {
x997 = false
()
}
def x1038elseb(): Unit = {
()
}
if (x1035) {
x1038thenb()
} else {
x1038elseb()
}
}
x1038
}
if (x1026) {
x1040thenb()
} else {
x1040elseb()
}
}
x1040
}
if (x1014) {
x1042thenb()
} else {
x1042elseb()
}
}
val x1043 = x996 += 1
()
}
val x1046 = x997
val x1047 = !x1046
val x1052 = {
def x1052thenb(): Float = {
0.819999f
}
def x1052elseb(): Float = {
val x1048 = x991
val x1049 = x1048 / x986
val x1050 = x1049.asInstanceOf[Float]
x1050
}
if (x1047) {
x1052thenb()
} else {
x1052elseb()
}
}
x1052
}
if (x990) {
x1054thenb()
} else {
x1054elseb()
}
}
x1054
}
if (x987) {
x1056thenb()
} else {
x1056elseb()
}
}
x1056
}
if (x983) {
x1058thenb()
} else {
x1058elseb()
}
}
val x1059 = x1058 > 0.82f
val x1078 = {
def x1078thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1060 = x980.rect
val x1062 = x1060.width
val x902 = x891
val x903 = Math.pow(2.0,x902)
val x904 = x903.asInstanceOf[Int]
val x1061 = x904 * x901
val x1063 = x1062 / 2
val x1064 = x1061 - x1063
val x1065 = x1064.asInstanceOf[Int]
val x1067 = x1060.height
val x1066 = x904 * x897
val x1068 = x1067 / 2
val x1069 = x1066 - x1068
val x1070 = x1069.asInstanceOf[Int]
val x1071 = new generated.scala.Rect(x1065,x1070,x1062,x1067)
val x1072 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1073 = new generated.scala.BiGGDetection(x884,x1058,x1071,null,x979,x901,x897,x980,x908)
val x1074 = x1072(0) = x1073
x1072
}
def x1078elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1076 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1076
}
if (x1059) {
x1078thenb()
} else {
x1078elseb()
}
}
x1078
}
var mapReduceIdx = 1
while (mapReduceIdx < x978.size) { // begin mapReduce loop x1108
val x979 = x978.dcApply(mapReduceIdx)
val x1081 = {
val x980 = x885(x979)
val x981 = x980.radius
val x983 = x981 != x982
val x1058 = {
def x1058thenb(): Float = {
-1.0f
}
def x1058elseb(): Float = {
val x984 = x980.match_list
val x985 = x984.length
val x986 = x985.asInstanceOf[Float]
val x987 = x986==0.0
val x1056 = {
def x1056thenb(): Float = {
-1.0f
}
def x1056elseb(): Float = {
val x988 = x964.asInstanceOf[Float]
val x989 = x988 / x986
val x990 = x989 < 0.82f
val x1054 = {
def x1054thenb(): Float = {
x989
}
def x1054elseb(): Float = {
var x991: Float = 0.0f
val x992 = x986 * 0.18f
val x993 = x992 + 0.5f
val x994 = x993.asInstanceOf[Int]
var x995: Int = x994
var x996: Int = 0
var x997: Boolean = true
val x1005 = x980.binary_gradients
val x1045 = while ({val x998 = x996
val x1000 = x997
val x999 = x998 < x985
val x1001 = x999 && x1000
x1001}) {
val x1003 = x996
val x1006 = x996
val x1010 = x996
val x1007 = x984(x1006)
val x1008 = x1005(x1007)
val x1009 = x1008==0
val x1011 = x984(x1010)
val x1012 = x950(x1011)
val x1013 = x1012==0
val x1014 = x1009 && x1013
val x1042 = {
def x1042thenb(): Unit = {
val x1015 = x991
val x1016 = x1015 + 1.0f
x991 = x1016
()
}
def x1042elseb(): Unit = {
val x1019 = x996
val x1022 = x996
val x1020 = x984(x1019)
val x1021 = x1005(x1020)
val x1023 = x984(x1022)
val x1024 = x950(x1023)
val x1025 = x1021 & x1024
val x1026 = x1025 > 0
val x1040 = {
def x1040thenb(): Unit = {
val x1027 = x991
val x1028 = x1027 + 1.0f
x991 = x1028
()
}
def x1040elseb(): Unit = {
val x1031 = x995
val x1032 = x1031 - 1
x995 = x1032
val x1034 = x995
val x1035 = x1034 <= 0
val x1038 = {
def x1038thenb(): Unit = {
x997 = false
()
}
def x1038elseb(): Unit = {
()
}
if (x1035) {
x1038thenb()
} else {
x1038elseb()
}
}
x1038
}
if (x1026) {
x1040thenb()
} else {
x1040elseb()
}
}
x1040
}
if (x1014) {
x1042thenb()
} else {
x1042elseb()
}
}
val x1043 = x996 += 1
()
}
val x1046 = x997
val x1047 = !x1046
val x1052 = {
def x1052thenb(): Float = {
0.819999f
}
def x1052elseb(): Float = {
val x1048 = x991
val x1049 = x1048 / x986
val x1050 = x1049.asInstanceOf[Float]
x1050
}
if (x1047) {
x1052thenb()
} else {
x1052elseb()
}
}
x1052
}
if (x990) {
x1054thenb()
} else {
x1054elseb()
}
}
x1054
}
if (x987) {
x1056thenb()
} else {
x1056elseb()
}
}
x1056
}
if (x983) {
x1058thenb()
} else {
x1058elseb()
}
}
val x1059 = x1058 > 0.82f
val x1078 = {
def x1078thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1060 = x980.rect
val x1062 = x1060.width
val x902 = x891
val x903 = Math.pow(2.0,x902)
val x904 = x903.asInstanceOf[Int]
val x1061 = x904 * x901
val x1063 = x1062 / 2
val x1064 = x1061 - x1063
val x1065 = x1064.asInstanceOf[Int]
val x1067 = x1060.height
val x1066 = x904 * x897
val x1068 = x1067 / 2
val x1069 = x1066 - x1068
val x1070 = x1069.asInstanceOf[Int]
val x1071 = new generated.scala.Rect(x1065,x1070,x1062,x1067)
val x1072 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1073 = new generated.scala.BiGGDetection(x884,x1058,x1071,null,x979,x901,x897,x980,x908)
val x1074 = x1072(0) = x1073
x1072
}
def x1078elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1076 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1076
}
if (x1059) {
x1078thenb()
} else {
x1078elseb()
}
}
x1078
}
x1080 = {
val x1082 = x1080.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1107 = { 
val x1105 = {
def x1105thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1081
}
def x1105elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1083 = x1081.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1103 = {
def x1103thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1080
}
def x1103elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1084 = x1080.length
val x1085 = x1081.length
val x1086 = x1084 + x1085
val x1087 = x1080.isRow
val x1088 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1086,x1087)
var x1090 : Int = 0
val x1094 = while (x1090 < x1084) {
val x1091 = x1080(x1090)
val x1092 = x1088(x1090) = x1091
x1092
x1090 = x1090 + 1
}
var x1096 : Int = 0
val x1101 = while (x1096 < x1085) {
val x1097 = x1096 + x1084
val x1098 = x1081(x1096)
val x1099 = x1088(x1097) = x1098
x1099
x1096 = x1096 + 1
}
x1088
}
if (x1083) {
x1103thenb()
} else {
x1103elseb()
}
}
x1103
}
if (x1082) {
x1105thenb()
} else {
x1105elseb()
}
}
x1105
}
x1107
}
mapReduceIdx += 1
} // end mapReduce loop x1108
x1080
}
val x1108 = x1108_block
x1108
}
x1110 = {
val x1112 = x1110.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1137 = { 
val x1135 = {
def x1135thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1111
}
def x1135elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1113 = x1111.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1133 = {
def x1133thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1110
}
def x1133elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1114 = x1110.length
val x1115 = x1111.length
val x1116 = x1114 + x1115
val x1117 = x1110.isRow
val x1118 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1116,x1117)
var x1120 : Int = 0
val x1124 = while (x1120 < x1114) {
val x1121 = x1110(x1120)
val x1122 = x1118(x1120) = x1121
x1122
x1120 = x1120 + 1
}
var x1126 : Int = 0
val x1131 = while (x1126 < x1115) {
val x1127 = x1126 + x1114
val x1128 = x1111(x1126)
val x1129 = x1118(x1127) = x1128
x1129
x1126 = x1126 + 1
}
x1118
}
if (x1113) {
x1133thenb()
} else {
x1133elseb()
}
}
x1133
}
if (x1112) {
x1135thenb()
} else {
x1135elseb()
}
}
x1135
}
x1137
}
mapReduceIdx += 1
} // end mapReduce loop x1138
x1110
}
val x1138 = x1138_block
x1138
}
x1139 = {
val x1141 = x1139.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1166 = { 
val x1164 = {
def x1164thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1140
}
def x1164elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1142 = x1140.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1162 = {
def x1162thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1139
}
def x1162elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1143 = x1139.length
val x1144 = x1140.length
val x1145 = x1143 + x1144
val x1146 = x1139.isRow
val x1147 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1145,x1146)
var x1149 : Int = 0
val x1153 = while (x1149 < x1143) {
val x1150 = x1139(x1149)
val x1151 = x1147(x1149) = x1150
x1151
x1149 = x1149 + 1
}
var x1155 : Int = 0
val x1160 = while (x1155 < x1144) {
val x1156 = x1155 + x1143
val x1157 = x1140(x1155)
val x1158 = x1147(x1156) = x1157
x1158
x1155 = x1155 + 1
}
x1147
}
if (x1142) {
x1162thenb()
} else {
x1162elseb()
}
}
x1162
}
if (x1141) {
x1164thenb()
} else {
x1164elseb()
}
}
x1164
}
x1166
}
mapReduceIdx += 1
} // end mapReduce loop x1167
x1139
}
val x1167 = x1167_block
val x1168 = x1167.length
val x1169 = "Detections: "+x1168
val x1170 = println(x1169)
x1167
}
var mapReduceIdx = 1
while (mapReduceIdx < x229.size) { // begin mapReduce loop x1200
val x883 = x229.dcApply(mapReduceIdx)
val x1173 = {
val x884 = x883._1
val x886 = "Name: "+x884
val x887 = println(x886)
val x885 = x883._2
val x888 = x885.length
val x889 = "Templates: "+x888
val x890 = println(x889)
val x978 = new generated.scala.IndexVectorRangeImpl(0,x888)
def x1167_block = {
val x897 = x896.dcApply(0)
var x1139 = {
val x920 = x897 - 15
val x921 = x920 < 0
val x925 = {
def x925thenb(): scala.Tuple2[Int, Int] = {
val x922 = 15 - x897
val x923 = (0,x922)
x923
}
def x925elseb(): scala.Tuple2[Int, Int] = {
val x924 = (x920,0)
x924
}
if (x921) {
x925thenb()
} else {
x925elseb()
}
}
val x926 = x925._1
val x928 = x897 + 15
val x929 = x928 > x894
val x930 = {
def x930thenb(): Int = {
x894
}
def x930elseb(): Int = {
x928
}
if (x929) {
x930thenb()
} else {
x930elseb()
}
}
val x927 = x925._2
def x1138_block = {
val x901 = x900.dcApply(0)
var x1110 = {
val x905 = new generated.scala.IntVectorImpl(900,false)
val x906 = new generated.scala.IntVectorImpl(0,true)
val x907 = new generated.scala.IndexVectorSeqImpl(x906)
val x908 = new generated.scala.BinarizedGradientTemplate(15,null,null,x891,x905,x907,null,null,null)
var x931: Int = x926
val x909 = x901 - 15
val x910 = x909 < 0
val x914 = {
def x914thenb(): scala.Tuple2[Int, Int] = {
val x911 = 15 - x901
val x912 = (0,x911)
x912
}
def x914elseb(): scala.Tuple2[Int, Int] = {
val x913 = (x909,0)
x913
}
if (x910) {
x914thenb()
} else {
x914elseb()
}
}
val x915 = x914._1
val x917 = x901 + 15
val x918 = x917 > x898
val x919 = {
def x919thenb(): Int = {
x898
}
def x919elseb(): Int = {
x917
}
if (x918) {
x919thenb()
} else {
x919elseb()
}
}
val x916 = x914._2
val x950 = x908.binary_gradients
val x963 = x908.match_list
val x964 = x963.length
val x973 = while ({val x932 = x931
val x933 = x932 < x930
x933}) {
val x935 = x931
var x937: Int = x915
val x953 = x935 * x898
val x970 = while ({val x938 = x937
val x939 = x938 < x919
x939}) {
val x941 = x931
val x945 = x937
val x942 = x927 + x941
val x943 = x942 - x926
val x944 = x943 * 30
val x946 = x916 + x945
val x947 = x946 - x915
val x948 = x944 + x947
var x949: Int = x948
val x951 = x949
val x952 = x937
val x954 = x953 + x952
val x955 = x893.dcApply(x954)
val x956 = { 
x955
}
val x957 = x950(x951) = x956
val x958 = x937
val x959 = x953 + x958
val x960 = x893.dcApply(x959)
val x961 = { 
x960
}
val x962 = x961 > 0
val x967 = {
def x967thenb(): Unit = {
val x965 = x963.insert(x964, x951)
x965
}
def x967elseb(): Unit = {
()
}
if (x962) {
x967thenb()
} else {
x967elseb()
}
}
val x968 = x937 += 1
()
}
val x971 = x931 += 1
()
}
val x974 = x964 < 0
val x977 = {
def x977thenb(): Unit = {
val x975 = println("dummy")
x975
}
def x977elseb(): Unit = {
()
}
if (x974) {
x977thenb()
} else {
x977elseb()
}
}
val x982 = x908.radius
def x1108_block = {
val x979 = x978.dcApply(0)
var x1080 = {
val x980 = x885(x979)
val x981 = x980.radius
val x983 = x981 != x982
val x1058 = {
def x1058thenb(): Float = {
-1.0f
}
def x1058elseb(): Float = {
val x984 = x980.match_list
val x985 = x984.length
val x986 = x985.asInstanceOf[Float]
val x987 = x986==0.0
val x1056 = {
def x1056thenb(): Float = {
-1.0f
}
def x1056elseb(): Float = {
val x988 = x964.asInstanceOf[Float]
val x989 = x988 / x986
val x990 = x989 < 0.82f
val x1054 = {
def x1054thenb(): Float = {
x989
}
def x1054elseb(): Float = {
var x991: Float = 0.0f
val x992 = x986 * 0.18f
val x993 = x992 + 0.5f
val x994 = x993.asInstanceOf[Int]
var x995: Int = x994
var x996: Int = 0
var x997: Boolean = true
val x1005 = x980.binary_gradients
val x1045 = while ({val x998 = x996
val x1000 = x997
val x999 = x998 < x985
val x1001 = x999 && x1000
x1001}) {
val x1003 = x996
val x1006 = x996
val x1010 = x996
val x1007 = x984(x1006)
val x1008 = x1005(x1007)
val x1009 = x1008==0
val x1011 = x984(x1010)
val x1012 = x950(x1011)
val x1013 = x1012==0
val x1014 = x1009 && x1013
val x1042 = {
def x1042thenb(): Unit = {
val x1015 = x991
val x1016 = x1015 + 1.0f
x991 = x1016
()
}
def x1042elseb(): Unit = {
val x1019 = x996
val x1022 = x996
val x1020 = x984(x1019)
val x1021 = x1005(x1020)
val x1023 = x984(x1022)
val x1024 = x950(x1023)
val x1025 = x1021 & x1024
val x1026 = x1025 > 0
val x1040 = {
def x1040thenb(): Unit = {
val x1027 = x991
val x1028 = x1027 + 1.0f
x991 = x1028
()
}
def x1040elseb(): Unit = {
val x1031 = x995
val x1032 = x1031 - 1
x995 = x1032
val x1034 = x995
val x1035 = x1034 <= 0
val x1038 = {
def x1038thenb(): Unit = {
x997 = false
()
}
def x1038elseb(): Unit = {
()
}
if (x1035) {
x1038thenb()
} else {
x1038elseb()
}
}
x1038
}
if (x1026) {
x1040thenb()
} else {
x1040elseb()
}
}
x1040
}
if (x1014) {
x1042thenb()
} else {
x1042elseb()
}
}
val x1043 = x996 += 1
()
}
val x1046 = x997
val x1047 = !x1046
val x1052 = {
def x1052thenb(): Float = {
0.819999f
}
def x1052elseb(): Float = {
val x1048 = x991
val x1049 = x1048 / x986
val x1050 = x1049.asInstanceOf[Float]
x1050
}
if (x1047) {
x1052thenb()
} else {
x1052elseb()
}
}
x1052
}
if (x990) {
x1054thenb()
} else {
x1054elseb()
}
}
x1054
}
if (x987) {
x1056thenb()
} else {
x1056elseb()
}
}
x1056
}
if (x983) {
x1058thenb()
} else {
x1058elseb()
}
}
val x1059 = x1058 > 0.82f
val x1078 = {
def x1078thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1060 = x980.rect
val x1062 = x1060.width
val x902 = x891
val x903 = Math.pow(2.0,x902)
val x904 = x903.asInstanceOf[Int]
val x1061 = x904 * x901
val x1063 = x1062 / 2
val x1064 = x1061 - x1063
val x1065 = x1064.asInstanceOf[Int]
val x1067 = x1060.height
val x1066 = x904 * x897
val x1068 = x1067 / 2
val x1069 = x1066 - x1068
val x1070 = x1069.asInstanceOf[Int]
val x1071 = new generated.scala.Rect(x1065,x1070,x1062,x1067)
val x1072 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1073 = new generated.scala.BiGGDetection(x884,x1058,x1071,null,x979,x901,x897,x980,x908)
val x1074 = x1072(0) = x1073
x1072
}
def x1078elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1076 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1076
}
if (x1059) {
x1078thenb()
} else {
x1078elseb()
}
}
x1078
}
var mapReduceIdx = 1
while (mapReduceIdx < x978.size) { // begin mapReduce loop x1108
val x979 = x978.dcApply(mapReduceIdx)
val x1081 = {
val x980 = x885(x979)
val x981 = x980.radius
val x983 = x981 != x982
val x1058 = {
def x1058thenb(): Float = {
-1.0f
}
def x1058elseb(): Float = {
val x984 = x980.match_list
val x985 = x984.length
val x986 = x985.asInstanceOf[Float]
val x987 = x986==0.0
val x1056 = {
def x1056thenb(): Float = {
-1.0f
}
def x1056elseb(): Float = {
val x988 = x964.asInstanceOf[Float]
val x989 = x988 / x986
val x990 = x989 < 0.82f
val x1054 = {
def x1054thenb(): Float = {
x989
}
def x1054elseb(): Float = {
var x991: Float = 0.0f
val x992 = x986 * 0.18f
val x993 = x992 + 0.5f
val x994 = x993.asInstanceOf[Int]
var x995: Int = x994
var x996: Int = 0
var x997: Boolean = true
val x1005 = x980.binary_gradients
val x1045 = while ({val x998 = x996
val x1000 = x997
val x999 = x998 < x985
val x1001 = x999 && x1000
x1001}) {
val x1003 = x996
val x1006 = x996
val x1010 = x996
val x1007 = x984(x1006)
val x1008 = x1005(x1007)
val x1009 = x1008==0
val x1011 = x984(x1010)
val x1012 = x950(x1011)
val x1013 = x1012==0
val x1014 = x1009 && x1013
val x1042 = {
def x1042thenb(): Unit = {
val x1015 = x991
val x1016 = x1015 + 1.0f
x991 = x1016
()
}
def x1042elseb(): Unit = {
val x1019 = x996
val x1022 = x996
val x1020 = x984(x1019)
val x1021 = x1005(x1020)
val x1023 = x984(x1022)
val x1024 = x950(x1023)
val x1025 = x1021 & x1024
val x1026 = x1025 > 0
val x1040 = {
def x1040thenb(): Unit = {
val x1027 = x991
val x1028 = x1027 + 1.0f
x991 = x1028
()
}
def x1040elseb(): Unit = {
val x1031 = x995
val x1032 = x1031 - 1
x995 = x1032
val x1034 = x995
val x1035 = x1034 <= 0
val x1038 = {
def x1038thenb(): Unit = {
x997 = false
()
}
def x1038elseb(): Unit = {
()
}
if (x1035) {
x1038thenb()
} else {
x1038elseb()
}
}
x1038
}
if (x1026) {
x1040thenb()
} else {
x1040elseb()
}
}
x1040
}
if (x1014) {
x1042thenb()
} else {
x1042elseb()
}
}
val x1043 = x996 += 1
()
}
val x1046 = x997
val x1047 = !x1046
val x1052 = {
def x1052thenb(): Float = {
0.819999f
}
def x1052elseb(): Float = {
val x1048 = x991
val x1049 = x1048 / x986
val x1050 = x1049.asInstanceOf[Float]
x1050
}
if (x1047) {
x1052thenb()
} else {
x1052elseb()
}
}
x1052
}
if (x990) {
x1054thenb()
} else {
x1054elseb()
}
}
x1054
}
if (x987) {
x1056thenb()
} else {
x1056elseb()
}
}
x1056
}
if (x983) {
x1058thenb()
} else {
x1058elseb()
}
}
val x1059 = x1058 > 0.82f
val x1078 = {
def x1078thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1060 = x980.rect
val x1062 = x1060.width
val x902 = x891
val x903 = Math.pow(2.0,x902)
val x904 = x903.asInstanceOf[Int]
val x1061 = x904 * x901
val x1063 = x1062 / 2
val x1064 = x1061 - x1063
val x1065 = x1064.asInstanceOf[Int]
val x1067 = x1060.height
val x1066 = x904 * x897
val x1068 = x1067 / 2
val x1069 = x1066 - x1068
val x1070 = x1069.asInstanceOf[Int]
val x1071 = new generated.scala.Rect(x1065,x1070,x1062,x1067)
val x1072 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1073 = new generated.scala.BiGGDetection(x884,x1058,x1071,null,x979,x901,x897,x980,x908)
val x1074 = x1072(0) = x1073
x1072
}
def x1078elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1076 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1076
}
if (x1059) {
x1078thenb()
} else {
x1078elseb()
}
}
x1078
}
x1080 = {
val x1082 = x1080.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1107 = { 
val x1105 = {
def x1105thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1081
}
def x1105elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1083 = x1081.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1103 = {
def x1103thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1080
}
def x1103elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1084 = x1080.length
val x1085 = x1081.length
val x1086 = x1084 + x1085
val x1087 = x1080.isRow
val x1088 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1086,x1087)
var x1090 : Int = 0
val x1094 = while (x1090 < x1084) {
val x1091 = x1080(x1090)
val x1092 = x1088(x1090) = x1091
x1092
x1090 = x1090 + 1
}
var x1096 : Int = 0
val x1101 = while (x1096 < x1085) {
val x1097 = x1096 + x1084
val x1098 = x1081(x1096)
val x1099 = x1088(x1097) = x1098
x1099
x1096 = x1096 + 1
}
x1088
}
if (x1083) {
x1103thenb()
} else {
x1103elseb()
}
}
x1103
}
if (x1082) {
x1105thenb()
} else {
x1105elseb()
}
}
x1105
}
x1107
}
mapReduceIdx += 1
} // end mapReduce loop x1108
x1080
}
val x1108 = x1108_block
x1108
}
var mapReduceIdx = 1
while (mapReduceIdx < x900.size) { // begin mapReduce loop x1138
val x901 = x900.dcApply(mapReduceIdx)
val x1111 = {
val x905 = new generated.scala.IntVectorImpl(900,false)
val x906 = new generated.scala.IntVectorImpl(0,true)
val x907 = new generated.scala.IndexVectorSeqImpl(x906)
val x908 = new generated.scala.BinarizedGradientTemplate(15,null,null,x891,x905,x907,null,null,null)
var x931: Int = x926
val x909 = x901 - 15
val x910 = x909 < 0
val x914 = {
def x914thenb(): scala.Tuple2[Int, Int] = {
val x911 = 15 - x901
val x912 = (0,x911)
x912
}
def x914elseb(): scala.Tuple2[Int, Int] = {
val x913 = (x909,0)
x913
}
if (x910) {
x914thenb()
} else {
x914elseb()
}
}
val x915 = x914._1
val x917 = x901 + 15
val x918 = x917 > x898
val x919 = {
def x919thenb(): Int = {
x898
}
def x919elseb(): Int = {
x917
}
if (x918) {
x919thenb()
} else {
x919elseb()
}
}
val x916 = x914._2
val x950 = x908.binary_gradients
val x963 = x908.match_list
val x964 = x963.length
val x973 = while ({val x932 = x931
val x933 = x932 < x930
x933}) {
val x935 = x931
var x937: Int = x915
val x953 = x935 * x898
val x970 = while ({val x938 = x937
val x939 = x938 < x919
x939}) {
val x941 = x931
val x945 = x937
val x942 = x927 + x941
val x943 = x942 - x926
val x944 = x943 * 30
val x946 = x916 + x945
val x947 = x946 - x915
val x948 = x944 + x947
var x949: Int = x948
val x951 = x949
val x952 = x937
val x954 = x953 + x952
val x955 = x893.dcApply(x954)
val x956 = { 
x955
}
val x957 = x950(x951) = x956
val x958 = x937
val x959 = x953 + x958
val x960 = x893.dcApply(x959)
val x961 = { 
x960
}
val x962 = x961 > 0
val x967 = {
def x967thenb(): Unit = {
val x965 = x963.insert(x964, x951)
x965
}
def x967elseb(): Unit = {
()
}
if (x962) {
x967thenb()
} else {
x967elseb()
}
}
val x968 = x937 += 1
()
}
val x971 = x931 += 1
()
}
val x974 = x964 < 0
val x977 = {
def x977thenb(): Unit = {
val x975 = println("dummy")
x975
}
def x977elseb(): Unit = {
()
}
if (x974) {
x977thenb()
} else {
x977elseb()
}
}
val x982 = x908.radius
def x1108_block = {
val x979 = x978.dcApply(0)
var x1080 = {
val x980 = x885(x979)
val x981 = x980.radius
val x983 = x981 != x982
val x1058 = {
def x1058thenb(): Float = {
-1.0f
}
def x1058elseb(): Float = {
val x984 = x980.match_list
val x985 = x984.length
val x986 = x985.asInstanceOf[Float]
val x987 = x986==0.0
val x1056 = {
def x1056thenb(): Float = {
-1.0f
}
def x1056elseb(): Float = {
val x988 = x964.asInstanceOf[Float]
val x989 = x988 / x986
val x990 = x989 < 0.82f
val x1054 = {
def x1054thenb(): Float = {
x989
}
def x1054elseb(): Float = {
var x991: Float = 0.0f
val x992 = x986 * 0.18f
val x993 = x992 + 0.5f
val x994 = x993.asInstanceOf[Int]
var x995: Int = x994
var x996: Int = 0
var x997: Boolean = true
val x1005 = x980.binary_gradients
val x1045 = while ({val x998 = x996
val x1000 = x997
val x999 = x998 < x985
val x1001 = x999 && x1000
x1001}) {
val x1003 = x996
val x1006 = x996
val x1010 = x996
val x1007 = x984(x1006)
val x1008 = x1005(x1007)
val x1009 = x1008==0
val x1011 = x984(x1010)
val x1012 = x950(x1011)
val x1013 = x1012==0
val x1014 = x1009 && x1013
val x1042 = {
def x1042thenb(): Unit = {
val x1015 = x991
val x1016 = x1015 + 1.0f
x991 = x1016
()
}
def x1042elseb(): Unit = {
val x1019 = x996
val x1022 = x996
val x1020 = x984(x1019)
val x1021 = x1005(x1020)
val x1023 = x984(x1022)
val x1024 = x950(x1023)
val x1025 = x1021 & x1024
val x1026 = x1025 > 0
val x1040 = {
def x1040thenb(): Unit = {
val x1027 = x991
val x1028 = x1027 + 1.0f
x991 = x1028
()
}
def x1040elseb(): Unit = {
val x1031 = x995
val x1032 = x1031 - 1
x995 = x1032
val x1034 = x995
val x1035 = x1034 <= 0
val x1038 = {
def x1038thenb(): Unit = {
x997 = false
()
}
def x1038elseb(): Unit = {
()
}
if (x1035) {
x1038thenb()
} else {
x1038elseb()
}
}
x1038
}
if (x1026) {
x1040thenb()
} else {
x1040elseb()
}
}
x1040
}
if (x1014) {
x1042thenb()
} else {
x1042elseb()
}
}
val x1043 = x996 += 1
()
}
val x1046 = x997
val x1047 = !x1046
val x1052 = {
def x1052thenb(): Float = {
0.819999f
}
def x1052elseb(): Float = {
val x1048 = x991
val x1049 = x1048 / x986
val x1050 = x1049.asInstanceOf[Float]
x1050
}
if (x1047) {
x1052thenb()
} else {
x1052elseb()
}
}
x1052
}
if (x990) {
x1054thenb()
} else {
x1054elseb()
}
}
x1054
}
if (x987) {
x1056thenb()
} else {
x1056elseb()
}
}
x1056
}
if (x983) {
x1058thenb()
} else {
x1058elseb()
}
}
val x1059 = x1058 > 0.82f
val x1078 = {
def x1078thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1060 = x980.rect
val x1062 = x1060.width
val x902 = x891
val x903 = Math.pow(2.0,x902)
val x904 = x903.asInstanceOf[Int]
val x1061 = x904 * x901
val x1063 = x1062 / 2
val x1064 = x1061 - x1063
val x1065 = x1064.asInstanceOf[Int]
val x1067 = x1060.height
val x1066 = x904 * x897
val x1068 = x1067 / 2
val x1069 = x1066 - x1068
val x1070 = x1069.asInstanceOf[Int]
val x1071 = new generated.scala.Rect(x1065,x1070,x1062,x1067)
val x1072 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1073 = new generated.scala.BiGGDetection(x884,x1058,x1071,null,x979,x901,x897,x980,x908)
val x1074 = x1072(0) = x1073
x1072
}
def x1078elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1076 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1076
}
if (x1059) {
x1078thenb()
} else {
x1078elseb()
}
}
x1078
}
var mapReduceIdx = 1
while (mapReduceIdx < x978.size) { // begin mapReduce loop x1108
val x979 = x978.dcApply(mapReduceIdx)
val x1081 = {
val x980 = x885(x979)
val x981 = x980.radius
val x983 = x981 != x982
val x1058 = {
def x1058thenb(): Float = {
-1.0f
}
def x1058elseb(): Float = {
val x984 = x980.match_list
val x985 = x984.length
val x986 = x985.asInstanceOf[Float]
val x987 = x986==0.0
val x1056 = {
def x1056thenb(): Float = {
-1.0f
}
def x1056elseb(): Float = {
val x988 = x964.asInstanceOf[Float]
val x989 = x988 / x986
val x990 = x989 < 0.82f
val x1054 = {
def x1054thenb(): Float = {
x989
}
def x1054elseb(): Float = {
var x991: Float = 0.0f
val x992 = x986 * 0.18f
val x993 = x992 + 0.5f
val x994 = x993.asInstanceOf[Int]
var x995: Int = x994
var x996: Int = 0
var x997: Boolean = true
val x1005 = x980.binary_gradients
val x1045 = while ({val x998 = x996
val x1000 = x997
val x999 = x998 < x985
val x1001 = x999 && x1000
x1001}) {
val x1003 = x996
val x1006 = x996
val x1010 = x996
val x1007 = x984(x1006)
val x1008 = x1005(x1007)
val x1009 = x1008==0
val x1011 = x984(x1010)
val x1012 = x950(x1011)
val x1013 = x1012==0
val x1014 = x1009 && x1013
val x1042 = {
def x1042thenb(): Unit = {
val x1015 = x991
val x1016 = x1015 + 1.0f
x991 = x1016
()
}
def x1042elseb(): Unit = {
val x1019 = x996
val x1022 = x996
val x1020 = x984(x1019)
val x1021 = x1005(x1020)
val x1023 = x984(x1022)
val x1024 = x950(x1023)
val x1025 = x1021 & x1024
val x1026 = x1025 > 0
val x1040 = {
def x1040thenb(): Unit = {
val x1027 = x991
val x1028 = x1027 + 1.0f
x991 = x1028
()
}
def x1040elseb(): Unit = {
val x1031 = x995
val x1032 = x1031 - 1
x995 = x1032
val x1034 = x995
val x1035 = x1034 <= 0
val x1038 = {
def x1038thenb(): Unit = {
x997 = false
()
}
def x1038elseb(): Unit = {
()
}
if (x1035) {
x1038thenb()
} else {
x1038elseb()
}
}
x1038
}
if (x1026) {
x1040thenb()
} else {
x1040elseb()
}
}
x1040
}
if (x1014) {
x1042thenb()
} else {
x1042elseb()
}
}
val x1043 = x996 += 1
()
}
val x1046 = x997
val x1047 = !x1046
val x1052 = {
def x1052thenb(): Float = {
0.819999f
}
def x1052elseb(): Float = {
val x1048 = x991
val x1049 = x1048 / x986
val x1050 = x1049.asInstanceOf[Float]
x1050
}
if (x1047) {
x1052thenb()
} else {
x1052elseb()
}
}
x1052
}
if (x990) {
x1054thenb()
} else {
x1054elseb()
}
}
x1054
}
if (x987) {
x1056thenb()
} else {
x1056elseb()
}
}
x1056
}
if (x983) {
x1058thenb()
} else {
x1058elseb()
}
}
val x1059 = x1058 > 0.82f
val x1078 = {
def x1078thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1060 = x980.rect
val x1062 = x1060.width
val x902 = x891
val x903 = Math.pow(2.0,x902)
val x904 = x903.asInstanceOf[Int]
val x1061 = x904 * x901
val x1063 = x1062 / 2
val x1064 = x1061 - x1063
val x1065 = x1064.asInstanceOf[Int]
val x1067 = x1060.height
val x1066 = x904 * x897
val x1068 = x1067 / 2
val x1069 = x1066 - x1068
val x1070 = x1069.asInstanceOf[Int]
val x1071 = new generated.scala.Rect(x1065,x1070,x1062,x1067)
val x1072 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1073 = new generated.scala.BiGGDetection(x884,x1058,x1071,null,x979,x901,x897,x980,x908)
val x1074 = x1072(0) = x1073
x1072
}
def x1078elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1076 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1076
}
if (x1059) {
x1078thenb()
} else {
x1078elseb()
}
}
x1078
}
x1080 = {
val x1082 = x1080.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1107 = { 
val x1105 = {
def x1105thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1081
}
def x1105elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1083 = x1081.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1103 = {
def x1103thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1080
}
def x1103elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1084 = x1080.length
val x1085 = x1081.length
val x1086 = x1084 + x1085
val x1087 = x1080.isRow
val x1088 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1086,x1087)
var x1090 : Int = 0
val x1094 = while (x1090 < x1084) {
val x1091 = x1080(x1090)
val x1092 = x1088(x1090) = x1091
x1092
x1090 = x1090 + 1
}
var x1096 : Int = 0
val x1101 = while (x1096 < x1085) {
val x1097 = x1096 + x1084
val x1098 = x1081(x1096)
val x1099 = x1088(x1097) = x1098
x1099
x1096 = x1096 + 1
}
x1088
}
if (x1083) {
x1103thenb()
} else {
x1103elseb()
}
}
x1103
}
if (x1082) {
x1105thenb()
} else {
x1105elseb()
}
}
x1105
}
x1107
}
mapReduceIdx += 1
} // end mapReduce loop x1108
x1080
}
val x1108 = x1108_block
x1108
}
x1110 = {
val x1112 = x1110.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1137 = { 
val x1135 = {
def x1135thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1111
}
def x1135elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1113 = x1111.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1133 = {
def x1133thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1110
}
def x1133elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1114 = x1110.length
val x1115 = x1111.length
val x1116 = x1114 + x1115
val x1117 = x1110.isRow
val x1118 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1116,x1117)
var x1120 : Int = 0
val x1124 = while (x1120 < x1114) {
val x1121 = x1110(x1120)
val x1122 = x1118(x1120) = x1121
x1122
x1120 = x1120 + 1
}
var x1126 : Int = 0
val x1131 = while (x1126 < x1115) {
val x1127 = x1126 + x1114
val x1128 = x1111(x1126)
val x1129 = x1118(x1127) = x1128
x1129
x1126 = x1126 + 1
}
x1118
}
if (x1113) {
x1133thenb()
} else {
x1133elseb()
}
}
x1133
}
if (x1112) {
x1135thenb()
} else {
x1135elseb()
}
}
x1135
}
x1137
}
mapReduceIdx += 1
} // end mapReduce loop x1138
x1110
}
val x1138 = x1138_block
x1138
}
var mapReduceIdx = 1
while (mapReduceIdx < x896.size) { // begin mapReduce loop x1167
val x897 = x896.dcApply(mapReduceIdx)
val x1140 = {
val x920 = x897 - 15
val x921 = x920 < 0
val x925 = {
def x925thenb(): scala.Tuple2[Int, Int] = {
val x922 = 15 - x897
val x923 = (0,x922)
x923
}
def x925elseb(): scala.Tuple2[Int, Int] = {
val x924 = (x920,0)
x924
}
if (x921) {
x925thenb()
} else {
x925elseb()
}
}
val x926 = x925._1
val x928 = x897 + 15
val x929 = x928 > x894
val x930 = {
def x930thenb(): Int = {
x894
}
def x930elseb(): Int = {
x928
}
if (x929) {
x930thenb()
} else {
x930elseb()
}
}
val x927 = x925._2
def x1138_block = {
val x901 = x900.dcApply(0)
var x1110 = {
val x905 = new generated.scala.IntVectorImpl(900,false)
val x906 = new generated.scala.IntVectorImpl(0,true)
val x907 = new generated.scala.IndexVectorSeqImpl(x906)
val x908 = new generated.scala.BinarizedGradientTemplate(15,null,null,x891,x905,x907,null,null,null)
var x931: Int = x926
val x909 = x901 - 15
val x910 = x909 < 0
val x914 = {
def x914thenb(): scala.Tuple2[Int, Int] = {
val x911 = 15 - x901
val x912 = (0,x911)
x912
}
def x914elseb(): scala.Tuple2[Int, Int] = {
val x913 = (x909,0)
x913
}
if (x910) {
x914thenb()
} else {
x914elseb()
}
}
val x915 = x914._1
val x917 = x901 + 15
val x918 = x917 > x898
val x919 = {
def x919thenb(): Int = {
x898
}
def x919elseb(): Int = {
x917
}
if (x918) {
x919thenb()
} else {
x919elseb()
}
}
val x916 = x914._2
val x950 = x908.binary_gradients
val x963 = x908.match_list
val x964 = x963.length
val x973 = while ({val x932 = x931
val x933 = x932 < x930
x933}) {
val x935 = x931
var x937: Int = x915
val x953 = x935 * x898
val x970 = while ({val x938 = x937
val x939 = x938 < x919
x939}) {
val x941 = x931
val x945 = x937
val x942 = x927 + x941
val x943 = x942 - x926
val x944 = x943 * 30
val x946 = x916 + x945
val x947 = x946 - x915
val x948 = x944 + x947
var x949: Int = x948
val x951 = x949
val x952 = x937
val x954 = x953 + x952
val x955 = x893.dcApply(x954)
val x956 = { 
x955
}
val x957 = x950(x951) = x956
val x958 = x937
val x959 = x953 + x958
val x960 = x893.dcApply(x959)
val x961 = { 
x960
}
val x962 = x961 > 0
val x967 = {
def x967thenb(): Unit = {
val x965 = x963.insert(x964, x951)
x965
}
def x967elseb(): Unit = {
()
}
if (x962) {
x967thenb()
} else {
x967elseb()
}
}
val x968 = x937 += 1
()
}
val x971 = x931 += 1
()
}
val x974 = x964 < 0
val x977 = {
def x977thenb(): Unit = {
val x975 = println("dummy")
x975
}
def x977elseb(): Unit = {
()
}
if (x974) {
x977thenb()
} else {
x977elseb()
}
}
val x982 = x908.radius
def x1108_block = {
val x979 = x978.dcApply(0)
var x1080 = {
val x980 = x885(x979)
val x981 = x980.radius
val x983 = x981 != x982
val x1058 = {
def x1058thenb(): Float = {
-1.0f
}
def x1058elseb(): Float = {
val x984 = x980.match_list
val x985 = x984.length
val x986 = x985.asInstanceOf[Float]
val x987 = x986==0.0
val x1056 = {
def x1056thenb(): Float = {
-1.0f
}
def x1056elseb(): Float = {
val x988 = x964.asInstanceOf[Float]
val x989 = x988 / x986
val x990 = x989 < 0.82f
val x1054 = {
def x1054thenb(): Float = {
x989
}
def x1054elseb(): Float = {
var x991: Float = 0.0f
val x992 = x986 * 0.18f
val x993 = x992 + 0.5f
val x994 = x993.asInstanceOf[Int]
var x995: Int = x994
var x996: Int = 0
var x997: Boolean = true
val x1005 = x980.binary_gradients
val x1045 = while ({val x998 = x996
val x1000 = x997
val x999 = x998 < x985
val x1001 = x999 && x1000
x1001}) {
val x1003 = x996
val x1006 = x996
val x1010 = x996
val x1007 = x984(x1006)
val x1008 = x1005(x1007)
val x1009 = x1008==0
val x1011 = x984(x1010)
val x1012 = x950(x1011)
val x1013 = x1012==0
val x1014 = x1009 && x1013
val x1042 = {
def x1042thenb(): Unit = {
val x1015 = x991
val x1016 = x1015 + 1.0f
x991 = x1016
()
}
def x1042elseb(): Unit = {
val x1019 = x996
val x1022 = x996
val x1020 = x984(x1019)
val x1021 = x1005(x1020)
val x1023 = x984(x1022)
val x1024 = x950(x1023)
val x1025 = x1021 & x1024
val x1026 = x1025 > 0
val x1040 = {
def x1040thenb(): Unit = {
val x1027 = x991
val x1028 = x1027 + 1.0f
x991 = x1028
()
}
def x1040elseb(): Unit = {
val x1031 = x995
val x1032 = x1031 - 1
x995 = x1032
val x1034 = x995
val x1035 = x1034 <= 0
val x1038 = {
def x1038thenb(): Unit = {
x997 = false
()
}
def x1038elseb(): Unit = {
()
}
if (x1035) {
x1038thenb()
} else {
x1038elseb()
}
}
x1038
}
if (x1026) {
x1040thenb()
} else {
x1040elseb()
}
}
x1040
}
if (x1014) {
x1042thenb()
} else {
x1042elseb()
}
}
val x1043 = x996 += 1
()
}
val x1046 = x997
val x1047 = !x1046
val x1052 = {
def x1052thenb(): Float = {
0.819999f
}
def x1052elseb(): Float = {
val x1048 = x991
val x1049 = x1048 / x986
val x1050 = x1049.asInstanceOf[Float]
x1050
}
if (x1047) {
x1052thenb()
} else {
x1052elseb()
}
}
x1052
}
if (x990) {
x1054thenb()
} else {
x1054elseb()
}
}
x1054
}
if (x987) {
x1056thenb()
} else {
x1056elseb()
}
}
x1056
}
if (x983) {
x1058thenb()
} else {
x1058elseb()
}
}
val x1059 = x1058 > 0.82f
val x1078 = {
def x1078thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1060 = x980.rect
val x1062 = x1060.width
val x902 = x891
val x903 = Math.pow(2.0,x902)
val x904 = x903.asInstanceOf[Int]
val x1061 = x904 * x901
val x1063 = x1062 / 2
val x1064 = x1061 - x1063
val x1065 = x1064.asInstanceOf[Int]
val x1067 = x1060.height
val x1066 = x904 * x897
val x1068 = x1067 / 2
val x1069 = x1066 - x1068
val x1070 = x1069.asInstanceOf[Int]
val x1071 = new generated.scala.Rect(x1065,x1070,x1062,x1067)
val x1072 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1073 = new generated.scala.BiGGDetection(x884,x1058,x1071,null,x979,x901,x897,x980,x908)
val x1074 = x1072(0) = x1073
x1072
}
def x1078elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1076 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1076
}
if (x1059) {
x1078thenb()
} else {
x1078elseb()
}
}
x1078
}
var mapReduceIdx = 1
while (mapReduceIdx < x978.size) { // begin mapReduce loop x1108
val x979 = x978.dcApply(mapReduceIdx)
val x1081 = {
val x980 = x885(x979)
val x981 = x980.radius
val x983 = x981 != x982
val x1058 = {
def x1058thenb(): Float = {
-1.0f
}
def x1058elseb(): Float = {
val x984 = x980.match_list
val x985 = x984.length
val x986 = x985.asInstanceOf[Float]
val x987 = x986==0.0
val x1056 = {
def x1056thenb(): Float = {
-1.0f
}
def x1056elseb(): Float = {
val x988 = x964.asInstanceOf[Float]
val x989 = x988 / x986
val x990 = x989 < 0.82f
val x1054 = {
def x1054thenb(): Float = {
x989
}
def x1054elseb(): Float = {
var x991: Float = 0.0f
val x992 = x986 * 0.18f
val x993 = x992 + 0.5f
val x994 = x993.asInstanceOf[Int]
var x995: Int = x994
var x996: Int = 0
var x997: Boolean = true
val x1005 = x980.binary_gradients
val x1045 = while ({val x998 = x996
val x1000 = x997
val x999 = x998 < x985
val x1001 = x999 && x1000
x1001}) {
val x1003 = x996
val x1006 = x996
val x1010 = x996
val x1007 = x984(x1006)
val x1008 = x1005(x1007)
val x1009 = x1008==0
val x1011 = x984(x1010)
val x1012 = x950(x1011)
val x1013 = x1012==0
val x1014 = x1009 && x1013
val x1042 = {
def x1042thenb(): Unit = {
val x1015 = x991
val x1016 = x1015 + 1.0f
x991 = x1016
()
}
def x1042elseb(): Unit = {
val x1019 = x996
val x1022 = x996
val x1020 = x984(x1019)
val x1021 = x1005(x1020)
val x1023 = x984(x1022)
val x1024 = x950(x1023)
val x1025 = x1021 & x1024
val x1026 = x1025 > 0
val x1040 = {
def x1040thenb(): Unit = {
val x1027 = x991
val x1028 = x1027 + 1.0f
x991 = x1028
()
}
def x1040elseb(): Unit = {
val x1031 = x995
val x1032 = x1031 - 1
x995 = x1032
val x1034 = x995
val x1035 = x1034 <= 0
val x1038 = {
def x1038thenb(): Unit = {
x997 = false
()
}
def x1038elseb(): Unit = {
()
}
if (x1035) {
x1038thenb()
} else {
x1038elseb()
}
}
x1038
}
if (x1026) {
x1040thenb()
} else {
x1040elseb()
}
}
x1040
}
if (x1014) {
x1042thenb()
} else {
x1042elseb()
}
}
val x1043 = x996 += 1
()
}
val x1046 = x997
val x1047 = !x1046
val x1052 = {
def x1052thenb(): Float = {
0.819999f
}
def x1052elseb(): Float = {
val x1048 = x991
val x1049 = x1048 / x986
val x1050 = x1049.asInstanceOf[Float]
x1050
}
if (x1047) {
x1052thenb()
} else {
x1052elseb()
}
}
x1052
}
if (x990) {
x1054thenb()
} else {
x1054elseb()
}
}
x1054
}
if (x987) {
x1056thenb()
} else {
x1056elseb()
}
}
x1056
}
if (x983) {
x1058thenb()
} else {
x1058elseb()
}
}
val x1059 = x1058 > 0.82f
val x1078 = {
def x1078thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1060 = x980.rect
val x1062 = x1060.width
val x902 = x891
val x903 = Math.pow(2.0,x902)
val x904 = x903.asInstanceOf[Int]
val x1061 = x904 * x901
val x1063 = x1062 / 2
val x1064 = x1061 - x1063
val x1065 = x1064.asInstanceOf[Int]
val x1067 = x1060.height
val x1066 = x904 * x897
val x1068 = x1067 / 2
val x1069 = x1066 - x1068
val x1070 = x1069.asInstanceOf[Int]
val x1071 = new generated.scala.Rect(x1065,x1070,x1062,x1067)
val x1072 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1073 = new generated.scala.BiGGDetection(x884,x1058,x1071,null,x979,x901,x897,x980,x908)
val x1074 = x1072(0) = x1073
x1072
}
def x1078elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1076 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1076
}
if (x1059) {
x1078thenb()
} else {
x1078elseb()
}
}
x1078
}
x1080 = {
val x1082 = x1080.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1107 = { 
val x1105 = {
def x1105thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1081
}
def x1105elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1083 = x1081.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1103 = {
def x1103thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1080
}
def x1103elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1084 = x1080.length
val x1085 = x1081.length
val x1086 = x1084 + x1085
val x1087 = x1080.isRow
val x1088 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1086,x1087)
var x1090 : Int = 0
val x1094 = while (x1090 < x1084) {
val x1091 = x1080(x1090)
val x1092 = x1088(x1090) = x1091
x1092
x1090 = x1090 + 1
}
var x1096 : Int = 0
val x1101 = while (x1096 < x1085) {
val x1097 = x1096 + x1084
val x1098 = x1081(x1096)
val x1099 = x1088(x1097) = x1098
x1099
x1096 = x1096 + 1
}
x1088
}
if (x1083) {
x1103thenb()
} else {
x1103elseb()
}
}
x1103
}
if (x1082) {
x1105thenb()
} else {
x1105elseb()
}
}
x1105
}
x1107
}
mapReduceIdx += 1
} // end mapReduce loop x1108
x1080
}
val x1108 = x1108_block
x1108
}
var mapReduceIdx = 1
while (mapReduceIdx < x900.size) { // begin mapReduce loop x1138
val x901 = x900.dcApply(mapReduceIdx)
val x1111 = {
val x905 = new generated.scala.IntVectorImpl(900,false)
val x906 = new generated.scala.IntVectorImpl(0,true)
val x907 = new generated.scala.IndexVectorSeqImpl(x906)
val x908 = new generated.scala.BinarizedGradientTemplate(15,null,null,x891,x905,x907,null,null,null)
var x931: Int = x926
val x909 = x901 - 15
val x910 = x909 < 0
val x914 = {
def x914thenb(): scala.Tuple2[Int, Int] = {
val x911 = 15 - x901
val x912 = (0,x911)
x912
}
def x914elseb(): scala.Tuple2[Int, Int] = {
val x913 = (x909,0)
x913
}
if (x910) {
x914thenb()
} else {
x914elseb()
}
}
val x915 = x914._1
val x917 = x901 + 15
val x918 = x917 > x898
val x919 = {
def x919thenb(): Int = {
x898
}
def x919elseb(): Int = {
x917
}
if (x918) {
x919thenb()
} else {
x919elseb()
}
}
val x916 = x914._2
val x950 = x908.binary_gradients
val x963 = x908.match_list
val x964 = x963.length
val x973 = while ({val x932 = x931
val x933 = x932 < x930
x933}) {
val x935 = x931
var x937: Int = x915
val x953 = x935 * x898
val x970 = while ({val x938 = x937
val x939 = x938 < x919
x939}) {
val x941 = x931
val x945 = x937
val x942 = x927 + x941
val x943 = x942 - x926
val x944 = x943 * 30
val x946 = x916 + x945
val x947 = x946 - x915
val x948 = x944 + x947
var x949: Int = x948
val x951 = x949
val x952 = x937
val x954 = x953 + x952
val x955 = x893.dcApply(x954)
val x956 = { 
x955
}
val x957 = x950(x951) = x956
val x958 = x937
val x959 = x953 + x958
val x960 = x893.dcApply(x959)
val x961 = { 
x960
}
val x962 = x961 > 0
val x967 = {
def x967thenb(): Unit = {
val x965 = x963.insert(x964, x951)
x965
}
def x967elseb(): Unit = {
()
}
if (x962) {
x967thenb()
} else {
x967elseb()
}
}
val x968 = x937 += 1
()
}
val x971 = x931 += 1
()
}
val x974 = x964 < 0
val x977 = {
def x977thenb(): Unit = {
val x975 = println("dummy")
x975
}
def x977elseb(): Unit = {
()
}
if (x974) {
x977thenb()
} else {
x977elseb()
}
}
val x982 = x908.radius
def x1108_block = {
val x979 = x978.dcApply(0)
var x1080 = {
val x980 = x885(x979)
val x981 = x980.radius
val x983 = x981 != x982
val x1058 = {
def x1058thenb(): Float = {
-1.0f
}
def x1058elseb(): Float = {
val x984 = x980.match_list
val x985 = x984.length
val x986 = x985.asInstanceOf[Float]
val x987 = x986==0.0
val x1056 = {
def x1056thenb(): Float = {
-1.0f
}
def x1056elseb(): Float = {
val x988 = x964.asInstanceOf[Float]
val x989 = x988 / x986
val x990 = x989 < 0.82f
val x1054 = {
def x1054thenb(): Float = {
x989
}
def x1054elseb(): Float = {
var x991: Float = 0.0f
val x992 = x986 * 0.18f
val x993 = x992 + 0.5f
val x994 = x993.asInstanceOf[Int]
var x995: Int = x994
var x996: Int = 0
var x997: Boolean = true
val x1005 = x980.binary_gradients
val x1045 = while ({val x998 = x996
val x1000 = x997
val x999 = x998 < x985
val x1001 = x999 && x1000
x1001}) {
val x1003 = x996
val x1006 = x996
val x1010 = x996
val x1007 = x984(x1006)
val x1008 = x1005(x1007)
val x1009 = x1008==0
val x1011 = x984(x1010)
val x1012 = x950(x1011)
val x1013 = x1012==0
val x1014 = x1009 && x1013
val x1042 = {
def x1042thenb(): Unit = {
val x1015 = x991
val x1016 = x1015 + 1.0f
x991 = x1016
()
}
def x1042elseb(): Unit = {
val x1019 = x996
val x1022 = x996
val x1020 = x984(x1019)
val x1021 = x1005(x1020)
val x1023 = x984(x1022)
val x1024 = x950(x1023)
val x1025 = x1021 & x1024
val x1026 = x1025 > 0
val x1040 = {
def x1040thenb(): Unit = {
val x1027 = x991
val x1028 = x1027 + 1.0f
x991 = x1028
()
}
def x1040elseb(): Unit = {
val x1031 = x995
val x1032 = x1031 - 1
x995 = x1032
val x1034 = x995
val x1035 = x1034 <= 0
val x1038 = {
def x1038thenb(): Unit = {
x997 = false
()
}
def x1038elseb(): Unit = {
()
}
if (x1035) {
x1038thenb()
} else {
x1038elseb()
}
}
x1038
}
if (x1026) {
x1040thenb()
} else {
x1040elseb()
}
}
x1040
}
if (x1014) {
x1042thenb()
} else {
x1042elseb()
}
}
val x1043 = x996 += 1
()
}
val x1046 = x997
val x1047 = !x1046
val x1052 = {
def x1052thenb(): Float = {
0.819999f
}
def x1052elseb(): Float = {
val x1048 = x991
val x1049 = x1048 / x986
val x1050 = x1049.asInstanceOf[Float]
x1050
}
if (x1047) {
x1052thenb()
} else {
x1052elseb()
}
}
x1052
}
if (x990) {
x1054thenb()
} else {
x1054elseb()
}
}
x1054
}
if (x987) {
x1056thenb()
} else {
x1056elseb()
}
}
x1056
}
if (x983) {
x1058thenb()
} else {
x1058elseb()
}
}
val x1059 = x1058 > 0.82f
val x1078 = {
def x1078thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1060 = x980.rect
val x1062 = x1060.width
val x902 = x891
val x903 = Math.pow(2.0,x902)
val x904 = x903.asInstanceOf[Int]
val x1061 = x904 * x901
val x1063 = x1062 / 2
val x1064 = x1061 - x1063
val x1065 = x1064.asInstanceOf[Int]
val x1067 = x1060.height
val x1066 = x904 * x897
val x1068 = x1067 / 2
val x1069 = x1066 - x1068
val x1070 = x1069.asInstanceOf[Int]
val x1071 = new generated.scala.Rect(x1065,x1070,x1062,x1067)
val x1072 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1073 = new generated.scala.BiGGDetection(x884,x1058,x1071,null,x979,x901,x897,x980,x908)
val x1074 = x1072(0) = x1073
x1072
}
def x1078elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1076 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1076
}
if (x1059) {
x1078thenb()
} else {
x1078elseb()
}
}
x1078
}
var mapReduceIdx = 1
while (mapReduceIdx < x978.size) { // begin mapReduce loop x1108
val x979 = x978.dcApply(mapReduceIdx)
val x1081 = {
val x980 = x885(x979)
val x981 = x980.radius
val x983 = x981 != x982
val x1058 = {
def x1058thenb(): Float = {
-1.0f
}
def x1058elseb(): Float = {
val x984 = x980.match_list
val x985 = x984.length
val x986 = x985.asInstanceOf[Float]
val x987 = x986==0.0
val x1056 = {
def x1056thenb(): Float = {
-1.0f
}
def x1056elseb(): Float = {
val x988 = x964.asInstanceOf[Float]
val x989 = x988 / x986
val x990 = x989 < 0.82f
val x1054 = {
def x1054thenb(): Float = {
x989
}
def x1054elseb(): Float = {
var x991: Float = 0.0f
val x992 = x986 * 0.18f
val x993 = x992 + 0.5f
val x994 = x993.asInstanceOf[Int]
var x995: Int = x994
var x996: Int = 0
var x997: Boolean = true
val x1005 = x980.binary_gradients
val x1045 = while ({val x998 = x996
val x1000 = x997
val x999 = x998 < x985
val x1001 = x999 && x1000
x1001}) {
val x1003 = x996
val x1006 = x996
val x1010 = x996
val x1007 = x984(x1006)
val x1008 = x1005(x1007)
val x1009 = x1008==0
val x1011 = x984(x1010)
val x1012 = x950(x1011)
val x1013 = x1012==0
val x1014 = x1009 && x1013
val x1042 = {
def x1042thenb(): Unit = {
val x1015 = x991
val x1016 = x1015 + 1.0f
x991 = x1016
()
}
def x1042elseb(): Unit = {
val x1019 = x996
val x1022 = x996
val x1020 = x984(x1019)
val x1021 = x1005(x1020)
val x1023 = x984(x1022)
val x1024 = x950(x1023)
val x1025 = x1021 & x1024
val x1026 = x1025 > 0
val x1040 = {
def x1040thenb(): Unit = {
val x1027 = x991
val x1028 = x1027 + 1.0f
x991 = x1028
()
}
def x1040elseb(): Unit = {
val x1031 = x995
val x1032 = x1031 - 1
x995 = x1032
val x1034 = x995
val x1035 = x1034 <= 0
val x1038 = {
def x1038thenb(): Unit = {
x997 = false
()
}
def x1038elseb(): Unit = {
()
}
if (x1035) {
x1038thenb()
} else {
x1038elseb()
}
}
x1038
}
if (x1026) {
x1040thenb()
} else {
x1040elseb()
}
}
x1040
}
if (x1014) {
x1042thenb()
} else {
x1042elseb()
}
}
val x1043 = x996 += 1
()
}
val x1046 = x997
val x1047 = !x1046
val x1052 = {
def x1052thenb(): Float = {
0.819999f
}
def x1052elseb(): Float = {
val x1048 = x991
val x1049 = x1048 / x986
val x1050 = x1049.asInstanceOf[Float]
x1050
}
if (x1047) {
x1052thenb()
} else {
x1052elseb()
}
}
x1052
}
if (x990) {
x1054thenb()
} else {
x1054elseb()
}
}
x1054
}
if (x987) {
x1056thenb()
} else {
x1056elseb()
}
}
x1056
}
if (x983) {
x1058thenb()
} else {
x1058elseb()
}
}
val x1059 = x1058 > 0.82f
val x1078 = {
def x1078thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1060 = x980.rect
val x1062 = x1060.width
val x902 = x891
val x903 = Math.pow(2.0,x902)
val x904 = x903.asInstanceOf[Int]
val x1061 = x904 * x901
val x1063 = x1062 / 2
val x1064 = x1061 - x1063
val x1065 = x1064.asInstanceOf[Int]
val x1067 = x1060.height
val x1066 = x904 * x897
val x1068 = x1067 / 2
val x1069 = x1066 - x1068
val x1070 = x1069.asInstanceOf[Int]
val x1071 = new generated.scala.Rect(x1065,x1070,x1062,x1067)
val x1072 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x1073 = new generated.scala.BiGGDetection(x884,x1058,x1071,null,x979,x901,x897,x980,x908)
val x1074 = x1072(0) = x1073
x1072
}
def x1078elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1076 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x1076
}
if (x1059) {
x1078thenb()
} else {
x1078elseb()
}
}
x1078
}
x1080 = {
val x1082 = x1080.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1107 = { 
val x1105 = {
def x1105thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1081
}
def x1105elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1083 = x1081.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1103 = {
def x1103thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1080
}
def x1103elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1084 = x1080.length
val x1085 = x1081.length
val x1086 = x1084 + x1085
val x1087 = x1080.isRow
val x1088 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1086,x1087)
var x1090 : Int = 0
val x1094 = while (x1090 < x1084) {
val x1091 = x1080(x1090)
val x1092 = x1088(x1090) = x1091
x1092
x1090 = x1090 + 1
}
var x1096 : Int = 0
val x1101 = while (x1096 < x1085) {
val x1097 = x1096 + x1084
val x1098 = x1081(x1096)
val x1099 = x1088(x1097) = x1098
x1099
x1096 = x1096 + 1
}
x1088
}
if (x1083) {
x1103thenb()
} else {
x1103elseb()
}
}
x1103
}
if (x1082) {
x1105thenb()
} else {
x1105elseb()
}
}
x1105
}
x1107
}
mapReduceIdx += 1
} // end mapReduce loop x1108
x1080
}
val x1108 = x1108_block
x1108
}
x1110 = {
val x1112 = x1110.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1137 = { 
val x1135 = {
def x1135thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1111
}
def x1135elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1113 = x1111.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1133 = {
def x1133thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1110
}
def x1133elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1114 = x1110.length
val x1115 = x1111.length
val x1116 = x1114 + x1115
val x1117 = x1110.isRow
val x1118 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1116,x1117)
var x1120 : Int = 0
val x1124 = while (x1120 < x1114) {
val x1121 = x1110(x1120)
val x1122 = x1118(x1120) = x1121
x1122
x1120 = x1120 + 1
}
var x1126 : Int = 0
val x1131 = while (x1126 < x1115) {
val x1127 = x1126 + x1114
val x1128 = x1111(x1126)
val x1129 = x1118(x1127) = x1128
x1129
x1126 = x1126 + 1
}
x1118
}
if (x1113) {
x1133thenb()
} else {
x1133elseb()
}
}
x1133
}
if (x1112) {
x1135thenb()
} else {
x1135elseb()
}
}
x1135
}
x1137
}
mapReduceIdx += 1
} // end mapReduce loop x1138
x1110
}
val x1138 = x1138_block
x1138
}
x1139 = {
val x1141 = x1139.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1166 = { 
val x1164 = {
def x1164thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1140
}
def x1164elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1142 = x1140.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1162 = {
def x1162thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1139
}
def x1162elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1143 = x1139.length
val x1144 = x1140.length
val x1145 = x1143 + x1144
val x1146 = x1139.isRow
val x1147 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1145,x1146)
var x1149 : Int = 0
val x1153 = while (x1149 < x1143) {
val x1150 = x1139(x1149)
val x1151 = x1147(x1149) = x1150
x1151
x1149 = x1149 + 1
}
var x1155 : Int = 0
val x1160 = while (x1155 < x1144) {
val x1156 = x1155 + x1143
val x1157 = x1140(x1155)
val x1158 = x1147(x1156) = x1157
x1158
x1155 = x1155 + 1
}
x1147
}
if (x1142) {
x1162thenb()
} else {
x1162elseb()
}
}
x1162
}
if (x1141) {
x1164thenb()
} else {
x1164elseb()
}
}
x1164
}
x1166
}
mapReduceIdx += 1
} // end mapReduce loop x1167
x1139
}
val x1167 = x1167_block
val x1168 = x1167.length
val x1169 = "Detections: "+x1168
val x1170 = println(x1169)
x1167
}
x1172 = {
val x1174 = x1172.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1199 = { 
val x1197 = {
def x1197thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1173
}
def x1197elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1175 = x1173.isInstanceOf[generated.scala.NilVector[generated.scala.BiGGDetection]]
val x1195 = {
def x1195thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
x1172
}
def x1195elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x1176 = x1172.length
val x1177 = x1173.length
val x1178 = x1176 + x1177
val x1179 = x1172.isRow
val x1180 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1178,x1179)
var x1182 : Int = 0
val x1186 = while (x1182 < x1176) {
val x1183 = x1172(x1182)
val x1184 = x1180(x1182) = x1183
x1184
x1182 = x1182 + 1
}
var x1188 : Int = 0
val x1193 = while (x1188 < x1177) {
val x1189 = x1188 + x1176
val x1190 = x1173(x1188)
val x1191 = x1180(x1189) = x1190
x1191
x1188 = x1188 + 1
}
x1180
}
if (x1175) {
x1195thenb()
} else {
x1195elseb()
}
}
x1195
}
if (x1174) {
x1197thenb()
} else {
x1197elseb()
}
}
x1197
}
x1199
}
mapReduceIdx += 1
} // end mapReduce loop x1200
x1172
}
val x1200 = x1200_block
val x1201 = x1200.length
var x1202: Int = x1201
val x1203 = x1202
val x1204 = "Detections before NMS: "+x1203
val x1205 = println(x1204)
var x1206: Int = 0
val x1320 = while ({val x1207 = x1206
val x1208 = x1202
val x1209 = x1208 - 1
val x1210 = x1207 < x1209
x1210}) {
val x1212 = x1206
val x1213 = x1212 + 1
var x1214: Int = x1213
var x1215: Boolean = false
val x1317 = while ({val x1216 = x1214
val x1217 = x1202
val x1219 = x1215
val x1218 = x1216 < x1217
val x1220 = x1219==false
val x1221 = x1218 && x1220
x1221}) {
val x1223 = x1206
val x1226 = x1214
val x1224 = x1200(x1223)
val x1225 = x1224.roi
val x1229 = x1225.x
val x1227 = x1200(x1226)
val x1228 = x1227.roi
val x1230 = x1228.x
val x1231 = x1228.width
val x1232 = x1230 + x1231
val x1233 = x1229 < x1232
val x1234 = x1225.width
val x1235 = x1229 + x1234
val x1236 = x1235 > x1230
val x1237 = x1233 && x1236
val x1238 = x1225.y
val x1239 = x1225.height
val x1240 = x1238 + x1239
val x1241 = x1228.y
val x1242 = x1240 > x1241
val x1243 = x1237 && x1242
val x1244 = x1228.height
val x1245 = x1241 + x1244
val x1246 = x1238 < x1245
val x1247 = x1243 && x1246
val x1268 = {
def x1268thenb(): Float = {
val x1254 = x1238 > x1241
val x1255 = {
def x1255thenb(): Int = {
x1238
}
def x1255elseb(): Int = {
x1241
}
if (x1254) {
x1255thenb()
} else {
x1255elseb()
}
}
val x1259 = x1240 < x1245
val x1260 = {
def x1260thenb(): Int = {
x1240
}
def x1260elseb(): Int = {
x1245
}
if (x1259) {
x1260thenb()
} else {
x1260elseb()
}
}
val x1261 = x1260 - x1255
val x1262 = x1261
val x1263 = 2.0f * x1262
val x1252 = x1229 > x1230
val x1253 = {
def x1253thenb(): Int = {
x1229
}
def x1253elseb(): Int = {
x1230
}
if (x1252) {
x1253thenb()
} else {
x1253elseb()
}
}
val x1256 = x1235 < x1232
val x1257 = {
def x1257thenb(): Int = {
x1235
}
def x1257elseb(): Int = {
x1232
}
if (x1256) {
x1257thenb()
} else {
x1257elseb()
}
}
val x1258 = x1257 - x1253
val x1264 = x1258
val x1265 = x1263 * x1264
val x1248 = x1244 * x1231
val x1249 = x1234 * x1239
val x1250 = x1248 + x1249
val x1251 = x1250
val x1266 = x1251 + 1.0E-6f
val x1267 = x1265 / x1266
x1267
}
def x1268elseb(): Float = {
0.0f
}
if (x1247) {
x1268thenb()
} else {
x1268elseb()
}
}
val x1269 = x1268 > 0.6f
val x1314 = {
def x1314thenb(): Unit = {
val x1270 = x1206
val x1273 = x1214
val x1271 = x1200(x1270)
val x1272 = x1271.score
val x1274 = x1200(x1273)
val x1275 = x1274.score
val x1276 = x1272 >= x1275
val x1312 = {
def x1312thenb(): Unit = {
val x1277 = x1202
val x1280 = x1202
val x1282 = x1214
val x1281 = x1280 - 1
val x1283 = x1200(x1282)
val x1284 = x1200(x1281) = x1283
val x1285 = x1214
val x1278 = x1277 - 1
val x1279 = x1200(x1278)
val x1286 = x1200(x1285) = x1279
val x1287 = x1202
val x1288 = x1287 - 1
x1202 = x1288
val x1290 = x1214
val x1291 = x1290 - 1
x1214 = x1291
()
}
def x1312elseb(): Unit = {
val x1294 = x1202
val x1297 = x1202
val x1299 = x1206
val x1298 = x1297 - 1
val x1300 = x1200(x1299)
val x1301 = x1200(x1298) = x1300
val x1302 = x1206
val x1295 = x1294 - 1
val x1296 = x1200(x1295)
val x1303 = x1200(x1302) = x1296
val x1304 = x1202
val x1305 = x1304 - 1
x1202 = x1305
val x1307 = x1206
val x1308 = x1307 - 1
x1206 = x1308
x1215 = true
()
}
if (x1276) {
x1312thenb()
} else {
x1312elseb()
}
}
x1312
}
def x1314elseb(): Unit = {
()
}
if (x1269) {
x1314thenb()
} else {
x1314elseb()
}
}
val x1315 = x1214 += 1
()
}
val x1318 = x1206 += 1
()
}
val x1321 = x1202
val x1322 = x1321 - 0
val x1323 = x1200.isRow
val x1333 = { 
val x1324 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1322,x1323)
var x1326 : Int = 0
val x1331 = while (x1326 < x1321) {
val x1327 = x1326 - 0
val x1328 = x1200(x1326)
val x1329 = x1324(x1327) = x1328
x1329
x1326 = x1326 + 1
}
x1324
}
val x1334 = x1333.length
val x1335 = "Total detections: "+x1334
val x1336 = println(x1335)
val x1337 = x232 += 1
()
}
val x1340 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
