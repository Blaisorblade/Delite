/*****************************************
  Emitting Generated Code                  
*******************************************/
class Application extends ((Array[java.lang.String])=>(Unit)) {
def apply(x0:Array[java.lang.String]): Unit = {
val x1 = x0(0)
def x54_block = { 
val x2 = new java.io.FileReader(x1)
val x3 = new java.io.BufferedReader(x2)
val x4 = x3.readLine()
var x5 = x4
val x6 = x5
val x7 = x6.trim()
x5 = x7
val x9 = x5
val x10 = x9.split("\\s+")
var x11 = x10
val x12 = x11
val x13 = x12.length
val x14 = new generated.scala.IntMatrixImpl(0,x13)
val x50 = while ({val x15 = x5
val x16 = x15 != null
x16}) {
val x18 = x11
val x19 = x18.length
val x20 = new generated.scala.IntVectorImpl(x19,true)
var x21 = 0
val x35 = while ({val x22 = x21
val x23 = x11
val x24 = x23.length
val x25 = x22 < x24
x25}) {
val x27 = x21
val x28 = x11
val x29 = x21
val x30 = x28(x29)
val x31 = java.lang.Integer.parseInt(x30)
val x32 = x20(x27) = x31
val x33 = x21 += 1
()
}
val x36 = x14.numRows
val x37 = x14.insertRow(x36,x20)
val x38 = x3.readLine()
x5 = x38
val x40 = x5
val x41 = x40 != null
val x48 = {
def x48thenb(): Unit = {
val x42 = x40.trim()
x5 = x42
val x44 = x5
val x45 = x44.split("\\s+")
x11 = x45
()
}
def x48elseb(): Unit = {
()
}
if (x41) {
x48thenb()
} else {
x48elseb()
}
}
x48
}
val x51 = x3.close()
val x52 = new generated.scala.GrayscaleImageImpl(x14)
x52
}
val x54 = x54_block
val x55 = x0(1)
def x229_block = { 
val x56 = new generated.scala.VectorImpl[java.lang.String](0,true)
val x57 = new java.io.File(x55)
val x58 = x57.getCanonicalFile()
val x59 = x58.listFiles()
val x65=x59.foreach{
x60 => 
val x62 = x56.length
val x61 = x60.getPath()
val x63 = x56.insert(x62, x61)
x63
}
def x227_block = {
val x223 = x56.length
val x224 = x56.isRow
val x225 = new generated.scala.VectorImpl[scala.Tuple2[java.lang.String, generated.scala.Vector[generated.scala.BinarizedGradientTemplate]]](x223,x224)
var mapIdx = 0
while (mapIdx < x56.size) {
val x66 = x56.dcApply(mapIdx)
x225.dcUpdate(mapIdx,  {
val x67 = "Loading model: "+x66
val x68 = println(x67)
val x69 = new generated.scala.VectorImpl[generated.scala.BinarizedGradientTemplate](0,true)
val x70 = new java.io.FileReader(x66)
val x71 = new java.io.BufferedReader(x70)
val x72 = x71.readLine()
val x73 = x72 != "bigg_object:"
val x76 = {
def x76thenb(): Nothing = {
val x74 = error("Illegal data format")
x74
}
def x76elseb(): Unit = {
()
}
if (x73) {
x76thenb()
} else {
x76elseb()
}
}
val x77 = x71.readLine()
val x78 = x71.readLine()
val x79 = x78.trim()
val x80 = x79.split(" ")
val x81 = x80(0)
val x82 = x81 != "obj_name/obj_num/num_objs:"
val x85 = {
def x85thenb(): Nothing = {
val x83 = error("Illegal data format")
x83
}
def x85elseb(): Unit = {
()
}
if (x82) {
x85thenb()
} else {
x85elseb()
}
}
var x90 = 0
val x88 = x80(3)
val x89 = java.lang.Integer.parseInt(x88)
val x220 = while ({val x91 = x90
val x92 = x91 < x89
x92}) {
val x94 = x71.readLine()
val x95 = x94.trim()
val x96 = x95 != "====OneBiGG====:"
val x99 = {
def x99thenb(): Nothing = {
val x97 = error("Illegal data format")
x97
}
def x99elseb(): Unit = {
()
}
if (x96) {
x99thenb()
} else {
x99elseb()
}
}
val x100 = x71.readLine()
val x101 = x100.trim()
val x102 = x101.split(" ")
var x103 = x102
val x104 = x103
val x105 = x104(0)
val x106 = x105 != "view/radius/reduction:"
val x109 = {
def x109thenb(): Nothing = {
val x107 = error("Illegal data format")
x107
}
def x109elseb(): Unit = {
()
}
if (x106) {
x109thenb()
} else {
x109elseb()
}
}
val x110 = x103
val x117 = x71.readLine()
val x118 = x117.trim()
val x119 = x118.split(" ")
x103 = x119
val x121 = x103
val x122 = x121(0)
val x123 = x122 != "Gradients:"
val x126 = {
def x126thenb(): Nothing = {
val x124 = error("Illegal data format")
x124
}
def x126elseb(): Unit = {
()
}
if (x123) {
x126thenb()
} else {
x126elseb()
}
}
val x127 = x103
val x128 = x127(1)
val x129 = java.lang.Integer.parseInt(x128)
val x130 = new generated.scala.IntVectorImpl(x129,true)
val x131 = x71.readLine()
var x134 = 0
val x132 = x131.trim()
val x133 = x132.split(" ")
val x145 = while ({val x135 = x134
val x136 = x135 < x129
x136}) {
val x138 = x134
val x139 = x134
val x140 = x133(x139)
val x141 = java.lang.Integer.parseInt(x140)
val x142 = x130(x138) = x141
val x143 = x134 += 1
()
}
val x146 = x71.readLine()
val x147 = x146.trim()
val x148 = x147.split(" ")
x103 = x148
val x150 = x103
val x151 = x150(0)
val x152 = x151 != "Match_list:"
val x155 = {
def x155thenb(): Nothing = {
val x153 = error("Illegal data format")
x153
}
def x155elseb(): Unit = {
()
}
if (x152) {
x155thenb()
} else {
x155elseb()
}
}
val x156 = x103
val x159 = new generated.scala.IntVectorImpl(0,true)
val x160 = new generated.scala.IndexVectorSeqImpl(x159)
val x161 = x71.readLine()
x134 = 0
val x157 = x156(1)
val x158 = java.lang.Integer.parseInt(x157)
val x162 = x161.trim()
val x163 = x162.split(" ")
val x171 = x160.length
val x175 = while ({val x165 = x134
val x166 = x165 < x158
x166}) {
val x168 = x134
val x169 = x163(x168)
val x170 = java.lang.Integer.parseInt(x169)
val x172 = x160.insert(x171, x170)
val x173 = x134 += 1
()
}
val x176 = x71.readLine()
val x177 = x176.trim()
val x178 = x177.split(" ")
x103 = x178
val x180 = x103
val x181 = x180(0)
val x182 = x181 != "Occlusions:"
val x185 = {
def x185thenb(): Nothing = {
val x183 = error("Illegal data format")
x183
}
def x185elseb(): Unit = {
()
}
if (x182) {
x185thenb()
} else {
x185elseb()
}
}
val x186 = x103
val x189 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](0,true)
val x190 = x71.readLine()
val x187 = x186(1)
val x188 = java.lang.Integer.parseInt(x187)
val x193 = x188 != 0
val x196 = {
def x196thenb(): Nothing = {
val x194 = error("Occlusions not supported.")
x194
}
def x196elseb(): Unit = {
()
}
if (x193) {
x196thenb()
} else {
x196elseb()
}
}
val x197 = x71.readLine()
val x198 = x197.trim()
val x199 = x198 != "BoundingBox:"
val x202 = {
def x202thenb(): Nothing = {
val x200 = error("Illegal data format")
x200
}
def x202elseb(): Unit = {
()
}
if (x199) {
x202thenb()
} else {
x202elseb()
}
}
val x203 = x71.readLine()
val x204 = x203.trim()
val x205 = x204.split(" ")
val x206 = x205(0)
val x207 = java.lang.Integer.parseInt(x206)
val x208 = x205(1)
val x209 = java.lang.Integer.parseInt(x208)
val x210 = x205(2)
val x211 = java.lang.Integer.parseInt(x210)
val x212 = x205(3)
val x213 = java.lang.Integer.parseInt(x212)
val x214 = new generated.scala.Rect(x207,x209,x211,x213)
val x113 = x110(2)
val x114 = java.lang.Integer.parseInt(x113)
val x215 = new generated.scala.BinarizedGradientTemplate(x114,x214,null,0,x130,x160,x189,null,null)
val x216 = x69.length
val x217 = x69.insert(x216, x215)
val x218 = x90 += 1
()
}
val x86 = x80(1)
val x221 = (x86,x69)
x221
})
mapIdx += 1
} // end while
x225
}
val x227 = x227_block
x227
}
val x229 = x229_block
val x230 = println("tic:" + (System.nanoTime / 1000000L))
var x231 = 0
val x265 = x54.numRows
val x266 = new generated.scala.IndexVectorRangeImpl(0,x265)
val x267 = x54.numCols
val x268 = new generated.scala.IndexVectorRangeImpl(0,x267)
val x269 = new generated.scala.IndexVector2Impl(x266,x268)
val x270 = x269.rowInd
val x271 = x270.length
val x275 = x269.colInd
val x333 = x275.length
val x334 = x275.isRow
val x484 = Math.Pi
val x497 = 200
val x545 = 2 / 2
val x1241 = while ({val x232 = x231
val x233 = x232 < 3
x233}) {
val x235 = new generated.scala.IntMatrixImpl(3,3)
val x236 = x235(0, 0) = -3
val x237 = x235(0, 1) = -10
val x238 = x235(0, 2) = -3
val x239 = x235(2, 0) = 3
val x240 = x235(2, 1) = 10
val x241 = x235(2, 2) = 3
def x258_block = { 
val x242 = x235.numCols
val x243 = x235.numRows
val x244 = new generated.scala.IntMatrixImpl(x242,x243)
val x245 = x244.numRows
var x247 : Int = 0
val x256 = while (x247 < x245) {
val x248 = x244.numCols
var x250 : Int = 0
val x254 = while (x250 < x248) {
val x251 = x235(x250, x247)
val x252 = x244(x247, x250) = x251
x252
x250 = x250 + 1
}
x254
x247 = x247 + 1
}
x244
}
val x258 = x258_block
val x259 = x258.numRows
val x261 = x259 - 1
val x262 = x261 / 2
val x278 = x265 - x262
val x260 = x258.numCols
val x263 = x260 - 1
val x264 = x263 / 2
val x283 = x267 - x264
def x338_block = {
val x272 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](x271,true)
var mapIdx = 0
while (mapIdx < x270.size) {
val x274 = x270.dcApply(mapIdx)
x272.dcUpdate(mapIdx,  {
val x277 = x274 >= x262
val x279 = x274 < x278
val x280 = x277 && x279
def x337_block = {
val x335 = new generated.scala.IntVectorImpl(x333,x334)
var mapIdx = 0
while (mapIdx < x275.size) {
val x276 = x275.dcApply(mapIdx)
x335.dcUpdate(mapIdx,  {
val x281 = x276 >= x264
val x282 = x280 && x281
val x284 = x276 < x283
val x285 = x282 && x284
val x332 = {
def x332thenb(): Int = {
val x286 = x274 - x262
val x287 = x274 + x262
val x288 = x287 + 1
val x289 = x276 - x264
val x290 = x276 + x264
val x291 = x290 + 1
val x292 = x288 - x286
val x293 = x291 - x289
def x318_block = { 
val x294 = new generated.scala.IntMatrixImpl(x292,x293)
var x295 = x286
val x316 = while ({val x296 = x295
val x297 = x296 < x288
x297}) {
var x299 = x289
val x313 = while ({val x300 = x299
val x301 = x300 < x291
x301}) {
val x303 = x295
val x305 = x299
val x307 = x295
val x308 = x299
val x304 = x303 - x286
val x306 = x305 - x289
val x309 = x54(x307, x308)
val x310 = x294(x304, x306) = x309
val x311 = x299 += 1
()
}
val x314 = x295 += 1
()
}
x294
}
val x318 = x318_block
val x319 = x318.numRows
val x320 = x318.numCols
def x326_block = {
val x321 = new generated.scala.IntMatrixImpl(x319,x320)
var zipIdx = 0
while (zipIdx < x318.size) {
val x323 = x318.dcApply(zipIdx)
val x324 = x258.dcApply(zipIdx)
x321.dcUpdate(zipIdx,  {
val x325 = x323 * x324
x325
})
zipIdx += 1
} // end while
x321
}
val x326 = x326_block
def x330_block = {
var x327 = x326.dcApply(0)
var reduceIdx = 1
while (reduceIdx < x326.size) {
val x328 = x326.dcApply(reduceIdx)
x327 = {
val x329 = x327 + x328
x329
}
reduceIdx += 1
} // end while
x327
}
val x330 = x330_block
x330
}
def x332elseb(): Int = {
val x331 = 0.asInstanceOf[Int]
x331
}
if (x285) {
x332thenb()
} else {
x332elseb()
}
}
x332
})
mapIdx += 1
} // end while
x335
}
val x337 = x337_block
x337
})
mapIdx += 1
} // end while
x272
}
val x338 = x338_block
val x339 = x338.length
val x340 = x339 > 0
val x343 = {
def x343thenb(): Int = {
val x341 = x338(0)
val x342 = x341.length
x342
}
def x343elseb(): Int = {
0
}
if (x340) {
x343thenb()
} else {
x343elseb()
}
}
def x357_block = { 
val x344 = new generated.scala.IntMatrixImpl(x339,x343)
var x346 : Int = 0
val x355 = while (x346 < x339) {
val x349 = x338(x346)
var x348 : Int = 0
val x353 = while (x348 < x343) {
val x350 = x349(x348)
val x351 = x344(x346, x348) = x350
x351
x348 = x348 + 1
}
x353
x346 = x346 + 1
}
x344
}
val x357 = x357_block
val x358 = new generated.scala.ImageImpl[Int](x357)
val x359 = x235.numRows
val x360 = x235.numCols
val x361 = x359 - 1
val x362 = x361 / 2
val x370 = x265 - x362
val x363 = x360 - 1
val x364 = x363 / 2
val x375 = x267 - x364
def x429_block = {
val x365 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](x271,true)
var mapIdx = 0
while (mapIdx < x270.size) {
val x367 = x270.dcApply(mapIdx)
x365.dcUpdate(mapIdx,  {
val x369 = x367 >= x362
val x371 = x367 < x370
val x372 = x369 && x371
def x428_block = {
val x426 = new generated.scala.IntVectorImpl(x333,x334)
var mapIdx = 0
while (mapIdx < x275.size) {
val x368 = x275.dcApply(mapIdx)
x426.dcUpdate(mapIdx,  {
val x373 = x368 >= x364
val x374 = x372 && x373
val x376 = x368 < x375
val x377 = x374 && x376
val x424 = {
def x424thenb(): Int = {
val x378 = x367 - x362
val x379 = x367 + x362
val x380 = x379 + 1
val x381 = x368 - x364
val x382 = x368 + x364
val x383 = x382 + 1
val x384 = x380 - x378
val x385 = x383 - x381
def x410_block = { 
val x386 = new generated.scala.IntMatrixImpl(x384,x385)
var x387 = x378
val x408 = while ({val x388 = x387
val x389 = x388 < x380
x389}) {
var x391 = x381
val x405 = while ({val x392 = x391
val x393 = x392 < x383
x393}) {
val x395 = x387
val x397 = x391
val x399 = x387
val x400 = x391
val x396 = x395 - x378
val x398 = x397 - x381
val x401 = x54(x399, x400)
val x402 = x386(x396, x398) = x401
val x403 = x391 += 1
()
}
val x406 = x387 += 1
()
}
x386
}
val x410 = x410_block
val x411 = x410.numRows
val x412 = x410.numCols
def x418_block = {
val x413 = new generated.scala.IntMatrixImpl(x411,x412)
var zipIdx = 0
while (zipIdx < x410.size) {
val x415 = x410.dcApply(zipIdx)
val x416 = x235.dcApply(zipIdx)
x413.dcUpdate(zipIdx,  {
val x417 = x415 * x416
x417
})
zipIdx += 1
} // end while
x413
}
val x418 = x418_block
def x422_block = {
var x419 = x418.dcApply(0)
var reduceIdx = 1
while (reduceIdx < x418.size) {
val x420 = x418.dcApply(reduceIdx)
x419 = {
val x421 = x419 + x420
x421
}
reduceIdx += 1
} // end while
x419
}
val x422 = x422_block
x422
}
def x424elseb(): Int = {
val x331 = 0.asInstanceOf[Int]
x331
}
if (x377) {
x424thenb()
} else {
x424elseb()
}
}
x424
})
mapIdx += 1
} // end while
x426
}
val x428 = x428_block
x428
})
mapIdx += 1
} // end while
x365
}
val x429 = x429_block
val x430 = x429.length
val x431 = x430 > 0
val x434 = {
def x434thenb(): Int = {
val x432 = x429(0)
val x433 = x432.length
x433
}
def x434elseb(): Int = {
0
}
if (x431) {
x434thenb()
} else {
x434elseb()
}
}
def x448_block = { 
val x435 = new generated.scala.IntMatrixImpl(x430,x434)
var x437 : Int = 0
val x446 = while (x437 < x430) {
val x440 = x429(x437)
var x439 : Int = 0
val x444 = while (x439 < x434) {
val x441 = x440(x439)
val x442 = x435(x437, x439) = x441
x442
x439 = x439 + 1
}
x444
x437 = x437 + 1
}
x435
}
val x448 = x448_block
val x449 = new generated.scala.ImageImpl[Int](x448)
val x452 = x358.numRows
val x453 = x358.numCols
def x456_block = {
val x454 = new generated.scala.FloatMatrixImpl(x452,x453)
var mapIdx = 0
while (mapIdx < x358.size) {
val x450 = x358.dcApply(mapIdx)
x454.dcUpdate(mapIdx,  {
val x451 = x450
x451
})
mapIdx += 1
} // end while
x454
}
val x456 = x456_block
val x459 = x449.numRows
val x460 = x449.numCols
def x463_block = {
val x461 = new generated.scala.FloatMatrixImpl(x459,x460)
var mapIdx = 0
while (mapIdx < x449.size) {
val x457 = x449.dcApply(mapIdx)
x461.dcUpdate(mapIdx,  {
val x458 = x457
x458
})
mapIdx += 1
} // end while
x461
}
val x463 = x463_block
val x464 = x456.numRows
val x465 = x456.numCols
def x487_block = {
val x476 = new generated.scala.FloatMatrixImpl(x464,x465)
var zipIdx = 0
while (zipIdx < x456.size) {
val x478 = x456.dcApply(zipIdx)
val x479 = x463.dcApply(zipIdx)
x476.dcUpdate(zipIdx,  {
val x480 = x479
val x481 = x478
val x482 = Math.atan2(x480, x481)
val x483 = x482 * 180.0
val x485 = x483 / x484
val x486 = x485.asInstanceOf[Float]
x486
})
zipIdx += 1
} // end while
x476
}
val x487 = x487_block
def x492_block = {
var mapIdx = 0
while (mapIdx < x487.size) {
val x488 = x487.dcApply(mapIdx)
x487.dcUpdate(mapIdx,  {
val x489 = x488 < 0.0f
val x491 = {
def x491thenb(): Float = {
val x490 = x488 + 360.0f
x490
}
def x491elseb(): Float = {
x488
}
if (x489) {
x491thenb()
} else {
x491elseb()
}
}
x491
})
mapIdx += 1
} // end while
x487
}
val x492 = x492_block
def x493_block = {
val x466 = new generated.scala.FloatMatrixImpl(x464,x465)
var zipIdx = 0
while (zipIdx < x456.size) {
val x468 = x456.dcApply(zipIdx)
val x469 = x463.dcApply(zipIdx)
x466.dcUpdate(zipIdx,  {
val x470 = x468 * x468
val x471 = x469 * x469
val x472 = x470 + x471
val x473 = x472
val x474 = Math.sqrt(x473)
val x475 = x474.asInstanceOf[Float]
x475
})
zipIdx += 1
} // end while
x466
}
val x493 = x493_block
val x517 = x493.numRows
val x518 = x493.numCols
def x521_block = {
val x519 = new generated.scala.IntMatrixImpl(x517,x518)
var zipIdx = 0
while (zipIdx < x493.size) {
val x495 = x493.dcApply(zipIdx)
val x496 = x492.dcApply(zipIdx)
x519.dcUpdate(zipIdx,  {
val x498 = x495 >= x497
val x515 = {
def x515thenb(): Int = {
var x499 = x496
val x500 = x499
val x501 = 180
val x502 = x500 >= x501
val x506 = {
def x506thenb(): Unit = {
val x503 = x500 - x501
x499 = x503
()
}
def x506elseb(): Unit = {
()
}
if (x502) {
x506thenb()
} else {
x506elseb()
}
}
val x507 = x499
val x508 = x507.asInstanceOf[Double]
val x509 = x508 / 22.5
val x510 = x509.asInstanceOf[Int]
val x511 = x510
val x512 = Math.pow(2.0,x511)
val x513 = x512.asInstanceOf[Int]
x513
}
def x515elseb(): Int = {
0
}
if (x498) {
x515thenb()
} else {
x515elseb()
}
}
x515
})
zipIdx += 1
} // end while
x519
}
val x521 = x521_block
val x522 = new generated.scala.GrayscaleImageImpl(x521)
val x523 = x522.numCols
val x524 = 0 * x523
val x525 = x522.vview(x524,1,x523,true)
def x526_block = { 
x525
}
val x526 = x526_block
def x528_block = {
var mapIdx = 0
while (mapIdx < x526.size) {
val x527 = x526.dcApply(mapIdx)
x526.dcUpdate(mapIdx,  {
0
})
mapIdx += 1
} // end while
x526
}
val x528 = x528_block
val x529 = x522.numRows
val x530 = x529 - 1
val x531 = x530 * x523
val x532 = x522.vview(x531,1,x523,true)
def x533_block = { 
x532
}
val x533 = x533_block
def x535_block = {
var mapIdx = 0
while (mapIdx < x533.size) {
val x534 = x533.dcApply(mapIdx)
x533.dcUpdate(mapIdx,  {
0
})
mapIdx += 1
} // end while
x533
}
val x535 = x535_block
val x536 = x522.vview(0,x523,x529,false)
def x537_block = { 
x536
}
val x537 = x537_block
def x539_block = {
var mapIdx = 0
while (mapIdx < x537.size) {
val x538 = x537.dcApply(mapIdx)
x537.dcUpdate(mapIdx,  {
0
})
mapIdx += 1
} // end while
x537
}
val x539 = x539_block
val x540 = x523 - 1
val x541 = x522.vview(x540,x523,x529,false)
def x542_block = { 
x541
}
val x542 = x542_block
def x544_block = {
var mapIdx = 0
while (mapIdx < x542.size) {
val x543 = x542.dcApply(mapIdx)
x542.dcUpdate(mapIdx,  {
0
})
mapIdx += 1
} // end while
x542
}
val x544 = x544_block
val x546 = new generated.scala.IndexVectorRangeImpl(0,x529)
val x547 = new generated.scala.IndexVectorRangeImpl(0,x523)
val x548 = new generated.scala.IndexVector2Impl(x546,x547)
val x549 = x548.rowInd
val x550 = x549.length
val x554 = x548.colInd
val x557 = x529 - x545
val x562 = x523 - x545
val x654 = x554.length
val x655 = x554.isRow
def x659_block = {
val x551 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](x550,true)
var mapIdx = 0
while (mapIdx < x549.size) {
val x553 = x549.dcApply(mapIdx)
x551.dcUpdate(mapIdx,  {
val x556 = x553 >= x545
val x558 = x553 < x557
val x559 = x556 && x558
def x658_block = {
val x656 = new generated.scala.IntVectorImpl(x654,x655)
var mapIdx = 0
while (mapIdx < x554.size) {
val x555 = x554.dcApply(mapIdx)
x656.dcUpdate(mapIdx,  {
val x560 = x555 >= x545
val x561 = x559 && x560
val x563 = x555 < x562
val x564 = x561 && x563
val x652 = {
def x652thenb(): Int = {
val x598 = new generated.scala.IntVectorImpl(256,true)
var x599 = 0
val x565 = x553 - x545
val x566 = x553 + x545
val x567 = x566 + 1
val x568 = x555 - x545
val x569 = x555 + x545
val x570 = x569 + 1
val x571 = x567 - x565
val x572 = x570 - x568
def x597_block = { 
val x573 = new generated.scala.IntMatrixImpl(x571,x572)
var x574 = x565
val x595 = while ({val x575 = x574
val x576 = x575 < x567
x576}) {
var x578 = x568
val x592 = while ({val x579 = x578
val x580 = x579 < x570
x580}) {
val x582 = x574
val x584 = x578
val x586 = x574
val x587 = x578
val x583 = x582 - x565
val x585 = x584 - x568
val x588 = x522(x586, x587)
val x589 = x573(x583, x585) = x588
val x590 = x578 += 1
()
}
val x593 = x574 += 1
()
}
x573
}
val x597 = x597_block
val x601 = x597.numRows
val x606 = x597.numCols
val x623 = while ({val x600 = x599
val x602 = x600 < x601
x602}) {
var x604 = 0
val x620 = while ({val x605 = x604
val x607 = x605 < x606
x607}) {
val x609 = x599
val x610 = x604
val x612 = x599
val x613 = x604
val x614 = x597(x612, x613)
val x615 = x598(x614)
val x611 = x597(x609, x610)
val x616 = x615 + 1
val x617 = x598(x611) = x616
val x618 = x604 += 1
()
}
val x621 = x599 += 1
()
}
var x624 = 2
val x625 = x598(1)
var x626 = x625
var x627 = 1
val x645 = while ({val x628 = x624
val x629 = x598.length
val x630 = x628 < x629
x630}) {
val x632 = x624
val x633 = x598(x632)
val x634 = x626
val x635 = x633 > x634
val x642 = {
def x642thenb(): Unit = {
val x636 = x624
val x637 = x598(x636)
x626 = x637
val x639 = x624
x627 = x639
()
}
def x642elseb(): Unit = {
()
}
if (x635) {
x642thenb()
} else {
x642elseb()
}
}
val x643 = x624 += 1
()
}
val x646 = x626
val x647 = x646 > 1
val x650 = {
def x650thenb(): Int = {
val x648 = x627
x648
}
def x650elseb(): Int = {
0
}
if (x647) {
x650thenb()
} else {
x650elseb()
}
}
x650
}
def x652elseb(): Int = {
val x331 = 0.asInstanceOf[Int]
x331
}
if (x564) {
x652thenb()
} else {
x652elseb()
}
}
x652
})
mapIdx += 1
} // end while
x656
}
val x658 = x658_block
x658
})
mapIdx += 1
} // end while
x551
}
val x659 = x659_block
val x660 = x659.length
val x661 = x660 > 0
val x664 = {
def x664thenb(): Int = {
val x662 = x659(0)
val x663 = x662.length
x663
}
def x664elseb(): Int = {
0
}
if (x661) {
x664thenb()
} else {
x664elseb()
}
}
def x678_block = { 
val x665 = new generated.scala.IntMatrixImpl(x660,x664)
var x667 : Int = 0
val x676 = while (x667 < x660) {
val x670 = x659(x667)
var x669 : Int = 0
val x674 = while (x669 < x664) {
val x671 = x670(x669)
val x672 = x665(x667, x669) = x671
x672
x669 = x669 + 1
}
x674
x667 = x667 + 1
}
x665
}
val x678 = x678_block
val x679 = new generated.scala.ImageImpl[Int](x678)
val x680 = new generated.scala.GrayscaleImageImpl(x679)
var x681 = x680
var x682 = 0
val x683 = new generated.scala.VectorImpl[generated.scala.GrayscaleImage](0,true)
val x684 = new generated.scala.BinarizedGradientPyramid(x683,3,1,3)
val x686 = x684.start_level
val x687 = x684.levels
val x688 = x686 + x687
val x693 = x684.pyramid
val x699 = x688 - 1
val x787 = while ({val x685 = x682
val x689 = x685 < x688
x689}) {
val x691 = x682
val x692 = x691 >= x686
val x698 = {
def x698thenb(): Unit = {
val x694 = x681
val x695 = x693.length
val x696 = x693.insert(x695, x694)
x696
}
def x698elseb(): Unit = {
()
}
if (x692) {
x698thenb()
} else {
x698elseb()
}
}
val x700 = x682
val x701 = x700 != x699
val x784 = {
def x784thenb(): Unit = {
val x702 = x681
val x703 = x702.numRows
val x704 = x703 / 2
val x705 = new generated.scala.IndexVectorRangeImpl(0,x704)
val x706 = x702.numCols
val x707 = x706 / 2
val x708 = new generated.scala.IndexVectorRangeImpl(0,x707)
val x709 = new generated.scala.IndexVector2Impl(x705,x708)
val x710 = x709.rowInd
val x711 = x710.length
val x715 = x709.colInd
val x755 = x715.length
val x756 = x715.isRow
def x760_block = {
val x712 = new generated.scala.VectorImpl[generated.scala.Vector[Int]](x711,true)
var mapIdx = 0
while (mapIdx < x710.size) {
val x714 = x710.dcApply(mapIdx)
x712.dcUpdate(mapIdx,  {
val x717 = 2 * x714
val x718 = x717 + 2
val x721 = x718 - x717
def x759_block = {
val x757 = new generated.scala.IntVectorImpl(x755,x756)
var mapIdx = 0
while (mapIdx < x715.size) {
val x716 = x715.dcApply(mapIdx)
x757.dcUpdate(mapIdx,  {
val x719 = 2 * x716
val x720 = x719 + 2
val x722 = x720 - x719
def x747_block = { 
val x723 = new generated.scala.IntMatrixImpl(x721,x722)
var x724 = x717
val x745 = while ({val x725 = x724
val x726 = x725 < x718
x726}) {
var x728 = x719
val x742 = while ({val x729 = x728
val x730 = x729 < x720
x730}) {
val x732 = x724
val x734 = x728
val x736 = x724
val x737 = x728
val x733 = x732 - x717
val x735 = x734 - x719
val x738 = x702(x736, x737)
val x739 = x723(x733, x735) = x738
val x740 = x728 += 1
()
}
val x743 = x724 += 1
()
}
x723
}
val x747 = x747_block
val x748 = x747(0, 0)
val x749 = x747(1, 0)
val x750 = x748 | x749
val x751 = x747(0, 1)
val x752 = x750 | x751
val x753 = x747(1, 1)
val x754 = x752 | x753
x754
})
mapIdx += 1
} // end while
x757
}
val x759 = x759_block
x759
})
mapIdx += 1
} // end while
x712
}
val x760 = x760_block
val x761 = x760.length
val x762 = x761 > 0
val x765 = {
def x765thenb(): Int = {
val x763 = x760(0)
val x764 = x763.length
x764
}
def x765elseb(): Int = {
0
}
if (x762) {
x765thenb()
} else {
x765elseb()
}
}
def x779_block = { 
val x766 = new generated.scala.IntMatrixImpl(x761,x765)
var x768 : Int = 0
val x777 = while (x768 < x761) {
val x771 = x760(x768)
var x770 : Int = 0
val x775 = while (x770 < x765) {
val x772 = x771(x770)
val x773 = x766(x768, x770) = x772
x773
x770 = x770 + 1
}
x775
x768 = x768 + 1
}
x766
}
val x779 = x779_block
val x780 = new generated.scala.ImageImpl[Int](x779)
val x781 = new generated.scala.GrayscaleImageImpl(x780)
x681 = x781
()
}
def x784elseb(): Unit = {
()
}
if (x701) {
x784thenb()
} else {
x784elseb()
}
}
val x785 = x682 += 1
()
}
val x796 = x684.fixedLevelIndex
val x797 = x796 - x686
val x798 = x693(x797)
val x799 = x798.numRows
val x800 = x799 - 5
val x801 = new generated.scala.IndexVectorRangeImpl(5,x800)
val x803 = x798.numCols
val x804 = x803 - 5
val x805 = new generated.scala.IndexVectorRangeImpl(5,x804)
def x1098_block = {
val x788 = x229.dcApply(0)
var x1071 = {
val x789 = x788._1
val x791 = "Name: "+x789
val x792 = println(x791)
val x790 = x788._2
val x793 = x790.length
val x794 = "Templates: "+x793
val x795 = println(x794)
val x880 = new generated.scala.IndexVectorRangeImpl(0,x793)
def x1066_block = {
val x802 = x801.dcApply(0)
var x1039 = {
val x825 = x802 - 15
val x826 = x825 < 0
val x830 = {
def x830thenb(): scala.Tuple2[Int, Int] = {
val x827 = 15 - x802
val x828 = (0,x827)
x828
}
def x830elseb(): scala.Tuple2[Int, Int] = {
val x829 = (x825,0)
x829
}
if (x826) {
x830thenb()
} else {
x830elseb()
}
}
val x831 = x830._1
val x833 = x802 + 15
val x834 = x833 > x799
val x835 = {
def x835thenb(): Int = {
x799
}
def x835elseb(): Int = {
x833
}
if (x834) {
x835thenb()
} else {
x835elseb()
}
}
val x832 = x830._2
def x1038_block = {
val x806 = x805.dcApply(0)
var x1011 = {
val x810 = new generated.scala.IntVectorImpl(900,false)
val x811 = new generated.scala.IntVectorImpl(0,true)
val x812 = new generated.scala.IndexVectorSeqImpl(x811)
val x813 = new generated.scala.BinarizedGradientTemplate(15,null,null,x796,x810,x812,null,null,null)
var x836 = x831
val x814 = x806 - 15
val x815 = x814 < 0
val x819 = {
def x819thenb(): scala.Tuple2[Int, Int] = {
val x816 = 15 - x806
val x817 = (0,x816)
x817
}
def x819elseb(): scala.Tuple2[Int, Int] = {
val x818 = (x814,0)
x818
}
if (x815) {
x819thenb()
} else {
x819elseb()
}
}
val x820 = x819._1
val x822 = x806 + 15
val x823 = x822 > x803
val x824 = {
def x824thenb(): Int = {
x803
}
def x824elseb(): Int = {
x822
}
if (x823) {
x824thenb()
} else {
x824elseb()
}
}
val x821 = x819._2
val x857 = x813.binary_gradients
val x865 = x813.match_list
val x866 = x865.length
val x875 = while ({val x837 = x836
val x838 = x837 < x835
x838}) {
val x840 = x836
var x844 = x820
val x872 = while ({val x845 = x844
val x846 = x845 < x824
x846}) {
val x848 = x836
val x852 = x844
val x849 = x832 + x848
val x850 = x849 - x831
val x851 = x850 * 30
val x853 = x821 + x852
val x854 = x853 - x820
val x855 = x851 + x854
var x856 = x855
val x858 = x856
val x859 = x844
val x860 = x798(x840, x859)
val x861 = x857(x858) = x860
val x862 = x844
val x863 = x798(x840, x862)
val x864 = x863 > 0
val x869 = {
def x869thenb(): Unit = {
val x867 = x865.insert(x866, x858)
x867
}
def x869elseb(): Unit = {
()
}
if (x864) {
x869thenb()
} else {
x869elseb()
}
}
val x870 = x844 += 1
()
}
val x873 = x836 += 1
()
}
val x876 = x866 < 0
val x879 = {
def x879thenb(): Unit = {
val x877 = println("dummy")
x877
}
def x879elseb(): Unit = {
()
}
if (x876) {
x879thenb()
} else {
x879elseb()
}
}
val x884 = x813.radius
def x1009_block = {
val x881 = x880.dcApply(0)
var x982 = {
val x882 = x790(x881)
val x883 = x882.radius
val x885 = x883 != x884
val x960 = {
def x960thenb(): Float = {
-1.0f
}
def x960elseb(): Float = {
val x886 = x882.match_list
val x887 = x886.length
val x888 = x887.asInstanceOf[Float]
val x889 = x888==0.0
val x958 = {
def x958thenb(): Float = {
-1.0f
}
def x958elseb(): Float = {
val x890 = x866.asInstanceOf[Float]
val x891 = x890 / x888
val x892 = x891 < 0.82f
val x956 = {
def x956thenb(): Float = {
x891
}
def x956elseb(): Float = {
var x893 = 0.0f
val x894 = x888 * 0.18f
val x895 = x894 + 0.5f
val x896 = x895.asInstanceOf[Int]
var x897 = x896
var x898 = 0
var x899 = true
val x907 = x882.binary_gradients
val x947 = while ({val x900 = x898
val x902 = x899
val x901 = x900 < x887
val x903 = x901 && x902
x903}) {
val x905 = x898
val x908 = x898
val x912 = x898
val x909 = x886(x908)
val x910 = x907(x909)
val x911 = x910==0
val x913 = x886(x912)
val x914 = x857(x913)
val x915 = x914==0
val x916 = x911 && x915
val x944 = {
def x944thenb(): Unit = {
val x917 = x893
val x918 = x917 + 1.0f
x893 = x918
()
}
def x944elseb(): Unit = {
val x921 = x898
val x924 = x898
val x922 = x886(x921)
val x923 = x907(x922)
val x925 = x886(x924)
val x926 = x857(x925)
val x927 = x923 & x926
val x928 = x927 > 0
val x942 = {
def x942thenb(): Unit = {
val x929 = x893
val x930 = x929 + 1.0f
x893 = x930
()
}
def x942elseb(): Unit = {
val x933 = x897
val x934 = x933 - 1
x897 = x934
val x936 = x897
val x937 = x936 <= 0
val x940 = {
def x940thenb(): Unit = {
x899 = false
()
}
def x940elseb(): Unit = {
()
}
if (x937) {
x940thenb()
} else {
x940elseb()
}
}
x940
}
if (x928) {
x942thenb()
} else {
x942elseb()
}
}
x942
}
if (x916) {
x944thenb()
} else {
x944elseb()
}
}
val x945 = x898 += 1
()
}
val x948 = x899
val x949 = !x948
val x954 = {
def x954thenb(): Float = {
0.819999f
}
def x954elseb(): Float = {
val x950 = x893
val x951 = x950 / x888
val x952 = x951.asInstanceOf[Float]
x952
}
if (x949) {
x954thenb()
} else {
x954elseb()
}
}
x954
}
if (x892) {
x956thenb()
} else {
x956elseb()
}
}
x956
}
if (x889) {
x958thenb()
} else {
x958elseb()
}
}
x958
}
if (x885) {
x960thenb()
} else {
x960elseb()
}
}
val x961 = x960 > 0.82f
val x980 = {
def x980thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x962 = x882.rect
val x964 = x962.width
val x807 = x796
val x808 = Math.pow(2.0,x807)
val x809 = x808.asInstanceOf[Int]
val x963 = x809 * x806
val x965 = x964 / 2
val x966 = x963 - x965
val x967 = x966.asInstanceOf[Int]
val x969 = x962.height
val x968 = x809 * x802
val x970 = x969 / 2
val x971 = x968 - x970
val x972 = x971.asInstanceOf[Int]
val x973 = new generated.scala.Rect(x967,x972,x964,x969)
val x974 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x975 = new generated.scala.BiGGDetection(x789,x960,x973,null,x881,x806,x802,x882,x813)
val x976 = x974(0) = x975
x974
}
def x980elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x978 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x978
}
if (x961) {
x980thenb()
} else {
x980elseb()
}
}
x980
}
var mapReduceIdx = 1
while (mapReduceIdx < x880.size) {
val x881 = x880.dcApply(mapReduceIdx)
val x983 = {
val x882 = x790(x881)
val x883 = x882.radius
val x885 = x883 != x884
val x960 = {
def x960thenb(): Float = {
-1.0f
}
def x960elseb(): Float = {
val x886 = x882.match_list
val x887 = x886.length
val x888 = x887.asInstanceOf[Float]
val x889 = x888==0.0
val x958 = {
def x958thenb(): Float = {
-1.0f
}
def x958elseb(): Float = {
val x890 = x866.asInstanceOf[Float]
val x891 = x890 / x888
val x892 = x891 < 0.82f
val x956 = {
def x956thenb(): Float = {
x891
}
def x956elseb(): Float = {
var x893 = 0.0f
val x894 = x888 * 0.18f
val x895 = x894 + 0.5f
val x896 = x895.asInstanceOf[Int]
var x897 = x896
var x898 = 0
var x899 = true
val x907 = x882.binary_gradients
val x947 = while ({val x900 = x898
val x902 = x899
val x901 = x900 < x887
val x903 = x901 && x902
x903}) {
val x905 = x898
val x908 = x898
val x912 = x898
val x909 = x886(x908)
val x910 = x907(x909)
val x911 = x910==0
val x913 = x886(x912)
val x914 = x857(x913)
val x915 = x914==0
val x916 = x911 && x915
val x944 = {
def x944thenb(): Unit = {
val x917 = x893
val x918 = x917 + 1.0f
x893 = x918
()
}
def x944elseb(): Unit = {
val x921 = x898
val x924 = x898
val x922 = x886(x921)
val x923 = x907(x922)
val x925 = x886(x924)
val x926 = x857(x925)
val x927 = x923 & x926
val x928 = x927 > 0
val x942 = {
def x942thenb(): Unit = {
val x929 = x893
val x930 = x929 + 1.0f
x893 = x930
()
}
def x942elseb(): Unit = {
val x933 = x897
val x934 = x933 - 1
x897 = x934
val x936 = x897
val x937 = x936 <= 0
val x940 = {
def x940thenb(): Unit = {
x899 = false
()
}
def x940elseb(): Unit = {
()
}
if (x937) {
x940thenb()
} else {
x940elseb()
}
}
x940
}
if (x928) {
x942thenb()
} else {
x942elseb()
}
}
x942
}
if (x916) {
x944thenb()
} else {
x944elseb()
}
}
val x945 = x898 += 1
()
}
val x948 = x899
val x949 = !x948
val x954 = {
def x954thenb(): Float = {
0.819999f
}
def x954elseb(): Float = {
val x950 = x893
val x951 = x950 / x888
val x952 = x951.asInstanceOf[Float]
x952
}
if (x949) {
x954thenb()
} else {
x954elseb()
}
}
x954
}
if (x892) {
x956thenb()
} else {
x956elseb()
}
}
x956
}
if (x889) {
x958thenb()
} else {
x958elseb()
}
}
x958
}
if (x885) {
x960thenb()
} else {
x960elseb()
}
}
val x961 = x960 > 0.82f
val x980 = {
def x980thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x962 = x882.rect
val x964 = x962.width
val x807 = x796
val x808 = Math.pow(2.0,x807)
val x809 = x808.asInstanceOf[Int]
val x963 = x809 * x806
val x965 = x964 / 2
val x966 = x963 - x965
val x967 = x966.asInstanceOf[Int]
val x969 = x962.height
val x968 = x809 * x802
val x970 = x969 / 2
val x971 = x968 - x970
val x972 = x971.asInstanceOf[Int]
val x973 = new generated.scala.Rect(x967,x972,x964,x969)
val x974 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x975 = new generated.scala.BiGGDetection(x789,x960,x973,null,x881,x806,x802,x882,x813)
val x976 = x974(0) = x975
x974
}
def x980elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x978 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x978
}
if (x961) {
x980thenb()
} else {
x980elseb()
}
}
x980
}
x982 = {
val x984 = x982.isRow
val x985 = x983.isRow
val x986 = x984 != x985
val x990 = x982.length
val x991 = x983.length
val x992 = x990 + x991
def x1008_block = { 
val x989 = {
def x989thenb(): Unit = {
val x987 = println("error: trying to concatenate row and column vectors")
x987
}
def x989elseb(): Unit = {
()
}
if (x986) {
x989thenb()
} else {
x989elseb()
}
}
val x993 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x992,x984)
var x995 : Int = 0
val x999 = while (x995 < x990) {
val x996 = x982(x995)
val x997 = x993(x995) = x996
x997
x995 = x995 + 1
}
var x1001 : Int = 0
val x1006 = while (x1001 < x991) {
val x1002 = x1001 + x990
val x1003 = x983(x1001)
val x1004 = x993(x1002) = x1003
x1004
x1001 = x1001 + 1
}
x993
}
val x1008 = x1008_block
x1008
}
mapReduceIdx += 1
} // end while
x982
}
val x1009 = x1009_block
x1009
}
var mapReduceIdx = 1
while (mapReduceIdx < x805.size) {
val x806 = x805.dcApply(mapReduceIdx)
val x1012 = {
val x810 = new generated.scala.IntVectorImpl(900,false)
val x811 = new generated.scala.IntVectorImpl(0,true)
val x812 = new generated.scala.IndexVectorSeqImpl(x811)
val x813 = new generated.scala.BinarizedGradientTemplate(15,null,null,x796,x810,x812,null,null,null)
var x836 = x831
val x814 = x806 - 15
val x815 = x814 < 0
val x819 = {
def x819thenb(): scala.Tuple2[Int, Int] = {
val x816 = 15 - x806
val x817 = (0,x816)
x817
}
def x819elseb(): scala.Tuple2[Int, Int] = {
val x818 = (x814,0)
x818
}
if (x815) {
x819thenb()
} else {
x819elseb()
}
}
val x820 = x819._1
val x822 = x806 + 15
val x823 = x822 > x803
val x824 = {
def x824thenb(): Int = {
x803
}
def x824elseb(): Int = {
x822
}
if (x823) {
x824thenb()
} else {
x824elseb()
}
}
val x821 = x819._2
val x857 = x813.binary_gradients
val x865 = x813.match_list
val x866 = x865.length
val x875 = while ({val x837 = x836
val x838 = x837 < x835
x838}) {
val x840 = x836
var x844 = x820
val x872 = while ({val x845 = x844
val x846 = x845 < x824
x846}) {
val x848 = x836
val x852 = x844
val x849 = x832 + x848
val x850 = x849 - x831
val x851 = x850 * 30
val x853 = x821 + x852
val x854 = x853 - x820
val x855 = x851 + x854
var x856 = x855
val x858 = x856
val x859 = x844
val x860 = x798(x840, x859)
val x861 = x857(x858) = x860
val x862 = x844
val x863 = x798(x840, x862)
val x864 = x863 > 0
val x869 = {
def x869thenb(): Unit = {
val x867 = x865.insert(x866, x858)
x867
}
def x869elseb(): Unit = {
()
}
if (x864) {
x869thenb()
} else {
x869elseb()
}
}
val x870 = x844 += 1
()
}
val x873 = x836 += 1
()
}
val x876 = x866 < 0
val x879 = {
def x879thenb(): Unit = {
val x877 = println("dummy")
x877
}
def x879elseb(): Unit = {
()
}
if (x876) {
x879thenb()
} else {
x879elseb()
}
}
val x884 = x813.radius
def x1009_block = {
val x881 = x880.dcApply(0)
var x982 = {
val x882 = x790(x881)
val x883 = x882.radius
val x885 = x883 != x884
val x960 = {
def x960thenb(): Float = {
-1.0f
}
def x960elseb(): Float = {
val x886 = x882.match_list
val x887 = x886.length
val x888 = x887.asInstanceOf[Float]
val x889 = x888==0.0
val x958 = {
def x958thenb(): Float = {
-1.0f
}
def x958elseb(): Float = {
val x890 = x866.asInstanceOf[Float]
val x891 = x890 / x888
val x892 = x891 < 0.82f
val x956 = {
def x956thenb(): Float = {
x891
}
def x956elseb(): Float = {
var x893 = 0.0f
val x894 = x888 * 0.18f
val x895 = x894 + 0.5f
val x896 = x895.asInstanceOf[Int]
var x897 = x896
var x898 = 0
var x899 = true
val x907 = x882.binary_gradients
val x947 = while ({val x900 = x898
val x902 = x899
val x901 = x900 < x887
val x903 = x901 && x902
x903}) {
val x905 = x898
val x908 = x898
val x912 = x898
val x909 = x886(x908)
val x910 = x907(x909)
val x911 = x910==0
val x913 = x886(x912)
val x914 = x857(x913)
val x915 = x914==0
val x916 = x911 && x915
val x944 = {
def x944thenb(): Unit = {
val x917 = x893
val x918 = x917 + 1.0f
x893 = x918
()
}
def x944elseb(): Unit = {
val x921 = x898
val x924 = x898
val x922 = x886(x921)
val x923 = x907(x922)
val x925 = x886(x924)
val x926 = x857(x925)
val x927 = x923 & x926
val x928 = x927 > 0
val x942 = {
def x942thenb(): Unit = {
val x929 = x893
val x930 = x929 + 1.0f
x893 = x930
()
}
def x942elseb(): Unit = {
val x933 = x897
val x934 = x933 - 1
x897 = x934
val x936 = x897
val x937 = x936 <= 0
val x940 = {
def x940thenb(): Unit = {
x899 = false
()
}
def x940elseb(): Unit = {
()
}
if (x937) {
x940thenb()
} else {
x940elseb()
}
}
x940
}
if (x928) {
x942thenb()
} else {
x942elseb()
}
}
x942
}
if (x916) {
x944thenb()
} else {
x944elseb()
}
}
val x945 = x898 += 1
()
}
val x948 = x899
val x949 = !x948
val x954 = {
def x954thenb(): Float = {
0.819999f
}
def x954elseb(): Float = {
val x950 = x893
val x951 = x950 / x888
val x952 = x951.asInstanceOf[Float]
x952
}
if (x949) {
x954thenb()
} else {
x954elseb()
}
}
x954
}
if (x892) {
x956thenb()
} else {
x956elseb()
}
}
x956
}
if (x889) {
x958thenb()
} else {
x958elseb()
}
}
x958
}
if (x885) {
x960thenb()
} else {
x960elseb()
}
}
val x961 = x960 > 0.82f
val x980 = {
def x980thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x962 = x882.rect
val x964 = x962.width
val x807 = x796
val x808 = Math.pow(2.0,x807)
val x809 = x808.asInstanceOf[Int]
val x963 = x809 * x806
val x965 = x964 / 2
val x966 = x963 - x965
val x967 = x966.asInstanceOf[Int]
val x969 = x962.height
val x968 = x809 * x802
val x970 = x969 / 2
val x971 = x968 - x970
val x972 = x971.asInstanceOf[Int]
val x973 = new generated.scala.Rect(x967,x972,x964,x969)
val x974 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x975 = new generated.scala.BiGGDetection(x789,x960,x973,null,x881,x806,x802,x882,x813)
val x976 = x974(0) = x975
x974
}
def x980elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x978 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x978
}
if (x961) {
x980thenb()
} else {
x980elseb()
}
}
x980
}
var mapReduceIdx = 1
while (mapReduceIdx < x880.size) {
val x881 = x880.dcApply(mapReduceIdx)
val x983 = {
val x882 = x790(x881)
val x883 = x882.radius
val x885 = x883 != x884
val x960 = {
def x960thenb(): Float = {
-1.0f
}
def x960elseb(): Float = {
val x886 = x882.match_list
val x887 = x886.length
val x888 = x887.asInstanceOf[Float]
val x889 = x888==0.0
val x958 = {
def x958thenb(): Float = {
-1.0f
}
def x958elseb(): Float = {
val x890 = x866.asInstanceOf[Float]
val x891 = x890 / x888
val x892 = x891 < 0.82f
val x956 = {
def x956thenb(): Float = {
x891
}
def x956elseb(): Float = {
var x893 = 0.0f
val x894 = x888 * 0.18f
val x895 = x894 + 0.5f
val x896 = x895.asInstanceOf[Int]
var x897 = x896
var x898 = 0
var x899 = true
val x907 = x882.binary_gradients
val x947 = while ({val x900 = x898
val x902 = x899
val x901 = x900 < x887
val x903 = x901 && x902
x903}) {
val x905 = x898
val x908 = x898
val x912 = x898
val x909 = x886(x908)
val x910 = x907(x909)
val x911 = x910==0
val x913 = x886(x912)
val x914 = x857(x913)
val x915 = x914==0
val x916 = x911 && x915
val x944 = {
def x944thenb(): Unit = {
val x917 = x893
val x918 = x917 + 1.0f
x893 = x918
()
}
def x944elseb(): Unit = {
val x921 = x898
val x924 = x898
val x922 = x886(x921)
val x923 = x907(x922)
val x925 = x886(x924)
val x926 = x857(x925)
val x927 = x923 & x926
val x928 = x927 > 0
val x942 = {
def x942thenb(): Unit = {
val x929 = x893
val x930 = x929 + 1.0f
x893 = x930
()
}
def x942elseb(): Unit = {
val x933 = x897
val x934 = x933 - 1
x897 = x934
val x936 = x897
val x937 = x936 <= 0
val x940 = {
def x940thenb(): Unit = {
x899 = false
()
}
def x940elseb(): Unit = {
()
}
if (x937) {
x940thenb()
} else {
x940elseb()
}
}
x940
}
if (x928) {
x942thenb()
} else {
x942elseb()
}
}
x942
}
if (x916) {
x944thenb()
} else {
x944elseb()
}
}
val x945 = x898 += 1
()
}
val x948 = x899
val x949 = !x948
val x954 = {
def x954thenb(): Float = {
0.819999f
}
def x954elseb(): Float = {
val x950 = x893
val x951 = x950 / x888
val x952 = x951.asInstanceOf[Float]
x952
}
if (x949) {
x954thenb()
} else {
x954elseb()
}
}
x954
}
if (x892) {
x956thenb()
} else {
x956elseb()
}
}
x956
}
if (x889) {
x958thenb()
} else {
x958elseb()
}
}
x958
}
if (x885) {
x960thenb()
} else {
x960elseb()
}
}
val x961 = x960 > 0.82f
val x980 = {
def x980thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x962 = x882.rect
val x964 = x962.width
val x807 = x796
val x808 = Math.pow(2.0,x807)
val x809 = x808.asInstanceOf[Int]
val x963 = x809 * x806
val x965 = x964 / 2
val x966 = x963 - x965
val x967 = x966.asInstanceOf[Int]
val x969 = x962.height
val x968 = x809 * x802
val x970 = x969 / 2
val x971 = x968 - x970
val x972 = x971.asInstanceOf[Int]
val x973 = new generated.scala.Rect(x967,x972,x964,x969)
val x974 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x975 = new generated.scala.BiGGDetection(x789,x960,x973,null,x881,x806,x802,x882,x813)
val x976 = x974(0) = x975
x974
}
def x980elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x978 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x978
}
if (x961) {
x980thenb()
} else {
x980elseb()
}
}
x980
}
x982 = {
val x984 = x982.isRow
val x985 = x983.isRow
val x986 = x984 != x985
val x990 = x982.length
val x991 = x983.length
val x992 = x990 + x991
def x1008_block = { 
val x989 = {
def x989thenb(): Unit = {
val x987 = println("error: trying to concatenate row and column vectors")
x987
}
def x989elseb(): Unit = {
()
}
if (x986) {
x989thenb()
} else {
x989elseb()
}
}
val x993 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x992,x984)
var x995 : Int = 0
val x999 = while (x995 < x990) {
val x996 = x982(x995)
val x997 = x993(x995) = x996
x997
x995 = x995 + 1
}
var x1001 : Int = 0
val x1006 = while (x1001 < x991) {
val x1002 = x1001 + x990
val x1003 = x983(x1001)
val x1004 = x993(x1002) = x1003
x1004
x1001 = x1001 + 1
}
x993
}
val x1008 = x1008_block
x1008
}
mapReduceIdx += 1
} // end while
x982
}
val x1009 = x1009_block
x1009
}
x1011 = {
val x1013 = x1011.isRow
val x1014 = x1012.isRow
val x1015 = x1013 != x1014
val x1019 = x1011.length
val x1020 = x1012.length
val x1021 = x1019 + x1020
def x1037_block = { 
val x1018 = {
def x1018thenb(): Unit = {
val x1016 = println("error: trying to concatenate row and column vectors")
x1016
}
def x1018elseb(): Unit = {
()
}
if (x1015) {
x1018thenb()
} else {
x1018elseb()
}
}
val x1022 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1021,x1013)
var x1024 : Int = 0
val x1028 = while (x1024 < x1019) {
val x1025 = x1011(x1024)
val x1026 = x1022(x1024) = x1025
x1026
x1024 = x1024 + 1
}
var x1030 : Int = 0
val x1035 = while (x1030 < x1020) {
val x1031 = x1030 + x1019
val x1032 = x1012(x1030)
val x1033 = x1022(x1031) = x1032
x1033
x1030 = x1030 + 1
}
x1022
}
val x1037 = x1037_block
x1037
}
mapReduceIdx += 1
} // end while
x1011
}
val x1038 = x1038_block
x1038
}
var mapReduceIdx = 1
while (mapReduceIdx < x801.size) {
val x802 = x801.dcApply(mapReduceIdx)
val x1040 = {
val x825 = x802 - 15
val x826 = x825 < 0
val x830 = {
def x830thenb(): scala.Tuple2[Int, Int] = {
val x827 = 15 - x802
val x828 = (0,x827)
x828
}
def x830elseb(): scala.Tuple2[Int, Int] = {
val x829 = (x825,0)
x829
}
if (x826) {
x830thenb()
} else {
x830elseb()
}
}
val x831 = x830._1
val x833 = x802 + 15
val x834 = x833 > x799
val x835 = {
def x835thenb(): Int = {
x799
}
def x835elseb(): Int = {
x833
}
if (x834) {
x835thenb()
} else {
x835elseb()
}
}
val x832 = x830._2
def x1038_block = {
val x806 = x805.dcApply(0)
var x1011 = {
val x810 = new generated.scala.IntVectorImpl(900,false)
val x811 = new generated.scala.IntVectorImpl(0,true)
val x812 = new generated.scala.IndexVectorSeqImpl(x811)
val x813 = new generated.scala.BinarizedGradientTemplate(15,null,null,x796,x810,x812,null,null,null)
var x836 = x831
val x814 = x806 - 15
val x815 = x814 < 0
val x819 = {
def x819thenb(): scala.Tuple2[Int, Int] = {
val x816 = 15 - x806
val x817 = (0,x816)
x817
}
def x819elseb(): scala.Tuple2[Int, Int] = {
val x818 = (x814,0)
x818
}
if (x815) {
x819thenb()
} else {
x819elseb()
}
}
val x820 = x819._1
val x822 = x806 + 15
val x823 = x822 > x803
val x824 = {
def x824thenb(): Int = {
x803
}
def x824elseb(): Int = {
x822
}
if (x823) {
x824thenb()
} else {
x824elseb()
}
}
val x821 = x819._2
val x857 = x813.binary_gradients
val x865 = x813.match_list
val x866 = x865.length
val x875 = while ({val x837 = x836
val x838 = x837 < x835
x838}) {
val x840 = x836
var x844 = x820
val x872 = while ({val x845 = x844
val x846 = x845 < x824
x846}) {
val x848 = x836
val x852 = x844
val x849 = x832 + x848
val x850 = x849 - x831
val x851 = x850 * 30
val x853 = x821 + x852
val x854 = x853 - x820
val x855 = x851 + x854
var x856 = x855
val x858 = x856
val x859 = x844
val x860 = x798(x840, x859)
val x861 = x857(x858) = x860
val x862 = x844
val x863 = x798(x840, x862)
val x864 = x863 > 0
val x869 = {
def x869thenb(): Unit = {
val x867 = x865.insert(x866, x858)
x867
}
def x869elseb(): Unit = {
()
}
if (x864) {
x869thenb()
} else {
x869elseb()
}
}
val x870 = x844 += 1
()
}
val x873 = x836 += 1
()
}
val x876 = x866 < 0
val x879 = {
def x879thenb(): Unit = {
val x877 = println("dummy")
x877
}
def x879elseb(): Unit = {
()
}
if (x876) {
x879thenb()
} else {
x879elseb()
}
}
val x884 = x813.radius
def x1009_block = {
val x881 = x880.dcApply(0)
var x982 = {
val x882 = x790(x881)
val x883 = x882.radius
val x885 = x883 != x884
val x960 = {
def x960thenb(): Float = {
-1.0f
}
def x960elseb(): Float = {
val x886 = x882.match_list
val x887 = x886.length
val x888 = x887.asInstanceOf[Float]
val x889 = x888==0.0
val x958 = {
def x958thenb(): Float = {
-1.0f
}
def x958elseb(): Float = {
val x890 = x866.asInstanceOf[Float]
val x891 = x890 / x888
val x892 = x891 < 0.82f
val x956 = {
def x956thenb(): Float = {
x891
}
def x956elseb(): Float = {
var x893 = 0.0f
val x894 = x888 * 0.18f
val x895 = x894 + 0.5f
val x896 = x895.asInstanceOf[Int]
var x897 = x896
var x898 = 0
var x899 = true
val x907 = x882.binary_gradients
val x947 = while ({val x900 = x898
val x902 = x899
val x901 = x900 < x887
val x903 = x901 && x902
x903}) {
val x905 = x898
val x908 = x898
val x912 = x898
val x909 = x886(x908)
val x910 = x907(x909)
val x911 = x910==0
val x913 = x886(x912)
val x914 = x857(x913)
val x915 = x914==0
val x916 = x911 && x915
val x944 = {
def x944thenb(): Unit = {
val x917 = x893
val x918 = x917 + 1.0f
x893 = x918
()
}
def x944elseb(): Unit = {
val x921 = x898
val x924 = x898
val x922 = x886(x921)
val x923 = x907(x922)
val x925 = x886(x924)
val x926 = x857(x925)
val x927 = x923 & x926
val x928 = x927 > 0
val x942 = {
def x942thenb(): Unit = {
val x929 = x893
val x930 = x929 + 1.0f
x893 = x930
()
}
def x942elseb(): Unit = {
val x933 = x897
val x934 = x933 - 1
x897 = x934
val x936 = x897
val x937 = x936 <= 0
val x940 = {
def x940thenb(): Unit = {
x899 = false
()
}
def x940elseb(): Unit = {
()
}
if (x937) {
x940thenb()
} else {
x940elseb()
}
}
x940
}
if (x928) {
x942thenb()
} else {
x942elseb()
}
}
x942
}
if (x916) {
x944thenb()
} else {
x944elseb()
}
}
val x945 = x898 += 1
()
}
val x948 = x899
val x949 = !x948
val x954 = {
def x954thenb(): Float = {
0.819999f
}
def x954elseb(): Float = {
val x950 = x893
val x951 = x950 / x888
val x952 = x951.asInstanceOf[Float]
x952
}
if (x949) {
x954thenb()
} else {
x954elseb()
}
}
x954
}
if (x892) {
x956thenb()
} else {
x956elseb()
}
}
x956
}
if (x889) {
x958thenb()
} else {
x958elseb()
}
}
x958
}
if (x885) {
x960thenb()
} else {
x960elseb()
}
}
val x961 = x960 > 0.82f
val x980 = {
def x980thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x962 = x882.rect
val x964 = x962.width
val x807 = x796
val x808 = Math.pow(2.0,x807)
val x809 = x808.asInstanceOf[Int]
val x963 = x809 * x806
val x965 = x964 / 2
val x966 = x963 - x965
val x967 = x966.asInstanceOf[Int]
val x969 = x962.height
val x968 = x809 * x802
val x970 = x969 / 2
val x971 = x968 - x970
val x972 = x971.asInstanceOf[Int]
val x973 = new generated.scala.Rect(x967,x972,x964,x969)
val x974 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x975 = new generated.scala.BiGGDetection(x789,x960,x973,null,x881,x806,x802,x882,x813)
val x976 = x974(0) = x975
x974
}
def x980elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x978 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x978
}
if (x961) {
x980thenb()
} else {
x980elseb()
}
}
x980
}
var mapReduceIdx = 1
while (mapReduceIdx < x880.size) {
val x881 = x880.dcApply(mapReduceIdx)
val x983 = {
val x882 = x790(x881)
val x883 = x882.radius
val x885 = x883 != x884
val x960 = {
def x960thenb(): Float = {
-1.0f
}
def x960elseb(): Float = {
val x886 = x882.match_list
val x887 = x886.length
val x888 = x887.asInstanceOf[Float]
val x889 = x888==0.0
val x958 = {
def x958thenb(): Float = {
-1.0f
}
def x958elseb(): Float = {
val x890 = x866.asInstanceOf[Float]
val x891 = x890 / x888
val x892 = x891 < 0.82f
val x956 = {
def x956thenb(): Float = {
x891
}
def x956elseb(): Float = {
var x893 = 0.0f
val x894 = x888 * 0.18f
val x895 = x894 + 0.5f
val x896 = x895.asInstanceOf[Int]
var x897 = x896
var x898 = 0
var x899 = true
val x907 = x882.binary_gradients
val x947 = while ({val x900 = x898
val x902 = x899
val x901 = x900 < x887
val x903 = x901 && x902
x903}) {
val x905 = x898
val x908 = x898
val x912 = x898
val x909 = x886(x908)
val x910 = x907(x909)
val x911 = x910==0
val x913 = x886(x912)
val x914 = x857(x913)
val x915 = x914==0
val x916 = x911 && x915
val x944 = {
def x944thenb(): Unit = {
val x917 = x893
val x918 = x917 + 1.0f
x893 = x918
()
}
def x944elseb(): Unit = {
val x921 = x898
val x924 = x898
val x922 = x886(x921)
val x923 = x907(x922)
val x925 = x886(x924)
val x926 = x857(x925)
val x927 = x923 & x926
val x928 = x927 > 0
val x942 = {
def x942thenb(): Unit = {
val x929 = x893
val x930 = x929 + 1.0f
x893 = x930
()
}
def x942elseb(): Unit = {
val x933 = x897
val x934 = x933 - 1
x897 = x934
val x936 = x897
val x937 = x936 <= 0
val x940 = {
def x940thenb(): Unit = {
x899 = false
()
}
def x940elseb(): Unit = {
()
}
if (x937) {
x940thenb()
} else {
x940elseb()
}
}
x940
}
if (x928) {
x942thenb()
} else {
x942elseb()
}
}
x942
}
if (x916) {
x944thenb()
} else {
x944elseb()
}
}
val x945 = x898 += 1
()
}
val x948 = x899
val x949 = !x948
val x954 = {
def x954thenb(): Float = {
0.819999f
}
def x954elseb(): Float = {
val x950 = x893
val x951 = x950 / x888
val x952 = x951.asInstanceOf[Float]
x952
}
if (x949) {
x954thenb()
} else {
x954elseb()
}
}
x954
}
if (x892) {
x956thenb()
} else {
x956elseb()
}
}
x956
}
if (x889) {
x958thenb()
} else {
x958elseb()
}
}
x958
}
if (x885) {
x960thenb()
} else {
x960elseb()
}
}
val x961 = x960 > 0.82f
val x980 = {
def x980thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x962 = x882.rect
val x964 = x962.width
val x807 = x796
val x808 = Math.pow(2.0,x807)
val x809 = x808.asInstanceOf[Int]
val x963 = x809 * x806
val x965 = x964 / 2
val x966 = x963 - x965
val x967 = x966.asInstanceOf[Int]
val x969 = x962.height
val x968 = x809 * x802
val x970 = x969 / 2
val x971 = x968 - x970
val x972 = x971.asInstanceOf[Int]
val x973 = new generated.scala.Rect(x967,x972,x964,x969)
val x974 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x975 = new generated.scala.BiGGDetection(x789,x960,x973,null,x881,x806,x802,x882,x813)
val x976 = x974(0) = x975
x974
}
def x980elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x978 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x978
}
if (x961) {
x980thenb()
} else {
x980elseb()
}
}
x980
}
x982 = {
val x984 = x982.isRow
val x985 = x983.isRow
val x986 = x984 != x985
val x990 = x982.length
val x991 = x983.length
val x992 = x990 + x991
def x1008_block = { 
val x989 = {
def x989thenb(): Unit = {
val x987 = println("error: trying to concatenate row and column vectors")
x987
}
def x989elseb(): Unit = {
()
}
if (x986) {
x989thenb()
} else {
x989elseb()
}
}
val x993 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x992,x984)
var x995 : Int = 0
val x999 = while (x995 < x990) {
val x996 = x982(x995)
val x997 = x993(x995) = x996
x997
x995 = x995 + 1
}
var x1001 : Int = 0
val x1006 = while (x1001 < x991) {
val x1002 = x1001 + x990
val x1003 = x983(x1001)
val x1004 = x993(x1002) = x1003
x1004
x1001 = x1001 + 1
}
x993
}
val x1008 = x1008_block
x1008
}
mapReduceIdx += 1
} // end while
x982
}
val x1009 = x1009_block
x1009
}
var mapReduceIdx = 1
while (mapReduceIdx < x805.size) {
val x806 = x805.dcApply(mapReduceIdx)
val x1012 = {
val x810 = new generated.scala.IntVectorImpl(900,false)
val x811 = new generated.scala.IntVectorImpl(0,true)
val x812 = new generated.scala.IndexVectorSeqImpl(x811)
val x813 = new generated.scala.BinarizedGradientTemplate(15,null,null,x796,x810,x812,null,null,null)
var x836 = x831
val x814 = x806 - 15
val x815 = x814 < 0
val x819 = {
def x819thenb(): scala.Tuple2[Int, Int] = {
val x816 = 15 - x806
val x817 = (0,x816)
x817
}
def x819elseb(): scala.Tuple2[Int, Int] = {
val x818 = (x814,0)
x818
}
if (x815) {
x819thenb()
} else {
x819elseb()
}
}
val x820 = x819._1
val x822 = x806 + 15
val x823 = x822 > x803
val x824 = {
def x824thenb(): Int = {
x803
}
def x824elseb(): Int = {
x822
}
if (x823) {
x824thenb()
} else {
x824elseb()
}
}
val x821 = x819._2
val x857 = x813.binary_gradients
val x865 = x813.match_list
val x866 = x865.length
val x875 = while ({val x837 = x836
val x838 = x837 < x835
x838}) {
val x840 = x836
var x844 = x820
val x872 = while ({val x845 = x844
val x846 = x845 < x824
x846}) {
val x848 = x836
val x852 = x844
val x849 = x832 + x848
val x850 = x849 - x831
val x851 = x850 * 30
val x853 = x821 + x852
val x854 = x853 - x820
val x855 = x851 + x854
var x856 = x855
val x858 = x856
val x859 = x844
val x860 = x798(x840, x859)
val x861 = x857(x858) = x860
val x862 = x844
val x863 = x798(x840, x862)
val x864 = x863 > 0
val x869 = {
def x869thenb(): Unit = {
val x867 = x865.insert(x866, x858)
x867
}
def x869elseb(): Unit = {
()
}
if (x864) {
x869thenb()
} else {
x869elseb()
}
}
val x870 = x844 += 1
()
}
val x873 = x836 += 1
()
}
val x876 = x866 < 0
val x879 = {
def x879thenb(): Unit = {
val x877 = println("dummy")
x877
}
def x879elseb(): Unit = {
()
}
if (x876) {
x879thenb()
} else {
x879elseb()
}
}
val x884 = x813.radius
def x1009_block = {
val x881 = x880.dcApply(0)
var x982 = {
val x882 = x790(x881)
val x883 = x882.radius
val x885 = x883 != x884
val x960 = {
def x960thenb(): Float = {
-1.0f
}
def x960elseb(): Float = {
val x886 = x882.match_list
val x887 = x886.length
val x888 = x887.asInstanceOf[Float]
val x889 = x888==0.0
val x958 = {
def x958thenb(): Float = {
-1.0f
}
def x958elseb(): Float = {
val x890 = x866.asInstanceOf[Float]
val x891 = x890 / x888
val x892 = x891 < 0.82f
val x956 = {
def x956thenb(): Float = {
x891
}
def x956elseb(): Float = {
var x893 = 0.0f
val x894 = x888 * 0.18f
val x895 = x894 + 0.5f
val x896 = x895.asInstanceOf[Int]
var x897 = x896
var x898 = 0
var x899 = true
val x907 = x882.binary_gradients
val x947 = while ({val x900 = x898
val x902 = x899
val x901 = x900 < x887
val x903 = x901 && x902
x903}) {
val x905 = x898
val x908 = x898
val x912 = x898
val x909 = x886(x908)
val x910 = x907(x909)
val x911 = x910==0
val x913 = x886(x912)
val x914 = x857(x913)
val x915 = x914==0
val x916 = x911 && x915
val x944 = {
def x944thenb(): Unit = {
val x917 = x893
val x918 = x917 + 1.0f
x893 = x918
()
}
def x944elseb(): Unit = {
val x921 = x898
val x924 = x898
val x922 = x886(x921)
val x923 = x907(x922)
val x925 = x886(x924)
val x926 = x857(x925)
val x927 = x923 & x926
val x928 = x927 > 0
val x942 = {
def x942thenb(): Unit = {
val x929 = x893
val x930 = x929 + 1.0f
x893 = x930
()
}
def x942elseb(): Unit = {
val x933 = x897
val x934 = x933 - 1
x897 = x934
val x936 = x897
val x937 = x936 <= 0
val x940 = {
def x940thenb(): Unit = {
x899 = false
()
}
def x940elseb(): Unit = {
()
}
if (x937) {
x940thenb()
} else {
x940elseb()
}
}
x940
}
if (x928) {
x942thenb()
} else {
x942elseb()
}
}
x942
}
if (x916) {
x944thenb()
} else {
x944elseb()
}
}
val x945 = x898 += 1
()
}
val x948 = x899
val x949 = !x948
val x954 = {
def x954thenb(): Float = {
0.819999f
}
def x954elseb(): Float = {
val x950 = x893
val x951 = x950 / x888
val x952 = x951.asInstanceOf[Float]
x952
}
if (x949) {
x954thenb()
} else {
x954elseb()
}
}
x954
}
if (x892) {
x956thenb()
} else {
x956elseb()
}
}
x956
}
if (x889) {
x958thenb()
} else {
x958elseb()
}
}
x958
}
if (x885) {
x960thenb()
} else {
x960elseb()
}
}
val x961 = x960 > 0.82f
val x980 = {
def x980thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x962 = x882.rect
val x964 = x962.width
val x807 = x796
val x808 = Math.pow(2.0,x807)
val x809 = x808.asInstanceOf[Int]
val x963 = x809 * x806
val x965 = x964 / 2
val x966 = x963 - x965
val x967 = x966.asInstanceOf[Int]
val x969 = x962.height
val x968 = x809 * x802
val x970 = x969 / 2
val x971 = x968 - x970
val x972 = x971.asInstanceOf[Int]
val x973 = new generated.scala.Rect(x967,x972,x964,x969)
val x974 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x975 = new generated.scala.BiGGDetection(x789,x960,x973,null,x881,x806,x802,x882,x813)
val x976 = x974(0) = x975
x974
}
def x980elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x978 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x978
}
if (x961) {
x980thenb()
} else {
x980elseb()
}
}
x980
}
var mapReduceIdx = 1
while (mapReduceIdx < x880.size) {
val x881 = x880.dcApply(mapReduceIdx)
val x983 = {
val x882 = x790(x881)
val x883 = x882.radius
val x885 = x883 != x884
val x960 = {
def x960thenb(): Float = {
-1.0f
}
def x960elseb(): Float = {
val x886 = x882.match_list
val x887 = x886.length
val x888 = x887.asInstanceOf[Float]
val x889 = x888==0.0
val x958 = {
def x958thenb(): Float = {
-1.0f
}
def x958elseb(): Float = {
val x890 = x866.asInstanceOf[Float]
val x891 = x890 / x888
val x892 = x891 < 0.82f
val x956 = {
def x956thenb(): Float = {
x891
}
def x956elseb(): Float = {
var x893 = 0.0f
val x894 = x888 * 0.18f
val x895 = x894 + 0.5f
val x896 = x895.asInstanceOf[Int]
var x897 = x896
var x898 = 0
var x899 = true
val x907 = x882.binary_gradients
val x947 = while ({val x900 = x898
val x902 = x899
val x901 = x900 < x887
val x903 = x901 && x902
x903}) {
val x905 = x898
val x908 = x898
val x912 = x898
val x909 = x886(x908)
val x910 = x907(x909)
val x911 = x910==0
val x913 = x886(x912)
val x914 = x857(x913)
val x915 = x914==0
val x916 = x911 && x915
val x944 = {
def x944thenb(): Unit = {
val x917 = x893
val x918 = x917 + 1.0f
x893 = x918
()
}
def x944elseb(): Unit = {
val x921 = x898
val x924 = x898
val x922 = x886(x921)
val x923 = x907(x922)
val x925 = x886(x924)
val x926 = x857(x925)
val x927 = x923 & x926
val x928 = x927 > 0
val x942 = {
def x942thenb(): Unit = {
val x929 = x893
val x930 = x929 + 1.0f
x893 = x930
()
}
def x942elseb(): Unit = {
val x933 = x897
val x934 = x933 - 1
x897 = x934
val x936 = x897
val x937 = x936 <= 0
val x940 = {
def x940thenb(): Unit = {
x899 = false
()
}
def x940elseb(): Unit = {
()
}
if (x937) {
x940thenb()
} else {
x940elseb()
}
}
x940
}
if (x928) {
x942thenb()
} else {
x942elseb()
}
}
x942
}
if (x916) {
x944thenb()
} else {
x944elseb()
}
}
val x945 = x898 += 1
()
}
val x948 = x899
val x949 = !x948
val x954 = {
def x954thenb(): Float = {
0.819999f
}
def x954elseb(): Float = {
val x950 = x893
val x951 = x950 / x888
val x952 = x951.asInstanceOf[Float]
x952
}
if (x949) {
x954thenb()
} else {
x954elseb()
}
}
x954
}
if (x892) {
x956thenb()
} else {
x956elseb()
}
}
x956
}
if (x889) {
x958thenb()
} else {
x958elseb()
}
}
x958
}
if (x885) {
x960thenb()
} else {
x960elseb()
}
}
val x961 = x960 > 0.82f
val x980 = {
def x980thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x962 = x882.rect
val x964 = x962.width
val x807 = x796
val x808 = Math.pow(2.0,x807)
val x809 = x808.asInstanceOf[Int]
val x963 = x809 * x806
val x965 = x964 / 2
val x966 = x963 - x965
val x967 = x966.asInstanceOf[Int]
val x969 = x962.height
val x968 = x809 * x802
val x970 = x969 / 2
val x971 = x968 - x970
val x972 = x971.asInstanceOf[Int]
val x973 = new generated.scala.Rect(x967,x972,x964,x969)
val x974 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x975 = new generated.scala.BiGGDetection(x789,x960,x973,null,x881,x806,x802,x882,x813)
val x976 = x974(0) = x975
x974
}
def x980elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x978 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x978
}
if (x961) {
x980thenb()
} else {
x980elseb()
}
}
x980
}
x982 = {
val x984 = x982.isRow
val x985 = x983.isRow
val x986 = x984 != x985
val x990 = x982.length
val x991 = x983.length
val x992 = x990 + x991
def x1008_block = { 
val x989 = {
def x989thenb(): Unit = {
val x987 = println("error: trying to concatenate row and column vectors")
x987
}
def x989elseb(): Unit = {
()
}
if (x986) {
x989thenb()
} else {
x989elseb()
}
}
val x993 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x992,x984)
var x995 : Int = 0
val x999 = while (x995 < x990) {
val x996 = x982(x995)
val x997 = x993(x995) = x996
x997
x995 = x995 + 1
}
var x1001 : Int = 0
val x1006 = while (x1001 < x991) {
val x1002 = x1001 + x990
val x1003 = x983(x1001)
val x1004 = x993(x1002) = x1003
x1004
x1001 = x1001 + 1
}
x993
}
val x1008 = x1008_block
x1008
}
mapReduceIdx += 1
} // end while
x982
}
val x1009 = x1009_block
x1009
}
x1011 = {
val x1013 = x1011.isRow
val x1014 = x1012.isRow
val x1015 = x1013 != x1014
val x1019 = x1011.length
val x1020 = x1012.length
val x1021 = x1019 + x1020
def x1037_block = { 
val x1018 = {
def x1018thenb(): Unit = {
val x1016 = println("error: trying to concatenate row and column vectors")
x1016
}
def x1018elseb(): Unit = {
()
}
if (x1015) {
x1018thenb()
} else {
x1018elseb()
}
}
val x1022 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1021,x1013)
var x1024 : Int = 0
val x1028 = while (x1024 < x1019) {
val x1025 = x1011(x1024)
val x1026 = x1022(x1024) = x1025
x1026
x1024 = x1024 + 1
}
var x1030 : Int = 0
val x1035 = while (x1030 < x1020) {
val x1031 = x1030 + x1019
val x1032 = x1012(x1030)
val x1033 = x1022(x1031) = x1032
x1033
x1030 = x1030 + 1
}
x1022
}
val x1037 = x1037_block
x1037
}
mapReduceIdx += 1
} // end while
x1011
}
val x1038 = x1038_block
x1038
}
x1039 = {
val x1041 = x1039.isRow
val x1042 = x1040.isRow
val x1043 = x1041 != x1042
val x1047 = x1039.length
val x1048 = x1040.length
val x1049 = x1047 + x1048
def x1065_block = { 
val x1046 = {
def x1046thenb(): Unit = {
val x1044 = println("error: trying to concatenate row and column vectors")
x1044
}
def x1046elseb(): Unit = {
()
}
if (x1043) {
x1046thenb()
} else {
x1046elseb()
}
}
val x1050 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1049,x1041)
var x1052 : Int = 0
val x1056 = while (x1052 < x1047) {
val x1053 = x1039(x1052)
val x1054 = x1050(x1052) = x1053
x1054
x1052 = x1052 + 1
}
var x1058 : Int = 0
val x1063 = while (x1058 < x1048) {
val x1059 = x1058 + x1047
val x1060 = x1040(x1058)
val x1061 = x1050(x1059) = x1060
x1061
x1058 = x1058 + 1
}
x1050
}
val x1065 = x1065_block
x1065
}
mapReduceIdx += 1
} // end while
x1039
}
val x1066 = x1066_block
val x1067 = x1066.length
val x1068 = "Detections: "+x1067
val x1069 = println(x1068)
x1066
}
var mapReduceIdx = 1
while (mapReduceIdx < x229.size) {
val x788 = x229.dcApply(mapReduceIdx)
val x1072 = {
val x789 = x788._1
val x791 = "Name: "+x789
val x792 = println(x791)
val x790 = x788._2
val x793 = x790.length
val x794 = "Templates: "+x793
val x795 = println(x794)
val x880 = new generated.scala.IndexVectorRangeImpl(0,x793)
def x1066_block = {
val x802 = x801.dcApply(0)
var x1039 = {
val x825 = x802 - 15
val x826 = x825 < 0
val x830 = {
def x830thenb(): scala.Tuple2[Int, Int] = {
val x827 = 15 - x802
val x828 = (0,x827)
x828
}
def x830elseb(): scala.Tuple2[Int, Int] = {
val x829 = (x825,0)
x829
}
if (x826) {
x830thenb()
} else {
x830elseb()
}
}
val x831 = x830._1
val x833 = x802 + 15
val x834 = x833 > x799
val x835 = {
def x835thenb(): Int = {
x799
}
def x835elseb(): Int = {
x833
}
if (x834) {
x835thenb()
} else {
x835elseb()
}
}
val x832 = x830._2
def x1038_block = {
val x806 = x805.dcApply(0)
var x1011 = {
val x810 = new generated.scala.IntVectorImpl(900,false)
val x811 = new generated.scala.IntVectorImpl(0,true)
val x812 = new generated.scala.IndexVectorSeqImpl(x811)
val x813 = new generated.scala.BinarizedGradientTemplate(15,null,null,x796,x810,x812,null,null,null)
var x836 = x831
val x814 = x806 - 15
val x815 = x814 < 0
val x819 = {
def x819thenb(): scala.Tuple2[Int, Int] = {
val x816 = 15 - x806
val x817 = (0,x816)
x817
}
def x819elseb(): scala.Tuple2[Int, Int] = {
val x818 = (x814,0)
x818
}
if (x815) {
x819thenb()
} else {
x819elseb()
}
}
val x820 = x819._1
val x822 = x806 + 15
val x823 = x822 > x803
val x824 = {
def x824thenb(): Int = {
x803
}
def x824elseb(): Int = {
x822
}
if (x823) {
x824thenb()
} else {
x824elseb()
}
}
val x821 = x819._2
val x857 = x813.binary_gradients
val x865 = x813.match_list
val x866 = x865.length
val x875 = while ({val x837 = x836
val x838 = x837 < x835
x838}) {
val x840 = x836
var x844 = x820
val x872 = while ({val x845 = x844
val x846 = x845 < x824
x846}) {
val x848 = x836
val x852 = x844
val x849 = x832 + x848
val x850 = x849 - x831
val x851 = x850 * 30
val x853 = x821 + x852
val x854 = x853 - x820
val x855 = x851 + x854
var x856 = x855
val x858 = x856
val x859 = x844
val x860 = x798(x840, x859)
val x861 = x857(x858) = x860
val x862 = x844
val x863 = x798(x840, x862)
val x864 = x863 > 0
val x869 = {
def x869thenb(): Unit = {
val x867 = x865.insert(x866, x858)
x867
}
def x869elseb(): Unit = {
()
}
if (x864) {
x869thenb()
} else {
x869elseb()
}
}
val x870 = x844 += 1
()
}
val x873 = x836 += 1
()
}
val x876 = x866 < 0
val x879 = {
def x879thenb(): Unit = {
val x877 = println("dummy")
x877
}
def x879elseb(): Unit = {
()
}
if (x876) {
x879thenb()
} else {
x879elseb()
}
}
val x884 = x813.radius
def x1009_block = {
val x881 = x880.dcApply(0)
var x982 = {
val x882 = x790(x881)
val x883 = x882.radius
val x885 = x883 != x884
val x960 = {
def x960thenb(): Float = {
-1.0f
}
def x960elseb(): Float = {
val x886 = x882.match_list
val x887 = x886.length
val x888 = x887.asInstanceOf[Float]
val x889 = x888==0.0
val x958 = {
def x958thenb(): Float = {
-1.0f
}
def x958elseb(): Float = {
val x890 = x866.asInstanceOf[Float]
val x891 = x890 / x888
val x892 = x891 < 0.82f
val x956 = {
def x956thenb(): Float = {
x891
}
def x956elseb(): Float = {
var x893 = 0.0f
val x894 = x888 * 0.18f
val x895 = x894 + 0.5f
val x896 = x895.asInstanceOf[Int]
var x897 = x896
var x898 = 0
var x899 = true
val x907 = x882.binary_gradients
val x947 = while ({val x900 = x898
val x902 = x899
val x901 = x900 < x887
val x903 = x901 && x902
x903}) {
val x905 = x898
val x908 = x898
val x912 = x898
val x909 = x886(x908)
val x910 = x907(x909)
val x911 = x910==0
val x913 = x886(x912)
val x914 = x857(x913)
val x915 = x914==0
val x916 = x911 && x915
val x944 = {
def x944thenb(): Unit = {
val x917 = x893
val x918 = x917 + 1.0f
x893 = x918
()
}
def x944elseb(): Unit = {
val x921 = x898
val x924 = x898
val x922 = x886(x921)
val x923 = x907(x922)
val x925 = x886(x924)
val x926 = x857(x925)
val x927 = x923 & x926
val x928 = x927 > 0
val x942 = {
def x942thenb(): Unit = {
val x929 = x893
val x930 = x929 + 1.0f
x893 = x930
()
}
def x942elseb(): Unit = {
val x933 = x897
val x934 = x933 - 1
x897 = x934
val x936 = x897
val x937 = x936 <= 0
val x940 = {
def x940thenb(): Unit = {
x899 = false
()
}
def x940elseb(): Unit = {
()
}
if (x937) {
x940thenb()
} else {
x940elseb()
}
}
x940
}
if (x928) {
x942thenb()
} else {
x942elseb()
}
}
x942
}
if (x916) {
x944thenb()
} else {
x944elseb()
}
}
val x945 = x898 += 1
()
}
val x948 = x899
val x949 = !x948
val x954 = {
def x954thenb(): Float = {
0.819999f
}
def x954elseb(): Float = {
val x950 = x893
val x951 = x950 / x888
val x952 = x951.asInstanceOf[Float]
x952
}
if (x949) {
x954thenb()
} else {
x954elseb()
}
}
x954
}
if (x892) {
x956thenb()
} else {
x956elseb()
}
}
x956
}
if (x889) {
x958thenb()
} else {
x958elseb()
}
}
x958
}
if (x885) {
x960thenb()
} else {
x960elseb()
}
}
val x961 = x960 > 0.82f
val x980 = {
def x980thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x962 = x882.rect
val x964 = x962.width
val x807 = x796
val x808 = Math.pow(2.0,x807)
val x809 = x808.asInstanceOf[Int]
val x963 = x809 * x806
val x965 = x964 / 2
val x966 = x963 - x965
val x967 = x966.asInstanceOf[Int]
val x969 = x962.height
val x968 = x809 * x802
val x970 = x969 / 2
val x971 = x968 - x970
val x972 = x971.asInstanceOf[Int]
val x973 = new generated.scala.Rect(x967,x972,x964,x969)
val x974 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x975 = new generated.scala.BiGGDetection(x789,x960,x973,null,x881,x806,x802,x882,x813)
val x976 = x974(0) = x975
x974
}
def x980elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x978 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x978
}
if (x961) {
x980thenb()
} else {
x980elseb()
}
}
x980
}
var mapReduceIdx = 1
while (mapReduceIdx < x880.size) {
val x881 = x880.dcApply(mapReduceIdx)
val x983 = {
val x882 = x790(x881)
val x883 = x882.radius
val x885 = x883 != x884
val x960 = {
def x960thenb(): Float = {
-1.0f
}
def x960elseb(): Float = {
val x886 = x882.match_list
val x887 = x886.length
val x888 = x887.asInstanceOf[Float]
val x889 = x888==0.0
val x958 = {
def x958thenb(): Float = {
-1.0f
}
def x958elseb(): Float = {
val x890 = x866.asInstanceOf[Float]
val x891 = x890 / x888
val x892 = x891 < 0.82f
val x956 = {
def x956thenb(): Float = {
x891
}
def x956elseb(): Float = {
var x893 = 0.0f
val x894 = x888 * 0.18f
val x895 = x894 + 0.5f
val x896 = x895.asInstanceOf[Int]
var x897 = x896
var x898 = 0
var x899 = true
val x907 = x882.binary_gradients
val x947 = while ({val x900 = x898
val x902 = x899
val x901 = x900 < x887
val x903 = x901 && x902
x903}) {
val x905 = x898
val x908 = x898
val x912 = x898
val x909 = x886(x908)
val x910 = x907(x909)
val x911 = x910==0
val x913 = x886(x912)
val x914 = x857(x913)
val x915 = x914==0
val x916 = x911 && x915
val x944 = {
def x944thenb(): Unit = {
val x917 = x893
val x918 = x917 + 1.0f
x893 = x918
()
}
def x944elseb(): Unit = {
val x921 = x898
val x924 = x898
val x922 = x886(x921)
val x923 = x907(x922)
val x925 = x886(x924)
val x926 = x857(x925)
val x927 = x923 & x926
val x928 = x927 > 0
val x942 = {
def x942thenb(): Unit = {
val x929 = x893
val x930 = x929 + 1.0f
x893 = x930
()
}
def x942elseb(): Unit = {
val x933 = x897
val x934 = x933 - 1
x897 = x934
val x936 = x897
val x937 = x936 <= 0
val x940 = {
def x940thenb(): Unit = {
x899 = false
()
}
def x940elseb(): Unit = {
()
}
if (x937) {
x940thenb()
} else {
x940elseb()
}
}
x940
}
if (x928) {
x942thenb()
} else {
x942elseb()
}
}
x942
}
if (x916) {
x944thenb()
} else {
x944elseb()
}
}
val x945 = x898 += 1
()
}
val x948 = x899
val x949 = !x948
val x954 = {
def x954thenb(): Float = {
0.819999f
}
def x954elseb(): Float = {
val x950 = x893
val x951 = x950 / x888
val x952 = x951.asInstanceOf[Float]
x952
}
if (x949) {
x954thenb()
} else {
x954elseb()
}
}
x954
}
if (x892) {
x956thenb()
} else {
x956elseb()
}
}
x956
}
if (x889) {
x958thenb()
} else {
x958elseb()
}
}
x958
}
if (x885) {
x960thenb()
} else {
x960elseb()
}
}
val x961 = x960 > 0.82f
val x980 = {
def x980thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x962 = x882.rect
val x964 = x962.width
val x807 = x796
val x808 = Math.pow(2.0,x807)
val x809 = x808.asInstanceOf[Int]
val x963 = x809 * x806
val x965 = x964 / 2
val x966 = x963 - x965
val x967 = x966.asInstanceOf[Int]
val x969 = x962.height
val x968 = x809 * x802
val x970 = x969 / 2
val x971 = x968 - x970
val x972 = x971.asInstanceOf[Int]
val x973 = new generated.scala.Rect(x967,x972,x964,x969)
val x974 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x975 = new generated.scala.BiGGDetection(x789,x960,x973,null,x881,x806,x802,x882,x813)
val x976 = x974(0) = x975
x974
}
def x980elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x978 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x978
}
if (x961) {
x980thenb()
} else {
x980elseb()
}
}
x980
}
x982 = {
val x984 = x982.isRow
val x985 = x983.isRow
val x986 = x984 != x985
val x990 = x982.length
val x991 = x983.length
val x992 = x990 + x991
def x1008_block = { 
val x989 = {
def x989thenb(): Unit = {
val x987 = println("error: trying to concatenate row and column vectors")
x987
}
def x989elseb(): Unit = {
()
}
if (x986) {
x989thenb()
} else {
x989elseb()
}
}
val x993 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x992,x984)
var x995 : Int = 0
val x999 = while (x995 < x990) {
val x996 = x982(x995)
val x997 = x993(x995) = x996
x997
x995 = x995 + 1
}
var x1001 : Int = 0
val x1006 = while (x1001 < x991) {
val x1002 = x1001 + x990
val x1003 = x983(x1001)
val x1004 = x993(x1002) = x1003
x1004
x1001 = x1001 + 1
}
x993
}
val x1008 = x1008_block
x1008
}
mapReduceIdx += 1
} // end while
x982
}
val x1009 = x1009_block
x1009
}
var mapReduceIdx = 1
while (mapReduceIdx < x805.size) {
val x806 = x805.dcApply(mapReduceIdx)
val x1012 = {
val x810 = new generated.scala.IntVectorImpl(900,false)
val x811 = new generated.scala.IntVectorImpl(0,true)
val x812 = new generated.scala.IndexVectorSeqImpl(x811)
val x813 = new generated.scala.BinarizedGradientTemplate(15,null,null,x796,x810,x812,null,null,null)
var x836 = x831
val x814 = x806 - 15
val x815 = x814 < 0
val x819 = {
def x819thenb(): scala.Tuple2[Int, Int] = {
val x816 = 15 - x806
val x817 = (0,x816)
x817
}
def x819elseb(): scala.Tuple2[Int, Int] = {
val x818 = (x814,0)
x818
}
if (x815) {
x819thenb()
} else {
x819elseb()
}
}
val x820 = x819._1
val x822 = x806 + 15
val x823 = x822 > x803
val x824 = {
def x824thenb(): Int = {
x803
}
def x824elseb(): Int = {
x822
}
if (x823) {
x824thenb()
} else {
x824elseb()
}
}
val x821 = x819._2
val x857 = x813.binary_gradients
val x865 = x813.match_list
val x866 = x865.length
val x875 = while ({val x837 = x836
val x838 = x837 < x835
x838}) {
val x840 = x836
var x844 = x820
val x872 = while ({val x845 = x844
val x846 = x845 < x824
x846}) {
val x848 = x836
val x852 = x844
val x849 = x832 + x848
val x850 = x849 - x831
val x851 = x850 * 30
val x853 = x821 + x852
val x854 = x853 - x820
val x855 = x851 + x854
var x856 = x855
val x858 = x856
val x859 = x844
val x860 = x798(x840, x859)
val x861 = x857(x858) = x860
val x862 = x844
val x863 = x798(x840, x862)
val x864 = x863 > 0
val x869 = {
def x869thenb(): Unit = {
val x867 = x865.insert(x866, x858)
x867
}
def x869elseb(): Unit = {
()
}
if (x864) {
x869thenb()
} else {
x869elseb()
}
}
val x870 = x844 += 1
()
}
val x873 = x836 += 1
()
}
val x876 = x866 < 0
val x879 = {
def x879thenb(): Unit = {
val x877 = println("dummy")
x877
}
def x879elseb(): Unit = {
()
}
if (x876) {
x879thenb()
} else {
x879elseb()
}
}
val x884 = x813.radius
def x1009_block = {
val x881 = x880.dcApply(0)
var x982 = {
val x882 = x790(x881)
val x883 = x882.radius
val x885 = x883 != x884
val x960 = {
def x960thenb(): Float = {
-1.0f
}
def x960elseb(): Float = {
val x886 = x882.match_list
val x887 = x886.length
val x888 = x887.asInstanceOf[Float]
val x889 = x888==0.0
val x958 = {
def x958thenb(): Float = {
-1.0f
}
def x958elseb(): Float = {
val x890 = x866.asInstanceOf[Float]
val x891 = x890 / x888
val x892 = x891 < 0.82f
val x956 = {
def x956thenb(): Float = {
x891
}
def x956elseb(): Float = {
var x893 = 0.0f
val x894 = x888 * 0.18f
val x895 = x894 + 0.5f
val x896 = x895.asInstanceOf[Int]
var x897 = x896
var x898 = 0
var x899 = true
val x907 = x882.binary_gradients
val x947 = while ({val x900 = x898
val x902 = x899
val x901 = x900 < x887
val x903 = x901 && x902
x903}) {
val x905 = x898
val x908 = x898
val x912 = x898
val x909 = x886(x908)
val x910 = x907(x909)
val x911 = x910==0
val x913 = x886(x912)
val x914 = x857(x913)
val x915 = x914==0
val x916 = x911 && x915
val x944 = {
def x944thenb(): Unit = {
val x917 = x893
val x918 = x917 + 1.0f
x893 = x918
()
}
def x944elseb(): Unit = {
val x921 = x898
val x924 = x898
val x922 = x886(x921)
val x923 = x907(x922)
val x925 = x886(x924)
val x926 = x857(x925)
val x927 = x923 & x926
val x928 = x927 > 0
val x942 = {
def x942thenb(): Unit = {
val x929 = x893
val x930 = x929 + 1.0f
x893 = x930
()
}
def x942elseb(): Unit = {
val x933 = x897
val x934 = x933 - 1
x897 = x934
val x936 = x897
val x937 = x936 <= 0
val x940 = {
def x940thenb(): Unit = {
x899 = false
()
}
def x940elseb(): Unit = {
()
}
if (x937) {
x940thenb()
} else {
x940elseb()
}
}
x940
}
if (x928) {
x942thenb()
} else {
x942elseb()
}
}
x942
}
if (x916) {
x944thenb()
} else {
x944elseb()
}
}
val x945 = x898 += 1
()
}
val x948 = x899
val x949 = !x948
val x954 = {
def x954thenb(): Float = {
0.819999f
}
def x954elseb(): Float = {
val x950 = x893
val x951 = x950 / x888
val x952 = x951.asInstanceOf[Float]
x952
}
if (x949) {
x954thenb()
} else {
x954elseb()
}
}
x954
}
if (x892) {
x956thenb()
} else {
x956elseb()
}
}
x956
}
if (x889) {
x958thenb()
} else {
x958elseb()
}
}
x958
}
if (x885) {
x960thenb()
} else {
x960elseb()
}
}
val x961 = x960 > 0.82f
val x980 = {
def x980thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x962 = x882.rect
val x964 = x962.width
val x807 = x796
val x808 = Math.pow(2.0,x807)
val x809 = x808.asInstanceOf[Int]
val x963 = x809 * x806
val x965 = x964 / 2
val x966 = x963 - x965
val x967 = x966.asInstanceOf[Int]
val x969 = x962.height
val x968 = x809 * x802
val x970 = x969 / 2
val x971 = x968 - x970
val x972 = x971.asInstanceOf[Int]
val x973 = new generated.scala.Rect(x967,x972,x964,x969)
val x974 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x975 = new generated.scala.BiGGDetection(x789,x960,x973,null,x881,x806,x802,x882,x813)
val x976 = x974(0) = x975
x974
}
def x980elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x978 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x978
}
if (x961) {
x980thenb()
} else {
x980elseb()
}
}
x980
}
var mapReduceIdx = 1
while (mapReduceIdx < x880.size) {
val x881 = x880.dcApply(mapReduceIdx)
val x983 = {
val x882 = x790(x881)
val x883 = x882.radius
val x885 = x883 != x884
val x960 = {
def x960thenb(): Float = {
-1.0f
}
def x960elseb(): Float = {
val x886 = x882.match_list
val x887 = x886.length
val x888 = x887.asInstanceOf[Float]
val x889 = x888==0.0
val x958 = {
def x958thenb(): Float = {
-1.0f
}
def x958elseb(): Float = {
val x890 = x866.asInstanceOf[Float]
val x891 = x890 / x888
val x892 = x891 < 0.82f
val x956 = {
def x956thenb(): Float = {
x891
}
def x956elseb(): Float = {
var x893 = 0.0f
val x894 = x888 * 0.18f
val x895 = x894 + 0.5f
val x896 = x895.asInstanceOf[Int]
var x897 = x896
var x898 = 0
var x899 = true
val x907 = x882.binary_gradients
val x947 = while ({val x900 = x898
val x902 = x899
val x901 = x900 < x887
val x903 = x901 && x902
x903}) {
val x905 = x898
val x908 = x898
val x912 = x898
val x909 = x886(x908)
val x910 = x907(x909)
val x911 = x910==0
val x913 = x886(x912)
val x914 = x857(x913)
val x915 = x914==0
val x916 = x911 && x915
val x944 = {
def x944thenb(): Unit = {
val x917 = x893
val x918 = x917 + 1.0f
x893 = x918
()
}
def x944elseb(): Unit = {
val x921 = x898
val x924 = x898
val x922 = x886(x921)
val x923 = x907(x922)
val x925 = x886(x924)
val x926 = x857(x925)
val x927 = x923 & x926
val x928 = x927 > 0
val x942 = {
def x942thenb(): Unit = {
val x929 = x893
val x930 = x929 + 1.0f
x893 = x930
()
}
def x942elseb(): Unit = {
val x933 = x897
val x934 = x933 - 1
x897 = x934
val x936 = x897
val x937 = x936 <= 0
val x940 = {
def x940thenb(): Unit = {
x899 = false
()
}
def x940elseb(): Unit = {
()
}
if (x937) {
x940thenb()
} else {
x940elseb()
}
}
x940
}
if (x928) {
x942thenb()
} else {
x942elseb()
}
}
x942
}
if (x916) {
x944thenb()
} else {
x944elseb()
}
}
val x945 = x898 += 1
()
}
val x948 = x899
val x949 = !x948
val x954 = {
def x954thenb(): Float = {
0.819999f
}
def x954elseb(): Float = {
val x950 = x893
val x951 = x950 / x888
val x952 = x951.asInstanceOf[Float]
x952
}
if (x949) {
x954thenb()
} else {
x954elseb()
}
}
x954
}
if (x892) {
x956thenb()
} else {
x956elseb()
}
}
x956
}
if (x889) {
x958thenb()
} else {
x958elseb()
}
}
x958
}
if (x885) {
x960thenb()
} else {
x960elseb()
}
}
val x961 = x960 > 0.82f
val x980 = {
def x980thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x962 = x882.rect
val x964 = x962.width
val x807 = x796
val x808 = Math.pow(2.0,x807)
val x809 = x808.asInstanceOf[Int]
val x963 = x809 * x806
val x965 = x964 / 2
val x966 = x963 - x965
val x967 = x966.asInstanceOf[Int]
val x969 = x962.height
val x968 = x809 * x802
val x970 = x969 / 2
val x971 = x968 - x970
val x972 = x971.asInstanceOf[Int]
val x973 = new generated.scala.Rect(x967,x972,x964,x969)
val x974 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x975 = new generated.scala.BiGGDetection(x789,x960,x973,null,x881,x806,x802,x882,x813)
val x976 = x974(0) = x975
x974
}
def x980elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x978 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x978
}
if (x961) {
x980thenb()
} else {
x980elseb()
}
}
x980
}
x982 = {
val x984 = x982.isRow
val x985 = x983.isRow
val x986 = x984 != x985
val x990 = x982.length
val x991 = x983.length
val x992 = x990 + x991
def x1008_block = { 
val x989 = {
def x989thenb(): Unit = {
val x987 = println("error: trying to concatenate row and column vectors")
x987
}
def x989elseb(): Unit = {
()
}
if (x986) {
x989thenb()
} else {
x989elseb()
}
}
val x993 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x992,x984)
var x995 : Int = 0
val x999 = while (x995 < x990) {
val x996 = x982(x995)
val x997 = x993(x995) = x996
x997
x995 = x995 + 1
}
var x1001 : Int = 0
val x1006 = while (x1001 < x991) {
val x1002 = x1001 + x990
val x1003 = x983(x1001)
val x1004 = x993(x1002) = x1003
x1004
x1001 = x1001 + 1
}
x993
}
val x1008 = x1008_block
x1008
}
mapReduceIdx += 1
} // end while
x982
}
val x1009 = x1009_block
x1009
}
x1011 = {
val x1013 = x1011.isRow
val x1014 = x1012.isRow
val x1015 = x1013 != x1014
val x1019 = x1011.length
val x1020 = x1012.length
val x1021 = x1019 + x1020
def x1037_block = { 
val x1018 = {
def x1018thenb(): Unit = {
val x1016 = println("error: trying to concatenate row and column vectors")
x1016
}
def x1018elseb(): Unit = {
()
}
if (x1015) {
x1018thenb()
} else {
x1018elseb()
}
}
val x1022 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1021,x1013)
var x1024 : Int = 0
val x1028 = while (x1024 < x1019) {
val x1025 = x1011(x1024)
val x1026 = x1022(x1024) = x1025
x1026
x1024 = x1024 + 1
}
var x1030 : Int = 0
val x1035 = while (x1030 < x1020) {
val x1031 = x1030 + x1019
val x1032 = x1012(x1030)
val x1033 = x1022(x1031) = x1032
x1033
x1030 = x1030 + 1
}
x1022
}
val x1037 = x1037_block
x1037
}
mapReduceIdx += 1
} // end while
x1011
}
val x1038 = x1038_block
x1038
}
var mapReduceIdx = 1
while (mapReduceIdx < x801.size) {
val x802 = x801.dcApply(mapReduceIdx)
val x1040 = {
val x825 = x802 - 15
val x826 = x825 < 0
val x830 = {
def x830thenb(): scala.Tuple2[Int, Int] = {
val x827 = 15 - x802
val x828 = (0,x827)
x828
}
def x830elseb(): scala.Tuple2[Int, Int] = {
val x829 = (x825,0)
x829
}
if (x826) {
x830thenb()
} else {
x830elseb()
}
}
val x831 = x830._1
val x833 = x802 + 15
val x834 = x833 > x799
val x835 = {
def x835thenb(): Int = {
x799
}
def x835elseb(): Int = {
x833
}
if (x834) {
x835thenb()
} else {
x835elseb()
}
}
val x832 = x830._2
def x1038_block = {
val x806 = x805.dcApply(0)
var x1011 = {
val x810 = new generated.scala.IntVectorImpl(900,false)
val x811 = new generated.scala.IntVectorImpl(0,true)
val x812 = new generated.scala.IndexVectorSeqImpl(x811)
val x813 = new generated.scala.BinarizedGradientTemplate(15,null,null,x796,x810,x812,null,null,null)
var x836 = x831
val x814 = x806 - 15
val x815 = x814 < 0
val x819 = {
def x819thenb(): scala.Tuple2[Int, Int] = {
val x816 = 15 - x806
val x817 = (0,x816)
x817
}
def x819elseb(): scala.Tuple2[Int, Int] = {
val x818 = (x814,0)
x818
}
if (x815) {
x819thenb()
} else {
x819elseb()
}
}
val x820 = x819._1
val x822 = x806 + 15
val x823 = x822 > x803
val x824 = {
def x824thenb(): Int = {
x803
}
def x824elseb(): Int = {
x822
}
if (x823) {
x824thenb()
} else {
x824elseb()
}
}
val x821 = x819._2
val x857 = x813.binary_gradients
val x865 = x813.match_list
val x866 = x865.length
val x875 = while ({val x837 = x836
val x838 = x837 < x835
x838}) {
val x840 = x836
var x844 = x820
val x872 = while ({val x845 = x844
val x846 = x845 < x824
x846}) {
val x848 = x836
val x852 = x844
val x849 = x832 + x848
val x850 = x849 - x831
val x851 = x850 * 30
val x853 = x821 + x852
val x854 = x853 - x820
val x855 = x851 + x854
var x856 = x855
val x858 = x856
val x859 = x844
val x860 = x798(x840, x859)
val x861 = x857(x858) = x860
val x862 = x844
val x863 = x798(x840, x862)
val x864 = x863 > 0
val x869 = {
def x869thenb(): Unit = {
val x867 = x865.insert(x866, x858)
x867
}
def x869elseb(): Unit = {
()
}
if (x864) {
x869thenb()
} else {
x869elseb()
}
}
val x870 = x844 += 1
()
}
val x873 = x836 += 1
()
}
val x876 = x866 < 0
val x879 = {
def x879thenb(): Unit = {
val x877 = println("dummy")
x877
}
def x879elseb(): Unit = {
()
}
if (x876) {
x879thenb()
} else {
x879elseb()
}
}
val x884 = x813.radius
def x1009_block = {
val x881 = x880.dcApply(0)
var x982 = {
val x882 = x790(x881)
val x883 = x882.radius
val x885 = x883 != x884
val x960 = {
def x960thenb(): Float = {
-1.0f
}
def x960elseb(): Float = {
val x886 = x882.match_list
val x887 = x886.length
val x888 = x887.asInstanceOf[Float]
val x889 = x888==0.0
val x958 = {
def x958thenb(): Float = {
-1.0f
}
def x958elseb(): Float = {
val x890 = x866.asInstanceOf[Float]
val x891 = x890 / x888
val x892 = x891 < 0.82f
val x956 = {
def x956thenb(): Float = {
x891
}
def x956elseb(): Float = {
var x893 = 0.0f
val x894 = x888 * 0.18f
val x895 = x894 + 0.5f
val x896 = x895.asInstanceOf[Int]
var x897 = x896
var x898 = 0
var x899 = true
val x907 = x882.binary_gradients
val x947 = while ({val x900 = x898
val x902 = x899
val x901 = x900 < x887
val x903 = x901 && x902
x903}) {
val x905 = x898
val x908 = x898
val x912 = x898
val x909 = x886(x908)
val x910 = x907(x909)
val x911 = x910==0
val x913 = x886(x912)
val x914 = x857(x913)
val x915 = x914==0
val x916 = x911 && x915
val x944 = {
def x944thenb(): Unit = {
val x917 = x893
val x918 = x917 + 1.0f
x893 = x918
()
}
def x944elseb(): Unit = {
val x921 = x898
val x924 = x898
val x922 = x886(x921)
val x923 = x907(x922)
val x925 = x886(x924)
val x926 = x857(x925)
val x927 = x923 & x926
val x928 = x927 > 0
val x942 = {
def x942thenb(): Unit = {
val x929 = x893
val x930 = x929 + 1.0f
x893 = x930
()
}
def x942elseb(): Unit = {
val x933 = x897
val x934 = x933 - 1
x897 = x934
val x936 = x897
val x937 = x936 <= 0
val x940 = {
def x940thenb(): Unit = {
x899 = false
()
}
def x940elseb(): Unit = {
()
}
if (x937) {
x940thenb()
} else {
x940elseb()
}
}
x940
}
if (x928) {
x942thenb()
} else {
x942elseb()
}
}
x942
}
if (x916) {
x944thenb()
} else {
x944elseb()
}
}
val x945 = x898 += 1
()
}
val x948 = x899
val x949 = !x948
val x954 = {
def x954thenb(): Float = {
0.819999f
}
def x954elseb(): Float = {
val x950 = x893
val x951 = x950 / x888
val x952 = x951.asInstanceOf[Float]
x952
}
if (x949) {
x954thenb()
} else {
x954elseb()
}
}
x954
}
if (x892) {
x956thenb()
} else {
x956elseb()
}
}
x956
}
if (x889) {
x958thenb()
} else {
x958elseb()
}
}
x958
}
if (x885) {
x960thenb()
} else {
x960elseb()
}
}
val x961 = x960 > 0.82f
val x980 = {
def x980thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x962 = x882.rect
val x964 = x962.width
val x807 = x796
val x808 = Math.pow(2.0,x807)
val x809 = x808.asInstanceOf[Int]
val x963 = x809 * x806
val x965 = x964 / 2
val x966 = x963 - x965
val x967 = x966.asInstanceOf[Int]
val x969 = x962.height
val x968 = x809 * x802
val x970 = x969 / 2
val x971 = x968 - x970
val x972 = x971.asInstanceOf[Int]
val x973 = new generated.scala.Rect(x967,x972,x964,x969)
val x974 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x975 = new generated.scala.BiGGDetection(x789,x960,x973,null,x881,x806,x802,x882,x813)
val x976 = x974(0) = x975
x974
}
def x980elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x978 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x978
}
if (x961) {
x980thenb()
} else {
x980elseb()
}
}
x980
}
var mapReduceIdx = 1
while (mapReduceIdx < x880.size) {
val x881 = x880.dcApply(mapReduceIdx)
val x983 = {
val x882 = x790(x881)
val x883 = x882.radius
val x885 = x883 != x884
val x960 = {
def x960thenb(): Float = {
-1.0f
}
def x960elseb(): Float = {
val x886 = x882.match_list
val x887 = x886.length
val x888 = x887.asInstanceOf[Float]
val x889 = x888==0.0
val x958 = {
def x958thenb(): Float = {
-1.0f
}
def x958elseb(): Float = {
val x890 = x866.asInstanceOf[Float]
val x891 = x890 / x888
val x892 = x891 < 0.82f
val x956 = {
def x956thenb(): Float = {
x891
}
def x956elseb(): Float = {
var x893 = 0.0f
val x894 = x888 * 0.18f
val x895 = x894 + 0.5f
val x896 = x895.asInstanceOf[Int]
var x897 = x896
var x898 = 0
var x899 = true
val x907 = x882.binary_gradients
val x947 = while ({val x900 = x898
val x902 = x899
val x901 = x900 < x887
val x903 = x901 && x902
x903}) {
val x905 = x898
val x908 = x898
val x912 = x898
val x909 = x886(x908)
val x910 = x907(x909)
val x911 = x910==0
val x913 = x886(x912)
val x914 = x857(x913)
val x915 = x914==0
val x916 = x911 && x915
val x944 = {
def x944thenb(): Unit = {
val x917 = x893
val x918 = x917 + 1.0f
x893 = x918
()
}
def x944elseb(): Unit = {
val x921 = x898
val x924 = x898
val x922 = x886(x921)
val x923 = x907(x922)
val x925 = x886(x924)
val x926 = x857(x925)
val x927 = x923 & x926
val x928 = x927 > 0
val x942 = {
def x942thenb(): Unit = {
val x929 = x893
val x930 = x929 + 1.0f
x893 = x930
()
}
def x942elseb(): Unit = {
val x933 = x897
val x934 = x933 - 1
x897 = x934
val x936 = x897
val x937 = x936 <= 0
val x940 = {
def x940thenb(): Unit = {
x899 = false
()
}
def x940elseb(): Unit = {
()
}
if (x937) {
x940thenb()
} else {
x940elseb()
}
}
x940
}
if (x928) {
x942thenb()
} else {
x942elseb()
}
}
x942
}
if (x916) {
x944thenb()
} else {
x944elseb()
}
}
val x945 = x898 += 1
()
}
val x948 = x899
val x949 = !x948
val x954 = {
def x954thenb(): Float = {
0.819999f
}
def x954elseb(): Float = {
val x950 = x893
val x951 = x950 / x888
val x952 = x951.asInstanceOf[Float]
x952
}
if (x949) {
x954thenb()
} else {
x954elseb()
}
}
x954
}
if (x892) {
x956thenb()
} else {
x956elseb()
}
}
x956
}
if (x889) {
x958thenb()
} else {
x958elseb()
}
}
x958
}
if (x885) {
x960thenb()
} else {
x960elseb()
}
}
val x961 = x960 > 0.82f
val x980 = {
def x980thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x962 = x882.rect
val x964 = x962.width
val x807 = x796
val x808 = Math.pow(2.0,x807)
val x809 = x808.asInstanceOf[Int]
val x963 = x809 * x806
val x965 = x964 / 2
val x966 = x963 - x965
val x967 = x966.asInstanceOf[Int]
val x969 = x962.height
val x968 = x809 * x802
val x970 = x969 / 2
val x971 = x968 - x970
val x972 = x971.asInstanceOf[Int]
val x973 = new generated.scala.Rect(x967,x972,x964,x969)
val x974 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x975 = new generated.scala.BiGGDetection(x789,x960,x973,null,x881,x806,x802,x882,x813)
val x976 = x974(0) = x975
x974
}
def x980elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x978 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x978
}
if (x961) {
x980thenb()
} else {
x980elseb()
}
}
x980
}
x982 = {
val x984 = x982.isRow
val x985 = x983.isRow
val x986 = x984 != x985
val x990 = x982.length
val x991 = x983.length
val x992 = x990 + x991
def x1008_block = { 
val x989 = {
def x989thenb(): Unit = {
val x987 = println("error: trying to concatenate row and column vectors")
x987
}
def x989elseb(): Unit = {
()
}
if (x986) {
x989thenb()
} else {
x989elseb()
}
}
val x993 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x992,x984)
var x995 : Int = 0
val x999 = while (x995 < x990) {
val x996 = x982(x995)
val x997 = x993(x995) = x996
x997
x995 = x995 + 1
}
var x1001 : Int = 0
val x1006 = while (x1001 < x991) {
val x1002 = x1001 + x990
val x1003 = x983(x1001)
val x1004 = x993(x1002) = x1003
x1004
x1001 = x1001 + 1
}
x993
}
val x1008 = x1008_block
x1008
}
mapReduceIdx += 1
} // end while
x982
}
val x1009 = x1009_block
x1009
}
var mapReduceIdx = 1
while (mapReduceIdx < x805.size) {
val x806 = x805.dcApply(mapReduceIdx)
val x1012 = {
val x810 = new generated.scala.IntVectorImpl(900,false)
val x811 = new generated.scala.IntVectorImpl(0,true)
val x812 = new generated.scala.IndexVectorSeqImpl(x811)
val x813 = new generated.scala.BinarizedGradientTemplate(15,null,null,x796,x810,x812,null,null,null)
var x836 = x831
val x814 = x806 - 15
val x815 = x814 < 0
val x819 = {
def x819thenb(): scala.Tuple2[Int, Int] = {
val x816 = 15 - x806
val x817 = (0,x816)
x817
}
def x819elseb(): scala.Tuple2[Int, Int] = {
val x818 = (x814,0)
x818
}
if (x815) {
x819thenb()
} else {
x819elseb()
}
}
val x820 = x819._1
val x822 = x806 + 15
val x823 = x822 > x803
val x824 = {
def x824thenb(): Int = {
x803
}
def x824elseb(): Int = {
x822
}
if (x823) {
x824thenb()
} else {
x824elseb()
}
}
val x821 = x819._2
val x857 = x813.binary_gradients
val x865 = x813.match_list
val x866 = x865.length
val x875 = while ({val x837 = x836
val x838 = x837 < x835
x838}) {
val x840 = x836
var x844 = x820
val x872 = while ({val x845 = x844
val x846 = x845 < x824
x846}) {
val x848 = x836
val x852 = x844
val x849 = x832 + x848
val x850 = x849 - x831
val x851 = x850 * 30
val x853 = x821 + x852
val x854 = x853 - x820
val x855 = x851 + x854
var x856 = x855
val x858 = x856
val x859 = x844
val x860 = x798(x840, x859)
val x861 = x857(x858) = x860
val x862 = x844
val x863 = x798(x840, x862)
val x864 = x863 > 0
val x869 = {
def x869thenb(): Unit = {
val x867 = x865.insert(x866, x858)
x867
}
def x869elseb(): Unit = {
()
}
if (x864) {
x869thenb()
} else {
x869elseb()
}
}
val x870 = x844 += 1
()
}
val x873 = x836 += 1
()
}
val x876 = x866 < 0
val x879 = {
def x879thenb(): Unit = {
val x877 = println("dummy")
x877
}
def x879elseb(): Unit = {
()
}
if (x876) {
x879thenb()
} else {
x879elseb()
}
}
val x884 = x813.radius
def x1009_block = {
val x881 = x880.dcApply(0)
var x982 = {
val x882 = x790(x881)
val x883 = x882.radius
val x885 = x883 != x884
val x960 = {
def x960thenb(): Float = {
-1.0f
}
def x960elseb(): Float = {
val x886 = x882.match_list
val x887 = x886.length
val x888 = x887.asInstanceOf[Float]
val x889 = x888==0.0
val x958 = {
def x958thenb(): Float = {
-1.0f
}
def x958elseb(): Float = {
val x890 = x866.asInstanceOf[Float]
val x891 = x890 / x888
val x892 = x891 < 0.82f
val x956 = {
def x956thenb(): Float = {
x891
}
def x956elseb(): Float = {
var x893 = 0.0f
val x894 = x888 * 0.18f
val x895 = x894 + 0.5f
val x896 = x895.asInstanceOf[Int]
var x897 = x896
var x898 = 0
var x899 = true
val x907 = x882.binary_gradients
val x947 = while ({val x900 = x898
val x902 = x899
val x901 = x900 < x887
val x903 = x901 && x902
x903}) {
val x905 = x898
val x908 = x898
val x912 = x898
val x909 = x886(x908)
val x910 = x907(x909)
val x911 = x910==0
val x913 = x886(x912)
val x914 = x857(x913)
val x915 = x914==0
val x916 = x911 && x915
val x944 = {
def x944thenb(): Unit = {
val x917 = x893
val x918 = x917 + 1.0f
x893 = x918
()
}
def x944elseb(): Unit = {
val x921 = x898
val x924 = x898
val x922 = x886(x921)
val x923 = x907(x922)
val x925 = x886(x924)
val x926 = x857(x925)
val x927 = x923 & x926
val x928 = x927 > 0
val x942 = {
def x942thenb(): Unit = {
val x929 = x893
val x930 = x929 + 1.0f
x893 = x930
()
}
def x942elseb(): Unit = {
val x933 = x897
val x934 = x933 - 1
x897 = x934
val x936 = x897
val x937 = x936 <= 0
val x940 = {
def x940thenb(): Unit = {
x899 = false
()
}
def x940elseb(): Unit = {
()
}
if (x937) {
x940thenb()
} else {
x940elseb()
}
}
x940
}
if (x928) {
x942thenb()
} else {
x942elseb()
}
}
x942
}
if (x916) {
x944thenb()
} else {
x944elseb()
}
}
val x945 = x898 += 1
()
}
val x948 = x899
val x949 = !x948
val x954 = {
def x954thenb(): Float = {
0.819999f
}
def x954elseb(): Float = {
val x950 = x893
val x951 = x950 / x888
val x952 = x951.asInstanceOf[Float]
x952
}
if (x949) {
x954thenb()
} else {
x954elseb()
}
}
x954
}
if (x892) {
x956thenb()
} else {
x956elseb()
}
}
x956
}
if (x889) {
x958thenb()
} else {
x958elseb()
}
}
x958
}
if (x885) {
x960thenb()
} else {
x960elseb()
}
}
val x961 = x960 > 0.82f
val x980 = {
def x980thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x962 = x882.rect
val x964 = x962.width
val x807 = x796
val x808 = Math.pow(2.0,x807)
val x809 = x808.asInstanceOf[Int]
val x963 = x809 * x806
val x965 = x964 / 2
val x966 = x963 - x965
val x967 = x966.asInstanceOf[Int]
val x969 = x962.height
val x968 = x809 * x802
val x970 = x969 / 2
val x971 = x968 - x970
val x972 = x971.asInstanceOf[Int]
val x973 = new generated.scala.Rect(x967,x972,x964,x969)
val x974 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x975 = new generated.scala.BiGGDetection(x789,x960,x973,null,x881,x806,x802,x882,x813)
val x976 = x974(0) = x975
x974
}
def x980elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x978 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x978
}
if (x961) {
x980thenb()
} else {
x980elseb()
}
}
x980
}
var mapReduceIdx = 1
while (mapReduceIdx < x880.size) {
val x881 = x880.dcApply(mapReduceIdx)
val x983 = {
val x882 = x790(x881)
val x883 = x882.radius
val x885 = x883 != x884
val x960 = {
def x960thenb(): Float = {
-1.0f
}
def x960elseb(): Float = {
val x886 = x882.match_list
val x887 = x886.length
val x888 = x887.asInstanceOf[Float]
val x889 = x888==0.0
val x958 = {
def x958thenb(): Float = {
-1.0f
}
def x958elseb(): Float = {
val x890 = x866.asInstanceOf[Float]
val x891 = x890 / x888
val x892 = x891 < 0.82f
val x956 = {
def x956thenb(): Float = {
x891
}
def x956elseb(): Float = {
var x893 = 0.0f
val x894 = x888 * 0.18f
val x895 = x894 + 0.5f
val x896 = x895.asInstanceOf[Int]
var x897 = x896
var x898 = 0
var x899 = true
val x907 = x882.binary_gradients
val x947 = while ({val x900 = x898
val x902 = x899
val x901 = x900 < x887
val x903 = x901 && x902
x903}) {
val x905 = x898
val x908 = x898
val x912 = x898
val x909 = x886(x908)
val x910 = x907(x909)
val x911 = x910==0
val x913 = x886(x912)
val x914 = x857(x913)
val x915 = x914==0
val x916 = x911 && x915
val x944 = {
def x944thenb(): Unit = {
val x917 = x893
val x918 = x917 + 1.0f
x893 = x918
()
}
def x944elseb(): Unit = {
val x921 = x898
val x924 = x898
val x922 = x886(x921)
val x923 = x907(x922)
val x925 = x886(x924)
val x926 = x857(x925)
val x927 = x923 & x926
val x928 = x927 > 0
val x942 = {
def x942thenb(): Unit = {
val x929 = x893
val x930 = x929 + 1.0f
x893 = x930
()
}
def x942elseb(): Unit = {
val x933 = x897
val x934 = x933 - 1
x897 = x934
val x936 = x897
val x937 = x936 <= 0
val x940 = {
def x940thenb(): Unit = {
x899 = false
()
}
def x940elseb(): Unit = {
()
}
if (x937) {
x940thenb()
} else {
x940elseb()
}
}
x940
}
if (x928) {
x942thenb()
} else {
x942elseb()
}
}
x942
}
if (x916) {
x944thenb()
} else {
x944elseb()
}
}
val x945 = x898 += 1
()
}
val x948 = x899
val x949 = !x948
val x954 = {
def x954thenb(): Float = {
0.819999f
}
def x954elseb(): Float = {
val x950 = x893
val x951 = x950 / x888
val x952 = x951.asInstanceOf[Float]
x952
}
if (x949) {
x954thenb()
} else {
x954elseb()
}
}
x954
}
if (x892) {
x956thenb()
} else {
x956elseb()
}
}
x956
}
if (x889) {
x958thenb()
} else {
x958elseb()
}
}
x958
}
if (x885) {
x960thenb()
} else {
x960elseb()
}
}
val x961 = x960 > 0.82f
val x980 = {
def x980thenb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x962 = x882.rect
val x964 = x962.width
val x807 = x796
val x808 = Math.pow(2.0,x807)
val x809 = x808.asInstanceOf[Int]
val x963 = x809 * x806
val x965 = x964 / 2
val x966 = x963 - x965
val x967 = x966.asInstanceOf[Int]
val x969 = x962.height
val x968 = x809 * x802
val x970 = x969 / 2
val x971 = x968 - x970
val x972 = x971.asInstanceOf[Int]
val x973 = new generated.scala.Rect(x967,x972,x964,x969)
val x974 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](1,true)
val x975 = new generated.scala.BiGGDetection(x789,x960,x973,null,x881,x806,x802,x882,x813)
val x976 = x974(0) = x975
x974
}
def x980elseb(): generated.scala.Vector[generated.scala.BiGGDetection] = {
val x978 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](0,true)
x978
}
if (x961) {
x980thenb()
} else {
x980elseb()
}
}
x980
}
x982 = {
val x984 = x982.isRow
val x985 = x983.isRow
val x986 = x984 != x985
val x990 = x982.length
val x991 = x983.length
val x992 = x990 + x991
def x1008_block = { 
val x989 = {
def x989thenb(): Unit = {
val x987 = println("error: trying to concatenate row and column vectors")
x987
}
def x989elseb(): Unit = {
()
}
if (x986) {
x989thenb()
} else {
x989elseb()
}
}
val x993 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x992,x984)
var x995 : Int = 0
val x999 = while (x995 < x990) {
val x996 = x982(x995)
val x997 = x993(x995) = x996
x997
x995 = x995 + 1
}
var x1001 : Int = 0
val x1006 = while (x1001 < x991) {
val x1002 = x1001 + x990
val x1003 = x983(x1001)
val x1004 = x993(x1002) = x1003
x1004
x1001 = x1001 + 1
}
x993
}
val x1008 = x1008_block
x1008
}
mapReduceIdx += 1
} // end while
x982
}
val x1009 = x1009_block
x1009
}
x1011 = {
val x1013 = x1011.isRow
val x1014 = x1012.isRow
val x1015 = x1013 != x1014
val x1019 = x1011.length
val x1020 = x1012.length
val x1021 = x1019 + x1020
def x1037_block = { 
val x1018 = {
def x1018thenb(): Unit = {
val x1016 = println("error: trying to concatenate row and column vectors")
x1016
}
def x1018elseb(): Unit = {
()
}
if (x1015) {
x1018thenb()
} else {
x1018elseb()
}
}
val x1022 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1021,x1013)
var x1024 : Int = 0
val x1028 = while (x1024 < x1019) {
val x1025 = x1011(x1024)
val x1026 = x1022(x1024) = x1025
x1026
x1024 = x1024 + 1
}
var x1030 : Int = 0
val x1035 = while (x1030 < x1020) {
val x1031 = x1030 + x1019
val x1032 = x1012(x1030)
val x1033 = x1022(x1031) = x1032
x1033
x1030 = x1030 + 1
}
x1022
}
val x1037 = x1037_block
x1037
}
mapReduceIdx += 1
} // end while
x1011
}
val x1038 = x1038_block
x1038
}
x1039 = {
val x1041 = x1039.isRow
val x1042 = x1040.isRow
val x1043 = x1041 != x1042
val x1047 = x1039.length
val x1048 = x1040.length
val x1049 = x1047 + x1048
def x1065_block = { 
val x1046 = {
def x1046thenb(): Unit = {
val x1044 = println("error: trying to concatenate row and column vectors")
x1044
}
def x1046elseb(): Unit = {
()
}
if (x1043) {
x1046thenb()
} else {
x1046elseb()
}
}
val x1050 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1049,x1041)
var x1052 : Int = 0
val x1056 = while (x1052 < x1047) {
val x1053 = x1039(x1052)
val x1054 = x1050(x1052) = x1053
x1054
x1052 = x1052 + 1
}
var x1058 : Int = 0
val x1063 = while (x1058 < x1048) {
val x1059 = x1058 + x1047
val x1060 = x1040(x1058)
val x1061 = x1050(x1059) = x1060
x1061
x1058 = x1058 + 1
}
x1050
}
val x1065 = x1065_block
x1065
}
mapReduceIdx += 1
} // end while
x1039
}
val x1066 = x1066_block
val x1067 = x1066.length
val x1068 = "Detections: "+x1067
val x1069 = println(x1068)
x1066
}
x1071 = {
val x1073 = x1071.isRow
val x1074 = x1072.isRow
val x1075 = x1073 != x1074
val x1079 = x1071.length
val x1080 = x1072.length
val x1081 = x1079 + x1080
def x1097_block = { 
val x1078 = {
def x1078thenb(): Unit = {
val x1076 = println("error: trying to concatenate row and column vectors")
x1076
}
def x1078elseb(): Unit = {
()
}
if (x1075) {
x1078thenb()
} else {
x1078elseb()
}
}
val x1082 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1081,x1073)
var x1084 : Int = 0
val x1088 = while (x1084 < x1079) {
val x1085 = x1071(x1084)
val x1086 = x1082(x1084) = x1085
x1086
x1084 = x1084 + 1
}
var x1090 : Int = 0
val x1095 = while (x1090 < x1080) {
val x1091 = x1090 + x1079
val x1092 = x1072(x1090)
val x1093 = x1082(x1091) = x1092
x1093
x1090 = x1090 + 1
}
x1082
}
val x1097 = x1097_block
x1097
}
mapReduceIdx += 1
} // end while
x1071
}
val x1098 = x1098_block
val x1099 = x1098.length
var x1100 = x1099
val x1101 = x1100
val x1102 = "Detections before NMS: "+x1101
val x1103 = println(x1102)
var x1105 : Int = 0
val x1222 = while (x1105 < 1) {
var x1106 = 0
val x1220 = while ({val x1107 = x1106
val x1108 = x1100
val x1109 = x1108 - 1
val x1110 = x1107 < x1109
x1110}) {
val x1112 = x1106
val x1113 = x1112 + 1
var x1114 = x1113
var x1115 = false
val x1217 = while ({val x1116 = x1114
val x1117 = x1100
val x1119 = x1115
val x1118 = x1116 < x1117
val x1120 = x1119==false
val x1121 = x1118 && x1120
x1121}) {
val x1123 = x1106
val x1126 = x1114
val x1124 = x1098(x1123)
val x1125 = x1124.roi
val x1129 = x1125.x
val x1127 = x1098(x1126)
val x1128 = x1127.roi
val x1130 = x1128.x
val x1131 = x1128.width
val x1132 = x1130 + x1131
val x1133 = x1129 < x1132
val x1134 = x1125.width
val x1135 = x1129 + x1134
val x1136 = x1135 > x1130
val x1137 = x1133 && x1136
val x1138 = x1125.y
val x1139 = x1125.height
val x1140 = x1138 + x1139
val x1141 = x1128.y
val x1142 = x1140 > x1141
val x1143 = x1137 && x1142
val x1144 = x1128.height
val x1145 = x1141 + x1144
val x1146 = x1138 < x1145
val x1147 = x1143 && x1146
val x1168 = {
def x1168thenb(): Float = {
val x1154 = x1138 > x1141
val x1155 = {
def x1155thenb(): Int = {
x1138
}
def x1155elseb(): Int = {
x1141
}
if (x1154) {
x1155thenb()
} else {
x1155elseb()
}
}
val x1159 = x1140 < x1145
val x1160 = {
def x1160thenb(): Int = {
x1140
}
def x1160elseb(): Int = {
x1145
}
if (x1159) {
x1160thenb()
} else {
x1160elseb()
}
}
val x1161 = x1160 - x1155
val x1162 = x1161
val x1163 = 2.0f * x1162
val x1152 = x1129 > x1130
val x1153 = {
def x1153thenb(): Int = {
x1129
}
def x1153elseb(): Int = {
x1130
}
if (x1152) {
x1153thenb()
} else {
x1153elseb()
}
}
val x1156 = x1135 < x1132
val x1157 = {
def x1157thenb(): Int = {
x1135
}
def x1157elseb(): Int = {
x1132
}
if (x1156) {
x1157thenb()
} else {
x1157elseb()
}
}
val x1158 = x1157 - x1153
val x1164 = x1158
val x1165 = x1163 * x1164
val x1148 = x1144 * x1131
val x1149 = x1134 * x1139
val x1150 = x1148 + x1149
val x1151 = x1150
val x1166 = x1151 + 1.0E-6f
val x1167 = x1165 / x1166
x1167
}
def x1168elseb(): Float = {
0.0f
}
if (x1147) {
x1168thenb()
} else {
x1168elseb()
}
}
val x1169 = x1168 > 0.6f
val x1214 = {
def x1214thenb(): Unit = {
val x1170 = x1106
val x1173 = x1114
val x1171 = x1098(x1170)
val x1172 = x1171.score
val x1174 = x1098(x1173)
val x1175 = x1174.score
val x1176 = x1172 >= x1175
val x1212 = {
def x1212thenb(): Unit = {
val x1177 = x1100
val x1180 = x1100
val x1182 = x1114
val x1181 = x1180 - 1
val x1183 = x1098(x1182)
val x1184 = x1098(x1181) = x1183
val x1185 = x1114
val x1178 = x1177 - 1
val x1179 = x1098(x1178)
val x1186 = x1098(x1185) = x1179
val x1187 = x1100
val x1188 = x1187 - 1
x1100 = x1188
val x1190 = x1114
val x1191 = x1190 - 1
x1114 = x1191
()
}
def x1212elseb(): Unit = {
val x1194 = x1100
val x1197 = x1100
val x1199 = x1106
val x1198 = x1197 - 1
val x1200 = x1098(x1199)
val x1201 = x1098(x1198) = x1200
val x1202 = x1106
val x1195 = x1194 - 1
val x1196 = x1098(x1195)
val x1203 = x1098(x1202) = x1196
val x1204 = x1100
val x1205 = x1204 - 1
x1100 = x1205
val x1207 = x1106
val x1208 = x1207 - 1
x1106 = x1208
x1115 = true
()
}
if (x1176) {
x1212thenb()
} else {
x1212elseb()
}
}
x1212
}
def x1214elseb(): Unit = {
()
}
if (x1169) {
x1214thenb()
} else {
x1214elseb()
}
}
val x1215 = x1114 += 1
()
}
val x1218 = x1106 += 1
()
}
()
x1105 = x1105 + 1
}
val x1223 = x1100
val x1224 = x1223 - 0
val x1225 = x1098.isRow
def x1235_block = { 
val x1226 = new generated.scala.VectorImpl[generated.scala.BiGGDetection](x1224,x1225)
var x1228 : Int = 0
val x1233 = while (x1228 < x1223) {
val x1229 = x1228 - 0
val x1230 = x1098(x1228)
val x1231 = x1226(x1229) = x1230
x1231
x1228 = x1228 + 1
}
x1226
}
val x1235 = x1235_block
val x1236 = x1235.length
val x1237 = "Total detections: "+x1236
val x1238 = println(x1237)
val x1239 = x231 += 1
()
}
val x1242 = println("toc:" + (System.nanoTime / 1000000L))
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
