/*****************************************
  Emitting Generated Code                  
*******************************************/
class LBPDenoiseRunner extends ((Array[java.lang.String])=>(Unit)) {
def apply(x0:Array[java.lang.String]): Unit = {
val x1 = x0.length
val x2 = x1 < 1
val x7 = {
def x7thenb(): Nothing = {
val x3 = println("Usage: GraphLBP <rows> <cols>")
val x4 = println("Example: GraphLBP 100 100")
val x5 = exit(-1)
x5
}
if (x2) {
x7thenb()
}
}
var x8: Int = 100
var x9: Int = 100
var x10: java.lang.String = "laplace"
val x11 = new generated.scala.DoubleMatrixImpl(5,5)
val x12 = x0(0)
val x59 = { 
val x13 = new java.io.FileReader(x12)
val x14 = new java.io.BufferedReader(x13)
val x15 = x14.readLine()
var x16: java.lang.String = x15
val x17 = x16
val x18 = x17.trim()
x16 = x18
val x20 = x16
val x21 = x20.split("\\s+")
var x22: Array[java.lang.String] = x21
val x23 = x22
val x24 = x23.length
val x25 = new generated.scala.DoubleMatrixImpl(0,x24)
val x55 = while ({val x26 = x16
val x27 = x26 != null
x27}) {
val x29 = x22
val x30 = x29.length
val x31 = new generated.scala.DoubleVectorImpl(x30,true)
var x33 : Int = 0
val x39 = while (x33 < x30) {
val x34 = x22
val x35 = x34(x33)
val x36 = java.lang.Double.parseDouble(x35)
val x37 = x31(x33) = x36
x37
x33 = x33 + 1
}
val x40 = x31// unsafe immutable
val x41 = x25.numRows
val x42 = x25.insertRow(x41,x40)
val x43 = x14.readLine()
x16 = x43
val x45 = x16
val x46 = x45 != null
val x47 = x45.trim()
val x53 = {
def x53thenb(): Unit = {
x16 = x47
val x49 = x16
val x50 = x49.split("\\s+")
x22 = x50
()
}
if (x46) {
x53thenb()
}
}
x53
}
val x56 = x14.close()
val x57 = x25// unsafe immutable
x57
}
val x63 = x59.numCols
val x64 = java.lang.String.valueOf(x63)
val x67 = x59.numRows
val x68 = java.lang.String.valueOf(x67)
val x69 = x68+"\n"
val x83 = List()
val x85 = new generated.scala.IndexVectorRangeImpl(0,x67)
def x76_block = {
var x72 = x59.dcApply(0)
var reduceIdx = 1
while (reduceIdx < x59.size) { // begin reduce loop x76
val x73 = x59.dcApply(reduceIdx)
x72 = {
val x74 = x72 < x73
val x75 = {
def x75thenb(): Double = {
x72
}
def x75elseb(): Double = {
x73
}
if (x74) {
x75thenb()
} else { 
x75elseb()
}
}
x75
}
reduceIdx += 1
} // end reduce loop x76
x72
}
val x76 = x76_block
def x81_block = {
var x77 = x59.dcApply(0)
var reduceIdx = 1
while (reduceIdx < x59.size) { // begin reduce loop x81
val x78 = x59.dcApply(reduceIdx)
x77 = {
val x79 = x77 > x78
val x80 = {
def x80thenb(): Double = {
x77
}
def x80elseb(): Double = {
x78
}
if (x79) {
x80thenb()
} else { 
x80elseb()
}
}
x80
}
reduceIdx += 1
} // end reduce loop x81
x77
}
val x81 = x81_block
val x88 = x76 != x81
val x91 = x81 - x76
val x109 = { 
val x60 = new java.io.FileWriter("check.pgm")
val x61 = new java.io.BufferedWriter(x60)
val x62 = x61.write("P2\n")
val x65 = x61.write(x64)
val x66 = x61.write(" ")
val x70 = x61.write(x69)
val x71 = x61.write("255\n")
val x106 = {
var forIdx = 0
while (forIdx < x85.size) { // begin foreach loop x106
val x84 = x85.dcApply(forIdx)
val x86 = x59.getRow(x84)
val x103 = {
var forIdx = 0
while (forIdx < x86.size) { // begin foreach loop x103
val x87 = x86.dcApply(forIdx)
val x89 = x87 - x76
val x90 = 255.0 * x89
val x92 = x90 / x91
val x93 = x92.asInstanceOf[Int]
val x94 = x93+""
val x99 = {
def x99thenb(): Unit = {
val x95 = x61.write(x94)
x95
}
def x99elseb(): Unit = {
val x97 = x61.write("0")
x97
}
if (x88) {
x99thenb()
} else { 
x99elseb()
}
}
val x100 = x61.write("\t")
x100
forIdx += 1
} // end foreach loop x103
}
val x104 = x61.write("\n")
x104
forIdx += 1
} // end foreach loop x106
}
val x107 = x61.close()
x107
}
val x111 = new generated.scala.UndirectedGraphImpl[generated.scala.MessageVertex, generated.scala.MessageEdge]()
val x115 = { 
val x112 = new generated.scala.DoubleVectorImpl(5,true)
x112
}
val x116 = x115.isRow
// a *thin* loop follows: x123
val x123 = {
val x118 = new generated.scala.DoubleVectorImpl(5,x116)
x118
}
var x117 = 0
while (x117 < 5) {  // begin fat loop x123
val x120 = x115(x117)
val x121 = java.lang.Math.exp(x120)
x123.dcUpdate(x117, x121)
x117 += 1
} // end fat loop x123
val x124 = x123.length
// a *thin* loop follows: x131
var x131: Double = 0
var x125 = 0
while (x125 < x124) {  // begin fat loop x131
val x128 = x123(x125)
val x126 = x131
val x127 = x128
val x130 = x126 + x127
x131 = x130
x125 += 1
} // end fat loop x131
val x132 = Math.log(x131)
def x135_block = {
var mapIdx = 0
while (mapIdx < x115.size) { // begin map loop x135
val x133 = x115.dcApply(mapIdx)
x115.dcUpdate(mapIdx,  {
val x134 = x133 - x132
x134
})
mapIdx += 1
} // end map loop x135
x115
}
val x135 = x135_block
val x110 = x59.cloneL
val x136 = x110.numRows
val x137 = x110.numCols
val x138 = new generated.scala.MatrixImpl[generated.scala.MessageVertex](x136,x137)
var x139: Int = 0
var x140: Int = 0
val x141 = x139
val x142 = x141 < x136
val x144 = x140
val x145 = x144 < x137
val x146 = x141 * x137
val x147 = x146 + x144
val x151 = x110.dcApply(x147)
val x152 = { 
x151
}
val x196 = while ({x142}) {
x140 = 0
val x193 = while ({x145}) {
val x150 = { 
val x112 = new generated.scala.DoubleVectorImpl(5,true)
x112
}
var x153: Int = 0
val x154 = x153
val x155 = x154 < 5
val x156 = x154
val x157 = x152 - x156
val x158 = x157 * x157
val x159 = x158 / 8.0
val x160 = 0.0 - x159
val x164 = while ({x155}) {
val x161 = x150(x154) = x160
val x162 = x153 += 1
()
}
val x165 = x150.isRow
// a *thin* loop follows: x172
val x172 = {
val x167 = new generated.scala.DoubleVectorImpl(5,x165)
x167
}
var x166 = 0
while (x166 < 5) {  // begin fat loop x172
val x169 = x150(x166)
val x170 = java.lang.Math.exp(x169)
x172.dcUpdate(x166, x170)
x166 += 1
} // end fat loop x172
val x173 = x172.length
// a *thin* loop follows: x180
var x180: Double = 0
var x174 = 0
while (x174 < x173) {  // begin fat loop x180
val x177 = x172(x174)
val x175 = x180
val x176 = x177
val x179 = x175 + x176
x180 = x179
x174 += 1
} // end fat loop x180
val x181 = Math.log(x180)
def x184_block = {
var mapIdx = 0
while (mapIdx < x150.size) { // begin map loop x184
val x182 = x150.dcApply(mapIdx)
x150.dcUpdate(mapIdx,  {
val x183 = x182 - x181
x183
})
mapIdx += 1
} // end map loop x184
x150
}
val x184 = x184_block
val x185 = x115.cloneL
val x186 = new generated.scala.DenoiseVertexDataImpl(x147,x185,x150)
val x187 = new generated.scala.MessageVertexImpl(x111,x186)
val x188 = x138.getRow(x141)
val x189 = x188(x144) = x187
val x190 = x111.addVertex(x187)
val x191 = x140 += 1
()
}
val x194 = x139 += 1
()
}
val x199 = { 
val x112 = new generated.scala.DoubleVectorImpl(5,true)
x112
}
val x200 = x199.isRow
// a *thin* loop follows: x207
val x207 = {
val x202 = new generated.scala.DoubleVectorImpl(5,x200)
x202
}
var x201 = 0
while (x201 < 5) {  // begin fat loop x207
val x204 = x199(x201)
val x205 = java.lang.Math.exp(x204)
x207.dcUpdate(x201, x205)
x201 += 1
} // end fat loop x207
val x208 = x207.length
// a *thin* loop follows: x215
var x215: Double = 0
var x209 = 0
while (x209 < x208) {  // begin fat loop x215
val x212 = x207(x209)
val x210 = x215
val x211 = x212
val x214 = x210 + x211
x215 = x214
x209 += 1
} // end fat loop x215
val x216 = Math.log(x215)
def x219_block = {
var mapIdx = 0
while (mapIdx < x199.size) { // begin map loop x219
val x217 = x199.dcApply(mapIdx)
x199.dcUpdate(mapIdx,  {
val x218 = x217 - x216
x218
})
mapIdx += 1
} // end map loop x219
x199
}
val x219 = x219_block
val x222 = { 
val x112 = new generated.scala.DoubleVectorImpl(5,true)
x112
}
val x223 = x222.isRow
// a *thin* loop follows: x230
val x230 = {
val x225 = new generated.scala.DoubleVectorImpl(5,x223)
x225
}
var x224 = 0
while (x224 < 5) {  // begin fat loop x230
val x227 = x222(x224)
val x228 = java.lang.Math.exp(x227)
x230.dcUpdate(x224, x228)
x224 += 1
} // end fat loop x230
val x231 = x230.length
// a *thin* loop follows: x238
var x238: Double = 0
var x232 = 0
while (x232 < x231) {  // begin fat loop x238
val x235 = x230(x232)
val x233 = x238
val x234 = x235
val x237 = x233 + x234
x238 = x237
x232 += 1
} // end fat loop x238
val x239 = Math.log(x238)
def x242_block = {
var mapIdx = 0
while (mapIdx < x222.size) { // begin map loop x242
val x240 = x222.dcApply(mapIdx)
x222.dcUpdate(mapIdx,  {
val x241 = x240 - x239
x241
})
mapIdx += 1
} // end map loop x242
x222
}
val x242 = x242_block
val x243 = new generated.scala.DenoiseEdgeDataImpl(x199,x222)
x139 = 0
val x246 = x137 - 1
val x247 = x144 < x246
val x344 = x144 + 1
val x353 = x136 - 1
val x354 = x141 < x353
val x451 = x141 + 1
val x467 = while ({x142}) {
x140 = 0
val x464 = while ({x145}) {
val x352 = {
def x352thenb(): Unit = {
val x250 = { 
val x112 = new generated.scala.DoubleVectorImpl(5,true)
x112
}
val x251 = x250.isRow
// a *thin* loop follows: x258
val x258 = {
val x253 = new generated.scala.DoubleVectorImpl(5,x251)
x253
}
var x252 = 0
while (x252 < 5) {  // begin fat loop x258
val x255 = x250(x252)
val x256 = java.lang.Math.exp(x255)
x258.dcUpdate(x252, x256)
x252 += 1
} // end fat loop x258
val x259 = x258.length
// a *thin* loop follows: x266
var x266: Double = 0
var x260 = 0
while (x260 < x259) {  // begin fat loop x266
val x263 = x258(x260)
val x261 = x266
val x262 = x263
val x265 = x261 + x262
x266 = x265
x260 += 1
} // end fat loop x266
val x267 = Math.log(x266)
def x270_block = {
var mapIdx = 0
while (mapIdx < x250.size) { // begin map loop x270
val x268 = x250.dcApply(mapIdx)
x250.dcUpdate(mapIdx,  {
val x269 = x268 - x267
x269
})
mapIdx += 1
} // end map loop x270
x250
}
val x270 = x270_block
val x273 = { 
val x112 = new generated.scala.DoubleVectorImpl(5,true)
x112
}
val x274 = x273.isRow
// a *thin* loop follows: x281
val x281 = {
val x276 = new generated.scala.DoubleVectorImpl(5,x274)
x276
}
var x275 = 0
while (x275 < 5) {  // begin fat loop x281
val x278 = x273(x275)
val x279 = java.lang.Math.exp(x278)
x281.dcUpdate(x275, x279)
x275 += 1
} // end fat loop x281
val x282 = x281.length
// a *thin* loop follows: x289
var x289: Double = 0
var x283 = 0
while (x283 < x282) {  // begin fat loop x289
val x286 = x281(x283)
val x284 = x289
val x285 = x286
val x288 = x284 + x285
x289 = x288
x283 += 1
} // end fat loop x289
val x290 = Math.log(x289)
def x293_block = {
var mapIdx = 0
while (mapIdx < x273.size) { // begin map loop x293
val x291 = x273.dcApply(mapIdx)
x273.dcUpdate(mapIdx,  {
val x292 = x291 - x290
x292
})
mapIdx += 1
} // end map loop x293
x273
}
val x293 = x293_block
val x294 = new generated.scala.DenoiseEdgeDataImpl(x250,x273)
val x297 = { 
val x112 = new generated.scala.DoubleVectorImpl(5,true)
x112
}
val x298 = x297.isRow
// a *thin* loop follows: x305
val x305 = {
val x300 = new generated.scala.DoubleVectorImpl(5,x298)
x300
}
var x299 = 0
while (x299 < 5) {  // begin fat loop x305
val x302 = x297(x299)
val x303 = java.lang.Math.exp(x302)
x305.dcUpdate(x299, x303)
x299 += 1
} // end fat loop x305
val x306 = x305.length
// a *thin* loop follows: x313
var x313: Double = 0
var x307 = 0
while (x307 < x306) {  // begin fat loop x313
val x310 = x305(x307)
val x308 = x313
val x309 = x310
val x312 = x308 + x309
x313 = x312
x307 += 1
} // end fat loop x313
val x314 = Math.log(x313)
def x317_block = {
var mapIdx = 0
while (mapIdx < x297.size) { // begin map loop x317
val x315 = x297.dcApply(mapIdx)
x297.dcUpdate(mapIdx,  {
val x316 = x315 - x314
x316
})
mapIdx += 1
} // end map loop x317
x297
}
val x317 = x317_block
val x320 = { 
val x112 = new generated.scala.DoubleVectorImpl(5,true)
x112
}
val x321 = x320.isRow
// a *thin* loop follows: x328
val x328 = {
val x323 = new generated.scala.DoubleVectorImpl(5,x321)
x323
}
var x322 = 0
while (x322 < 5) {  // begin fat loop x328
val x325 = x320(x322)
val x326 = java.lang.Math.exp(x325)
x328.dcUpdate(x322, x326)
x322 += 1
} // end fat loop x328
val x329 = x328.length
// a *thin* loop follows: x336
var x336: Double = 0
var x330 = 0
while (x330 < x329) {  // begin fat loop x336
val x333 = x328(x330)
val x331 = x336
val x332 = x333
val x335 = x331 + x332
x336 = x335
x330 += 1
} // end fat loop x336
val x337 = Math.log(x336)
def x340_block = {
var mapIdx = 0
while (mapIdx < x320.size) { // begin map loop x340
val x338 = x320.dcApply(mapIdx)
x320.dcUpdate(mapIdx,  {
val x339 = x338 - x337
x339
})
mapIdx += 1
} // end map loop x340
x320
}
val x340 = x340_block
val x341 = new generated.scala.DenoiseEdgeDataImpl(x297,x320)
val x342 = x138.getRow(x141)
val x343 = x342(x144)
val x345 = x342(x344)
val x346 = new generated.scala.MessageEdgeImpl(x111,x294,x341,x343,x345)
val x347 = x138.getRow(x141)
val x348 = x347(x144)
val x349 = x347(x344)
val x350 = x111.addEdge(x346,x348,x349)
x350
}
if (x247) {
x352thenb()
}
}
val x461 = {
def x461thenb(): Unit = {
val x357 = { 
val x112 = new generated.scala.DoubleVectorImpl(5,true)
x112
}
val x358 = x357.isRow
// a *thin* loop follows: x365
val x365 = {
val x360 = new generated.scala.DoubleVectorImpl(5,x358)
x360
}
var x359 = 0
while (x359 < 5) {  // begin fat loop x365
val x362 = x357(x359)
val x363 = java.lang.Math.exp(x362)
x365.dcUpdate(x359, x363)
x359 += 1
} // end fat loop x365
val x366 = x365.length
// a *thin* loop follows: x373
var x373: Double = 0
var x367 = 0
while (x367 < x366) {  // begin fat loop x373
val x370 = x365(x367)
val x368 = x373
val x369 = x370
val x372 = x368 + x369
x373 = x372
x367 += 1
} // end fat loop x373
val x374 = Math.log(x373)
def x377_block = {
var mapIdx = 0
while (mapIdx < x357.size) { // begin map loop x377
val x375 = x357.dcApply(mapIdx)
x357.dcUpdate(mapIdx,  {
val x376 = x375 - x374
x376
})
mapIdx += 1
} // end map loop x377
x357
}
val x377 = x377_block
val x380 = { 
val x112 = new generated.scala.DoubleVectorImpl(5,true)
x112
}
val x381 = x380.isRow
// a *thin* loop follows: x388
val x388 = {
val x383 = new generated.scala.DoubleVectorImpl(5,x381)
x383
}
var x382 = 0
while (x382 < 5) {  // begin fat loop x388
val x385 = x380(x382)
val x386 = java.lang.Math.exp(x385)
x388.dcUpdate(x382, x386)
x382 += 1
} // end fat loop x388
val x389 = x388.length
// a *thin* loop follows: x396
var x396: Double = 0
var x390 = 0
while (x390 < x389) {  // begin fat loop x396
val x393 = x388(x390)
val x391 = x396
val x392 = x393
val x395 = x391 + x392
x396 = x395
x390 += 1
} // end fat loop x396
val x397 = Math.log(x396)
def x400_block = {
var mapIdx = 0
while (mapIdx < x380.size) { // begin map loop x400
val x398 = x380.dcApply(mapIdx)
x380.dcUpdate(mapIdx,  {
val x399 = x398 - x397
x399
})
mapIdx += 1
} // end map loop x400
x380
}
val x400 = x400_block
val x401 = new generated.scala.DenoiseEdgeDataImpl(x357,x380)
val x404 = { 
val x112 = new generated.scala.DoubleVectorImpl(5,true)
x112
}
val x405 = x404.isRow
// a *thin* loop follows: x412
val x412 = {
val x407 = new generated.scala.DoubleVectorImpl(5,x405)
x407
}
var x406 = 0
while (x406 < 5) {  // begin fat loop x412
val x409 = x404(x406)
val x410 = java.lang.Math.exp(x409)
x412.dcUpdate(x406, x410)
x406 += 1
} // end fat loop x412
val x413 = x412.length
// a *thin* loop follows: x420
var x420: Double = 0
var x414 = 0
while (x414 < x413) {  // begin fat loop x420
val x417 = x412(x414)
val x415 = x420
val x416 = x417
val x419 = x415 + x416
x420 = x419
x414 += 1
} // end fat loop x420
val x421 = Math.log(x420)
def x424_block = {
var mapIdx = 0
while (mapIdx < x404.size) { // begin map loop x424
val x422 = x404.dcApply(mapIdx)
x404.dcUpdate(mapIdx,  {
val x423 = x422 - x421
x423
})
mapIdx += 1
} // end map loop x424
x404
}
val x424 = x424_block
val x427 = { 
val x112 = new generated.scala.DoubleVectorImpl(5,true)
x112
}
val x428 = x427.isRow
// a *thin* loop follows: x435
val x435 = {
val x430 = new generated.scala.DoubleVectorImpl(5,x428)
x430
}
var x429 = 0
while (x429 < 5) {  // begin fat loop x435
val x432 = x427(x429)
val x433 = java.lang.Math.exp(x432)
x435.dcUpdate(x429, x433)
x429 += 1
} // end fat loop x435
val x436 = x435.length
// a *thin* loop follows: x443
var x443: Double = 0
var x437 = 0
while (x437 < x436) {  // begin fat loop x443
val x440 = x435(x437)
val x438 = x443
val x439 = x440
val x442 = x438 + x439
x443 = x442
x437 += 1
} // end fat loop x443
val x444 = Math.log(x443)
def x447_block = {
var mapIdx = 0
while (mapIdx < x427.size) { // begin map loop x447
val x445 = x427.dcApply(mapIdx)
x427.dcUpdate(mapIdx,  {
val x446 = x445 - x444
x446
})
mapIdx += 1
} // end map loop x447
x427
}
val x447 = x447_block
val x448 = new generated.scala.DenoiseEdgeDataImpl(x404,x427)
val x449 = x138.getRow(x141)
val x450 = x449(x144)
val x452 = x138.getRow(x451)
val x453 = x452(x144)
val x454 = new generated.scala.MessageEdgeImpl(x111,x401,x448,x450,x453)
val x455 = x138.getRow(x141)
val x456 = x455(x144)
val x457 = x138.getRow(x451)
val x458 = x457(x144)
val x459 = x111.addEdge(x454,x456,x458)
x459
}
if (x354) {
x461thenb()
}
}
val x462 = x140 += 1
()
}
val x465 = x139 += 1
()
}
val x468 = x10
val x469 = x468=="laplace"
val x470 = 10
val x495 = x468=="square"
val x508 = 0.0 - x470
val x523 = {
def x523thenb(): Unit = {
var x471: Int = 0
var x472: Int = 0
val x473 = x471
val x478 = x472
val x482 = x473 - x478
val x483 = Math.abs(x482)
val x484 = x483
val x485 = x470 * x484
val x486 = 0.0 - x485
val x493 = while ({val x474 = x11.numRows
val x475 = x473 < x474
x475}) {
x472 = 0
val x490 = while ({val x479 = x11.numCols
val x480 = x478 < x479
x480}) {
val x487 = x11(x473, x478) = x486
val x488 = x472 += 1
()
}
val x491 = x471 += 1
()
}
()
}
def x523elseb(): Unit = {
val x521 = {
def x521thenb(): Unit = {
var x496: Int = 0
var x497: Int = 0
val x498 = x496
val x503 = x497
val x507 = x498 != x503
val x519 = while ({val x499 = x11.numRows
val x500 = x498 < x499
x500}) {
x497 = 0
val x516 = while ({val x504 = x11.numCols
val x505 = x503 < x504
x505}) {
val x513 = {
def x513thenb(): Unit = {
val x509 = x11(x498, x503) = x508
x509
}
def x513elseb(): Unit = {
val x511 = x11(x498, x503) = 0.0
x511
}
if (x507) {
x513thenb()
} else { 
x513elseb()
}
}
val x514 = x497 += 1
()
}
val x517 = x496 += 1
()
}
()
}
if (x495) {
x521thenb()
}
}
x521
}
if (x469) {
x523thenb()
} else { 
x523elseb()
}
}
val x545 = { 
val x524 = x11.numRows
var x526 : Int = 0
val x543 = while (x526 < x524) {
val x527 = print("[ ")
val x528 = x11.numCols
var x530 : Int = 0
val x540 = while (x530 < x528) {
val x536 = { 
val x531 = x11.numCols
val x532 = x526 * x531
val x533 = x532 + x530
val x534 = x11.dcApply(x533)
x534
}
val x537 = print(x536)
val x538 = print(" ")
x538
x530 = x530 + 1
}
val x541 = print("]\n")
x541
x526 = x526 + 1
}
x543
}
var x546: Int = 1
val x547 = x111.freeze()
val x548 = Seq()
val x549 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
val x550 = x111.vertices
val x551 = x550.cloneL
val x552 = collection.mutable.HashSet[generated.scala.MessageVertex]()
val x646 = scala.Double.MinValue
val x647 = Math.log(x646)
val x650 = x11.numRows
val x651 = new generated.scala.VectorImpl[generated.scala.MatrixRow[Double]](x650,true)
val x652 = x11.numRows
var x654 : Int = 0
val x658 = while (x654 < x652) {
val x655 = x11.getRow(x654)
val x656 = x651(x654) = x655
x656
x654 = x654 + 1
}
val x686 = 0.1 != 0
val x745 = x546
val x746 = x745 % 100000
val x747 = x746==0
val x792 = while ({val x553 = x550.length
val x554 = x553 > 0
x554}) {
val x763 = {
var forIdx = 0
while (forIdx < x551.size) { // begin foreach loop x763
val x556 = x551.dcApply(forIdx)
val x557 = x556.data
val x558 = x557.asInstanceOf[generated.scala.DenoiseVertexData]
val x559 = x558.belief
val x560 = x558.potential
val x561 = x559.copyFrom(0, x560)
val x562 = x556.edges
val x574 = {
var forIdx = 0
while (forIdx < x562.size) { // begin foreach loop x574
val x563 = x562.dcApply(forIdx)
val x564 = x563.asInstanceOf[generated.scala.MessageEdge]
val x565 = x564.in(x556)
val x566 = x565.asInstanceOf[generated.scala.DenoiseEdgeData]
val x567 = x566.message
def x571_block = {
var zipIdx = 0
while (zipIdx < x559.size) { // begin zip loop x571
val x568 = x559.dcApply(zipIdx)
val x569 = x567.dcApply(zipIdx)
x559.dcUpdate(zipIdx,  {
val x570 = x568 + x569
x570
})
zipIdx += 1
} // end zip loop x571
x559
}
val x571 = x571_block
()
forIdx += 1
} // end foreach loop x574
}
val x575 = x559.length
val x576 = x559.isRow
val x582 = {
val x578 = new generated.scala.DoubleVectorImpl(x575,x576)
x578
}
var x577 = 0
while (x577 < x575) {  // begin fat loop x582
val x580 = x559(x577)
val x581 = java.lang.Math.exp(x580)
x582.dcUpdate(x577, x581)
x577 += 1
} // end fat loop x582
var x588: Double = 0
var x583 = 0
while (x583 < x575) {  // begin fat loop x588
val x586 = x582(x583)
val x584 = x588
val x585 = x586
val x587 = x584 + x585
x588 = x587
x583 += 1
} // end fat loop x588
val x589 = Math.log(x588)
def x592_block = {
var mapIdx = 0
while (mapIdx < x559.size) { // begin map loop x592
val x590 = x559.dcApply(mapIdx)
x559.dcUpdate(mapIdx,  {
val x591 = x590 - x589
x591
})
mapIdx += 1
} // end map loop x592
x559
}
val x592 = x592_block
val x599 = x559.cloneL
val x759 = {
var forIdx = 0
while (forIdx < x562.size) { // begin foreach loop x759
val x593 = x562.dcApply(forIdx)
val x594 = x593.asInstanceOf[generated.scala.MessageEdge]
val x595 = x594.in(x556)
val x596 = x595.asInstanceOf[generated.scala.DenoiseEdgeData]
val x600 = x596.message
def x604_block = {
var zipIdx = 0
while (zipIdx < x599.size) { // begin zip loop x604
val x601 = x599.dcApply(zipIdx)
val x602 = x600.dcApply(zipIdx)
x599.dcUpdate(zipIdx,  {
val x603 = x601 - x602
x603
})
zipIdx += 1
} // end zip loop x604
x599
}
val x604 = x604_block
val x605 = x604.length
val x606 = x604.isRow
val x612 = {
val x608 = new generated.scala.DoubleVectorImpl(x605,x606)
x608
}
var x607 = 0
while (x607 < x605) {  // begin fat loop x612
val x610 = x604(x607)
val x611 = java.lang.Math.exp(x610)
x612.dcUpdate(x607, x611)
x607 += 1
} // end fat loop x612
var x618: Double = 0
var x613 = 0
while (x613 < x605) {  // begin fat loop x618
val x616 = x612(x613)
val x614 = x618
val x615 = x616
val x617 = x614 + x615
x618 = x617
x613 += 1
} // end fat loop x618
val x619 = Math.log(x618)
def x622_block = {
var mapIdx = 0
while (mapIdx < x604.size) { // begin map loop x622
val x620 = x604.dcApply(mapIdx)
x604.dcUpdate(mapIdx,  {
val x621 = x620 - x619
x621
})
mapIdx += 1
} // end map loop x622
x604
}
val x622 = x622_block
def x663_block = {
val x660 = x11.numRows
val x661 = new generated.scala.DoubleVectorImpl(x660,true)
var mapIdx = 0
while (mapIdx < x651.size) { // begin map loop x663
val x623 = x651.dcApply(mapIdx)
x661.dcUpdate(mapIdx,  {
val x624 = x623.length
val x625 = x623.isRow
val x632 = {
val x627 = new generated.scala.DoubleVectorImpl(x624,x625)
x627
}
var x626 = 0
while (x626 < x624) {  // begin fat loop x632
val x629 = x623(x626)
val x630 = x622(x626)
val x631 = x629 + x630
x632.dcUpdate(x626, x631)
x626 += 1
} // end fat loop x632
val x638 = {
val x634 = new generated.scala.DoubleVectorImpl(x624,x625)
x634
}
var x633 = 0
while (x633 < x624) {  // begin fat loop x638
val x636 = x632(x633)
val x637 = java.lang.Math.exp(x636)
x638.dcUpdate(x633, x637)
x633 += 1
} // end fat loop x638
var x644: Double = 0
var x639 = 0
while (x639 < x624) {  // begin fat loop x644
val x642 = x638(x639)
val x640 = x644
val x641 = x642
val x643 = x640 + x641
x644 = x643
x639 += 1
} // end fat loop x644
val x645 = x644==0
val x648 = Math.log(x644)
val x649 = {
def x649thenb(): Double = {
x647
}
def x649elseb(): Double = {
x648
}
if (x645) {
x649thenb()
} else { 
x649elseb()
}
}
x649
})
mapIdx += 1
} // end map loop x663
x661
}
val x663 = x663_block
val x664 = x663.length
val x665 = x663.isRow
// a *thin* loop follows: x672
val x672 = {
val x667 = new generated.scala.DoubleVectorImpl(x664,x665)
x667
}
var x666 = 0
while (x666 < x664) {  // begin fat loop x672
val x669 = x663(x666)
val x670 = java.lang.Math.exp(x669)
x672.dcUpdate(x666, x670)
x666 += 1
} // end fat loop x672
val x673 = x672.length
// a *thin* loop follows: x680
var x680: Double = 0
var x674 = 0
while (x674 < x673) {  // begin fat loop x680
val x677 = x672(x674)
val x675 = x680
val x676 = x677
val x679 = x675 + x676
x680 = x679
x674 += 1
} // end fat loop x680
val x681 = Math.log(x680)
def x684_block = {
var mapIdx = 0
while (mapIdx < x663.size) { // begin map loop x684
val x682 = x663.dcApply(mapIdx)
x663.dcUpdate(mapIdx,  {
val x683 = x682 - x681
x683
})
mapIdx += 1
} // end map loop x684
x663
}
val x684 = x684_block
val x597 = x594.out(x556)
val x598 = x597.asInstanceOf[generated.scala.DenoiseEdgeData]
val x685 = x598.message
val x697 = {
def x697thenb(): generated.scala.Vector[Double] = {
def x695_block = {
var zipIdx = 0
while (zipIdx < x684.size) { // begin zip loop x695
val x687 = x684.dcApply(zipIdx)
val x688 = x685.dcApply(zipIdx)
x684.dcUpdate(zipIdx,  {
val x689 = Math.exp(x687)
val x690 = x689 * 0.9
val x691 = Math.exp(x688)
val x692 = x691 * 0.1
val x693 = x690 + x692
val x694 = Math.log(x693)
x694
})
zipIdx += 1
} // end zip loop x695
x684
}
val x695 = x695_block
x695
}
if (x686) {
x697thenb()
}
}
val x698 = x684.length
val x699 = x684.isRow
// a *thin* loop follows: x706
val x706 = {
val x701 = new generated.scala.DoubleVectorImpl(x698,x699)
x701
}
var x700 = 0
while (x700 < x698) {  // begin fat loop x706
val x703 = x684(x700)
val x704 = java.lang.Math.exp(x703)
x706.dcUpdate(x700, x704)
x700 += 1
} // end fat loop x706
val x715 = x706.length
val x716 = x706.isRow
val x707 = x685.length
val x708 = x685.isRow
val x714 = {
val x710 = new generated.scala.DoubleVectorImpl(x707,x708)
x710
}
var x709 = 0
while (x709 < x707) {  // begin fat loop x714
val x712 = x685(x709)
val x713 = java.lang.Math.exp(x712)
x714.dcUpdate(x709, x713)
x709 += 1
} // end fat loop x714
// a *thin* loop follows: x724
val x724 = {
val x718 = new generated.scala.DoubleVectorImpl(x715,x716)
x718
}
var x717 = 0
while (x717 < x715) {  // begin fat loop x724
val x720 = x706(x717)
val x721 = x714(x717)
val x722 = x720 - x721
x724.dcUpdate(x717, x722)
x717 += 1
} // end fat loop x724
val x725 = x724.length
val x726 = x724.isRow
// a *thin* loop follows: x733
val x733 = {
val x728 = new generated.scala.DoubleVectorImpl(x725,x726)
x728
}
var x727 = 0
while (x727 < x725) {  // begin fat loop x733
val x730 = x724(x727)
val x731 = java.lang.Math.abs(x730)
x733.dcUpdate(x727, x731)
x727 += 1
} // end fat loop x733
val x734 = x733.length
// a *thin* loop follows: x741
var x741: Double = 0
var x735 = 0
while (x735 < x734) {  // begin fat loop x741
val x738 = x733(x735)
val x736 = x741
val x737 = x738
val x740 = x736 + x737
x741 = x740
x735 += 1
} // end fat loop x741
val x744 = x598.setMessage(x684)
val x742 = x698
val x743 = x741 / x742
val x751 = {
def x751thenb(): Unit = {
val x748 = println(x745)
val x749 = println(x743)
x749
}
if (x747) {
x751thenb()
}
}
val x752 = x743 > 1.0E-15
val x753 = x594.target(x556)
val x756 = {
def x756thenb(): Unit = {
val x754 = x556.addTask(x753)
x754
}
if (x752) {
x756thenb()
}
}
x756
forIdx += 1
} // end foreach loop x759
}
val x760 = x546 += 1
()
forIdx += 1
} // end foreach loop x763
}
val x764 = x551.clear()
var x765: Int = 0
val x766 = x550.length
var x768 : Int = 0
val x789 = while (x768 < x766) {
val x769 = x550(x768)
val x770 = x769.tasks
val x771 = x770.length
val x772 = x765 += x771
var x774 : Int = 0
val x785 = while (x774 < x771) {
val x775 = x770(x774)
val x776 = x775.asInstanceOf[generated.scala.MessageVertex]
val x777 = x552.contains(x776)
val x778 = !x777
val x783 = {
def x783thenb(): Unit = {
val x779 = x550.length
val x780 = x551.insert(x779, x776)
val x781 = x552.add(x776)
x781
}
if (x778) {
x783thenb()
}
}
x783
x774 = x774 + 1
}
val x786 = x550(x768)
val x787 = x786.clearTasks()
x787
x768 = x768 + 1
}
val x790 = x552.clear()
x790
}
val x793 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
val x794 = x111.vertices
def x828_block = {
var forIdx = 0
while (forIdx < x794.size) { // begin foreachBounded loop x828
val x795 = x794.dcApply(forIdx)
var x800: Int = 0
val x796 = x795.data
val x797 = x796.asInstanceOf[generated.scala.DenoiseVertexData]
val x799 = x797.belief
val x801 = x799(0)
var x802: Double = x801
var x803: Int = 0
val x804 = x803
val x805 = x799.length
val x806 = x804 < x805
val x807 = x799(x804)
val x808 = x802
val x809 = x807 > x808
val x816 = while ({x806}) {
val x813 = {
def x813thenb(): Unit = {
x802 = x807
x800 = x804
()
}
if (x809) {
x813thenb()
}
}
val x814 = x803 += 1
()
}
val x817 = x800
val x818 = x817
val x798 = x797.id
val x819 = x798 / x137
val x820 = x798 % x137
val x821 = x110(x819, x820) = x818
x821
forIdx += 1
} // end foreachBounded loop x828
}
val x828 = x828_block
val x832 = java.lang.String.valueOf(x137)
val x835 = java.lang.String.valueOf(x136)
val x836 = x835+"\n"
val x851 = new generated.scala.IndexVectorRangeImpl(0,x136)
def x843_block = {
var x839 = x110.dcApply(0)
var reduceIdx = 1
while (reduceIdx < x110.size) { // begin reduce loop x843
val x840 = x110.dcApply(reduceIdx)
x839 = {
val x841 = x839 < x840
val x842 = {
def x842thenb(): Double = {
x839
}
def x842elseb(): Double = {
x840
}
if (x841) {
x842thenb()
} else { 
x842elseb()
}
}
x842
}
reduceIdx += 1
} // end reduce loop x843
x839
}
val x843 = x843_block
def x848_block = {
var x844 = x110.dcApply(0)
var reduceIdx = 1
while (reduceIdx < x110.size) { // begin reduce loop x848
val x845 = x110.dcApply(reduceIdx)
x844 = {
val x846 = x844 > x845
val x847 = {
def x847thenb(): Double = {
x844
}
def x847elseb(): Double = {
x845
}
if (x846) {
x847thenb()
} else { 
x847elseb()
}
}
x847
}
reduceIdx += 1
} // end reduce loop x848
x844
}
val x848 = x848_block
val x854 = x843 != x848
val x857 = x848 - x843
val x875 = { 
val x829 = new java.io.FileWriter("pred.pgm")
val x830 = new java.io.BufferedWriter(x829)
val x831 = x830.write("P2\n")
val x833 = x830.write(x832)
val x834 = x830.write(" ")
val x837 = x830.write(x836)
val x838 = x830.write("255\n")
val x872 = {
var forIdx = 0
while (forIdx < x851.size) { // begin foreach loop x872
val x850 = x851.dcApply(forIdx)
val x852 = x110.getRow(x850)
val x869 = {
var forIdx = 0
while (forIdx < x852.size) { // begin foreach loop x869
val x853 = x852.dcApply(forIdx)
val x855 = x853 - x843
val x856 = 255.0 * x855
val x858 = x856 / x857
val x859 = x858.asInstanceOf[Int]
val x860 = x859+""
val x865 = {
def x865thenb(): Unit = {
val x861 = x830.write(x860)
x861
}
def x865elseb(): Unit = {
val x863 = x830.write("0")
x863
}
if (x854) {
x865thenb()
} else { 
x865elseb()
}
}
val x866 = x830.write("\t")
x866
forIdx += 1
} // end foreach loop x869
}
val x870 = x830.write("\n")
x870
forIdx += 1
} // end foreach loop x872
}
val x873 = x830.close()
x873
}
val x876 = "Update functions ran: "+x745
val x877 = println(x876)
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
