/*****************************************
  Emitting Generated Code                  
*******************************************/
class Application extends ((Array[java.lang.String])=>(Unit)) {
def apply(x0:Array[java.lang.String]): Unit = {
val x1 = x0.length
val x2 = x1 < 1
val x7 = {
def x7thenb(): Nothing = {
val x3 = println("Usage: GraphLBP <rows> <cols>")
val x4 = println("Example: GraphLBP 100 100")
val x5 = exit(-1)
x5
}
def x7elseb(): Unit = {
()
}
if (x2) {
x7thenb()
} else {
x7elseb()
}
}
var x8 = 100
var x9 = 100
var x10 = "laplace"
val x11 = new generated.scala.DoubleMatrixImpl(5,5)
val x12 = x0(0)
def x57_block = { 
val x13 = new java.io.FileReader(x12)
val x14 = new java.io.BufferedReader(x13)
val x15 = x14.readLine()
var x16 = x15
val x17 = x16
val x18 = x17.trim()
x16 = x18
val x20 = x16
val x21 = x20.split("\\s+")
var x22 = x21
val x23 = x22
val x24 = x23.length
val x25 = new generated.scala.DoubleMatrixImpl(0,x24)
val x54 = while ({val x26 = x16
val x27 = x26 != null
x27}) {
val x29 = x22
val x30 = x29.length
val x31 = new generated.scala.DoubleVectorImpl(x30,true)
var x33 : Int = 0
val x39 = while (x33 < x30) {
val x34 = x22
val x35 = x34(x33)
val x36 = java.lang.Double.parseDouble(x35)
val x37 = x31(x33) = x36
x37
x33 = x33 + 1
}
val x40 = x25.numRows
val x41 = x25.insertRow(x40,x31)
val x42 = x14.readLine()
x16 = x42
val x44 = x16
val x45 = x44 != null
val x52 = {
def x52thenb(): Unit = {
val x46 = x44.trim()
x16 = x46
val x48 = x16
val x49 = x48.split("\\s+")
x22 = x49
()
}
def x52elseb(): Unit = {
()
}
if (x45) {
x52thenb()
} else {
x52elseb()
}
}
x52
}
val x55 = x14.close()
x25
}
val x57 = x57_block
val x61 = x57.numCols
val x62 = java.lang.String.valueOf(x61)
val x65 = x57.numRows
val x66 = java.lang.String.valueOf(x65)
val x67 = x66+"\n"
def x74_block = {
var x70 = x57.dcApply(0)
var reduceIdx = 1
while (reduceIdx < x57.size) {
val x71 = x57.dcApply(reduceIdx)
x70 = {
val x72 = x70 < x71
val x73 = {
def x73thenb(): Double = {
x70
}
def x73elseb(): Double = {
x71
}
if (x72) {
x73thenb()
} else {
x73elseb()
}
}
x73
}
reduceIdx += 1
} // end while
x70
}
val x74 = x74_block
def x79_block = {
var x75 = x57.dcApply(0)
var reduceIdx = 1
while (reduceIdx < x57.size) {
val x76 = x57.dcApply(reduceIdx)
x75 = {
val x77 = x75 > x76
val x78 = {
def x78thenb(): Double = {
x75
}
def x78elseb(): Double = {
x76
}
if (x77) {
x78thenb()
} else {
x78elseb()
}
}
x78
}
reduceIdx += 1
} // end while
x75
}
val x79 = x79_block
val x86 = x74 != x79
def x110_block = { 
val x58 = new java.io.FileWriter("check.pgm")
val x59 = new java.io.BufferedWriter(x58)
val x60 = x59.write("P2\n")
val x63 = x59.write(x62)
val x64 = x59.write(" ")
val x68 = x59.write(x67)
val x69 = x59.write("255\n")
def x107_block = { 
var x81 : Int = 0
val x105 = while (x81 < x65) {
val x82 = x81 * x61
val x83 = x57.vview(x82,1,x61,true)
def x84_block = { 
x83
}
val x84 = x84_block
def x102_block = {
var forIdx = 0
while (forIdx < x84.size) {
val x85 = x84.dcApply(forIdx)
val x97 = {
def x97thenb(): Unit = {
val x87 = x85 - x74
val x88 = 255.0 * x87
val x89 = x79 - x74
val x90 = x88 / x89
val x91 = x90.asInstanceOf[Int]
val x92 = x91+""
val x93 = x59.write(x92)
x93
}
def x97elseb(): Unit = {
val x95 = x59.write("0")
x95
}
if (x86) {
x97thenb()
} else {
x97elseb()
}
}
val x98 = x59.write("\t")
x98
forIdx += 1
} // end while
}
val x102 = x102_block
val x103 = x59.write("\n")
x103
x81 = x81 + 1
}
x105
}
val x107 = x107_block
val x108 = x59.close()
x108
}
val x110 = x110_block
val x113 = new generated.scala.UndirectedGraphImpl[generated.scala.MessageVertex, generated.scala.MessageEdge]()
def x116_block = { 
val x114 = new generated.scala.DoubleVectorImpl(5,true)
x114
}
val x116 = x116_block
def x122_block = {
val x117 = x116.isRow
val x118 = new generated.scala.DoubleVectorImpl(5,x117)
var mapIdx = 0
while (mapIdx < x116.size) {
val x120 = x116.dcApply(mapIdx)
x118.dcUpdate(mapIdx,  {
val x121 = Math.exp(x120)
x121
})
mapIdx += 1
} // end while
x118
}
val x122 = x122_block
val x123 = x122.length
var x129: Double = 0
var x124 = 0
while (x124 < x123) {  // begin fat loop x129
val x127 = x122(x124)
val x125 = x129
val x126 = x127
val x128 = x125 + x126
x129 = x128
x124 += 1
} // end fat loop x129
val x130 = Math.log(x129)
def x133_block = {
var mapIdx = 0
while (mapIdx < x116.size) {
val x131 = x116.dcApply(mapIdx)
x116.dcUpdate(mapIdx,  {
val x132 = x131 - x130
x132
})
mapIdx += 1
} // end while
x116
}
val x133 = x133_block
val x111 = x57.cloneL
val x135 = x111.numRows
val x136 = x111.numCols
val x137 = new generated.scala.MatrixImpl[generated.scala.MessageVertex](x135,x136)
val x112 = 2
val x134 = x112 * x112
val x153 = 2.0 * x134
var x139 : Int = 0
val x189 = while (x139 < x135) {
val x142 = x139 * x136
var x141 : Int = 0
val x187 = while (x141 < x136) {
def x146_block = { 
val x144 = new generated.scala.DoubleVectorImpl(5,true)
x144
}
val x146 = x146_block
val x147 = x111(x139, x141)
var x149 : Int = 0
val x158 = while (x149 < 5) {
val x150 = x149
val x151 = x147 - x150
val x152 = x151 * x151
val x154 = x152 / x153
val x155 = 0.0 - x154
val x156 = x146(x149) = x155
x156
x149 = x149 + 1
}
def x164_block = {
val x159 = x146.isRow
val x160 = new generated.scala.DoubleVectorImpl(5,x159)
var mapIdx = 0
while (mapIdx < x146.size) {
val x162 = x146.dcApply(mapIdx)
x160.dcUpdate(mapIdx,  {
val x163 = Math.exp(x162)
x163
})
mapIdx += 1
} // end while
x160
}
val x164 = x164_block
val x165 = x164.length
var x171: Double = 0
var x166 = 0
while (x166 < x165) {  // begin fat loop x171
val x169 = x164(x166)
val x167 = x171
val x168 = x169
val x170 = x167 + x168
x171 = x170
x166 += 1
} // end fat loop x171
val x172 = Math.log(x171)
def x175_block = {
var mapIdx = 0
while (mapIdx < x146.size) {
val x173 = x146.dcApply(mapIdx)
x146.dcUpdate(mapIdx,  {
val x174 = x173 - x172
x174
})
mapIdx += 1
} // end while
x146
}
val x175 = x175_block
val x176 = x116.cloneL
val x143 = x142 + x141
val x177 = new generated.scala.DenoiseVertexDataImpl(x143,x176,x146)
val x178 = new generated.scala.MessageVertexImpl(x113,x177)
def x183_block = { 
val x179 = x137.numCols
val x180 = x139 * x179
val x181 = x137.vview(x180,1,x179,true)
x181
}
val x183 = x183_block
val x184 = x183(x141) = x178
val x185 = x113.addVertex(x178)
x185
x141 = x141 + 1
}
x187
x139 = x139 + 1
}
def x192_block = { 
val x190 = new generated.scala.DoubleVectorImpl(5,true)
x190
}
val x192 = x192_block
def x198_block = {
val x193 = x192.isRow
val x194 = new generated.scala.DoubleVectorImpl(5,x193)
var mapIdx = 0
while (mapIdx < x192.size) {
val x196 = x192.dcApply(mapIdx)
x194.dcUpdate(mapIdx,  {
val x197 = Math.exp(x196)
x197
})
mapIdx += 1
} // end while
x194
}
val x198 = x198_block
val x199 = x198.length
var x205: Double = 0
var x200 = 0
while (x200 < x199) {  // begin fat loop x205
val x203 = x198(x200)
val x201 = x205
val x202 = x203
val x204 = x201 + x202
x205 = x204
x200 += 1
} // end fat loop x205
val x206 = Math.log(x205)
def x209_block = {
var mapIdx = 0
while (mapIdx < x192.size) {
val x207 = x192.dcApply(mapIdx)
x192.dcUpdate(mapIdx,  {
val x208 = x207 - x206
x208
})
mapIdx += 1
} // end while
x192
}
val x209 = x209_block
def x212_block = { 
val x210 = new generated.scala.DoubleVectorImpl(5,true)
x210
}
val x212 = x212_block
def x218_block = {
val x213 = x212.isRow
val x214 = new generated.scala.DoubleVectorImpl(5,x213)
var mapIdx = 0
while (mapIdx < x212.size) {
val x216 = x212.dcApply(mapIdx)
x214.dcUpdate(mapIdx,  {
val x217 = Math.exp(x216)
x217
})
mapIdx += 1
} // end while
x214
}
val x218 = x218_block
val x219 = x218.length
var x225: Double = 0
var x220 = 0
while (x220 < x219) {  // begin fat loop x225
val x223 = x218(x220)
val x221 = x225
val x222 = x223
val x224 = x221 + x222
x225 = x224
x220 += 1
} // end fat loop x225
val x226 = Math.log(x225)
def x229_block = {
var mapIdx = 0
while (mapIdx < x212.size) {
val x227 = x212.dcApply(mapIdx)
x212.dcUpdate(mapIdx,  {
val x228 = x227 - x226
x228
})
mapIdx += 1
} // end while
x212
}
val x229 = x229_block
val x230 = new generated.scala.DenoiseEdgeDataImpl(x192,x212)
val x233 = x136 - 1
val x346 = x135 - 1
var x231 : Int = 0
val x464 = while (x231 < x135) {
val x347 = x231 < x346
var x232 : Int = 0
val x462 = while (x232 < x136) {
val x234 = x232 < x233
val x345 = {
def x345thenb(): Unit = {
def x237_block = { 
val x235 = new generated.scala.DoubleVectorImpl(5,true)
x235
}
val x237 = x237_block
def x243_block = {
val x238 = x237.isRow
val x239 = new generated.scala.DoubleVectorImpl(5,x238)
var mapIdx = 0
while (mapIdx < x237.size) {
val x241 = x237.dcApply(mapIdx)
x239.dcUpdate(mapIdx,  {
val x242 = Math.exp(x241)
x242
})
mapIdx += 1
} // end while
x239
}
val x243 = x243_block
val x244 = x243.length
var x250: Double = 0
var x245 = 0
while (x245 < x244) {  // begin fat loop x250
val x248 = x243(x245)
val x246 = x250
val x247 = x248
val x249 = x246 + x247
x250 = x249
x245 += 1
} // end fat loop x250
val x251 = Math.log(x250)
def x254_block = {
var mapIdx = 0
while (mapIdx < x237.size) {
val x252 = x237.dcApply(mapIdx)
x237.dcUpdate(mapIdx,  {
val x253 = x252 - x251
x253
})
mapIdx += 1
} // end while
x237
}
val x254 = x254_block
def x257_block = { 
val x255 = new generated.scala.DoubleVectorImpl(5,true)
x255
}
val x257 = x257_block
def x263_block = {
val x258 = x257.isRow
val x259 = new generated.scala.DoubleVectorImpl(5,x258)
var mapIdx = 0
while (mapIdx < x257.size) {
val x261 = x257.dcApply(mapIdx)
x259.dcUpdate(mapIdx,  {
val x262 = Math.exp(x261)
x262
})
mapIdx += 1
} // end while
x259
}
val x263 = x263_block
val x264 = x263.length
var x270: Double = 0
var x265 = 0
while (x265 < x264) {  // begin fat loop x270
val x268 = x263(x265)
val x266 = x270
val x267 = x268
val x269 = x266 + x267
x270 = x269
x265 += 1
} // end fat loop x270
val x271 = Math.log(x270)
def x274_block = {
var mapIdx = 0
while (mapIdx < x257.size) {
val x272 = x257.dcApply(mapIdx)
x257.dcUpdate(mapIdx,  {
val x273 = x272 - x271
x273
})
mapIdx += 1
} // end while
x257
}
val x274 = x274_block
val x275 = new generated.scala.DenoiseEdgeDataImpl(x237,x257)
def x278_block = { 
val x276 = new generated.scala.DoubleVectorImpl(5,true)
x276
}
val x278 = x278_block
def x284_block = {
val x279 = x278.isRow
val x280 = new generated.scala.DoubleVectorImpl(5,x279)
var mapIdx = 0
while (mapIdx < x278.size) {
val x282 = x278.dcApply(mapIdx)
x280.dcUpdate(mapIdx,  {
val x283 = Math.exp(x282)
x283
})
mapIdx += 1
} // end while
x280
}
val x284 = x284_block
val x285 = x284.length
var x291: Double = 0
var x286 = 0
while (x286 < x285) {  // begin fat loop x291
val x289 = x284(x286)
val x287 = x291
val x288 = x289
val x290 = x287 + x288
x291 = x290
x286 += 1
} // end fat loop x291
val x292 = Math.log(x291)
def x295_block = {
var mapIdx = 0
while (mapIdx < x278.size) {
val x293 = x278.dcApply(mapIdx)
x278.dcUpdate(mapIdx,  {
val x294 = x293 - x292
x294
})
mapIdx += 1
} // end while
x278
}
val x295 = x295_block
def x298_block = { 
val x296 = new generated.scala.DoubleVectorImpl(5,true)
x296
}
val x298 = x298_block
def x304_block = {
val x299 = x298.isRow
val x300 = new generated.scala.DoubleVectorImpl(5,x299)
var mapIdx = 0
while (mapIdx < x298.size) {
val x302 = x298.dcApply(mapIdx)
x300.dcUpdate(mapIdx,  {
val x303 = Math.exp(x302)
x303
})
mapIdx += 1
} // end while
x300
}
val x304 = x304_block
val x305 = x304.length
var x311: Double = 0
var x306 = 0
while (x306 < x305) {  // begin fat loop x311
val x309 = x304(x306)
val x307 = x311
val x308 = x309
val x310 = x307 + x308
x311 = x310
x306 += 1
} // end fat loop x311
val x312 = Math.log(x311)
def x315_block = {
var mapIdx = 0
while (mapIdx < x298.size) {
val x313 = x298.dcApply(mapIdx)
x298.dcUpdate(mapIdx,  {
val x314 = x313 - x312
x314
})
mapIdx += 1
} // end while
x298
}
val x315 = x315_block
val x316 = new generated.scala.DenoiseEdgeDataImpl(x278,x298)
def x321_block = { 
val x317 = x137.numCols
val x318 = x231 * x317
val x319 = x137.vview(x318,1,x317,true)
x319
}
val x321 = x321_block
val x322 = x321(x232)
val x328 = x232 + 1
val x329 = x321(x328)
val x330 = new generated.scala.MessageEdgeImpl(x113,x275,x316,x322,x329)
def x335_block = { 
val x331 = x137.numCols
val x332 = x231 * x331
val x333 = x137.vview(x332,1,x331,true)
x333
}
val x335 = x335_block
val x336 = x335(x232)
val x342 = x335(x328)
val x343 = x113.addEdge(x330,x336,x342)
x343
}
def x345elseb(): Unit = {
()
}
if (x234) {
x345thenb()
} else {
x345elseb()
}
}
val x460 = {
def x460thenb(): Unit = {
def x350_block = { 
val x348 = new generated.scala.DoubleVectorImpl(5,true)
x348
}
val x350 = x350_block
def x356_block = {
val x351 = x350.isRow
val x352 = new generated.scala.DoubleVectorImpl(5,x351)
var mapIdx = 0
while (mapIdx < x350.size) {
val x354 = x350.dcApply(mapIdx)
x352.dcUpdate(mapIdx,  {
val x355 = Math.exp(x354)
x355
})
mapIdx += 1
} // end while
x352
}
val x356 = x356_block
val x357 = x356.length
var x363: Double = 0
var x358 = 0
while (x358 < x357) {  // begin fat loop x363
val x361 = x356(x358)
val x359 = x363
val x360 = x361
val x362 = x359 + x360
x363 = x362
x358 += 1
} // end fat loop x363
val x364 = Math.log(x363)
def x367_block = {
var mapIdx = 0
while (mapIdx < x350.size) {
val x365 = x350.dcApply(mapIdx)
x350.dcUpdate(mapIdx,  {
val x366 = x365 - x364
x366
})
mapIdx += 1
} // end while
x350
}
val x367 = x367_block
def x370_block = { 
val x368 = new generated.scala.DoubleVectorImpl(5,true)
x368
}
val x370 = x370_block
def x376_block = {
val x371 = x370.isRow
val x372 = new generated.scala.DoubleVectorImpl(5,x371)
var mapIdx = 0
while (mapIdx < x370.size) {
val x374 = x370.dcApply(mapIdx)
x372.dcUpdate(mapIdx,  {
val x375 = Math.exp(x374)
x375
})
mapIdx += 1
} // end while
x372
}
val x376 = x376_block
val x377 = x376.length
var x383: Double = 0
var x378 = 0
while (x378 < x377) {  // begin fat loop x383
val x381 = x376(x378)
val x379 = x383
val x380 = x381
val x382 = x379 + x380
x383 = x382
x378 += 1
} // end fat loop x383
val x384 = Math.log(x383)
def x387_block = {
var mapIdx = 0
while (mapIdx < x370.size) {
val x385 = x370.dcApply(mapIdx)
x370.dcUpdate(mapIdx,  {
val x386 = x385 - x384
x386
})
mapIdx += 1
} // end while
x370
}
val x387 = x387_block
val x388 = new generated.scala.DenoiseEdgeDataImpl(x350,x370)
def x391_block = { 
val x389 = new generated.scala.DoubleVectorImpl(5,true)
x389
}
val x391 = x391_block
def x397_block = {
val x392 = x391.isRow
val x393 = new generated.scala.DoubleVectorImpl(5,x392)
var mapIdx = 0
while (mapIdx < x391.size) {
val x395 = x391.dcApply(mapIdx)
x393.dcUpdate(mapIdx,  {
val x396 = Math.exp(x395)
x396
})
mapIdx += 1
} // end while
x393
}
val x397 = x397_block
val x398 = x397.length
var x404: Double = 0
var x399 = 0
while (x399 < x398) {  // begin fat loop x404
val x402 = x397(x399)
val x400 = x404
val x401 = x402
val x403 = x400 + x401
x404 = x403
x399 += 1
} // end fat loop x404
val x405 = Math.log(x404)
def x408_block = {
var mapIdx = 0
while (mapIdx < x391.size) {
val x406 = x391.dcApply(mapIdx)
x391.dcUpdate(mapIdx,  {
val x407 = x406 - x405
x407
})
mapIdx += 1
} // end while
x391
}
val x408 = x408_block
def x411_block = { 
val x409 = new generated.scala.DoubleVectorImpl(5,true)
x409
}
val x411 = x411_block
def x417_block = {
val x412 = x411.isRow
val x413 = new generated.scala.DoubleVectorImpl(5,x412)
var mapIdx = 0
while (mapIdx < x411.size) {
val x415 = x411.dcApply(mapIdx)
x413.dcUpdate(mapIdx,  {
val x416 = Math.exp(x415)
x416
})
mapIdx += 1
} // end while
x413
}
val x417 = x417_block
val x418 = x417.length
var x424: Double = 0
var x419 = 0
while (x419 < x418) {  // begin fat loop x424
val x422 = x417(x419)
val x420 = x424
val x421 = x422
val x423 = x420 + x421
x424 = x423
x419 += 1
} // end fat loop x424
val x425 = Math.log(x424)
def x428_block = {
var mapIdx = 0
while (mapIdx < x411.size) {
val x426 = x411.dcApply(mapIdx)
x411.dcUpdate(mapIdx,  {
val x427 = x426 - x425
x427
})
mapIdx += 1
} // end while
x411
}
val x428 = x428_block
val x429 = new generated.scala.DenoiseEdgeDataImpl(x391,x411)
def x434_block = { 
val x430 = x137.numCols
val x431 = x231 * x430
val x432 = x137.vview(x431,1,x430,true)
x432
}
val x434 = x434_block
val x436 = x231 + 1
def x442_block = { 
val x437 = x137.numCols
val x439 = x137.numCols
val x438 = x436 * x437
val x440 = x137.vview(x438,1,x439,true)
x440
}
val x442 = x442_block
val x435 = x434(x232)
val x443 = x442(x232)
val x444 = new generated.scala.MessageEdgeImpl(x113,x388,x429,x435,x443)
def x449_block = { 
val x445 = x137.numCols
val x446 = x231 * x445
val x447 = x137.vview(x446,1,x445,true)
x447
}
val x449 = x449_block
def x456_block = { 
val x451 = x137.numCols
val x453 = x137.numCols
val x452 = x436 * x451
val x454 = x137.vview(x452,1,x453,true)
x454
}
val x456 = x456_block
val x450 = x449(x232)
val x457 = x456(x232)
val x458 = x113.addEdge(x444,x450,x457)
x458
}
def x460elseb(): Unit = {
()
}
if (x347) {
x460thenb()
} else {
x460elseb()
}
}
x460
x232 = x232 + 1
}
x462
x231 = x231 + 1
}
val x465 = x10
val x466 = x465=="laplace"
val x506 = {
def x506thenb(): Unit = {
val x468 = x11.numRows
val x467 = 10
var x470 : Int = 0
val x483 = while (x470 < x468) {
val x471 = x11.numCols
var x473 : Int = 0
val x481 = while (x473 < x471) {
val x474 = x470 - x473
val x475 = Math.abs(x474)
val x476 = x475
val x477 = x467 * x476
val x478 = 0.0 - x477
val x479 = x11(x470, x473) = x478
x479
x473 = x473 + 1
}
x481
x470 = x470 + 1
}
x483
}
def x506elseb(): Unit = {
val x485 = x465=="square"
val x504 = {
def x504thenb(): Unit = {
val x486 = x11.numRows
var x488 : Int = 0
val x502 = while (x488 < x486) {
val x489 = x11.numCols
var x491 : Int = 0
val x500 = while (x491 < x489) {
val x492 = x488 != x491
val x498 = {
def x498thenb(): Unit = {
val x467 = 10
val x493 = 0.0 - x467
val x494 = x11(x488, x491) = x493
x494
}
def x498elseb(): Unit = {
val x496 = x11(x488, x491) = 0.0
x496
}
if (x492) {
x498thenb()
} else {
x498elseb()
}
}
x498
x491 = x491 + 1
}
x500
x488 = x488 + 1
}
x502
}
def x504elseb(): Unit = {
()
}
if (x485) {
x504thenb()
} else {
x504elseb()
}
}
x504
}
if (x466) {
x506thenb()
} else {
x506elseb()
}
}
def x523_block = { 
val x507 = x11.numRows
var x509 : Int = 0
val x521 = while (x509 < x507) {
val x510 = print("[ ")
val x511 = x11.numCols
var x513 : Int = 0
val x518 = while (x513 < x511) {
val x514 = x11(x509, x513)
val x515 = print(x514)
val x516 = print(" ")
x516
x513 = x513 + 1
}
val x519 = print("]\n")
x519
x509 = x509 + 1
}
x521
}
val x523 = x523_block
var x524 = 1
val x525 = x113.freeze()
val x526 = println("tic:" + (System.nanoTime / 1000000L))
val x527 = x113.vertices
val x529 = collection.mutable.HashSet[generated.scala.MessageVertex]()
val x530 = x527.length
val x531 = x530 > 0
val x528 = x527.cloneL
val x629 = x11.numRows
val x630 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](x629,true)
var x631 = x630
var x633 : Int = 0
val x643 = while (x633 < x629) {
val x634 = x631
def x640_block = { 
val x635 = x11.numCols
val x637 = x11.numCols
val x636 = x633 * x635
val x638 = x11.vview(x636,1,x637,true)
x638
}
val x640 = x640_block
val x641 = x634(x633) = x640
x641
x633 = x633 + 1
}
val x644 = x631
val x669 = 0.1 != 0
val x764 = while ({x531}) {
def x738_block = {
var forIdx = 0
while (forIdx < x528.size) {
val x532 = x528.dcApply(forIdx)
val x533 = x532.data
val x534 = x533.asInstanceOf[generated.scala.DenoiseVertexData]
val x535 = x534.belief
val x536 = x534.potential
val x537 = x535.copyFrom(0, x536)
val x538 = x532.edges
def x550_block = {
var forIdx = 0
while (forIdx < x538.size) {
val x539 = x538.dcApply(forIdx)
val x540 = x539.asInstanceOf[generated.scala.MessageEdge]
val x541 = x540.in(x532)
val x542 = x541.asInstanceOf[generated.scala.DenoiseEdgeData]
val x543 = x542.message
def x547_block = {
var zipIdx = 0
while (zipIdx < x535.size) {
val x544 = x535.dcApply(zipIdx)
val x545 = x543.dcApply(zipIdx)
x535.dcUpdate(zipIdx,  {
val x546 = x544 + x545
x546
})
zipIdx += 1
} // end while
x535
}
val x547 = x547_block
()
forIdx += 1
} // end while
}
val x550 = x550_block
val x551 = x535.length
val x552 = x535.isRow
def x557_block = {
val x553 = new generated.scala.DoubleVectorImpl(x551,x552)
var mapIdx = 0
while (mapIdx < x535.size) {
val x555 = x535.dcApply(mapIdx)
x553.dcUpdate(mapIdx,  {
val x556 = Math.exp(x555)
x556
})
mapIdx += 1
} // end while
x553
}
val x557 = x557_block
val x558 = x557.length
var x564: Double = 0
var x559 = 0
while (x559 < x558) {  // begin fat loop x564
val x562 = x557(x559)
val x560 = x564
val x561 = x562
val x563 = x560 + x561
x564 = x563
x559 += 1
} // end fat loop x564
val x565 = Math.log(x564)
def x568_block = {
var mapIdx = 0
while (mapIdx < x535.size) {
val x566 = x535.dcApply(mapIdx)
x535.dcUpdate(mapIdx,  {
val x567 = x566 - x565
x567
})
mapIdx += 1
} // end while
x535
}
val x568 = x568_block
val x575 = x535.cloneL
def x734_block = {
var forIdx = 0
while (forIdx < x538.size) {
val x569 = x538.dcApply(forIdx)
val x570 = x569.asInstanceOf[generated.scala.MessageEdge]
val x571 = x570.in(x532)
val x572 = x571.asInstanceOf[generated.scala.DenoiseEdgeData]
val x576 = x572.message
def x580_block = {
var zipIdx = 0
while (zipIdx < x575.size) {
val x577 = x575.dcApply(zipIdx)
val x578 = x576.dcApply(zipIdx)
x575.dcUpdate(zipIdx,  {
val x579 = x577 - x578
x579
})
zipIdx += 1
} // end while
x575
}
val x580 = x580_block
val x581 = x580.length
val x582 = x580.isRow
def x587_block = {
val x583 = new generated.scala.DoubleVectorImpl(x581,x582)
var mapIdx = 0
while (mapIdx < x580.size) {
val x585 = x580.dcApply(mapIdx)
x583.dcUpdate(mapIdx,  {
val x586 = Math.exp(x585)
x586
})
mapIdx += 1
} // end while
x583
}
val x587 = x587_block
val x588 = x587.length
var x594: Double = 0
var x589 = 0
while (x589 < x588) {  // begin fat loop x594
val x592 = x587(x589)
val x590 = x594
val x591 = x592
val x593 = x590 + x591
x594 = x593
x589 += 1
} // end fat loop x594
val x595 = Math.log(x594)
def x598_block = {
var mapIdx = 0
while (mapIdx < x580.size) {
val x596 = x580.dcApply(mapIdx)
x580.dcUpdate(mapIdx,  {
val x597 = x596 - x595
x597
})
mapIdx += 1
} // end while
x580
}
val x598 = x598_block
def x649_block = {
val x646 = x11.numRows
val x647 = new generated.scala.DoubleVectorImpl(x646,true)
var mapIdx = 0
while (mapIdx < x644.size) {
val x599 = x644.dcApply(mapIdx)
x647.dcUpdate(mapIdx,  {
val x600 = x599.length
val x601 = x599.isRow
val x608 = {
val x603 = new generated.scala.DoubleVectorImpl(x600,x601)
x603
}
var x602 = 0
while (x602 < x600) {  // begin fat loop x608
val x605 = x599(x602)
val x606 = x598(x602)
val x607 = x605 + x606
x608.dcUpdate(x602, x607)
x602 += 1
} // end fat loop x608
def x613_block = {
val x609 = new generated.scala.DoubleVectorImpl(x600,x601)
var mapIdx = 0
while (mapIdx < x608.size) {
val x611 = x608.dcApply(mapIdx)
x609.dcUpdate(mapIdx,  {
val x612 = Math.exp(x611)
x612
})
mapIdx += 1
} // end while
x609
}
val x613 = x613_block
val x614 = x613.length
var x620: Double = 0
var x615 = 0
while (x615 < x614) {  // begin fat loop x620
val x618 = x613(x615)
val x616 = x620
val x617 = x618
val x619 = x616 + x617
x620 = x619
x615 += 1
} // end fat loop x620
val x621 = x620==0
val x627 = {
def x627thenb(): Double = {
val x622 = scala.Double.MinValue
val x623 = Math.log(x622)
x623
}
def x627elseb(): Double = {
val x625 = Math.log(x620)
x625
}
if (x621) {
x627thenb()
} else {
x627elseb()
}
}
x627
})
mapIdx += 1
} // end while
x647
}
val x649 = x649_block
val x650 = x649.length
val x651 = x649.isRow
def x656_block = {
val x652 = new generated.scala.DoubleVectorImpl(x650,x651)
var mapIdx = 0
while (mapIdx < x649.size) {
val x654 = x649.dcApply(mapIdx)
x652.dcUpdate(mapIdx,  {
val x655 = Math.exp(x654)
x655
})
mapIdx += 1
} // end while
x652
}
val x656 = x656_block
val x657 = x656.length
var x663: Double = 0
var x658 = 0
while (x658 < x657) {  // begin fat loop x663
val x661 = x656(x658)
val x659 = x663
val x660 = x661
val x662 = x659 + x660
x663 = x662
x658 += 1
} // end fat loop x663
val x664 = Math.log(x663)
def x667_block = {
var mapIdx = 0
while (mapIdx < x649.size) {
val x665 = x649.dcApply(mapIdx)
x649.dcUpdate(mapIdx,  {
val x666 = x665 - x664
x666
})
mapIdx += 1
} // end while
x649
}
val x667 = x667_block
val x573 = x570.out(x532)
val x574 = x573.asInstanceOf[generated.scala.DenoiseEdgeData]
val x668 = x574.message
val x681 = {
def x681thenb(): generated.scala.Vector[Double] = {
def x679_block = {
var zipIdx = 0
while (zipIdx < x667.size) {
val x670 = x667.dcApply(zipIdx)
val x671 = x668.dcApply(zipIdx)
x667.dcUpdate(zipIdx,  {
val x672 = Math.exp(x670)
val x674 = Math.exp(x671)
val x673 = x672 * 0.9
val x675 = x674 * 0.1
val x676 = x673 + x675
val x677 = Math.log(x676)
x677
})
zipIdx += 1
} // end while
x667
}
val x679 = x679_block
x679
}
def x681elseb(): Unit = {
()
}
if (x669) {
x681thenb()
} else {
x681elseb()
}
}
val x719 = x574.setMessage(x667)
val x720 = x524
val x721 = x720 % 100000
val x722 = x721==0
val x682 = x667.length
val x683 = x667.isRow
def x688_block = {
val x684 = new generated.scala.DoubleVectorImpl(x682,x683)
var mapIdx = 0
while (mapIdx < x667.size) {
val x686 = x667.dcApply(mapIdx)
x684.dcUpdate(mapIdx,  {
val x687 = Math.exp(x686)
x687
})
mapIdx += 1
} // end while
x684
}
val x688 = x688_block
val x696 = x688.length
val x697 = x688.isRow
val x689 = x668.length
val x690 = x668.isRow
def x695_block = {
val x691 = new generated.scala.DoubleVectorImpl(x689,x690)
var mapIdx = 0
while (mapIdx < x668.size) {
val x693 = x668.dcApply(mapIdx)
x691.dcUpdate(mapIdx,  {
val x694 = Math.exp(x693)
x694
})
mapIdx += 1
} // end while
x691
}
val x695 = x695_block
val x704 = {
val x699 = new generated.scala.DoubleVectorImpl(x696,x697)
x699
}
var x698 = 0
while (x698 < x696) {  // begin fat loop x704
val x701 = x688(x698)
val x702 = x695(x698)
val x703 = x701 - x702
x704.dcUpdate(x698, x703)
x698 += 1
} // end fat loop x704
def x709_block = {
val x705 = new generated.scala.DoubleVectorImpl(x696,x697)
var mapIdx = 0
while (mapIdx < x704.size) {
val x707 = x704.dcApply(mapIdx)
x705.dcUpdate(mapIdx,  {
val x708 = Math.abs(x707)
x708
})
mapIdx += 1
} // end while
x705
}
val x709 = x709_block
val x710 = x709.length
var x716: Double = 0
var x711 = 0
while (x711 < x710) {  // begin fat loop x716
val x714 = x709(x711)
val x712 = x716
val x713 = x714
val x715 = x712 + x713
x716 = x715
x711 += 1
} // end fat loop x716
val x717 = x682
val x718 = x716 / x717
val x726 = {
def x726thenb(): Unit = {
val x723 = println(x720)
val x724 = println(x718)
x724
}
def x726elseb(): Unit = {
()
}
if (x722) {
x726thenb()
} else {
x726elseb()
}
}
val x727 = x718 > 1.0E-15
val x731 = {
def x731thenb(): Unit = {
val x728 = x570.target(x532)
val x729 = x532.addTask(x728)
x729
}
def x731elseb(): Unit = {
()
}
if (x727) {
x731thenb()
} else {
x731elseb()
}
}
x731
forIdx += 1
} // end while
}
val x734 = x734_block
val x735 = x524 += 1
()
forIdx += 1
} // end while
}
val x738 = x738_block
val x739 = x528.clear()
var x740 = 0
var x742 : Int = 0
val x761 = while (x742 < x530) {
val x743 = x527(x742)
val x744 = x743.tasks
val x745 = x744.length
val x746 = x740 += x745
var x748 : Int = 0
val x758 = while (x748 < x745) {
val x749 = x744(x748)
val x750 = x749.asInstanceOf[generated.scala.MessageVertex]
val x751 = x529.contains(x750)
val x752 = !x751
val x756 = {
def x756thenb(): Unit = {
val x753 = x528.insert(x530, x750)
val x754 = x529.add(x750)
x754
}
def x756elseb(): Unit = {
()
}
if (x752) {
x756thenb()
} else {
x756elseb()
}
}
x756
x748 = x748 + 1
}
val x759 = x743.clearTasks()
x759
x742 = x742 + 1
}
val x762 = x529.clear()
x762
}
val x765 = println("toc:" + (System.nanoTime / 1000000L))
val x766 = x113.vertices
def x804_block = {
var forIdx = 0
while (forIdx < x766.size) {
val x767 = x766.dcApply(forIdx)
var x772 = 0
val x768 = x767.data
val x769 = x768.asInstanceOf[generated.scala.DenoiseVertexData]
val x771 = x769.belief
val x773 = x771(0)
var x774 = x773
var x775 = 0
val x777 = x771.length
val x793 = while ({val x776 = x775
val x778 = x776 < x777
x778}) {
val x780 = x775
val x782 = x774
val x781 = x771(x780)
val x783 = x781 > x782
val x790 = {
def x790thenb(): Unit = {
val x784 = x775
val x785 = x771(x784)
x774 = x785
val x787 = x775
x772 = x787
()
}
def x790elseb(): Unit = {
()
}
if (x783) {
x790thenb()
} else {
x790elseb()
}
}
val x791 = x775 += 1
()
}
val x794 = x772
val x795 = x794
val x770 = x769.id
val x796 = x770 / x136
val x797 = x770 % x136
val x798 = x111(x796, x797) = x795
x798
forIdx += 1
} // end while
}
val x804 = x804_block
val x808 = java.lang.String.valueOf(x136)
val x811 = java.lang.String.valueOf(x135)
val x812 = x811+"\n"
def x819_block = {
var x815 = x111.dcApply(0)
var reduceIdx = 1
while (reduceIdx < x111.size) {
val x816 = x111.dcApply(reduceIdx)
x815 = {
val x817 = x815 < x816
val x818 = {
def x818thenb(): Double = {
x815
}
def x818elseb(): Double = {
x816
}
if (x817) {
x818thenb()
} else {
x818elseb()
}
}
x818
}
reduceIdx += 1
} // end while
x815
}
val x819 = x819_block
def x824_block = {
var x820 = x111.dcApply(0)
var reduceIdx = 1
while (reduceIdx < x111.size) {
val x821 = x111.dcApply(reduceIdx)
x820 = {
val x822 = x820 > x821
val x823 = {
def x823thenb(): Double = {
x820
}
def x823elseb(): Double = {
x821
}
if (x822) {
x823thenb()
} else {
x823elseb()
}
}
x823
}
reduceIdx += 1
} // end while
x820
}
val x824 = x824_block
val x830 = x819 != x824
def x853_block = { 
val x805 = new java.io.FileWriter("pred.pgm")
val x806 = new java.io.BufferedWriter(x805)
val x807 = x806.write("P2\n")
val x809 = x806.write(x808)
val x810 = x806.write(" ")
val x813 = x806.write(x812)
val x814 = x806.write("255\n")
def x850_block = { 
var x825 : Int = 0
val x848 = while (x825 < x135) {
val x826 = x825 * x136
val x827 = x111.vview(x826,1,x136,true)
def x828_block = { 
x827
}
val x828 = x828_block
def x845_block = {
var forIdx = 0
while (forIdx < x828.size) {
val x829 = x828.dcApply(forIdx)
val x841 = {
def x841thenb(): Unit = {
val x831 = x829 - x819
val x832 = 255.0 * x831
val x833 = x824 - x819
val x834 = x832 / x833
val x835 = x834.asInstanceOf[Int]
val x836 = x835+""
val x837 = x806.write(x836)
x837
}
def x841elseb(): Unit = {
val x839 = x806.write("0")
x839
}
if (x830) {
x841thenb()
} else {
x841elseb()
}
}
val x842 = x806.write("\t")
x842
forIdx += 1
} // end while
}
val x845 = x845_block
val x846 = x806.write("\n")
x846
x825 = x825 + 1
}
x848
}
val x850 = x850_block
val x851 = x806.close()
x851
}
val x853 = x853_block
val x854 = x524
val x855 = "Update functions ran: "+x854
val x856 = println(x855)
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
