/*****************************************
  Emitting Generated Code                  
*******************************************/
class LinRegRunner extends ((Array[java.lang.String])=>(Unit)) {
def apply(x0:Array[java.lang.String]): Unit = {
val x1 = x0.length
val x2 = x1 < 2
val x6 = {
def x6thenb(): Nothing = {
val x3 = println("Usage: LinRegSerial <input vector file> <output vector file>")
val x4 = exit(-1)
x4
}
def x6elseb(): Unit = {
()
}
if (x2) {
x6thenb()
} else {
x6elseb()
}
}
val x7 = x0(0)
val x29 = { 
val x8 = new generated.scala.DoubleVectorImpl(0,true)
val x9 = new java.io.FileReader(x7)
val x10 = new java.io.BufferedReader(x9)
val x11 = x10.readLine()
var x12: java.lang.String = x11
val x26 = while ({val x13 = x12
val x14 = x13 != null
x14}) {
val x16 = x12
val x17 = x16.trim()
x12 = x17
val x19 = x12
val x21 = x8.length
val x20 = java.lang.Double.parseDouble(x19)
val x22 = x8.insert(x21, x20)
val x23 = x10.readLine()
x12 = x23
()
}
val x27 = x10.close()
x8
}
val x30 = x29.mtrans
val x31 = x0(1)
val x53 = { 
val x32 = new generated.scala.DoubleVectorImpl(0,true)
val x33 = new java.io.FileReader(x31)
val x34 = new java.io.BufferedReader(x33)
val x35 = x34.readLine()
var x36: java.lang.String = x35
val x50 = while ({val x37 = x36
val x38 = x37 != null
x38}) {
val x40 = x36
val x41 = x40.trim()
x36 = x41
val x43 = x36
val x45 = x32.length
val x44 = java.lang.Double.parseDouble(x43)
val x46 = x32.insert(x45, x44)
val x47 = x34.readLine()
x36 = x47
()
}
val x51 = x34.close()
x32
}
val x54 = x53.mtrans
val x55 = x30.length
val x60 = { 
val x56 = new generated.scala.DoubleVectorImpl(x55,true)
def x58_block = {
var mapIdx = 0
while (mapIdx < x56.size) { // begin map loop x58
val x57 = x56.dcApply(mapIdx)
x56.dcUpdate(mapIdx,  {
1.0
})
mapIdx += 1
} // end map loop x58
x56
}
val x58 = x58_block
x58
}
val x61 = x60.mtrans
val x62 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
val x63 = x62.length
val x64 = x62.insert(x63, x61)
val x65 = x62.length
val x66 = x62.insert(x65, x30)
val x102 = { 
val x67 = x62.length
val x68 = x67==0
val x100 = {
def x100thenb(): generated.scala.Matrix[Double] = {
val x69 = new generated.scala.DoubleMatrixImpl(0,0)
x69
}
def x100elseb(): generated.scala.Matrix[Double] = {
val x71 = x62(0)
val x72 = x71.isRow
val x98 = {
def x98thenb(): generated.scala.Matrix[Double] = {
val x73 = x71.length
val x74 = new generated.scala.DoubleMatrixImpl(x67,x73)
var x76 : Int = 0
val x85 = while (x76 < x67) {
var x78 : Int = 0
val x83 = while (x78 < x73) {
val x79 = x62(x76)
val x80 = x79(x78)
val x81 = x74(x76, x78) = x80
x81
x78 = x78 + 1
}
x83
x76 = x76 + 1
}
x74
}
def x98elseb(): generated.scala.Matrix[Double] = {
val x73 = x71.length
val x87 = new generated.scala.DoubleMatrixImpl(x73,x67)
var x88 : Int = 0
val x96 = while (x88 < x67) {
var x89 : Int = 0
val x94 = while (x89 < x73) {
val x90 = x62(x88)
val x91 = x90(x89)
val x92 = x87(x89, x88) = x91
x92
x89 = x89 + 1
}
x94
x88 = x88 + 1
}
x87
}
if (x72) {
x98thenb()
} else {
x98elseb()
}
}
x98
}
if (x68) {
x100thenb()
} else {
x100elseb()
}
}
x100
}
val x409 = println("Unweighted linear regression")
val x410 = println("theta: ")
val x103 = x102.numCols
val x104 = x102.numRows
val x119 = { 
val x105 = new generated.scala.DoubleMatrixImpl(x103,x104)
val x106 = x105.numRows
var x108 : Int = 0
val x117 = while (x108 < x106) {
val x109 = x105.numCols
var x111 : Int = 0
val x115 = while (x111 < x109) {
val x112 = x102(x111, x108)
val x113 = x105(x108, x111) = x112
x113
x111 = x111 + 1
}
x115
x108 = x108 + 1
}
x105
}
val x134 = x119.numRows
val x136 = new generated.scala.IndexVectorRangeImpl(0,x134)
val x150 = x119.numCols
val x171 = List()
val x174 = { 
val x135 = new generated.scala.DoubleMatrixImpl(x134,x103)
def x172_block = {
var forIdx = 0
while (forIdx < x136.size) { // begin foreach loop x172
val x137 = x136.dcApply(forIdx)
var x138: Int = 0
val x144 = x119(x137, 0)
val x168 = while ({val x139 = x138
val x140 = x135.numCols
val x141 = x139 < x140
x141}) {
var x143: Int = 1
val x145 = x138
val x146 = x119(x145, 0)
val x147 = x144 * x146
var x148: Double = x147
val x162 = while ({val x149 = x143
val x151 = x149 < x150
x151}) {
val x153 = x143
val x155 = x138
val x156 = x143
val x154 = x119(x137, x153)
val x157 = x119(x155, x156)
val x158 = x154 * x157
val x159 = x148 += x158
val x160 = x143 += 1
()
}
val x163 = x138
val x164 = x148
val x165 = x135(x137, x163) = x164
val x166 = x138 += 1
()
}
()
forIdx += 1
} // end foreach loop x172
}
val x172 = x172_block
x135
}
val x175 = x174.cloneL
val x177 = x174.numCols
val x196 = { 
val x183 = new generated.scala.DoubleMatrixImpl(x177,x177)
var x184: Int = 0
val x194 = while ({val x185 = x184
val x186 = x185 < x177
x186}) {
val x188 = x184
val x189 = x184
val x190 = x184
val x191 = x183(x188, x189) = 1
val x192 = x184 += 1
()
}
x183
}
val x197 = { 
x196
}
val x356 = { 
var x176: generated.scala.Matrix[Double] = x175
val x198 = x176
val x200 = x198.numRows
val x201 = x198.numCols
def x204_block = {
val x202 = new generated.scala.DoubleMatrixImpl(x200,x201)
var mapIdx = 0
while (mapIdx < x198.size) { // begin map loop x204
val x199 = x198.dcApply(mapIdx)
x202.dcUpdate(mapIdx,  {
x199
})
mapIdx += 1
} // end map loop x204
x202
}
val x204 = x204_block
val x205 = x204.insertAllCols(x201,x197)
var x206: Int = 0
var x207: Boolean = false
var x208: Int = 0
val x212 = x204.numRows
val x353 = while ({val x209 = x207
val x211 = x208
val x210 = !x209
val x213 = x211 < x212
val x214 = x210 && x213
x214}) {
val x216 = x206
val x217 = x212 <= x216
val x220 = {
def x220thenb(): Unit = {
x207 = true
()
}
def x220elseb(): Unit = {
()
}
if (x217) {
x220thenb()
} else {
x220elseb()
}
}
val x221 = x207
val x222 = !x221
val x350 = {
def x350thenb(): Unit = {
val x223 = x208
var x224: Int = x223
val x234 = x204.numCols
val x248 = while ({val x225 = x207
val x227 = x224
val x228 = x206
val x226 = !x225
val x229 = x204(x227, x228)
val x230 = x229==0.0
val x231 = x226 && x230
x231}) {
val x233 = x224 += 1
val x235 = x224
val x236 = x234==x235
val x246 = {
def x246thenb(): Unit = {
val x237 = x208
x224 = x237
val x239 = x206 += 1
val x240 = x206
val x241 = x212==x240
val x244 = {
def x244thenb(): Unit = {
x207 = true
()
}
def x244elseb(): Unit = {
()
}
if (x241) {
x244thenb()
} else {
x244elseb()
}
}
x244
}
def x246elseb(): Unit = {
()
}
if (x236) {
x246thenb()
} else {
x246elseb()
}
}
x246
}
val x249 = x207
val x250 = !x249
val x348 = {
def x348thenb(): Unit = {
val x251 = x224
val x253 = x208
val x267 = { 
var x255: Int = 0
val x265 = while ({val x256 = x255
val x257 = x256 < x234
x257}) {
val x259 = x255
val x260 = x255
val x261 = x204(x253, x260)
val x262 = x204(x251, x259) = x261
val x263 = x255 += 1
()
}
()
}
val x268 = x208
val x281 = { 
var x269: Int = 0
val x279 = while ({val x270 = x269
val x271 = x270 < x234
x271}) {
val x273 = x269
val x274 = x269
val x275 = x204(x251, x274)
val x276 = x204(x268, x273) = x275
val x277 = x269 += 1
()
}
()
}
val x282 = x208
val x283 = x208
val x285 = x208
val x286 = x206
val x287 = x204(x285, x286)
val x293 = {
val x289 = new generated.scala.DoubleVectorImpl(x234,true)
x289
}
var x288 = 0
while (x288 < x234) {  // begin fat loop x293
val x291 = x204(x283, x288)
val x292 = x291 / x287
x293.dcUpdate(x288, x292)
x288 += 1
} // end fat loop x293
val x306 = { 
var x294: Int = 0
val x304 = while ({val x295 = x294
val x296 = x295 < x234
x296}) {
val x298 = x294
val x299 = x294
val x300 = x293(x299)
val x301 = x204(x282, x298) = x300
val x302 = x294 += 1
()
}
()
}
var x308 : Int = 0
val x345 = while (x308 < x212) {
val x309 = x208
val x310 = x308 != x309
val x343 = {
def x343thenb(): Unit = {
val x312 = x208
val x314 = x206
val x315 = x204(x308, x314)
val x321 = {
val x317 = new generated.scala.DoubleVectorImpl(x234,true)
x317
}
var x316 = 0
while (x316 < x234) {  // begin fat loop x321
val x319 = x204(x312, x316)
val x320 = x319 * x315
x321.dcUpdate(x316, x320)
x316 += 1
} // end fat loop x321
val x328 = {
val x323 = new generated.scala.DoubleVectorImpl(x234,true)
x323
}
var x322 = 0
while (x322 < x234) {  // begin fat loop x328
val x325 = x204(x308, x322)
val x326 = x321(x322)
val x327 = x325 - x326
x328.dcUpdate(x322, x327)
x322 += 1
} // end fat loop x328
val x341 = { 
var x329: Int = 0
val x339 = while ({val x330 = x329
val x331 = x330 < x234
x331}) {
val x333 = x329
val x334 = x329
val x335 = x328(x334)
val x336 = x204(x308, x333) = x335
val x337 = x329 += 1
()
}
()
}
x341
}
def x343elseb(): Unit = {
()
}
if (x310) {
x343thenb()
} else {
x343elseb()
}
}
x343
x308 = x308 + 1
}
val x346 = x206 += 1
()
}
def x348elseb(): Unit = {
()
}
if (x250) {
x348thenb()
} else {
x348elseb()
}
}
x348
}
def x350elseb(): Unit = {
()
}
if (x222) {
x350thenb()
} else {
x350elseb()
}
}
val x351 = x208 += 1
()
}
val x354 = x204.removeCols(0,x177)
x204
}
val x389 = x356.numRows
val x394 = x356.numCols
val x388 = {
val x372 = new generated.scala.DoubleVectorImpl(x134,false)
x372
}
var x371 = 0
while (x371 < x134) {  // begin fat loop x388
val x381 = {
val x376 = new generated.scala.DoubleVectorImpl(x150,true)
x376
}
var x375 = 0
while (x375 < x150) {  // begin fat loop x381
val x378 = x119(x371, x375)
val x379 = x54(x375)
val x380 = x378 * x379
x381.dcUpdate(x375, x380)
x375 += 1
} // end fat loop x381
var x387: Double = 0
var x382 = 0
while (x382 < x150) {  // begin fat loop x387
val x385 = x381(x382)
val x383 = x387
val x384 = x385
val x386 = x383 + x384
x387 = x386
x382 += 1
} // end fat loop x387
x388.dcUpdate(x371, x387)
x371 += 1
} // end fat loop x388
val x408 = {
val x391 = new generated.scala.DoubleVectorImpl(x389,false)
x391
}
var x390 = 0
while (x390 < x389) {  // begin fat loop x408
val x401 = {
val x396 = new generated.scala.DoubleVectorImpl(x394,true)
x396
}
var x395 = 0
while (x395 < x394) {  // begin fat loop x401
val x398 = x356(x390, x395)
val x399 = x388(x395)
val x400 = x398 * x399
x401.dcUpdate(x395, x400)
x395 += 1
} // end fat loop x401
var x407: Double = 0
var x402 = 0
while (x402 < x394) {  // begin fat loop x407
val x405 = x401(x402)
val x403 = x407
val x404 = x405
val x406 = x403 + x404
x407 = x406
x402 += 1
} // end fat loop x407
x408.dcUpdate(x390, x407)
x390 += 1
} // end fat loop x408
val x420 = { 
var x412 : Int = 0
val x418 = while (x412 < x389) {
val x413 = print("[")
val x414 = x408(x412)
val x415 = print(x414)
val x416 = print(" ]\n")
x416
x412 = x412 + 1
}
x418
}
val x421 = print("\n")
val x422 = Seq()
val x423 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
val x428 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
val x429 = x428.length
val x430 = x428.insert(x429, x60)
val x431 = x428.length
val x432 = x428.insert(x431, x30)
val x468 = { 
val x433 = x428.length
val x434 = x433==0
val x466 = {
def x466thenb(): generated.scala.Matrix[Double] = {
val x435 = new generated.scala.DoubleMatrixImpl(0,0)
x435
}
def x466elseb(): generated.scala.Matrix[Double] = {
val x437 = x428(0)
val x438 = x437.isRow
val x464 = {
def x464thenb(): generated.scala.Matrix[Double] = {
val x439 = x437.length
val x440 = new generated.scala.DoubleMatrixImpl(x433,x439)
var x442 : Int = 0
val x451 = while (x442 < x433) {
var x444 : Int = 0
val x449 = while (x444 < x439) {
val x445 = x428(x442)
val x446 = x445(x444)
val x447 = x440(x442, x444) = x446
x447
x444 = x444 + 1
}
x449
x442 = x442 + 1
}
x440
}
def x464elseb(): generated.scala.Matrix[Double] = {
val x439 = x437.length
val x453 = new generated.scala.DoubleMatrixImpl(x439,x433)
var x454 : Int = 0
val x462 = while (x454 < x433) {
var x455 : Int = 0
val x460 = while (x455 < x439) {
val x456 = x428(x454)
val x457 = x456(x455)
val x458 = x453(x455, x454) = x457
x458
x455 = x455 + 1
}
x460
x454 = x454 + 1
}
x453
}
if (x438) {
x464thenb()
} else {
x464elseb()
}
}
x464
}
if (x434) {
x466thenb()
} else {
x466elseb()
}
}
x466
}
val x469 = x468.numRows
val x470 = x469
val x471 = 25.0 / x470
val x472 = 24.990000000000002 / x471
val x473 = Math.ceil(x472)
val x474 = x473.asInstanceOf[Int]
val x485 = { 
val x475 = new generated.scala.DoubleVectorImpl(x474,true)
var x477 : Int = 0
val x483 = while (x477 < x474) {
val x478 = x477
val x479 = x471 * x478
val x480 = x479 + -10.0
val x481 = x475(x477) = x480
x481
x477 = x477 + 1
}
x475
}
val x486 = x485.length
val x498 = { 
val x494 = new generated.scala.DoubleVectorImpl(x486,true)
def x496_block = {
var mapIdx = 0
while (mapIdx < x494.size) { // begin map loop x496
val x495 = x494.dcApply(mapIdx)
x494.dcUpdate(mapIdx,  {
1.0
})
mapIdx += 1
} // end map loop x496
x494
}
val x496 = x496_block
x496
}
val x499 = x498.mtrans
val x500 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
val x501 = x500.length
val x502 = x500.insert(x501, x499)
val x503 = x500.length
val x487 = x485.isRow
val x488 = !x487
val x493 = {
val x490 = new generated.scala.DoubleVectorImpl(x486,x488)
x490
}
var x489 = 0
while (x489 < x486) {  // begin fat loop x493
val x492 = x485(x489)
x493.dcUpdate(x489, x492)
x489 += 1
} // end fat loop x493
val x504 = x500.insert(x503, x493)
val x540 = { 
val x505 = x500.length
val x506 = x505==0
val x538 = {
def x538thenb(): generated.scala.Matrix[Double] = {
val x507 = new generated.scala.DoubleMatrixImpl(0,0)
x507
}
def x538elseb(): generated.scala.Matrix[Double] = {
val x509 = x500(0)
val x510 = x509.isRow
val x536 = {
def x536thenb(): generated.scala.Matrix[Double] = {
val x511 = x509.length
val x512 = new generated.scala.DoubleMatrixImpl(x505,x511)
var x514 : Int = 0
val x523 = while (x514 < x505) {
var x516 : Int = 0
val x521 = while (x516 < x511) {
val x517 = x500(x514)
val x518 = x517(x516)
val x519 = x512(x514, x516) = x518
x519
x516 = x516 + 1
}
x521
x514 = x514 + 1
}
x512
}
def x536elseb(): generated.scala.Matrix[Double] = {
val x511 = x509.length
val x525 = new generated.scala.DoubleMatrixImpl(x511,x505)
var x526 : Int = 0
val x534 = while (x526 < x505) {
var x527 : Int = 0
val x532 = while (x527 < x511) {
val x528 = x500(x526)
val x529 = x528(x527)
val x530 = x525(x527, x526) = x529
x530
x527 = x527 + 1
}
x532
x526 = x526 + 1
}
x525
}
if (x510) {
x536thenb()
} else {
x536elseb()
}
}
x536
}
if (x506) {
x538thenb()
} else {
x538elseb()
}
}
x538
}
val x557 = x540.numRows
val x558 = new generated.scala.IndexVectorRangeImpl(0,x557)
val x541 = x468.numCols
val x568 = x30.isRow
val x556 = { 
val x542 = new generated.scala.DoubleMatrixImpl(x541,x469)
val x543 = x542.numRows
var x545 : Int = 0
val x554 = while (x545 < x543) {
val x546 = x542.numCols
var x548 : Int = 0
val x552 = while (x548 < x546) {
val x549 = x468(x548, x545)
val x550 = x542(x545, x548) = x549
x550
x548 = x548 + 1
}
x552
x545 = x545 + 1
}
x542
}
val x605 = x556.numRows
val x607 = new generated.scala.IndexVectorRangeImpl(0,x605)
val x675 = x556.numCols
val x920 = !false
val x947 = x558.length
val x948 = x558.isRow
def x951_block = {
val x949 = new generated.scala.DoubleVectorImpl(x947,x948)
var mapIdx = 0
while (mapIdx < x558.size) { // begin map loop x951
val x559 = x558.dcApply(mapIdx)
x949.dcUpdate(mapIdx,  {
val x560 = x540(x559, 1)
def x571_block = {
val x569 = new generated.scala.DoubleVectorImpl(x55,x568)
var mapIdx = 0
while (mapIdx < x30.size) { // begin map loop x571
val x561 = x30.dcApply(mapIdx)
x569.dcUpdate(mapIdx,  {
val x562 = x560 - x561
val x563 = -0.1 * x562
val x564 = x563 * x562
val x565 = x564 / 200.0
val x566 = Math.exp(x565)
val x567 = x566 / 2.0
x567
})
mapIdx += 1
} // end map loop x571
x569
}
val x571 = x571_block
val x572 = x571.length
val x587 = { 
val x573 = new generated.scala.DoubleMatrixImpl(x572,x572)
var x574: Int = 0
val x585 = while ({val x575 = x574
val x576 = x575 < x572
x576}) {
val x578 = x574
val x579 = x574
val x580 = x574
val x581 = x571(x580)
val x582 = x573(x578, x579) = x581
val x583 = x574 += 1
()
}
x573
}
val x588 = x587.numCols
val x589 = x587.numRows
val x604 = { 
val x590 = new generated.scala.DoubleMatrixImpl(x588,x589)
val x591 = x590.numRows
var x593 : Int = 0
val x602 = while (x593 < x591) {
val x594 = x590.numCols
var x596 : Int = 0
val x600 = while (x596 < x594) {
val x597 = x587(x596, x593)
val x598 = x590(x593, x596) = x597
x598
x596 = x596 + 1
}
x600
x593 = x593 + 1
}
x590
}
val x621 = x604.numCols
val x644 = { 
val x606 = new generated.scala.DoubleMatrixImpl(x605,x588)
def x642_block = {
var forIdx = 0
while (forIdx < x607.size) { // begin foreach loop x642
val x608 = x607.dcApply(forIdx)
var x609: Int = 0
val x615 = x556(x608, 0)
val x639 = while ({val x610 = x609
val x611 = x606.numCols
val x612 = x610 < x611
x612}) {
var x614: Int = 1
val x616 = x609
val x617 = x604(x616, 0)
val x618 = x615 * x617
var x619: Double = x618
val x633 = while ({val x620 = x614
val x622 = x620 < x621
x622}) {
val x624 = x614
val x626 = x609
val x627 = x614
val x625 = x556(x608, x624)
val x628 = x604(x626, x627)
val x629 = x625 * x628
val x630 = x619 += x629
val x631 = x614 += 1
()
}
val x634 = x609
val x635 = x619
val x636 = x606(x608, x634) = x635
val x637 = x609 += 1
()
}
()
forIdx += 1
} // end foreach loop x642
}
val x642 = x642_block
x606
}
val x659 = x644.numRows
val x661 = new generated.scala.IndexVectorRangeImpl(0,x659)
val x698 = { 
val x660 = new generated.scala.DoubleMatrixImpl(x659,x541)
def x696_block = {
var forIdx = 0
while (forIdx < x661.size) { // begin foreach loop x696
val x662 = x661.dcApply(forIdx)
var x663: Int = 0
val x669 = x644(x662, 0)
val x693 = while ({val x664 = x663
val x665 = x660.numCols
val x666 = x664 < x665
x666}) {
var x668: Int = 1
val x670 = x663
val x671 = x556(x670, 0)
val x672 = x669 * x671
var x673: Double = x672
val x687 = while ({val x674 = x668
val x676 = x674 < x675
x676}) {
val x678 = x668
val x680 = x663
val x681 = x668
val x679 = x644(x662, x678)
val x682 = x556(x680, x681)
val x683 = x679 * x682
val x684 = x673 += x683
val x685 = x668 += 1
()
}
val x688 = x663
val x689 = x673
val x690 = x660(x662, x688) = x689
val x691 = x663 += 1
()
}
()
forIdx += 1
} // end foreach loop x696
}
val x696 = x696_block
x660
}
val x699 = x698.cloneL
val x701 = x698.numCols
val x720 = { 
val x707 = new generated.scala.DoubleMatrixImpl(x701,x701)
var x708: Int = 0
val x718 = while ({val x709 = x708
val x710 = x709 < x701
x710}) {
val x712 = x708
val x713 = x708
val x714 = x708
val x715 = x707(x712, x713) = 1
val x716 = x708 += 1
()
}
x707
}
val x721 = { 
x720
}
val x880 = { 
var x700: generated.scala.Matrix[Double] = x699
val x722 = x700
val x724 = x722.numRows
val x725 = x722.numCols
def x728_block = {
val x726 = new generated.scala.DoubleMatrixImpl(x724,x725)
var mapIdx = 0
while (mapIdx < x722.size) { // begin map loop x728
val x723 = x722.dcApply(mapIdx)
x726.dcUpdate(mapIdx,  {
x723
})
mapIdx += 1
} // end map loop x728
x726
}
val x728 = x728_block
val x729 = x728.insertAllCols(x725,x721)
var x730: Int = 0
var x731: Boolean = false
var x732: Int = 0
val x736 = x728.numRows
val x877 = while ({val x733 = x731
val x735 = x732
val x734 = !x733
val x737 = x735 < x736
val x738 = x734 && x737
x738}) {
val x740 = x730
val x741 = x736 <= x740
val x744 = {
def x744thenb(): Unit = {
x731 = true
()
}
def x744elseb(): Unit = {
()
}
if (x741) {
x744thenb()
} else {
x744elseb()
}
}
val x745 = x731
val x746 = !x745
val x874 = {
def x874thenb(): Unit = {
val x747 = x732
var x748: Int = x747
val x758 = x728.numCols
val x772 = while ({val x749 = x731
val x751 = x748
val x752 = x730
val x750 = !x749
val x753 = x728(x751, x752)
val x754 = x753==0.0
val x755 = x750 && x754
x755}) {
val x757 = x748 += 1
val x759 = x748
val x760 = x758==x759
val x770 = {
def x770thenb(): Unit = {
val x761 = x732
x748 = x761
val x763 = x730 += 1
val x764 = x730
val x765 = x736==x764
val x768 = {
def x768thenb(): Unit = {
x731 = true
()
}
def x768elseb(): Unit = {
()
}
if (x765) {
x768thenb()
} else {
x768elseb()
}
}
x768
}
def x770elseb(): Unit = {
()
}
if (x760) {
x770thenb()
} else {
x770elseb()
}
}
x770
}
val x773 = x731
val x774 = !x773
val x872 = {
def x872thenb(): Unit = {
val x775 = x748
val x777 = x732
val x791 = { 
var x779: Int = 0
val x789 = while ({val x780 = x779
val x781 = x780 < x758
x781}) {
val x783 = x779
val x784 = x779
val x785 = x728(x777, x784)
val x786 = x728(x775, x783) = x785
val x787 = x779 += 1
()
}
()
}
val x792 = x732
val x805 = { 
var x793: Int = 0
val x803 = while ({val x794 = x793
val x795 = x794 < x758
x795}) {
val x797 = x793
val x798 = x793
val x799 = x728(x775, x798)
val x800 = x728(x792, x797) = x799
val x801 = x793 += 1
()
}
()
}
val x806 = x732
val x807 = x732
val x809 = x732
val x810 = x730
val x811 = x728(x809, x810)
val x817 = {
val x813 = new generated.scala.DoubleVectorImpl(x758,true)
x813
}
var x812 = 0
while (x812 < x758) {  // begin fat loop x817
val x815 = x728(x807, x812)
val x816 = x815 / x811
x817.dcUpdate(x812, x816)
x812 += 1
} // end fat loop x817
val x830 = { 
var x818: Int = 0
val x828 = while ({val x819 = x818
val x820 = x819 < x758
x820}) {
val x822 = x818
val x823 = x818
val x824 = x817(x823)
val x825 = x728(x806, x822) = x824
val x826 = x818 += 1
()
}
()
}
var x832 : Int = 0
val x869 = while (x832 < x736) {
val x833 = x732
val x834 = x832 != x833
val x867 = {
def x867thenb(): Unit = {
val x836 = x732
val x838 = x730
val x839 = x728(x832, x838)
val x845 = {
val x841 = new generated.scala.DoubleVectorImpl(x758,true)
x841
}
var x840 = 0
while (x840 < x758) {  // begin fat loop x845
val x843 = x728(x836, x840)
val x844 = x843 * x839
x845.dcUpdate(x840, x844)
x840 += 1
} // end fat loop x845
val x852 = {
val x847 = new generated.scala.DoubleVectorImpl(x758,true)
x847
}
var x846 = 0
while (x846 < x758) {  // begin fat loop x852
val x849 = x728(x832, x846)
val x850 = x845(x846)
val x851 = x849 - x850
x852.dcUpdate(x846, x851)
x846 += 1
} // end fat loop x852
val x865 = { 
var x853: Int = 0
val x863 = while ({val x854 = x853
val x855 = x854 < x758
x855}) {
val x857 = x853
val x858 = x853
val x859 = x852(x858)
val x860 = x728(x832, x857) = x859
val x861 = x853 += 1
()
}
()
}
x865
}
def x867elseb(): Unit = {
()
}
if (x834) {
x867thenb()
} else {
x867elseb()
}
}
x867
x832 = x832 + 1
}
val x870 = x730 += 1
()
}
def x872elseb(): Unit = {
()
}
if (x774) {
x872thenb()
} else {
x872elseb()
}
}
x872
}
def x874elseb(): Unit = {
()
}
if (x746) {
x874thenb()
} else {
x874elseb()
}
}
val x875 = x732 += 1
()
}
val x878 = x728.removeCols(0,x701)
x728
}
val x900 = x880.numRows
val x905 = x880.numCols
val x885 = x644.numCols
val x899 = {
val x882 = new generated.scala.DoubleVectorImpl(x659,false)
x882
}
var x881 = 0
while (x881 < x659) {  // begin fat loop x899
val x892 = {
val x887 = new generated.scala.DoubleVectorImpl(x885,true)
x887
}
var x886 = 0
while (x886 < x885) {  // begin fat loop x892
val x889 = x644(x881, x886)
val x890 = x54(x886)
val x891 = x889 * x890
x892.dcUpdate(x886, x891)
x886 += 1
} // end fat loop x892
var x898: Double = 0
var x893 = 0
while (x893 < x885) {  // begin fat loop x898
val x896 = x892(x893)
val x894 = x898
val x895 = x896
val x897 = x894 + x895
x898 = x897
x893 += 1
} // end fat loop x898
x899.dcUpdate(x881, x898)
x881 += 1
} // end fat loop x899
val x919 = {
val x902 = new generated.scala.DoubleVectorImpl(x900,false)
x902
}
var x901 = 0
while (x901 < x900) {  // begin fat loop x919
val x912 = {
val x907 = new generated.scala.DoubleVectorImpl(x905,true)
x907
}
var x906 = 0
while (x906 < x905) {  // begin fat loop x912
val x909 = x880(x901, x906)
val x910 = x899(x906)
val x911 = x909 * x910
x912.dcUpdate(x906, x911)
x906 += 1
} // end fat loop x912
var x918: Double = 0
var x913 = 0
while (x913 < x905) {  // begin fat loop x918
val x916 = x912(x913)
val x914 = x918
val x915 = x916
val x917 = x914 + x915
x918 = x917
x913 += 1
} // end fat loop x918
x919.dcUpdate(x901, x918)
x901 += 1
} // end fat loop x919
val x940 = {
val x935 = new generated.scala.DoubleVectorImpl(x900,x920)
x935
}
var x934 = 0
while (x934 < x900) {  // begin fat loop x940
val x937 = x919(x934)
val x938 = x540(x559, x934)
val x939 = x937 * x938
x940.dcUpdate(x934, x939)
x934 += 1
} // end fat loop x940
var x946: Double = 0
var x941 = 0
while (x941 < x900) {  // begin fat loop x946
val x944 = x940(x941)
val x942 = x946
val x943 = x944
val x945 = x942 + x943
x946 = x945
x941 += 1
} // end fat loop x946
x946
})
mapIdx += 1
} // end map loop x951
x949
}
val x951 = x951_block
val x952 = Seq(x951)
val x953 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
val x954 = println("Locally weighted linear regression")
val x955 = println("guess: ")
val x956 = x951.isRow
val x978 = { 
val x976 = {
def x976thenb(): Unit = {
val x957 = print("[ ")
val x958 = x951.length
var x960 : Int = 0
val x965 = while (x960 < x958) {
val x961 = x951(x960)
val x962 = print(x961)
val x963 = print(" ")
x963
x960 = x960 + 1
}
val x966 = print("]\n")
x966
}
def x976elseb(): Unit = {
val x958 = x951.length
var x968 : Int = 0
val x974 = while (x968 < x958) {
val x969 = print("[")
val x970 = x951(x968)
val x971 = print(x970)
val x972 = print(" ]\n")
x972
x968 = x968 + 1
}
x974
}
if (x956) {
x976thenb()
} else {
x976elseb()
}
}
x976
}
val x979 = print("\n")
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
