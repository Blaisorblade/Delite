/*****************************************
  Emitting Generated Code                  
*******************************************/
class LinRegRunner extends ((Array[java.lang.String])=>(Unit)) {
def apply(x0:Array[java.lang.String]): Unit = {
val x1 = x0.length
val x2 = x1 < 2
val x6 = {
def x6thenb(): Nothing = {
val x3 = println("Usage: LinRegSerial <input vector file> <output vector file>")
val x4 = exit(-1)
x4
}
if (x2) {
x6thenb()
}
}
val x7 = x0(0)
val x29 = { 
val x8 = new generated.scala.DoubleVectorImpl(0,true)
val x9 = new java.io.FileReader(x7)
val x10 = new java.io.BufferedReader(x9)
val x11 = x10.readLine()
var x12: java.lang.String = x11
val x26 = while ({val x13 = x12
val x14 = x13 != null
x14}) {
val x16 = x12
val x17 = x16.trim()
x12 = x17
val x19 = x12
val x21 = x8.length
val x20 = java.lang.Double.parseDouble(x19)
val x22 = x8.insert(x21, x20)
val x23 = x10.readLine()
x12 = x23
()
}
val x27 = x10.close()
x8
}
val x38 = x0(1)
val x60 = { 
val x39 = new generated.scala.DoubleVectorImpl(0,true)
val x40 = new java.io.FileReader(x38)
val x41 = new java.io.BufferedReader(x40)
val x42 = x41.readLine()
var x43: java.lang.String = x42
val x57 = while ({val x44 = x43
val x45 = x44 != null
x45}) {
val x47 = x43
val x48 = x47.trim()
x43 = x48
val x50 = x43
val x52 = x39.length
val x51 = java.lang.Double.parseDouble(x50)
val x53 = x39.insert(x52, x51)
val x54 = x41.readLine()
x43 = x54
()
}
val x58 = x41.close()
x39
}
val x81 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
val x82 = x81.length
val x30 = x29.length
val x73 = { 
val x69 = new generated.scala.DoubleVectorImpl(x30,true)
def x71_block = {
var mapIdx = 0
while (mapIdx < x69.size) { // begin map loop x71
val x70 = x69.dcApply(mapIdx)
x69.dcUpdate(mapIdx,  {
1.0
})
mapIdx += 1
} // end map loop x71
x69
}
val x71 = x71_block
x71
}
val x74 = x73.length
val x75 = x73.isRow
val x76 = !x75
val x80 = {
val x78 = new generated.scala.DoubleVectorImpl(x74,x76)
x78
}
var x77 = 0
while (x77 < x74) {  // begin fat loop x80
x80.dcUpdate(x77, 1)
x77 += 1
} // end fat loop x80
val x83 = x81.insert(x82, x80)
val x84 = x81.length
val x31 = x29.isRow
val x32 = !x31
val x37 = {
val x34 = new generated.scala.DoubleVectorImpl(x30,x32)
x34
}
var x33 = 0
while (x33 < x30) {  // begin fat loop x37
val x36 = x29(x33)
x37.dcUpdate(x33, x36)
x33 += 1
} // end fat loop x37
val x85 = x81.insert(x84, x37)
val x86 = x81.cloneL
val x453 = println("Unweighted linear regression")
val x454 = println("theta: ")
val x122 = { 
val x87 = x81.length
val x88 = x87==0
val x120 = {
def x120thenb(): generated.scala.Matrix[Double] = {
val x89 = new generated.scala.DoubleMatrixImpl(0,0)
x89
}
def x120elseb(): generated.scala.Matrix[Double] = {
val x91 = x86(0)
val x92 = x91.isRow
val x118 = {
def x118thenb(): generated.scala.Matrix[Double] = {
val x93 = x91.length
val x94 = new generated.scala.DoubleMatrixImpl(x87,x93)
var x96 : Int = 0
val x105 = while (x96 < x87) {
val x99 = x86(x96)
var x98 : Int = 0
val x103 = while (x98 < x93) {
val x100 = x99(x98)
val x101 = x94(x96, x98) = x100
x101
x98 = x98 + 1
}
x103
x96 = x96 + 1
}
x94
}
def x118elseb(): generated.scala.Matrix[Double] = {
val x93 = x91.length
val x107 = new generated.scala.DoubleMatrixImpl(x93,x87)
var x108 : Int = 0
val x116 = while (x108 < x87) {
val x110 = x86(x108)
var x109 : Int = 0
val x114 = while (x109 < x93) {
val x111 = x110(x109)
val x112 = x107(x109, x108) = x111
x112
x109 = x109 + 1
}
x114
x108 = x108 + 1
}
x107
}
if (x92) {
x118thenb()
} else { 
x118elseb()
}
}
x118
}
if (x88) {
x120thenb()
} else { 
x120elseb()
}
}
x120
}
val x123 = x122.numCols
val x124 = x122.numRows
val x142 = { 
val x125 = new generated.scala.DoubleMatrixImpl(x123,x124)
val x126 = x125.numRows
var x128 : Int = 0
val x140 = while (x128 < x126) {
val x129 = x125.numCols
var x131 : Int = 0
val x138 = while (x131 < x129) {
val x132 = x131 * x123
val x133 = x132 + x128
val x134 = x122.dcApply(x133)
val x135 = { 
x134
}
val x136 = x125(x128, x131) = x135
x136
x131 = x131 + 1
}
x138
x128 = x128 + 1
}
x125
}
val x160 = x142.numRows
val x162 = new generated.scala.IndexVectorRangeImpl(0,x160)
val x170 = x142.numCols
val x201 = List()
val x204 = { 
val x161 = new generated.scala.DoubleMatrixImpl(x160,x123)
val x202 = {
var forIdx = 0
while (forIdx < x162.size) { // begin foreach loop x202
val x163 = x162.dcApply(forIdx)
var x164: Int = 0
val x165 = x164
val x171 = x163 * x170
val x172 = x171 + 0
val x173 = x142.dcApply(x172)
val x174 = { 
x173
}
val x175 = x165 * x170
val x176 = x175 + 0
val x177 = x142.dcApply(x176)
val x178 = { 
x177
}
val x179 = x174 * x178
val x198 = while ({val x166 = x161.numCols
val x167 = x165 < x166
x167}) {
var x169: Int = 1
var x180: Double = x179
val x181 = x169
val x182 = x181 < x170
val x183 = x171 + x181
val x184 = x142.dcApply(x183)
val x185 = { 
x184
}
val x186 = x175 + x181
val x187 = x142.dcApply(x186)
val x188 = { 
x187
}
val x189 = x185 * x188
val x193 = while ({x182}) {
val x190 = x180 += x189
val x191 = x169 += 1
()
}
val x194 = x180
val x195 = x161(x163, x165) = x194
val x196 = x164 += 1
()
}
()
forIdx += 1
} // end foreach loop x202
}
x161
}
val x205 = x204.numCols
val x223 = x204.numRows
def x226_block = {
val x224 = new generated.scala.DoubleMatrixImpl(x223,x205)
var mapIdx = 0
while (mapIdx < x204.size) { // begin map loop x226
val x222 = x204.dcApply(mapIdx)
x224.dcUpdate(mapIdx,  {
x222
})
mapIdx += 1
} // end map loop x226
x224
}
val x226 = x226_block
val x220 = { 
val x211 = new generated.scala.DoubleMatrixImpl(x205,x205)
var x212: Int = 0
val x213 = x212
val x214 = x213 < x205
val x218 = while ({x214}) {
val x215 = x211(x213, x213) = 1
val x216 = x212 += 1
()
}
x211
}
val x221 = { 
x220
}
val x382 = { 
val x227 = x226.cloneL
val x228 = x227.numCols
val x229 = x227.insertAllCols(x228,x221)
var x230: Int = 0
var x231: Boolean = false
var x232: Int = 0
val x233 = x231
val x234 = !x233
val x235 = x232
val x241 = x230
val x379 = while ({val x236 = x227.numRows
val x237 = x235 < x236
val x238 = x234 && x237
x238}) {
val x240 = x227.numRows
val x242 = x240 <= x241
val x245 = {
def x245thenb(): Unit = {
x231 = true
()
}
if (x242) {
x245thenb()
}
}
val x376 = {
def x376thenb(): Unit = {
var x246: Int = x235
val x247 = x246
val x270 = while ({val x253 = { 
val x248 = x227.numCols
val x249 = x247 * x248
val x250 = x249 + x241
val x251 = x227.dcApply(x250)
x251
}
val x254 = x253==0.0
val x255 = x234 && x254
x255}) {
val x257 = x246 += 1
val x258 = x227.numCols
val x259 = x258==x247
val x268 = {
def x268thenb(): Unit = {
x246 = x235
val x261 = x230 += 1
val x262 = x227.numRows
val x263 = x262==x241
val x266 = {
def x266thenb(): Unit = {
x231 = true
()
}
if (x263) {
x266thenb()
}
}
x266
}
if (x259) {
x268thenb()
}
}
x268
}
val x374 = {
def x374thenb(): Unit = {
val x271 = x227.getRow(x247)
val x272 = x227.getRow(x235)
val x284 = { 
var x273: Int = 0
val x274 = x273
val x282 = while ({val x275 = x227.numCols
val x276 = x274 < x275
x276}) {
val x278 = x272(x274)
val x279 = x227(x247, x274) = x278
val x280 = x273 += 1
()
}
()
}
val x296 = { 
var x285: Int = 0
val x286 = x285
val x294 = while ({val x287 = x227.numCols
val x288 = x286 < x287
x288}) {
val x290 = x271(x286)
val x291 = x227(x235, x286) = x290
val x292 = x285 += 1
()
}
()
}
val x297 = x227.getRow(x235)
val x303 = { 
val x298 = x227.numCols
val x299 = x235 * x298
val x300 = x299 + x241
val x301 = x227.dcApply(x300)
x301
}
val x304 = x297.length
val x305 = x297.isRow
// a *thin* loop follows: x312
val x312 = {
val x307 = new generated.scala.DoubleVectorImpl(x304,x305)
x307
}
var x306 = 0
while (x306 < x304) {  // begin fat loop x312
val x309 = x297(x306)
val x310 = x309 / x303
x312.dcUpdate(x306, x310)
x306 += 1
} // end fat loop x312
val x324 = { 
var x313: Int = 0
val x314 = x313
val x322 = while ({val x315 = x227.numCols
val x316 = x314 < x315
x316}) {
val x318 = x312(x314)
val x319 = x227(x235, x314) = x318
val x320 = x313 += 1
()
}
()
}
val x325 = x227.numRows
var x327 : Int = 0
val x371 = while (x327 < x325) {
val x328 = x327 != x235
val x369 = {
def x369thenb(): Unit = {
val x329 = x227.getRow(x327)
val x330 = x227.getRow(x235)
val x336 = { 
val x331 = x227.numCols
val x332 = x327 * x331
val x333 = x332 + x241
val x334 = x227.dcApply(x333)
x334
}
val x337 = x330.length
val x338 = x330.isRow
// a *thin* loop follows: x345
val x345 = {
val x340 = new generated.scala.DoubleVectorImpl(x337,x338)
x340
}
var x339 = 0
while (x339 < x337) {  // begin fat loop x345
val x342 = x330(x339)
val x343 = x342 * x336
x345.dcUpdate(x339, x343)
x339 += 1
} // end fat loop x345
val x346 = x329.length
val x347 = x329.isRow
// a *thin* loop follows: x355
val x355 = {
val x349 = new generated.scala.DoubleVectorImpl(x346,x347)
x349
}
var x348 = 0
while (x348 < x346) {  // begin fat loop x355
val x351 = x329(x348)
val x352 = x345(x348)
val x353 = x351 - x352
x355.dcUpdate(x348, x353)
x348 += 1
} // end fat loop x355
val x367 = { 
var x356: Int = 0
val x357 = x356
val x365 = while ({val x358 = x227.numCols
val x359 = x357 < x358
x359}) {
val x361 = x355(x357)
val x362 = x227(x327, x357) = x361
val x363 = x356 += 1
()
}
()
}
x367
}
if (x328) {
x369thenb()
}
}
x369
x327 = x327 + 1
}
val x372 = x230 += 1
()
}
if (x234) {
x374thenb()
}
}
x374
}
if (x234) {
x376thenb()
}
}
val x377 = x232 += 1
()
}
val x380 = x227.removeCols(0,x205)
x227
}
val x61 = x60.length
val x62 = x60.isRow
val x63 = !x62
val x68 = {
val x65 = new generated.scala.DoubleVectorImpl(x61,x63)
x65
}
var x64 = 0
while (x64 < x61) {  // begin fat loop x68
val x67 = x60(x64)
x68.dcUpdate(x64, x67)
x64 += 1
} // end fat loop x68
val x424 = { 
val x400 = new generated.scala.DoubleVectorImpl(x160,false)
val x422 = {
var forIdx = 0
while (forIdx < x162.size) { // begin foreach loop x422
val x401 = x162.dcApply(forIdx)
val x406 = x401 * x170
val x412 = {
val x404 = new generated.scala.DoubleVectorImpl(x170,true)
x404
}
var x403 = 0
while (x403 < x170) {  // begin fat loop x412
val x407 = x406 + x403
val x408 = x142.dcApply(x407)
val x409 = { 
x408
}
val x410 = x60(x403)
val x411 = x409 * x410
x412.dcUpdate(x403, x411)
x403 += 1
} // end fat loop x412
var x418: Double = 0
var x413 = 0
while (x413 < x170) {  // begin fat loop x418
val x416 = x412(x413)
val x414 = x418
val x415 = x416
val x417 = x414 + x415
x418 = x417
x413 += 1
} // end fat loop x418
val x419 = x400(x401) = x418
x419
forIdx += 1
} // end foreach loop x422
}
x400
}
val x425 = x382.numRows
val x427 = new generated.scala.IndexVectorRangeImpl(0,x425)
val x430 = x382.numCols
val x452 = { 
val x426 = new generated.scala.DoubleVectorImpl(x425,false)
val x450 = {
var forIdx = 0
while (forIdx < x427.size) { // begin foreach loop x450
val x428 = x427.dcApply(forIdx)
val x434 = x428 * x430
val x440 = {
val x432 = new generated.scala.DoubleVectorImpl(x430,true)
x432
}
var x431 = 0
while (x431 < x430) {  // begin fat loop x440
val x435 = x434 + x431
val x436 = x382.dcApply(x435)
val x437 = { 
x436
}
val x438 = x424(x431)
val x439 = x437 * x438
x440.dcUpdate(x431, x439)
x431 += 1
} // end fat loop x440
var x446: Double = 0
var x441 = 0
while (x441 < x430) {  // begin fat loop x446
val x444 = x440(x441)
val x442 = x446
val x443 = x444
val x445 = x442 + x443
x446 = x445
x441 += 1
} // end fat loop x446
val x447 = x426(x428) = x446
x447
forIdx += 1
} // end foreach loop x450
}
x426
}
val x455 = x452.isRow
val x477 = { 
val x475 = {
def x475thenb(): Unit = {
val x456 = print("[ ")
val x457 = x452.length
var x459 : Int = 0
val x464 = while (x459 < x457) {
val x460 = x452(x459)
val x461 = print(x460)
val x462 = print(" ")
x462
x459 = x459 + 1
}
val x465 = print("]\n")
x465
}
def x475elseb(): Unit = {
val x457 = x452.length
var x467 : Int = 0
val x473 = while (x467 < x457) {
val x468 = print("[")
val x469 = x452(x467)
val x470 = print(x469)
val x471 = print(" ]\n")
x471
x467 = x467 + 1
}
x473
}
if (x455) {
x475thenb()
} else { 
x475elseb()
}
}
x475
}
val x478 = print("\n")
val x479 = Seq()
val x480 = ppl.delite.runtime.profiler.PerformanceTimer.start("app", false)
val x488 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
val x489 = x488.length
val x490 = x488.insert(x489, x80)
val x491 = x488.length
val x492 = x488.insert(x491, x37)
val x493 = x488.cloneL
val x567 = new generated.scala.VectorImpl[generated.scala.Vector[Double]](0,true)
val x568 = x567.length
val x529 = { 
val x494 = x488.length
val x495 = x494==0
val x527 = {
def x527thenb(): generated.scala.Matrix[Double] = {
val x496 = new generated.scala.DoubleMatrixImpl(0,0)
x496
}
def x527elseb(): generated.scala.Matrix[Double] = {
val x498 = x493(0)
val x499 = x498.isRow
val x525 = {
def x525thenb(): generated.scala.Matrix[Double] = {
val x500 = x498.length
val x501 = new generated.scala.DoubleMatrixImpl(x494,x500)
var x503 : Int = 0
val x512 = while (x503 < x494) {
val x506 = x493(x503)
var x505 : Int = 0
val x510 = while (x505 < x500) {
val x507 = x506(x505)
val x508 = x501(x503, x505) = x507
x508
x505 = x505 + 1
}
x510
x503 = x503 + 1
}
x501
}
def x525elseb(): generated.scala.Matrix[Double] = {
val x500 = x498.length
val x514 = new generated.scala.DoubleMatrixImpl(x500,x494)
var x515 : Int = 0
val x523 = while (x515 < x494) {
val x517 = x493(x515)
var x516 : Int = 0
val x521 = while (x516 < x500) {
val x518 = x517(x516)
val x519 = x514(x516, x515) = x518
x519
x516 = x516 + 1
}
x521
x515 = x515 + 1
}
x514
}
if (x499) {
x525thenb()
} else { 
x525elseb()
}
}
x525
}
if (x495) {
x527thenb()
} else { 
x527elseb()
}
}
x527
}
val x530 = x529.numRows
val x531 = x530
val x532 = 25.0 / x531
val x533 = 24.990000000000002 / x532
val x534 = Math.ceil(x533)
val x535 = x534.asInstanceOf[Int]
val x546 = { 
val x536 = new generated.scala.DoubleVectorImpl(x535,true)
var x538 : Int = 0
val x544 = while (x538 < x535) {
val x539 = x538
val x540 = x532 * x539
val x541 = x540 + -10.0
val x542 = x536(x538) = x541
x542
x538 = x538 + 1
}
x536
}
val x547 = x546.length
val x559 = { 
val x555 = new generated.scala.DoubleVectorImpl(x547,true)
def x557_block = {
var mapIdx = 0
while (mapIdx < x555.size) { // begin map loop x557
val x556 = x555.dcApply(mapIdx)
x555.dcUpdate(mapIdx,  {
1.0
})
mapIdx += 1
} // end map loop x557
x555
}
val x557 = x557_block
x557
}
val x560 = x559.length
val x561 = x559.isRow
val x562 = !x561
val x566 = {
val x564 = new generated.scala.DoubleVectorImpl(x560,x562)
x564
}
var x563 = 0
while (x563 < x560) {  // begin fat loop x566
x566.dcUpdate(x563, 1)
x563 += 1
} // end fat loop x566
val x569 = x567.insert(x568, x566)
val x570 = x567.length
val x548 = x546.isRow
val x549 = !x548
val x554 = {
val x551 = new generated.scala.DoubleVectorImpl(x547,x549)
x551
}
var x550 = 0
while (x550 < x547) {  // begin fat loop x554
val x553 = x546(x550)
x554.dcUpdate(x550, x553)
x550 += 1
} // end fat loop x554
val x571 = x567.insert(x570, x554)
val x572 = x567.cloneL
val x608 = { 
val x573 = x567.length
val x574 = x573==0
val x606 = {
def x606thenb(): generated.scala.Matrix[Double] = {
val x575 = new generated.scala.DoubleMatrixImpl(0,0)
x575
}
def x606elseb(): generated.scala.Matrix[Double] = {
val x577 = x572(0)
val x578 = x577.isRow
val x604 = {
def x604thenb(): generated.scala.Matrix[Double] = {
val x579 = x577.length
val x580 = new generated.scala.DoubleMatrixImpl(x573,x579)
var x582 : Int = 0
val x591 = while (x582 < x573) {
val x585 = x572(x582)
var x584 : Int = 0
val x589 = while (x584 < x579) {
val x586 = x585(x584)
val x587 = x580(x582, x584) = x586
x587
x584 = x584 + 1
}
x589
x582 = x582 + 1
}
x580
}
def x604elseb(): generated.scala.Matrix[Double] = {
val x579 = x577.length
val x593 = new generated.scala.DoubleMatrixImpl(x579,x573)
var x594 : Int = 0
val x602 = while (x594 < x573) {
val x596 = x572(x594)
var x595 : Int = 0
val x600 = while (x595 < x579) {
val x597 = x596(x595)
val x598 = x593(x595, x594) = x597
x598
x595 = x595 + 1
}
x600
x594 = x594 + 1
}
x593
}
if (x578) {
x604thenb()
} else { 
x604elseb()
}
}
x604
}
if (x574) {
x606thenb()
} else { 
x606elseb()
}
}
x606
}
val x628 = x608.numRows
val x629 = new generated.scala.IndexVectorRangeImpl(0,x628)
val x609 = x529.numCols
val x627 = { 
val x610 = new generated.scala.DoubleMatrixImpl(x609,x530)
val x611 = x610.numRows
var x613 : Int = 0
val x625 = while (x613 < x611) {
val x614 = x610.numCols
var x616 : Int = 0
val x623 = while (x616 < x614) {
val x617 = x616 * x609
val x618 = x617 + x613
val x619 = x529.dcApply(x618)
val x620 = { 
x619
}
val x621 = x610(x613, x616) = x620
x621
x616 = x616 + 1
}
x623
x613 = x613 + 1
}
x610
}
val x631 = x608.numCols
val x678 = x627.numRows
val x680 = new generated.scala.IndexVectorRangeImpl(0,x678)
val x688 = x627.numCols
val x1047 = x629.length
val x1048 = x629.isRow
def x1051_block = {
val x1049 = new generated.scala.DoubleVectorImpl(x1047,x1048)
var mapIdx = 0
while (mapIdx < x629.size) { // begin map loop x1051
val x630 = x629.dcApply(mapIdx)
x1049.dcUpdate(mapIdx,  {
val x632 = x630 * x631
val x633 = x632 + 1
val x634 = x608.dcApply(x633)
val x635 = { 
x634
}
def x645_block = {
val x643 = new generated.scala.DoubleVectorImpl(x30,x32)
var mapIdx = 0
while (mapIdx < x37.size) { // begin map loop x645
val x636 = x37.dcApply(mapIdx)
x643.dcUpdate(mapIdx,  {
val x637 = x635 - x636
val x638 = -0.1 * x637
val x639 = x638 * x637
val x640 = x639 / 200.0
val x641 = Math.exp(x640)
val x642 = x641 / 2.0
x642
})
mapIdx += 1
} // end map loop x645
x643
}
val x645 = x645_block
val x646 = x645.length
val x657 = { 
val x647 = new generated.scala.DoubleMatrixImpl(x646,x646)
var x648: Int = 0
val x649 = x648
val x650 = x649 < x646
val x651 = x645(x649)
val x655 = while ({x650}) {
val x652 = x647(x649, x649) = x651
val x653 = x648 += 1
()
}
x647
}
val x658 = x657.numCols
val x659 = x657.numRows
val x677 = { 
val x660 = new generated.scala.DoubleMatrixImpl(x658,x659)
val x661 = x660.numRows
var x663 : Int = 0
val x675 = while (x663 < x661) {
val x664 = x660.numCols
var x666 : Int = 0
val x673 = while (x666 < x664) {
val x667 = x666 * x658
val x668 = x667 + x663
val x669 = x657.dcApply(x668)
val x670 = { 
x669
}
val x671 = x660(x663, x666) = x670
x671
x666 = x666 + 1
}
x673
x663 = x663 + 1
}
x660
}
val x693 = x677.numCols
val x722 = { 
val x679 = new generated.scala.DoubleMatrixImpl(x678,x658)
val x720 = {
var forIdx = 0
while (forIdx < x680.size) { // begin foreach loop x720
val x681 = x680.dcApply(forIdx)
var x682: Int = 0
val x683 = x682
val x689 = x681 * x688
val x690 = x689 + 0
val x691 = x627.dcApply(x690)
val x692 = { 
x691
}
val x694 = x683 * x693
val x695 = x694 + 0
val x696 = x677.dcApply(x695)
val x697 = { 
x696
}
val x698 = x692 * x697
val x717 = while ({val x684 = x679.numCols
val x685 = x683 < x684
x685}) {
var x687: Int = 1
var x699: Double = x698
val x700 = x687
val x701 = x700 < x693
val x702 = x689 + x700
val x703 = x627.dcApply(x702)
val x704 = { 
x703
}
val x705 = x694 + x700
val x706 = x677.dcApply(x705)
val x707 = { 
x706
}
val x708 = x704 * x707
val x712 = while ({x701}) {
val x709 = x699 += x708
val x710 = x687 += 1
()
}
val x713 = x699
val x714 = x679(x681, x683) = x713
val x715 = x682 += 1
()
}
()
forIdx += 1
} // end foreach loop x720
}
x679
}
val x740 = x722.numRows
val x742 = new generated.scala.IndexVectorRangeImpl(0,x740)
val x750 = x722.numCols
val x783 = { 
val x741 = new generated.scala.DoubleMatrixImpl(x740,x609)
val x781 = {
var forIdx = 0
while (forIdx < x742.size) { // begin foreach loop x781
val x743 = x742.dcApply(forIdx)
var x744: Int = 0
val x745 = x744
val x751 = x743 * x750
val x752 = x751 + 0
val x753 = x722.dcApply(x752)
val x754 = { 
x753
}
val x755 = x745 * x688
val x756 = x755 + 0
val x757 = x627.dcApply(x756)
val x758 = { 
x757
}
val x759 = x754 * x758
val x778 = while ({val x746 = x741.numCols
val x747 = x745 < x746
x747}) {
var x749: Int = 1
var x760: Double = x759
val x761 = x749
val x762 = x761 < x688
val x763 = x751 + x761
val x764 = x722.dcApply(x763)
val x765 = { 
x764
}
val x766 = x755 + x761
val x767 = x627.dcApply(x766)
val x768 = { 
x767
}
val x769 = x765 * x768
val x773 = while ({x762}) {
val x770 = x760 += x769
val x771 = x749 += 1
()
}
val x774 = x760
val x775 = x741(x743, x745) = x774
val x776 = x744 += 1
()
}
()
forIdx += 1
} // end foreach loop x781
}
x741
}
val x784 = x783.numCols
val x802 = x783.numRows
def x805_block = {
val x803 = new generated.scala.DoubleMatrixImpl(x802,x784)
var mapIdx = 0
while (mapIdx < x783.size) { // begin map loop x805
val x801 = x783.dcApply(mapIdx)
x803.dcUpdate(mapIdx,  {
x801
})
mapIdx += 1
} // end map loop x805
x803
}
val x805 = x805_block
val x799 = { 
val x790 = new generated.scala.DoubleMatrixImpl(x784,x784)
var x791: Int = 0
val x792 = x791
val x793 = x792 < x784
val x797 = while ({x793}) {
val x794 = x790(x792, x792) = 1
val x795 = x791 += 1
()
}
x790
}
val x800 = { 
x799
}
val x961 = { 
val x806 = x805.cloneL
val x807 = x806.numCols
val x808 = x806.insertAllCols(x807,x800)
var x809: Int = 0
var x810: Boolean = false
var x811: Int = 0
val x812 = x810
val x813 = !x812
val x814 = x811
val x820 = x809
val x958 = while ({val x815 = x806.numRows
val x816 = x814 < x815
val x817 = x813 && x816
x817}) {
val x819 = x806.numRows
val x821 = x819 <= x820
val x824 = {
def x824thenb(): Unit = {
x810 = true
()
}
if (x821) {
x824thenb()
}
}
val x955 = {
def x955thenb(): Unit = {
var x825: Int = x814
val x826 = x825
val x849 = while ({val x832 = { 
val x827 = x806.numCols
val x828 = x826 * x827
val x829 = x828 + x820
val x830 = x806.dcApply(x829)
x830
}
val x833 = x832==0.0
val x834 = x813 && x833
x834}) {
val x836 = x825 += 1
val x837 = x806.numCols
val x838 = x837==x826
val x847 = {
def x847thenb(): Unit = {
x825 = x814
val x840 = x809 += 1
val x841 = x806.numRows
val x842 = x841==x820
val x845 = {
def x845thenb(): Unit = {
x810 = true
()
}
if (x842) {
x845thenb()
}
}
x845
}
if (x838) {
x847thenb()
}
}
x847
}
val x953 = {
def x953thenb(): Unit = {
val x850 = x806.getRow(x826)
val x851 = x806.getRow(x814)
val x863 = { 
var x852: Int = 0
val x853 = x852
val x861 = while ({val x854 = x806.numCols
val x855 = x853 < x854
x855}) {
val x857 = x851(x853)
val x858 = x806(x826, x853) = x857
val x859 = x852 += 1
()
}
()
}
val x875 = { 
var x864: Int = 0
val x865 = x864
val x873 = while ({val x866 = x806.numCols
val x867 = x865 < x866
x867}) {
val x869 = x850(x865)
val x870 = x806(x814, x865) = x869
val x871 = x864 += 1
()
}
()
}
val x876 = x806.getRow(x814)
val x882 = { 
val x877 = x806.numCols
val x878 = x814 * x877
val x879 = x878 + x820
val x880 = x806.dcApply(x879)
x880
}
val x883 = x876.length
val x884 = x876.isRow
// a *thin* loop follows: x891
val x891 = {
val x886 = new generated.scala.DoubleVectorImpl(x883,x884)
x886
}
var x885 = 0
while (x885 < x883) {  // begin fat loop x891
val x888 = x876(x885)
val x889 = x888 / x882
x891.dcUpdate(x885, x889)
x885 += 1
} // end fat loop x891
val x903 = { 
var x892: Int = 0
val x893 = x892
val x901 = while ({val x894 = x806.numCols
val x895 = x893 < x894
x895}) {
val x897 = x891(x893)
val x898 = x806(x814, x893) = x897
val x899 = x892 += 1
()
}
()
}
val x904 = x806.numRows
var x906 : Int = 0
val x950 = while (x906 < x904) {
val x907 = x906 != x814
val x948 = {
def x948thenb(): Unit = {
val x908 = x806.getRow(x906)
val x909 = x806.getRow(x814)
val x915 = { 
val x910 = x806.numCols
val x911 = x906 * x910
val x912 = x911 + x820
val x913 = x806.dcApply(x912)
x913
}
val x916 = x909.length
val x917 = x909.isRow
// a *thin* loop follows: x924
val x924 = {
val x919 = new generated.scala.DoubleVectorImpl(x916,x917)
x919
}
var x918 = 0
while (x918 < x916) {  // begin fat loop x924
val x921 = x909(x918)
val x922 = x921 * x915
x924.dcUpdate(x918, x922)
x918 += 1
} // end fat loop x924
val x925 = x908.length
val x926 = x908.isRow
// a *thin* loop follows: x934
val x934 = {
val x928 = new generated.scala.DoubleVectorImpl(x925,x926)
x928
}
var x927 = 0
while (x927 < x925) {  // begin fat loop x934
val x930 = x908(x927)
val x931 = x924(x927)
val x932 = x930 - x931
x934.dcUpdate(x927, x932)
x927 += 1
} // end fat loop x934
val x946 = { 
var x935: Int = 0
val x936 = x935
val x944 = while ({val x937 = x806.numCols
val x938 = x936 < x937
x938}) {
val x940 = x934(x936)
val x941 = x806(x906, x936) = x940
val x942 = x935 += 1
()
}
()
}
x946
}
if (x907) {
x948thenb()
}
}
x948
x906 = x906 + 1
}
val x951 = x809 += 1
()
}
if (x813) {
x953thenb()
}
}
x953
}
if (x813) {
x955thenb()
}
}
val x956 = x811 += 1
()
}
val x959 = x806.removeCols(0,x784)
x806
}
val x986 = { 
val x962 = new generated.scala.DoubleVectorImpl(x740,false)
val x984 = {
var forIdx = 0
while (forIdx < x742.size) { // begin foreach loop x984
val x963 = x742.dcApply(forIdx)
val x968 = x963 * x750
val x974 = {
val x966 = new generated.scala.DoubleVectorImpl(x750,true)
x966
}
var x965 = 0
while (x965 < x750) {  // begin fat loop x974
val x969 = x968 + x965
val x970 = x722.dcApply(x969)
val x971 = { 
x970
}
val x972 = x60(x965)
val x973 = x971 * x972
x974.dcUpdate(x965, x973)
x965 += 1
} // end fat loop x974
var x980: Double = 0
var x975 = 0
while (x975 < x750) {  // begin fat loop x980
val x978 = x974(x975)
val x976 = x980
val x977 = x978
val x979 = x976 + x977
x980 = x979
x975 += 1
} // end fat loop x980
val x981 = x962(x963) = x980
x981
forIdx += 1
} // end foreach loop x984
}
x962
}
val x987 = x961.numRows
val x989 = new generated.scala.IndexVectorRangeImpl(0,x987)
val x992 = x961.numCols
val x1014 = { 
val x988 = new generated.scala.DoubleVectorImpl(x987,false)
val x1012 = {
var forIdx = 0
while (forIdx < x989.size) { // begin foreach loop x1012
val x990 = x989.dcApply(forIdx)
val x996 = x990 * x992
val x1002 = {
val x994 = new generated.scala.DoubleVectorImpl(x992,true)
x994
}
var x993 = 0
while (x993 < x992) {  // begin fat loop x1002
val x997 = x996 + x993
val x998 = x961.dcApply(x997)
val x999 = { 
x998
}
val x1000 = x986(x993)
val x1001 = x999 * x1000
x1002.dcUpdate(x993, x1001)
x993 += 1
} // end fat loop x1002
var x1008: Double = 0
var x1003 = 0
while (x1003 < x992) {  // begin fat loop x1008
val x1006 = x1002(x1003)
val x1004 = x1008
val x1005 = x1006
val x1007 = x1004 + x1005
x1008 = x1007
x1003 += 1
} // end fat loop x1008
val x1009 = x988(x990) = x1008
x1009
forIdx += 1
} // end foreach loop x1012
}
x988
}
val x1015 = x1014.length
val x1016 = x1014.isRow
val x1017 = !x1016
val x1040 = {
val x1033 = new generated.scala.DoubleVectorImpl(x1015,x1017)
x1033
}
var x1032 = 0
while (x1032 < x1015) {  // begin fat loop x1040
val x1035 = x1014(x1032)
val x1036 = x632 + x1032
val x1037 = x608.dcApply(x1036)
val x1038 = { 
x1037
}
val x1039 = x1035 * x1038
x1040.dcUpdate(x1032, x1039)
x1032 += 1
} // end fat loop x1040
var x1046: Double = 0
var x1041 = 0
while (x1041 < x1015) {  // begin fat loop x1046
val x1044 = x1040(x1041)
val x1042 = x1046
val x1043 = x1044
val x1045 = x1042 + x1043
x1046 = x1045
x1041 += 1
} // end fat loop x1046
x1046
})
mapIdx += 1
} // end map loop x1051
x1049
}
val x1051 = x1051_block
val x1052 = Seq(x1051)
val x1053 = ppl.delite.runtime.profiler.PerformanceTimer.stop("app", false)
val x1054 = println("Locally weighted linear regression")
val x1055 = println("guess: ")
val x1056 = x1051.isRow
val x1078 = { 
val x1076 = {
def x1076thenb(): Unit = {
val x1057 = print("[ ")
val x1058 = x1051.length
var x1060 : Int = 0
val x1065 = while (x1060 < x1058) {
val x1061 = x1051(x1060)
val x1062 = print(x1061)
val x1063 = print(" ")
x1063
x1060 = x1060 + 1
}
val x1066 = print("]\n")
x1066
}
def x1076elseb(): Unit = {
val x1058 = x1051.length
var x1068 : Int = 0
val x1074 = while (x1068 < x1058) {
val x1069 = print("[")
val x1070 = x1051(x1068)
val x1071 = print(x1070)
val x1072 = print(" ]\n")
x1072
x1068 = x1068 + 1
}
x1074
}
if (x1056) {
x1076thenb()
} else { 
x1076elseb()
}
}
x1076
}
val x1079 = print("\n")
()
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
